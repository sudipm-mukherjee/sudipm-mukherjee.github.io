<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/net/ipv6/route.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n *\tLinux INET6 implementation\n *\tFIB front-end.\n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\n */\n\n/*\tChanges:\n *\n *\tYOSHIFUJI Hideaki @USAGI\n *\t\treworked default router selection.\n *\t\t- respect outgoing interface\n *\t\t- select from (probably) reachable routers (i.e.\n *\t\trouters in REACHABLE, STALE, DELAY or PROBE states).\n *\t\t- always select the same router if it is (probably)\n *\t\treachable.  otherwise, round-robin the list.\n *\tVille Nuorvala\n *\t\tFixed routing subtrees.\n */\n\n#define pr_fmt(fmt) \"IPv6: \" fmt\n\n#include <linux/capability.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/times.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/route.h>\n#include <linux/netdevice.h>\n#include <linux/in6.h>\n#include <linux/mroute6.h>\n#include <linux/init.h>\n#include <linux/if_arp.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/nsproxy.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <net/net_namespace.h>\n#include <net/snmp.h>\n#include <net/ipv6.h>\n#include <net/ip6_fib.h>\n#include <net/ip6_route.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/tcp.h>\n#include <linux/rtnetlink.h>\n#include <net/dst.h>\n#include <net/dst_metadata.h>\n#include <net/xfrm.h>\n#include <net/netevent.h>\n#include <net/netlink.h>\n#include <net/rtnh.h>\n#include <net/lwtunnel.h>\n#include <net/ip_tunnels.h>\n#include <net/l3mdev.h>\n#include <net/ip.h>\n#include <linux/uaccess.h>\n#include <linux/btf_ids.h>\n\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n\nstatic int ip6_rt_type_to_error(u8 fib6_type);\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/fib6.h>\nEXPORT_TRACEPOINT_SYMBOL_GPL(fib6_table_lookup);\n#undef CREATE_TRACE_POINTS\n\nenum rt6_nud_state {\n\tRT6_NUD_FAIL_HARD = -3,\n\tRT6_NUD_FAIL_PROBE = -2,\n\tRT6_NUD_FAIL_DO_RR = -1,\n\tRT6_NUD_SUCCEED = 1\n};\n\nINDIRECT_CALLABLE_SCOPE\nstruct dst_entry\t*ip6_dst_check(struct dst_entry *dst, u32 cookie);\nstatic unsigned int\t ip6_default_advmss(const struct dst_entry *dst);\nINDIRECT_CALLABLE_SCOPE\nunsigned int\t\tip6_mtu(const struct dst_entry *dst);\nstatic struct dst_entry *ip6_negative_advice(struct dst_entry *);\nstatic void\t\tip6_dst_destroy(struct dst_entry *);\nstatic void\t\tip6_dst_ifdown(struct dst_entry *,\n\t\t\t\t       struct net_device *dev, int how);\nstatic int\t\t ip6_dst_gc(struct dst_ops *ops);\n\nstatic int\t\tip6_pkt_discard(struct sk_buff *skb);\nstatic int\t\tip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nstatic int\t\tip6_pkt_prohibit(struct sk_buff *skb);\nstatic int\t\tip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb);\nstatic void\t\tip6_link_failure(struct sk_buff *skb);\nstatic void\t\tip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\t   struct sk_buff *skb, u32 mtu,\n\t\t\t\t\t   bool confirm_neigh);\nstatic void\t\trt6_do_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\tstruct sk_buff *skb);\nstatic int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,\n\t\t\t   int strict);\nstatic size_t rt6_nlmsg_size(struct fib6_info *f6i);\nstatic int rt6_fill_node(struct net *net, struct sk_buff *skb,\n\t\t\t struct fib6_info *rt, struct dst_entry *dst,\n\t\t\t struct in6_addr *dest, struct in6_addr *src,\n\t\t\t int iif, int type, u32 portid, u32 seq,\n\t\t\t unsigned int flags);\nstatic struct rt6_info *rt6_find_cached_rt(const struct fib6_result *res,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const struct in6_addr *saddr);\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\nstatic struct fib6_info *rt6_add_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   unsigned int pref);\nstatic struct fib6_info *rt6_get_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev);\n#endif\n\nstruct uncached_list {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n};\n\nstatic DEFINE_PER_CPU_ALIGNED(struct uncached_list, rt6_uncached_list);\n\nvoid rt6_uncached_list_add(struct rt6_info *rt)\n{\n\tstruct uncached_list *ul = raw_cpu_ptr(&rt6_uncached_list);\n\n\trt->rt6i_uncached_list = ul;\n\n\tspin_lock_bh(&ul->lock);\n\tlist_add_tail(&rt->rt6i_uncached, &ul->head);\n\tspin_unlock_bh(&ul->lock);\n}\n\nvoid rt6_uncached_list_del(struct rt6_info *rt)\n{\n\tif (!list_empty(&rt->rt6i_uncached)) {\n\t\tstruct uncached_list *ul = rt->rt6i_uncached_list;\n\t\tstruct net *net = dev_net(rt->dst.dev);\n\n\t\tspin_lock_bh(&ul->lock);\n\t\tlist_del(&rt->rt6i_uncached);\n\t\tatomic_dec(&net->ipv6.rt6_stats->fib_rt_uncache);\n\t\tspin_unlock_bh(&ul->lock);\n\t}\n}\n\nstatic void rt6_uncached_list_flush_dev(struct net *net, struct net_device *dev)\n{\n\tstruct net_device *loopback_dev = net->loopback_dev;\n\tint cpu;\n\n\tif (dev == loopback_dev)\n\t\treturn;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = per_cpu_ptr(&rt6_uncached_list, cpu);\n\t\tstruct rt6_info *rt;\n\n\t\tspin_lock_bh(&ul->lock);\n\t\tlist_for_each_entry(rt, &ul->head, rt6i_uncached) {\n\t\t\tstruct inet6_dev *rt_idev = rt->rt6i_idev;\n\t\t\tstruct net_device *rt_dev = rt->dst.dev;\n\n\t\t\tif (rt_idev->dev == dev) {\n\t\t\t\trt->rt6i_idev = in6_dev_get(loopback_dev);\n\t\t\t\tin6_dev_put(rt_idev);\n\t\t\t}\n\n\t\t\tif (rt_dev == dev) {\n\t\t\t\trt->dst.dev = blackhole_netdev;\n\t\t\t\tdev_hold(rt->dst.dev);\n\t\t\t\tdev_put(rt_dev);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&ul->lock);\n\t}\n}\n\nstatic inline const void *choose_neigh_daddr(const struct in6_addr *p,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\tif (!ipv6_addr_any(p))\n\t\treturn (const void *) p;\n\telse if (skb)\n\t\treturn &ipv6_hdr(skb)->daddr;\n\treturn daddr;\n}\n\nstruct neighbour *ip6_neigh_lookup(const struct in6_addr *gw,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const void *daddr)\n{\n\tstruct neighbour *n;\n\n\tdaddr = choose_neigh_daddr(gw, skb, daddr);\n\tn = __ipv6_neigh_lookup(dev, daddr);\n\tif (n)\n\t\treturn n;\n\n\tn = neigh_create(&nd_tbl, daddr, dev);\n\treturn IS_ERR(n) ? NULL : n;\n}\n\nstatic struct neighbour *ip6_dst_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      const void *daddr)\n{\n\tconst struct rt6_info *rt = container_of(dst, struct rt6_info, dst);\n\n\treturn ip6_neigh_lookup(rt6_nexthop(rt, &in6addr_any),\n\t\t\t\tdst->dev, skb, daddr);\n}\n\nstatic void ip6_confirm_neigh(const struct dst_entry *dst, const void *daddr)\n{\n\tstruct net_device *dev = dst->dev;\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tdaddr = choose_neigh_daddr(rt6_nexthop(rt, &in6addr_any), NULL, daddr);\n\tif (!daddr)\n\t\treturn;\n\tif (dev->flags & (IFF_NOARP | IFF_LOOPBACK))\n\t\treturn;\n\tif (ipv6_addr_is_multicast((const struct in6_addr *)daddr))\n\t\treturn;\n\t__ipv6_confirm_neigh(dev, daddr);\n}\n\nstatic struct dst_ops ip6_dst_ops_template = {\n\t.family\t\t\t=\tAF_INET6,\n\t.gc\t\t\t=\tip6_dst_gc,\n\t.gc_thresh\t\t=\t1024,\n\t.check\t\t\t=\tip6_dst_check,\n\t.default_advmss\t\t=\tip6_default_advmss,\n\t.mtu\t\t\t=\tip6_mtu,\n\t.cow_metrics\t\t=\tdst_cow_metrics_generic,\n\t.destroy\t\t=\tip6_dst_destroy,\n\t.ifdown\t\t\t=\tip6_dst_ifdown,\n\t.negative_advice\t=\tip6_negative_advice,\n\t.link_failure\t\t=\tip6_link_failure,\n\t.update_pmtu\t\t=\tip6_rt_update_pmtu,\n\t.redirect\t\t=\trt6_do_redirect,\n\t.local_out\t\t=\t__ip6_local_out,\n\t.neigh_lookup\t\t=\tip6_dst_neigh_lookup,\n\t.confirm_neigh\t\t=\tip6_confirm_neigh,\n};\n\nstatic unsigned int ip6_blackhole_mtu(const struct dst_entry *dst)\n{\n\tunsigned int mtu = dst_metric_raw(dst, RTAX_MTU);\n\n\treturn mtu ? : dst->dev->mtu;\n}\n\nstatic void ip6_rt_blackhole_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\t struct sk_buff *skb, u32 mtu,\n\t\t\t\t\t bool confirm_neigh)\n{\n}\n\nstatic void ip6_rt_blackhole_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t      struct sk_buff *skb)\n{\n}\n\nstatic struct dst_ops ip6_dst_blackhole_ops = {\n\t.family\t\t\t=\tAF_INET6,\n\t.destroy\t\t=\tip6_dst_destroy,\n\t.check\t\t\t=\tip6_dst_check,\n\t.mtu\t\t\t=\tip6_blackhole_mtu,\n\t.default_advmss\t\t=\tip6_default_advmss,\n\t.update_pmtu\t\t=\tip6_rt_blackhole_update_pmtu,\n\t.redirect\t\t=\tip6_rt_blackhole_redirect,\n\t.cow_metrics\t\t=\tdst_cow_metrics_generic,\n\t.neigh_lookup\t\t=\tip6_dst_neigh_lookup,\n};\n\nstatic const u32 ip6_template_metrics[RTAX_MAX] = {\n\t[RTAX_HOPLIMIT - 1] = 0,\n};\n\nstatic const struct fib6_info fib6_null_entry_template = {\n\t.fib6_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n\t.fib6_protocol  = RTPROT_KERNEL,\n\t.fib6_metric\t= ~(u32)0,\n\t.fib6_ref\t= REFCOUNT_INIT(1),\n\t.fib6_type\t= RTN_UNREACHABLE,\n\t.fib6_metrics\t= (struct dst_metrics *)&dst_default_metrics,\n};\n\nstatic const struct rt6_info ip6_null_entry_template = {\n\t.dst = {\n\t\t.__refcnt\t= ATOMIC_INIT(1),\n\t\t.__use\t\t= 1,\n\t\t.obsolete\t= DST_OBSOLETE_FORCE_CHK,\n\t\t.error\t\t= -ENETUNREACH,\n\t\t.input\t\t= ip6_pkt_discard,\n\t\t.output\t\t= ip6_pkt_discard_out,\n\t},\n\t.rt6i_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n};\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\nstatic const struct rt6_info ip6_prohibit_entry_template = {\n\t.dst = {\n\t\t.__refcnt\t= ATOMIC_INIT(1),\n\t\t.__use\t\t= 1,\n\t\t.obsolete\t= DST_OBSOLETE_FORCE_CHK,\n\t\t.error\t\t= -EACCES,\n\t\t.input\t\t= ip6_pkt_prohibit,\n\t\t.output\t\t= ip6_pkt_prohibit_out,\n\t},\n\t.rt6i_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n};\n\nstatic const struct rt6_info ip6_blk_hole_entry_template = {\n\t.dst = {\n\t\t.__refcnt\t= ATOMIC_INIT(1),\n\t\t.__use\t\t= 1,\n\t\t.obsolete\t= DST_OBSOLETE_FORCE_CHK,\n\t\t.error\t\t= -EINVAL,\n\t\t.input\t\t= dst_discard,\n\t\t.output\t\t= dst_discard_out,\n\t},\n\t.rt6i_flags\t= (RTF_REJECT | RTF_NONEXTHOP),\n};\n\n#endif\n\nstatic void rt6_info_init(struct rt6_info *rt)\n{\n\tstruct dst_entry *dst = &rt->dst;\n\n\tmemset(dst + 1, 0, sizeof(*rt) - sizeof(*dst));\n\tINIT_LIST_HEAD(&rt->rt6i_uncached);\n}\n\n/* allocate dst with ip6_dst_ops */\nstruct rt6_info *ip6_dst_alloc(struct net *net, struct net_device *dev,\n\t\t\t       int flags)\n{\n\tstruct rt6_info *rt = dst_alloc(&net->ipv6.ip6_dst_ops, dev,\n\t\t\t\t\t1, DST_OBSOLETE_FORCE_CHK, flags);\n\n\tif (rt) {\n\t\trt6_info_init(rt);\n\t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_alloc);\n\t}\n\n\treturn rt;\n}\nEXPORT_SYMBOL(ip6_dst_alloc);\n\nstatic void ip6_dst_destroy(struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct fib6_info *from;\n\tstruct inet6_dev *idev;\n\n\tip_dst_metrics_put(dst);\n\trt6_uncached_list_del(rt);\n\n\tidev = rt->rt6i_idev;\n\tif (idev) {\n\t\trt->rt6i_idev = NULL;\n\t\tin6_dev_put(idev);\n\t}\n\n\tfrom = xchg((__force struct fib6_info **)&rt->from, NULL);\n\tfib6_info_release(from);\n}\n\nstatic void ip6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,\n\t\t\t   int how)\n{\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tstruct inet6_dev *idev = rt->rt6i_idev;\n\tstruct net_device *loopback_dev =\n\t\tdev_net(dev)->loopback_dev;\n\n\tif (idev && idev->dev != loopback_dev) {\n\t\tstruct inet6_dev *loopback_idev = in6_dev_get(loopback_dev);\n\t\tif (loopback_idev) {\n\t\t\trt->rt6i_idev = loopback_idev;\n\t\t\tin6_dev_put(idev);\n\t\t}\n\t}\n}\n\nstatic bool __rt6_check_expired(const struct rt6_info *rt)\n{\n\tif (rt->rt6i_flags & RTF_EXPIRES)\n\t\treturn time_after(jiffies, rt->dst.expires);\n\telse\n\t\treturn false;\n}\n\nstatic bool rt6_check_expired(const struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\n\tfrom = rcu_dereference(rt->from);\n\n\tif (rt->rt6i_flags & RTF_EXPIRES) {\n\t\tif (time_after(jiffies, rt->dst.expires))\n\t\t\treturn true;\n\t} else if (from) {\n\t\treturn rt->dst.obsolete != DST_OBSOLETE_FORCE_CHK ||\n\t\t\tfib6_check_expired(from);\n\t}\n\treturn false;\n}\n\nvoid fib6_select_path(const struct net *net, struct fib6_result *res,\n\t\t      struct flowi6 *fl6, int oif, bool have_oif_match,\n\t\t      const struct sk_buff *skb, int strict)\n{\n\tstruct fib6_info *sibling, *next_sibling;\n\tstruct fib6_info *match = res->f6i;\n\n\tif (!match->nh && (!match->fib6_nsiblings || have_oif_match))\n\t\tgoto out;\n\n\tif (match->nh && have_oif_match && res->nh)\n\t\treturn;\n\n\t/* We might have already computed the hash for ICMPv6 errors. In such\n\t * case it will always be non-zero. Otherwise now is the time to do it.\n\t */\n\tif (!fl6->mp_hash &&\n\t    (!match->nh || nexthop_is_multipath(match->nh)))\n\t\tfl6->mp_hash = rt6_multipath_hash(net, fl6, skb, NULL);\n\n\tif (unlikely(match->nh)) {\n\t\tnexthop_path_fib6_result(res, fl6->mp_hash);\n\t\treturn;\n\t}\n\n\tif (fl6->mp_hash <= atomic_read(&match->fib6_nh->fib_nh_upper_bound))\n\t\tgoto out;\n\n\tlist_for_each_entry_safe(sibling, next_sibling, &match->fib6_siblings,\n\t\t\t\t fib6_siblings) {\n\t\tconst struct fib6_nh *nh = sibling->fib6_nh;\n\t\tint nh_upper_bound;\n\n\t\tnh_upper_bound = atomic_read(&nh->fib_nh_upper_bound);\n\t\tif (fl6->mp_hash > nh_upper_bound)\n\t\t\tcontinue;\n\t\tif (rt6_score_route(nh, sibling->fib6_flags, oif, strict) < 0)\n\t\t\tbreak;\n\t\tmatch = sibling;\n\t\tbreak;\n\t}\n\nout:\n\tres->f6i = match;\n\tres->nh = match->fib6_nh;\n}\n\n/*\n *\tRoute lookup. rcu_read_lock() should be held.\n */\n\nstatic bool __rt6_device_match(struct net *net, const struct fib6_nh *nh,\n\t\t\t       const struct in6_addr *saddr, int oif, int flags)\n{\n\tconst struct net_device *dev;\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD)\n\t\treturn false;\n\n\tdev = nh->fib_nh_dev;\n\tif (oif) {\n\t\tif (dev->ifindex == oif)\n\t\t\treturn true;\n\t} else {\n\t\tif (ipv6_chk_addr(net, saddr, dev,\n\t\t\t\t  flags & RT6_LOOKUP_F_IFACE))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstruct fib6_nh_dm_arg {\n\tstruct net\t\t*net;\n\tconst struct in6_addr\t*saddr;\n\tint\t\t\toif;\n\tint\t\t\tflags;\n\tstruct fib6_nh\t\t*nh;\n};\n\nstatic int __rt6_nh_dev_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_dm_arg *arg = _arg;\n\n\targ->nh = nh;\n\treturn __rt6_device_match(arg->net, nh, arg->saddr, arg->oif,\n\t\t\t\t  arg->flags);\n}\n\n/* returns fib6_nh from nexthop or NULL */\nstatic struct fib6_nh *rt6_nh_dev_match(struct net *net, struct nexthop *nh,\n\t\t\t\t\tstruct fib6_result *res,\n\t\t\t\t\tconst struct in6_addr *saddr,\n\t\t\t\t\tint oif, int flags)\n{\n\tstruct fib6_nh_dm_arg arg = {\n\t\t.net   = net,\n\t\t.saddr = saddr,\n\t\t.oif   = oif,\n\t\t.flags = flags,\n\t};\n\n\tif (nexthop_is_blackhole(nh))\n\t\treturn NULL;\n\n\tif (nexthop_for_each_fib6_nh(nh, __rt6_nh_dev_match, &arg))\n\t\treturn arg.nh;\n\n\treturn NULL;\n}\n\nstatic void rt6_device_match(struct net *net, struct fib6_result *res,\n\t\t\t     const struct in6_addr *saddr, int oif, int flags)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct fib6_info *spf6i;\n\tstruct fib6_nh *nh;\n\n\tif (!oif && ipv6_addr_any(saddr)) {\n\t\tif (unlikely(f6i->nh)) {\n\t\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\t\tgoto out_blackhole;\n\t\t} else {\n\t\t\tnh = f6i->fib6_nh;\n\t\t}\n\t\tif (!(nh->fib_nh_flags & RTNH_F_DEAD))\n\t\t\tgoto out;\n\t}\n\n\tfor (spf6i = f6i; spf6i; spf6i = rcu_dereference(spf6i->fib6_next)) {\n\t\tbool matched = false;\n\n\t\tif (unlikely(spf6i->nh)) {\n\t\t\tnh = rt6_nh_dev_match(net, spf6i->nh, res, saddr,\n\t\t\t\t\t      oif, flags);\n\t\t\tif (nh)\n\t\t\t\tmatched = true;\n\t\t} else {\n\t\t\tnh = spf6i->fib6_nh;\n\t\t\tif (__rt6_device_match(net, nh, saddr, oif, flags))\n\t\t\t\tmatched = true;\n\t\t}\n\t\tif (matched) {\n\t\t\tres->f6i = spf6i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (oif && flags & RT6_LOOKUP_F_IFACE) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(f6i->nh)) {\n\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\tgoto out_blackhole;\n\t} else {\n\t\tnh = f6i->fib6_nh;\n\t}\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t}\nout:\n\tres->nh = nh;\n\tres->fib6_type = res->f6i->fib6_type;\n\tres->fib6_flags = res->f6i->fib6_flags;\n\treturn;\n\nout_blackhole:\n\tres->fib6_flags |= RTF_REJECT;\n\tres->fib6_type = RTN_BLACKHOLE;\n\tres->nh = nh;\n}\n\n#ifdef CONFIG_IPV6_ROUTER_PREF\nstruct __rt6_probe_work {\n\tstruct work_struct work;\n\tstruct in6_addr target;\n\tstruct net_device *dev;\n};\n\nstatic void rt6_probe_deferred(struct work_struct *w)\n{\n\tstruct in6_addr mcaddr;\n\tstruct __rt6_probe_work *work =\n\t\tcontainer_of(w, struct __rt6_probe_work, work);\n\n\taddrconf_addr_solict_mult(&work->target, &mcaddr);\n\tndisc_send_ns(work->dev, &work->target, &mcaddr, NULL, 0);\n\tdev_put(work->dev);\n\tkfree(work);\n}\n\nstatic void rt6_probe(struct fib6_nh *fib6_nh)\n{\n\tstruct __rt6_probe_work *work = NULL;\n\tconst struct in6_addr *nh_gw;\n\tunsigned long last_probe;\n\tstruct neighbour *neigh;\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\n\t/*\n\t * Okay, this does not seem to be appropriate\n\t * for now, however, we need to check if it\n\t * is really so; aka Router Reachability Probing.\n\t *\n\t * Router Reachability Probe MUST be rate-limited\n\t * to no more than one per minute.\n\t */\n\tif (!fib6_nh->fib_nh_gw_family)\n\t\treturn;\n\n\tnh_gw = &fib6_nh->fib_nh_gw6;\n\tdev = fib6_nh->fib_nh_dev;\n\trcu_read_lock_bh();\n\tlast_probe = READ_ONCE(fib6_nh->last_probe);\n\tidev = __in6_dev_get(dev);\n\tneigh = __ipv6_neigh_lookup_noref(dev, nh_gw);\n\tif (neigh) {\n\t\tif (neigh->nud_state & NUD_VALID)\n\t\t\tgoto out;\n\n\t\twrite_lock(&neigh->lock);\n\t\tif (!(neigh->nud_state & NUD_VALID) &&\n\t\t    time_after(jiffies,\n\t\t\t       neigh->updated + idev->cnf.rtr_probe_interval)) {\n\t\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\t\tif (work)\n\t\t\t\t__neigh_set_probe_once(neigh);\n\t\t}\n\t\twrite_unlock(&neigh->lock);\n\t} else if (time_after(jiffies, last_probe +\n\t\t\t\t       idev->cnf.rtr_probe_interval)) {\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t}\n\n\tif (!work || cmpxchg(&fib6_nh->last_probe,\n\t\t\t     last_probe, jiffies) != last_probe) {\n\t\tkfree(work);\n\t} else {\n\t\tINIT_WORK(&work->work, rt6_probe_deferred);\n\t\twork->target = *nh_gw;\n\t\tdev_hold(dev);\n\t\twork->dev = dev;\n\t\tschedule_work(&work->work);\n\t}\n\nout:\n\trcu_read_unlock_bh();\n}\n#else\nstatic inline void rt6_probe(struct fib6_nh *fib6_nh)\n{\n}\n#endif\n\n/*\n * Default Router Selection (RFC 2461 6.3.6)\n */\nstatic enum rt6_nud_state rt6_check_neigh(const struct fib6_nh *fib6_nh)\n{\n\tenum rt6_nud_state ret = RT6_NUD_FAIL_HARD;\n\tstruct neighbour *neigh;\n\n\trcu_read_lock_bh();\n\tneigh = __ipv6_neigh_lookup_noref(fib6_nh->fib_nh_dev,\n\t\t\t\t\t  &fib6_nh->fib_nh_gw6);\n\tif (neigh) {\n\t\tread_lock(&neigh->lock);\n\t\tif (neigh->nud_state & NUD_VALID)\n\t\t\tret = RT6_NUD_SUCCEED;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\t\telse if (!(neigh->nud_state & NUD_FAILED))\n\t\t\tret = RT6_NUD_SUCCEED;\n\t\telse\n\t\t\tret = RT6_NUD_FAIL_PROBE;\n#endif\n\t\tread_unlock(&neigh->lock);\n\t} else {\n\t\tret = IS_ENABLED(CONFIG_IPV6_ROUTER_PREF) ?\n\t\t      RT6_NUD_SUCCEED : RT6_NUD_FAIL_DO_RR;\n\t}\n\trcu_read_unlock_bh();\n\n\treturn ret;\n}\n\nstatic int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,\n\t\t\t   int strict)\n{\n\tint m = 0;\n\n\tif (!oif || nh->fib_nh_dev->ifindex == oif)\n\t\tm = 2;\n\n\tif (!m && (strict & RT6_LOOKUP_F_IFACE))\n\t\treturn RT6_NUD_FAIL_HARD;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tm |= IPV6_DECODE_PREF(IPV6_EXTRACT_PREF(fib6_flags)) << 2;\n#endif\n\tif ((strict & RT6_LOOKUP_F_REACHABLE) &&\n\t    !(fib6_flags & RTF_NONEXTHOP) && nh->fib_nh_gw_family) {\n\t\tint n = rt6_check_neigh(nh);\n\t\tif (n < 0)\n\t\t\treturn n;\n\t}\n\treturn m;\n}\n\nstatic bool find_match(struct fib6_nh *nh, u32 fib6_flags,\n\t\t       int oif, int strict, int *mpri, bool *do_rr)\n{\n\tbool match_do_rr = false;\n\tbool rc = false;\n\tint m;\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD)\n\t\tgoto out;\n\n\tif (ip6_ignore_linkdown(nh->fib_nh_dev) &&\n\t    nh->fib_nh_flags & RTNH_F_LINKDOWN &&\n\t    !(strict & RT6_LOOKUP_F_IGNORE_LINKSTATE))\n\t\tgoto out;\n\n\tm = rt6_score_route(nh, fib6_flags, oif, strict);\n\tif (m == RT6_NUD_FAIL_DO_RR) {\n\t\tmatch_do_rr = true;\n\t\tm = 0; /* lowest valid score */\n\t} else if (m == RT6_NUD_FAIL_HARD) {\n\t\tgoto out;\n\t}\n\n\tif (strict & RT6_LOOKUP_F_REACHABLE)\n\t\trt6_probe(nh);\n\n\t/* note that m can be RT6_NUD_FAIL_PROBE at this point */\n\tif (m > *mpri) {\n\t\t*do_rr = match_do_rr;\n\t\t*mpri = m;\n\t\trc = true;\n\t}\nout:\n\treturn rc;\n}\n\nstruct fib6_nh_frl_arg {\n\tu32\t\tflags;\n\tint\t\toif;\n\tint\t\tstrict;\n\tint\t\t*mpri;\n\tbool\t\t*do_rr;\n\tstruct fib6_nh\t*nh;\n};\n\nstatic int rt6_nh_find_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_frl_arg *arg = _arg;\n\n\targ->nh = nh;\n\treturn find_match(nh, arg->flags, arg->oif, arg->strict,\n\t\t\t  arg->mpri, arg->do_rr);\n}\n\nstatic void __find_rr_leaf(struct fib6_info *f6i_start,\n\t\t\t   struct fib6_info *nomatch, u32 metric,\n\t\t\t   struct fib6_result *res, struct fib6_info **cont,\n\t\t\t   int oif, int strict, bool *do_rr, int *mpri)\n{\n\tstruct fib6_info *f6i;\n\n\tfor (f6i = f6i_start;\n\t     f6i && f6i != nomatch;\n\t     f6i = rcu_dereference(f6i->fib6_next)) {\n\t\tbool matched = false;\n\t\tstruct fib6_nh *nh;\n\n\t\tif (cont && f6i->fib6_metric != metric) {\n\t\t\t*cont = f6i;\n\t\t\treturn;\n\t\t}\n\n\t\tif (fib6_check_expired(f6i))\n\t\t\tcontinue;\n\n\t\tif (unlikely(f6i->nh)) {\n\t\t\tstruct fib6_nh_frl_arg arg = {\n\t\t\t\t.flags  = f6i->fib6_flags,\n\t\t\t\t.oif    = oif,\n\t\t\t\t.strict = strict,\n\t\t\t\t.mpri   = mpri,\n\t\t\t\t.do_rr  = do_rr\n\t\t\t};\n\n\t\t\tif (nexthop_is_blackhole(f6i->nh)) {\n\t\t\t\tres->fib6_flags = RTF_REJECT;\n\t\t\t\tres->fib6_type = RTN_BLACKHOLE;\n\t\t\t\tres->f6i = f6i;\n\t\t\t\tres->nh = nexthop_fib6_nh(f6i->nh);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (nexthop_for_each_fib6_nh(f6i->nh, rt6_nh_find_match,\n\t\t\t\t\t\t     &arg)) {\n\t\t\t\tmatched = true;\n\t\t\t\tnh = arg.nh;\n\t\t\t}\n\t\t} else {\n\t\t\tnh = f6i->fib6_nh;\n\t\t\tif (find_match(nh, f6i->fib6_flags, oif, strict,\n\t\t\t\t       mpri, do_rr))\n\t\t\t\tmatched = true;\n\t\t}\n\t\tif (matched) {\n\t\t\tres->f6i = f6i;\n\t\t\tres->nh = nh;\n\t\t\tres->fib6_flags = f6i->fib6_flags;\n\t\t\tres->fib6_type = f6i->fib6_type;\n\t\t}\n\t}\n}\n\nstatic void find_rr_leaf(struct fib6_node *fn, struct fib6_info *leaf,\n\t\t\t struct fib6_info *rr_head, int oif, int strict,\n\t\t\t bool *do_rr, struct fib6_result *res)\n{\n\tu32 metric = rr_head->fib6_metric;\n\tstruct fib6_info *cont = NULL;\n\tint mpri = -1;\n\n\t__find_rr_leaf(rr_head, NULL, metric, res, &cont,\n\t\t       oif, strict, do_rr, &mpri);\n\n\t__find_rr_leaf(leaf, rr_head, metric, res, &cont,\n\t\t       oif, strict, do_rr, &mpri);\n\n\tif (res->f6i || !cont)\n\t\treturn;\n\n\t__find_rr_leaf(cont, NULL, metric, res, NULL,\n\t\t       oif, strict, do_rr, &mpri);\n}\n\nstatic void rt6_select(struct net *net, struct fib6_node *fn, int oif,\n\t\t       struct fib6_result *res, int strict)\n{\n\tstruct fib6_info *leaf = rcu_dereference(fn->leaf);\n\tstruct fib6_info *rt0;\n\tbool do_rr = false;\n\tint key_plen;\n\n\t/* make sure this function or its helpers sets f6i */\n\tres->f6i = NULL;\n\n\tif (!leaf || leaf == net->ipv6.fib6_null_entry)\n\t\tgoto out;\n\n\trt0 = rcu_dereference(fn->rr_ptr);\n\tif (!rt0)\n\t\trt0 = leaf;\n\n\t/* Double check to make sure fn is not an intermediate node\n\t * and fn->leaf does not points to its child's leaf\n\t * (This might happen if all routes under fn are deleted from\n\t * the tree and fib6_repair_tree() is called on the node.)\n\t */\n\tkey_plen = rt0->fib6_dst.plen;\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (rt0->fib6_src.plen)\n\t\tkey_plen = rt0->fib6_src.plen;\n#endif\n\tif (fn->fn_bit != key_plen)\n\t\tgoto out;\n\n\tfind_rr_leaf(fn, leaf, rt0, oif, strict, &do_rr, res);\n\tif (do_rr) {\n\t\tstruct fib6_info *next = rcu_dereference(rt0->fib6_next);\n\n\t\t/* no entries matched; do round-robin */\n\t\tif (!next || next->fib6_metric != rt0->fib6_metric)\n\t\t\tnext = leaf;\n\n\t\tif (next != rt0) {\n\t\t\tspin_lock_bh(&leaf->fib6_table->tb6_lock);\n\t\t\t/* make sure next is not being deleted from the tree */\n\t\t\tif (next->fib6_node)\n\t\t\t\trcu_assign_pointer(fn->rr_ptr, next);\n\t\t\tspin_unlock_bh(&leaf->fib6_table->tb6_lock);\n\t\t}\n\t}\n\nout:\n\tif (!res->f6i) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tres->nh = res->f6i->fib6_nh;\n\t\tres->fib6_flags = res->f6i->fib6_flags;\n\t\tres->fib6_type = res->f6i->fib6_type;\n\t}\n}\n\nstatic bool rt6_is_gw_or_nonexthop(const struct fib6_result *res)\n{\n\treturn (res->f6i->fib6_flags & RTF_NONEXTHOP) ||\n\t       res->nh->fib_nh_gw_family;\n}\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\nint rt6_route_rcv(struct net_device *dev, u8 *opt, int len,\n\t\t  const struct in6_addr *gwaddr)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct route_info *rinfo = (struct route_info *) opt;\n\tstruct in6_addr prefix_buf, *prefix;\n\tunsigned int pref;\n\tunsigned long lifetime;\n\tstruct fib6_info *rt;\n\n\tif (len < sizeof(struct route_info)) {\n\t\treturn -EINVAL;\n\t}\n\n\t/* Sanity check for prefix_len and length */\n\tif (rinfo->length > 3) {\n\t\treturn -EINVAL;\n\t} else if (rinfo->prefix_len > 128) {\n\t\treturn -EINVAL;\n\t} else if (rinfo->prefix_len > 64) {\n\t\tif (rinfo->length < 2) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (rinfo->prefix_len > 0) {\n\t\tif (rinfo->length < 1) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpref = rinfo->route_pref;\n\tif (pref == ICMPV6_ROUTER_PREF_INVALID)\n\t\treturn -EINVAL;\n\n\tlifetime = addrconf_timeout_fixup(ntohl(rinfo->lifetime), HZ);\n\n\tif (rinfo->length == 3)\n\t\tprefix = (struct in6_addr *)rinfo->prefix;\n\telse {\n\t\t/* this function is safe */\n\t\tipv6_addr_prefix(&prefix_buf,\n\t\t\t\t (struct in6_addr *)rinfo->prefix,\n\t\t\t\t rinfo->prefix_len);\n\t\tprefix = &prefix_buf;\n\t}\n\n\tif (rinfo->prefix_len == 0)\n\t\trt = rt6_get_dflt_router(net, gwaddr, dev);\n\telse\n\t\trt = rt6_get_route_info(net, prefix, rinfo->prefix_len,\n\t\t\t\t\tgwaddr, dev);\n\n\tif (rt && !lifetime) {\n\t\tip6_del_rt(net, rt, false);\n\t\trt = NULL;\n\t}\n\n\tif (!rt && lifetime)\n\t\trt = rt6_add_route_info(net, prefix, rinfo->prefix_len, gwaddr,\n\t\t\t\t\tdev, pref);\n\telse if (rt)\n\t\trt->fib6_flags = RTF_ROUTEINFO |\n\t\t\t\t (rt->fib6_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\n\n\tif (rt) {\n\t\tif (!addrconf_finite_timeout(lifetime))\n\t\t\tfib6_clean_expires(rt);\n\t\telse\n\t\t\tfib6_set_expires(rt, jiffies + HZ * lifetime);\n\n\t\tfib6_info_release(rt);\n\t}\n\treturn 0;\n}\n#endif\n\n/*\n *\tMisc support functions\n */\n\n/* called with rcu_lock held */\nstatic struct net_device *ip6_rt_get_dev_rcu(const struct fib6_result *res)\n{\n\tstruct net_device *dev = res->nh->fib_nh_dev;\n\n\tif (res->fib6_flags & (RTF_LOCAL | RTF_ANYCAST)) {\n\t\t/* for copies of local routes, dst->dev needs to be the\n\t\t * device if it is a master device, the master device if\n\t\t * device is enslaved, and the loopback as the default\n\t\t */\n\t\tif (netif_is_l3_slave(dev) &&\n\t\t    !rt6_need_strict(&res->f6i->fib6_dst.addr))\n\t\t\tdev = l3mdev_master_dev_rcu(dev);\n\t\telse if (!netif_is_l3_master(dev))\n\t\t\tdev = dev_net(dev)->loopback_dev;\n\t\t/* last case is netif_is_l3_master(dev) is true in which\n\t\t * case we want dev returned to be dev\n\t\t */\n\t}\n\n\treturn dev;\n}\n\nstatic const int fib6_prop[RTN_MAX + 1] = {\n\t[RTN_UNSPEC]\t= 0,\n\t[RTN_UNICAST]\t= 0,\n\t[RTN_LOCAL]\t= 0,\n\t[RTN_BROADCAST]\t= 0,\n\t[RTN_ANYCAST]\t= 0,\n\t[RTN_MULTICAST]\t= 0,\n\t[RTN_BLACKHOLE]\t= -EINVAL,\n\t[RTN_UNREACHABLE] = -EHOSTUNREACH,\n\t[RTN_PROHIBIT]\t= -EACCES,\n\t[RTN_THROW]\t= -EAGAIN,\n\t[RTN_NAT]\t= -EINVAL,\n\t[RTN_XRESOLVE]\t= -EINVAL,\n};\n\nstatic int ip6_rt_type_to_error(u8 fib6_type)\n{\n\treturn fib6_prop[fib6_type];\n}\n\nstatic unsigned short fib6_info_dst_flags(struct fib6_info *rt)\n{\n\tunsigned short flags = 0;\n\n\tif (rt->dst_nocount)\n\t\tflags |= DST_NOCOUNT;\n\tif (rt->dst_nopolicy)\n\t\tflags |= DST_NOPOLICY;\n\n\treturn flags;\n}\n\nstatic void ip6_rt_init_dst_reject(struct rt6_info *rt, u8 fib6_type)\n{\n\trt->dst.error = ip6_rt_type_to_error(fib6_type);\n\n\tswitch (fib6_type) {\n\tcase RTN_BLACKHOLE:\n\t\trt->dst.output = dst_discard_out;\n\t\trt->dst.input = dst_discard;\n\t\tbreak;\n\tcase RTN_PROHIBIT:\n\t\trt->dst.output = ip6_pkt_prohibit_out;\n\t\trt->dst.input = ip6_pkt_prohibit;\n\t\tbreak;\n\tcase RTN_THROW:\n\tcase RTN_UNREACHABLE:\n\tdefault:\n\t\trt->dst.output = ip6_pkt_discard_out;\n\t\trt->dst.input = ip6_pkt_discard;\n\t\tbreak;\n\t}\n}\n\nstatic void ip6_rt_init_dst(struct rt6_info *rt, const struct fib6_result *res)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\n\tif (res->fib6_flags & RTF_REJECT) {\n\t\tip6_rt_init_dst_reject(rt, res->fib6_type);\n\t\treturn;\n\t}\n\n\trt->dst.error = 0;\n\trt->dst.output = ip6_output;\n\n\tif (res->fib6_type == RTN_LOCAL || res->fib6_type == RTN_ANYCAST) {\n\t\trt->dst.input = ip6_input;\n\t} else if (ipv6_addr_type(&f6i->fib6_dst.addr) & IPV6_ADDR_MULTICAST) {\n\t\trt->dst.input = ip6_mc_input;\n\t} else {\n\t\trt->dst.input = ip6_forward;\n\t}\n\n\tif (res->nh->fib_nh_lws) {\n\t\trt->dst.lwtstate = lwtstate_get(res->nh->fib_nh_lws);\n\t\tlwtunnel_set_redirect(&rt->dst);\n\t}\n\n\trt->dst.lastuse = jiffies;\n}\n\n/* Caller must already hold reference to @from */\nstatic void rt6_set_from(struct rt6_info *rt, struct fib6_info *from)\n{\n\trt->rt6i_flags &= ~RTF_EXPIRES;\n\trcu_assign_pointer(rt->from, from);\n\tip_dst_init_metrics(&rt->dst, from->fib6_metrics);\n}\n\n/* Caller must already hold reference to f6i in result */\nstatic void ip6_rt_copy_init(struct rt6_info *rt, const struct fib6_result *res)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\tconst struct net_device *dev = nh->fib_nh_dev;\n\tstruct fib6_info *f6i = res->f6i;\n\n\tip6_rt_init_dst(rt, res);\n\n\trt->rt6i_dst = f6i->fib6_dst;\n\trt->rt6i_idev = dev ? in6_dev_get(dev) : NULL;\n\trt->rt6i_flags = res->fib6_flags;\n\tif (nh->fib_nh_gw_family) {\n\t\trt->rt6i_gateway = nh->fib_nh_gw6;\n\t\trt->rt6i_flags |= RTF_GATEWAY;\n\t}\n\trt6_set_from(rt, f6i);\n#ifdef CONFIG_IPV6_SUBTREES\n\trt->rt6i_src = f6i->fib6_src;\n#endif\n}\n\nstatic struct fib6_node* fib6_backtrack(struct fib6_node *fn,\n\t\t\t\t\tstruct in6_addr *saddr)\n{\n\tstruct fib6_node *pn, *sn;\n\twhile (1) {\n\t\tif (fn->fn_flags & RTN_TL_ROOT)\n\t\t\treturn NULL;\n\t\tpn = rcu_dereference(fn->parent);\n\t\tsn = FIB6_SUBTREE(pn);\n\t\tif (sn && sn != fn)\n\t\t\tfn = fib6_node_lookup(sn, NULL, saddr);\n\t\telse\n\t\t\tfn = pn;\n\t\tif (fn->fn_flags & RTN_RTINFO)\n\t\t\treturn fn;\n\t}\n}\n\nstatic bool ip6_hold_safe(struct net *net, struct rt6_info **prt)\n{\n\tstruct rt6_info *rt = *prt;\n\n\tif (dst_hold_safe(&rt->dst))\n\t\treturn true;\n\tif (net) {\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tdst_hold(&rt->dst);\n\t} else {\n\t\trt = NULL;\n\t}\n\t*prt = rt;\n\treturn false;\n}\n\n/* called with rcu_lock held */\nstatic struct rt6_info *ip6_create_rt_rcu(const struct fib6_result *res)\n{\n\tstruct net_device *dev = res->nh->fib_nh_dev;\n\tstruct fib6_info *f6i = res->f6i;\n\tunsigned short flags;\n\tstruct rt6_info *nrt;\n\n\tif (!fib6_info_hold_safe(f6i))\n\t\tgoto fallback;\n\n\tflags = fib6_info_dst_flags(f6i);\n\tnrt = ip6_dst_alloc(dev_net(dev), dev, flags);\n\tif (!nrt) {\n\t\tfib6_info_release(f6i);\n\t\tgoto fallback;\n\t}\n\n\tip6_rt_copy_init(nrt, res);\n\treturn nrt;\n\nfallback:\n\tnrt = dev_net(dev)->ipv6.ip6_null_entry;\n\tdst_hold(&nrt->dst);\n\treturn nrt;\n}\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *ip6_pol_route_lookup(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags)\n{\n\tstruct fib6_result res = {};\n\tstruct fib6_node *fn;\n\tstruct rt6_info *rt;\n\n\tif (fl6->flowi6_flags & FLOWI_FLAG_SKIP_NH_OIF)\n\t\tflags &= ~RT6_LOOKUP_F_IFACE;\n\n\trcu_read_lock();\n\tfn = fib6_node_lookup(&table->tb6_root, &fl6->daddr, &fl6->saddr);\nrestart:\n\tres.f6i = rcu_dereference(fn->leaf);\n\tif (!res.f6i)\n\t\tres.f6i = net->ipv6.fib6_null_entry;\n\telse\n\t\trt6_device_match(net, &res, &fl6->saddr, fl6->flowi6_oif,\n\t\t\t\t flags);\n\n\tif (res.f6i == net->ipv6.fib6_null_entry) {\n\t\tfn = fib6_backtrack(fn, &fl6->saddr);\n\t\tif (fn)\n\t\t\tgoto restart;\n\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tdst_hold(&rt->dst);\n\t\tgoto out;\n\t} else if (res.fib6_flags & RTF_REJECT) {\n\t\tgoto do_create;\n\t}\n\n\tfib6_select_path(net, &res, fl6, fl6->flowi6_oif,\n\t\t\t fl6->flowi6_oif != 0, skb, flags);\n\n\t/* Search through exception table */\n\trt = rt6_find_cached_rt(&res, &fl6->daddr, &fl6->saddr);\n\tif (rt) {\n\t\tif (ip6_hold_safe(net, &rt))\n\t\t\tdst_use_noref(&rt->dst, jiffies);\n\t} else {\ndo_create:\n\t\trt = ip6_create_rt_rcu(&res);\n\t}\n\nout:\n\ttrace_fib6_table_lookup(net, &res, table, fl6);\n\n\trcu_read_unlock();\n\n\treturn rt;\n}\n\nstruct dst_entry *ip6_route_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb, int flags)\n{\n\treturn fib6_rule_lookup(net, fl6, skb, flags, ip6_pol_route_lookup);\n}\nEXPORT_SYMBOL_GPL(ip6_route_lookup);\n\nstruct rt6_info *rt6_lookup(struct net *net, const struct in6_addr *daddr,\n\t\t\t    const struct in6_addr *saddr, int oif,\n\t\t\t    const struct sk_buff *skb, int strict)\n{\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = oif,\n\t\t.daddr = *daddr,\n\t};\n\tstruct dst_entry *dst;\n\tint flags = strict ? RT6_LOOKUP_F_IFACE : 0;\n\n\tif (saddr) {\n\t\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\t}\n\n\tdst = fib6_rule_lookup(net, &fl6, skb, flags, ip6_pol_route_lookup);\n\tif (dst->error == 0)\n\t\treturn (struct rt6_info *) dst;\n\n\tdst_release(dst);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(rt6_lookup);\n\n/* ip6_ins_rt is called with FREE table->tb6_lock.\n * It takes new route entry, the addition fails by any reason the\n * route is released.\n * Caller must hold dst before calling it.\n */\n\nstatic int __ip6_ins_rt(struct fib6_info *rt, struct nl_info *info,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint err;\n\tstruct fib6_table *table;\n\n\ttable = rt->fib6_table;\n\tspin_lock_bh(&table->tb6_lock);\n\terr = fib6_add(&table->tb6_root, rt, info, extack);\n\tspin_unlock_bh(&table->tb6_lock);\n\n\treturn err;\n}\n\nint ip6_ins_rt(struct net *net, struct fib6_info *rt)\n{\n\tstruct nl_info info = {\t.nl_net = net, };\n\n\treturn __ip6_ins_rt(rt, &info, NULL);\n}\n\nstatic struct rt6_info *ip6_rt_cache_alloc(const struct fib6_result *res,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const struct in6_addr *saddr)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct net_device *dev;\n\tstruct rt6_info *rt;\n\n\t/*\n\t *\tClone the route.\n\t */\n\n\tif (!fib6_info_hold_safe(f6i))\n\t\treturn NULL;\n\n\tdev = ip6_rt_get_dev_rcu(res);\n\trt = ip6_dst_alloc(dev_net(dev), dev, 0);\n\tif (!rt) {\n\t\tfib6_info_release(f6i);\n\t\treturn NULL;\n\t}\n\n\tip6_rt_copy_init(rt, res);\n\trt->rt6i_flags |= RTF_CACHE;\n\trt->rt6i_dst.addr = *daddr;\n\trt->rt6i_dst.plen = 128;\n\n\tif (!rt6_is_gw_or_nonexthop(res)) {\n\t\tif (f6i->fib6_dst.plen != 128 &&\n\t\t    ipv6_addr_equal(&f6i->fib6_dst.addr, daddr))\n\t\t\trt->rt6i_flags |= RTF_ANYCAST;\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (rt->rt6i_src.plen && saddr) {\n\t\t\trt->rt6i_src.addr = *saddr;\n\t\t\trt->rt6i_src.plen = 128;\n\t\t}\n#endif\n\t}\n\n\treturn rt;\n}\n\nstatic struct rt6_info *ip6_rt_pcpu_alloc(const struct fib6_result *res)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tunsigned short flags = fib6_info_dst_flags(f6i);\n\tstruct net_device *dev;\n\tstruct rt6_info *pcpu_rt;\n\n\tif (!fib6_info_hold_safe(f6i))\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tdev = ip6_rt_get_dev_rcu(res);\n\tpcpu_rt = ip6_dst_alloc(dev_net(dev), dev, flags | DST_NOCOUNT);\n\trcu_read_unlock();\n\tif (!pcpu_rt) {\n\t\tfib6_info_release(f6i);\n\t\treturn NULL;\n\t}\n\tip6_rt_copy_init(pcpu_rt, res);\n\tpcpu_rt->rt6i_flags |= RTF_PCPU;\n\n\tif (f6i->nh)\n\t\tpcpu_rt->sernum = rt_genid_ipv6(dev_net(dev));\n\n\treturn pcpu_rt;\n}\n\nstatic bool rt6_is_valid(const struct rt6_info *rt6)\n{\n\treturn rt6->sernum == rt_genid_ipv6(dev_net(rt6->dst.dev));\n}\n\n/* It should be called with rcu_read_lock() acquired */\nstatic struct rt6_info *rt6_get_pcpu_route(const struct fib6_result *res)\n{\n\tstruct rt6_info *pcpu_rt;\n\n\tpcpu_rt = this_cpu_read(*res->nh->rt6i_pcpu);\n\n\tif (pcpu_rt && pcpu_rt->sernum && !rt6_is_valid(pcpu_rt)) {\n\t\tstruct rt6_info *prev, **p;\n\n\t\tp = this_cpu_ptr(res->nh->rt6i_pcpu);\n\t\tprev = xchg(p, NULL);\n\t\tif (prev) {\n\t\t\tdst_dev_put(&prev->dst);\n\t\t\tdst_release(&prev->dst);\n\t\t}\n\n\t\tpcpu_rt = NULL;\n\t}\n\n\treturn pcpu_rt;\n}\n\nstatic struct rt6_info *rt6_make_pcpu_route(struct net *net,\n\t\t\t\t\t    const struct fib6_result *res)\n{\n\tstruct rt6_info *pcpu_rt, *prev, **p;\n\n\tpcpu_rt = ip6_rt_pcpu_alloc(res);\n\tif (!pcpu_rt)\n\t\treturn NULL;\n\n\tp = this_cpu_ptr(res->nh->rt6i_pcpu);\n\tprev = cmpxchg(p, NULL, pcpu_rt);\n\tBUG_ON(prev);\n\n\tif (res->f6i->fib6_destroying) {\n\t\tstruct fib6_info *from;\n\n\t\tfrom = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);\n\t\tfib6_info_release(from);\n\t}\n\n\treturn pcpu_rt;\n}\n\n/* exception hash table implementation\n */\nstatic DEFINE_SPINLOCK(rt6_exception_lock);\n\n/* Remove rt6_ex from hash table and free the memory\n * Caller must hold rt6_exception_lock\n */\nstatic void rt6_remove_exception(struct rt6_exception_bucket *bucket,\n\t\t\t\t struct rt6_exception *rt6_ex)\n{\n\tstruct fib6_info *from;\n\tstruct net *net;\n\n\tif (!bucket || !rt6_ex)\n\t\treturn;\n\n\tnet = dev_net(rt6_ex->rt6i->dst.dev);\n\tnet->ipv6.rt6_stats->fib_rt_cache--;\n\n\t/* purge completely the exception to allow releasing the held resources:\n\t * some [sk] cache may keep the dst around for unlimited time\n\t */\n\tfrom = xchg((__force struct fib6_info **)&rt6_ex->rt6i->from, NULL);\n\tfib6_info_release(from);\n\tdst_dev_put(&rt6_ex->rt6i->dst);\n\n\thlist_del_rcu(&rt6_ex->hlist);\n\tdst_release(&rt6_ex->rt6i->dst);\n\tkfree_rcu(rt6_ex, rcu);\n\tWARN_ON_ONCE(!bucket->depth);\n\tbucket->depth--;\n}\n\n/* Remove oldest rt6_ex in bucket and free the memory\n * Caller must hold rt6_exception_lock\n */\nstatic void rt6_exception_remove_oldest(struct rt6_exception_bucket *bucket)\n{\n\tstruct rt6_exception *rt6_ex, *oldest = NULL;\n\n\tif (!bucket)\n\t\treturn;\n\n\thlist_for_each_entry(rt6_ex, &bucket->chain, hlist) {\n\t\tif (!oldest || time_before(rt6_ex->stamp, oldest->stamp))\n\t\t\toldest = rt6_ex;\n\t}\n\trt6_remove_exception(bucket, oldest);\n}\n\nstatic u32 rt6_exception_hash(const struct in6_addr *dst,\n\t\t\t      const struct in6_addr *src)\n{\n\tstatic u32 seed __read_mostly;\n\tu32 val;\n\n\tnet_get_random_once(&seed, sizeof(seed));\n\tval = jhash2((const u32 *)dst, sizeof(*dst)/sizeof(u32), seed);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src)\n\t\tval = jhash2((const u32 *)src, sizeof(*src)/sizeof(u32), val);\n#endif\n\treturn hash_32(val, FIB6_EXCEPTION_BUCKET_SIZE_SHIFT);\n}\n\n/* Helper function to find the cached rt in the hash table\n * and update bucket pointer to point to the bucket for this\n * (daddr, saddr) pair\n * Caller must hold rt6_exception_lock\n */\nstatic struct rt6_exception *\n__rt6_find_exception_spinlock(struct rt6_exception_bucket **bucket,\n\t\t\t      const struct in6_addr *daddr,\n\t\t\t      const struct in6_addr *saddr)\n{\n\tstruct rt6_exception *rt6_ex;\n\tu32 hval;\n\n\tif (!(*bucket) || !daddr)\n\t\treturn NULL;\n\n\thval = rt6_exception_hash(daddr, saddr);\n\t*bucket += hval;\n\n\thlist_for_each_entry(rt6_ex, &(*bucket)->chain, hlist) {\n\t\tstruct rt6_info *rt6 = rt6_ex->rt6i;\n\t\tbool matched = ipv6_addr_equal(daddr, &rt6->rt6i_dst.addr);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (matched && saddr)\n\t\t\tmatched = ipv6_addr_equal(saddr, &rt6->rt6i_src.addr);\n#endif\n\t\tif (matched)\n\t\t\treturn rt6_ex;\n\t}\n\treturn NULL;\n}\n\n/* Helper function to find the cached rt in the hash table\n * and update bucket pointer to point to the bucket for this\n * (daddr, saddr) pair\n * Caller must hold rcu_read_lock()\n */\nstatic struct rt6_exception *\n__rt6_find_exception_rcu(struct rt6_exception_bucket **bucket,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstruct rt6_exception *rt6_ex;\n\tu32 hval;\n\n\tWARN_ON_ONCE(!rcu_read_lock_held());\n\n\tif (!(*bucket) || !daddr)\n\t\treturn NULL;\n\n\thval = rt6_exception_hash(daddr, saddr);\n\t*bucket += hval;\n\n\thlist_for_each_entry_rcu(rt6_ex, &(*bucket)->chain, hlist) {\n\t\tstruct rt6_info *rt6 = rt6_ex->rt6i;\n\t\tbool matched = ipv6_addr_equal(daddr, &rt6->rt6i_dst.addr);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tif (matched && saddr)\n\t\t\tmatched = ipv6_addr_equal(saddr, &rt6->rt6i_src.addr);\n#endif\n\t\tif (matched)\n\t\t\treturn rt6_ex;\n\t}\n\treturn NULL;\n}\n\nstatic unsigned int fib6_mtu(const struct fib6_result *res)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\tunsigned int mtu;\n\n\tif (res->f6i->fib6_pmtu) {\n\t\tmtu = res->f6i->fib6_pmtu;\n\t} else {\n\t\tstruct net_device *dev = nh->fib_nh_dev;\n\t\tstruct inet6_dev *idev;\n\n\t\trcu_read_lock();\n\t\tidev = __in6_dev_get(dev);\n\t\tmtu = idev->cnf.mtu6;\n\t\trcu_read_unlock();\n\t}\n\n\tmtu = min_t(unsigned int, mtu, IP6_MAX_MTU);\n\n\treturn mtu - lwtunnel_headroom(nh->fib_nh_lws, mtu);\n}\n\n#define FIB6_EXCEPTION_BUCKET_FLUSHED  0x1UL\n\n/* used when the flushed bit is not relevant, only access to the bucket\n * (ie., all bucket users except rt6_insert_exception);\n *\n * called under rcu lock; sometimes called with rt6_exception_lock held\n */\nstatic\nstruct rt6_exception_bucket *fib6_nh_get_excptn_bucket(const struct fib6_nh *nh,\n\t\t\t\t\t\t       spinlock_t *lock)\n{\n\tstruct rt6_exception_bucket *bucket;\n\n\tif (lock)\n\t\tbucket = rcu_dereference_protected(nh->rt6i_exception_bucket,\n\t\t\t\t\t\t   lockdep_is_held(lock));\n\telse\n\t\tbucket = rcu_dereference(nh->rt6i_exception_bucket);\n\n\t/* remove bucket flushed bit if set */\n\tif (bucket) {\n\t\tunsigned long p = (unsigned long)bucket;\n\n\t\tp &= ~FIB6_EXCEPTION_BUCKET_FLUSHED;\n\t\tbucket = (struct rt6_exception_bucket *)p;\n\t}\n\n\treturn bucket;\n}\n\nstatic bool fib6_nh_excptn_bucket_flushed(struct rt6_exception_bucket *bucket)\n{\n\tunsigned long p = (unsigned long)bucket;\n\n\treturn !!(p & FIB6_EXCEPTION_BUCKET_FLUSHED);\n}\n\n/* called with rt6_exception_lock held */\nstatic void fib6_nh_excptn_bucket_set_flushed(struct fib6_nh *nh,\n\t\t\t\t\t      spinlock_t *lock)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tunsigned long p;\n\n\tbucket = rcu_dereference_protected(nh->rt6i_exception_bucket,\n\t\t\t\t\t   lockdep_is_held(lock));\n\n\tp = (unsigned long)bucket;\n\tp |= FIB6_EXCEPTION_BUCKET_FLUSHED;\n\tbucket = (struct rt6_exception_bucket *)p;\n\trcu_assign_pointer(nh->rt6i_exception_bucket, bucket);\n}\n\nstatic int rt6_insert_exception(struct rt6_info *nrt,\n\t\t\t\tconst struct fib6_result *res)\n{\n\tstruct net *net = dev_net(nrt->dst.dev);\n\tstruct rt6_exception_bucket *bucket;\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct in6_addr *src_key = NULL;\n\tstruct rt6_exception *rt6_ex;\n\tstruct fib6_nh *nh = res->nh;\n\tint err = 0;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\n\tbucket = rcu_dereference_protected(nh->rt6i_exception_bucket,\n\t\t\t\t\t  lockdep_is_held(&rt6_exception_lock));\n\tif (!bucket) {\n\t\tbucket = kcalloc(FIB6_EXCEPTION_BUCKET_SIZE, sizeof(*bucket),\n\t\t\t\t GFP_ATOMIC);\n\t\tif (!bucket) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\trcu_assign_pointer(nh->rt6i_exception_bucket, bucket);\n\t} else if (fib6_nh_excptn_bucket_flushed(bucket)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* fib6_src.plen != 0 indicates f6i is in subtree\n\t * and exception table is indexed by a hash of\n\t * both fib6_dst and fib6_src.\n\t * Otherwise, the exception table is indexed by\n\t * a hash of only fib6_dst.\n\t */\n\tif (f6i->fib6_src.plen)\n\t\tsrc_key = &nrt->rt6i_src.addr;\n#endif\n\t/* rt6_mtu_change() might lower mtu on f6i.\n\t * Only insert this exception route if its mtu\n\t * is less than f6i's mtu value.\n\t */\n\tif (dst_metric_raw(&nrt->dst, RTAX_MTU) >= fib6_mtu(res)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trt6_ex = __rt6_find_exception_spinlock(&bucket, &nrt->rt6i_dst.addr,\n\t\t\t\t\t       src_key);\n\tif (rt6_ex)\n\t\trt6_remove_exception(bucket, rt6_ex);\n\n\trt6_ex = kzalloc(sizeof(*rt6_ex), GFP_ATOMIC);\n\tif (!rt6_ex) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\trt6_ex->rt6i = nrt;\n\trt6_ex->stamp = jiffies;\n\thlist_add_head_rcu(&rt6_ex->hlist, &bucket->chain);\n\tbucket->depth++;\n\tnet->ipv6.rt6_stats->fib_rt_cache++;\n\n\tif (bucket->depth > FIB6_MAX_DEPTH)\n\t\trt6_exception_remove_oldest(bucket);\n\nout:\n\tspin_unlock_bh(&rt6_exception_lock);\n\n\t/* Update fn->fn_sernum to invalidate all cached dst */\n\tif (!err) {\n\t\tspin_lock_bh(&f6i->fib6_table->tb6_lock);\n\t\tfib6_update_sernum(net, f6i);\n\t\tspin_unlock_bh(&f6i->fib6_table->tb6_lock);\n\t\tfib6_force_start_gc(net);\n\t}\n\n\treturn err;\n}\n\nstatic void fib6_nh_flush_exceptions(struct fib6_nh *nh, struct fib6_info *from)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (!bucket)\n\t\tgoto out;\n\n\t/* Prevent rt6_insert_exception() to recreate the bucket list */\n\tif (!from)\n\t\tfib6_nh_excptn_bucket_set_flushed(nh, &rt6_exception_lock);\n\n\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\thlist_for_each_entry_safe(rt6_ex, tmp, &bucket->chain, hlist) {\n\t\t\tif (!from ||\n\t\t\t    rcu_access_pointer(rt6_ex->rt6i->from) == from)\n\t\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t}\n\t\tWARN_ON_ONCE(!from && bucket->depth);\n\t\tbucket++;\n\t}\nout:\n\tspin_unlock_bh(&rt6_exception_lock);\n}\n\nstatic int rt6_nh_flush_exceptions(struct fib6_nh *nh, void *arg)\n{\n\tstruct fib6_info *f6i = arg;\n\n\tfib6_nh_flush_exceptions(nh, f6i);\n\n\treturn 0;\n}\n\nvoid rt6_flush_exceptions(struct fib6_info *f6i)\n{\n\tif (f6i->nh)\n\t\tnexthop_for_each_fib6_nh(f6i->nh, rt6_nh_flush_exceptions,\n\t\t\t\t\t f6i);\n\telse\n\t\tfib6_nh_flush_exceptions(f6i->fib6_nh, f6i);\n}\n\n/* Find cached rt in the hash table inside passed in rt\n * Caller has to hold rcu_read_lock()\n */\nstatic struct rt6_info *rt6_find_cached_rt(const struct fib6_result *res,\n\t\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t\t   const struct in6_addr *saddr)\n{\n\tconst struct in6_addr *src_key = NULL;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct rt6_info *ret = NULL;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* fib6i_src.plen != 0 indicates f6i is in subtree\n\t * and exception table is indexed by a hash of\n\t * both fib6_dst and fib6_src.\n\t * However, the src addr used to create the hash\n\t * might not be exactly the passed in saddr which\n\t * is a /128 addr from the flow.\n\t * So we need to use f6i->fib6_src to redo lookup\n\t * if the passed in saddr does not find anything.\n\t * (See the logic in ip6_rt_cache_alloc() on how\n\t * rt->rt6i_src is updated.)\n\t */\n\tif (res->f6i->fib6_src.plen)\n\t\tsrc_key = saddr;\nfind_ex:\n#endif\n\tbucket = fib6_nh_get_excptn_bucket(res->nh, NULL);\n\trt6_ex = __rt6_find_exception_rcu(&bucket, daddr, src_key);\n\n\tif (rt6_ex && !rt6_check_expired(rt6_ex->rt6i))\n\t\tret = rt6_ex->rt6i;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* Use fib6_src as src_key and redo lookup */\n\tif (!ret && src_key && src_key != &res->f6i->fib6_src.addr) {\n\t\tsrc_key = &res->f6i->fib6_src.addr;\n\t\tgoto find_ex;\n\t}\n#endif\n\n\treturn ret;\n}\n\n/* Remove the passed in cached rt from the hash table that contains it */\nstatic int fib6_nh_remove_exception(const struct fib6_nh *nh, int plen,\n\t\t\t\t    const struct rt6_info *rt)\n{\n\tconst struct in6_addr *src_key = NULL;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tint err;\n\n\tif (!rcu_access_pointer(nh->rt6i_exception_bucket))\n\t\treturn -ENOENT;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* rt6i_src.plen != 0 indicates 'from' is in subtree\n\t * and exception table is indexed by a hash of\n\t * both rt6i_dst and rt6i_src.\n\t * Otherwise, the exception table is indexed by\n\t * a hash of only rt6i_dst.\n\t */\n\tif (plen)\n\t\tsrc_key = &rt->rt6i_src.addr;\n#endif\n\trt6_ex = __rt6_find_exception_spinlock(&bucket,\n\t\t\t\t\t       &rt->rt6i_dst.addr,\n\t\t\t\t\t       src_key);\n\tif (rt6_ex) {\n\t\trt6_remove_exception(bucket, rt6_ex);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\n\tspin_unlock_bh(&rt6_exception_lock);\n\treturn err;\n}\n\nstruct fib6_nh_excptn_arg {\n\tstruct rt6_info\t*rt;\n\tint\t\tplen;\n};\n\nstatic int rt6_nh_remove_exception_rt(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_excptn_arg *arg = _arg;\n\tint err;\n\n\terr = fib6_nh_remove_exception(nh, arg->plen, arg->rt);\n\tif (err == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int rt6_remove_exception_rt(struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\n\tfrom = rcu_dereference(rt->from);\n\tif (!from || !(rt->rt6i_flags & RTF_CACHE))\n\t\treturn -EINVAL;\n\n\tif (from->nh) {\n\t\tstruct fib6_nh_excptn_arg arg = {\n\t\t\t.rt = rt,\n\t\t\t.plen = from->fib6_src.plen\n\t\t};\n\t\tint rc;\n\n\t\t/* rc = 1 means an entry was found */\n\t\trc = nexthop_for_each_fib6_nh(from->nh,\n\t\t\t\t\t      rt6_nh_remove_exception_rt,\n\t\t\t\t\t      &arg);\n\t\treturn rc ? 0 : -ENOENT;\n\t}\n\n\treturn fib6_nh_remove_exception(from->fib6_nh,\n\t\t\t\t\tfrom->fib6_src.plen, rt);\n}\n\n/* Find rt6_ex which contains the passed in rt cache and\n * refresh its stamp\n */\nstatic void fib6_nh_update_exception(const struct fib6_nh *nh, int plen,\n\t\t\t\t     const struct rt6_info *rt)\n{\n\tconst struct in6_addr *src_key = NULL;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, NULL);\n#ifdef CONFIG_IPV6_SUBTREES\n\t/* rt6i_src.plen != 0 indicates 'from' is in subtree\n\t * and exception table is indexed by a hash of\n\t * both rt6i_dst and rt6i_src.\n\t * Otherwise, the exception table is indexed by\n\t * a hash of only rt6i_dst.\n\t */\n\tif (plen)\n\t\tsrc_key = &rt->rt6i_src.addr;\n#endif\n\trt6_ex = __rt6_find_exception_rcu(&bucket, &rt->rt6i_dst.addr, src_key);\n\tif (rt6_ex)\n\t\trt6_ex->stamp = jiffies;\n}\n\nstruct fib6_nh_match_arg {\n\tconst struct net_device *dev;\n\tconst struct in6_addr\t*gw;\n\tstruct fib6_nh\t\t*match;\n};\n\n/* determine if fib6_nh has given device and gateway */\nstatic int fib6_nh_find_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_match_arg *arg = _arg;\n\n\tif (arg->dev != nh->fib_nh_dev ||\n\t    (arg->gw && !nh->fib_nh_gw_family) ||\n\t    (!arg->gw && nh->fib_nh_gw_family) ||\n\t    (arg->gw && !ipv6_addr_equal(arg->gw, &nh->fib_nh_gw6)))\n\t\treturn 0;\n\n\targ->match = nh;\n\n\t/* found a match, break the loop */\n\treturn 1;\n}\n\nstatic void rt6_update_exception_stamp_rt(struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\tstruct fib6_nh *fib6_nh;\n\n\trcu_read_lock();\n\n\tfrom = rcu_dereference(rt->from);\n\tif (!from || !(rt->rt6i_flags & RTF_CACHE))\n\t\tgoto unlock;\n\n\tif (from->nh) {\n\t\tstruct fib6_nh_match_arg arg = {\n\t\t\t.dev = rt->dst.dev,\n\t\t\t.gw = &rt->rt6i_gateway,\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(from->nh, fib6_nh_find_match, &arg);\n\n\t\tif (!arg.match)\n\t\t\tgoto unlock;\n\t\tfib6_nh = arg.match;\n\t} else {\n\t\tfib6_nh = from->fib6_nh;\n\t}\n\tfib6_nh_update_exception(fib6_nh, from->fib6_src.plen, rt);\nunlock:\n\trcu_read_unlock();\n}\n\nstatic bool rt6_mtu_change_route_allowed(struct inet6_dev *idev,\n\t\t\t\t\t struct rt6_info *rt, int mtu)\n{\n\t/* If the new MTU is lower than the route PMTU, this new MTU will be the\n\t * lowest MTU in the path: always allow updating the route PMTU to\n\t * reflect PMTU decreases.\n\t *\n\t * If the new MTU is higher, and the route PMTU is equal to the local\n\t * MTU, this means the old MTU is the lowest in the path, so allow\n\t * updating it: if other nodes now have lower MTUs, PMTU discovery will\n\t * handle this.\n\t */\n\n\tif (dst_mtu(&rt->dst) >= mtu)\n\t\treturn true;\n\n\tif (dst_mtu(&rt->dst) == idev->cnf.mtu6)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void rt6_exceptions_update_pmtu(struct inet6_dev *idev,\n\t\t\t\t       const struct fib6_nh *nh, int mtu)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tint i;\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (!bucket)\n\t\treturn;\n\n\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\thlist_for_each_entry(rt6_ex, &bucket->chain, hlist) {\n\t\t\tstruct rt6_info *entry = rt6_ex->rt6i;\n\n\t\t\t/* For RTF_CACHE with rt6i_pmtu == 0 (i.e. a redirected\n\t\t\t * route), the metrics of its rt->from have already\n\t\t\t * been updated.\n\t\t\t */\n\t\t\tif (dst_metric_raw(&entry->dst, RTAX_MTU) &&\n\t\t\t    rt6_mtu_change_route_allowed(idev, entry, mtu))\n\t\t\t\tdst_metric_set(&entry->dst, RTAX_MTU, mtu);\n\t\t}\n\t\tbucket++;\n\t}\n}\n\n#define RTF_CACHE_GATEWAY\t(RTF_GATEWAY | RTF_CACHE)\n\nstatic void fib6_nh_exceptions_clean_tohost(const struct fib6_nh *nh,\n\t\t\t\t\t    const struct in6_addr *gateway)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tif (!rcu_access_pointer(nh->rt6i_exception_bucket))\n\t\treturn;\n\n\tspin_lock_bh(&rt6_exception_lock);\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (bucket) {\n\t\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\t\thlist_for_each_entry_safe(rt6_ex, tmp,\n\t\t\t\t\t\t  &bucket->chain, hlist) {\n\t\t\t\tstruct rt6_info *entry = rt6_ex->rt6i;\n\n\t\t\t\tif ((entry->rt6i_flags & RTF_CACHE_GATEWAY) ==\n\t\t\t\t    RTF_CACHE_GATEWAY &&\n\t\t\t\t    ipv6_addr_equal(gateway,\n\t\t\t\t\t\t    &entry->rt6i_gateway)) {\n\t\t\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbucket++;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rt6_exception_lock);\n}\n\nstatic void rt6_age_examine_exception(struct rt6_exception_bucket *bucket,\n\t\t\t\t      struct rt6_exception *rt6_ex,\n\t\t\t\t      struct fib6_gc_args *gc_args,\n\t\t\t\t      unsigned long now)\n{\n\tstruct rt6_info *rt = rt6_ex->rt6i;\n\n\t/* we are pruning and obsoleting aged-out and non gateway exceptions\n\t * even if others have still references to them, so that on next\n\t * dst_check() such references can be dropped.\n\t * EXPIRES exceptions - e.g. pmtu-generated ones are pruned when\n\t * expired, independently from their aging, as per RFC 8201 section 4\n\t */\n\tif (!(rt->rt6i_flags & RTF_EXPIRES)) {\n\t\tif (time_after_eq(now, rt->dst.lastuse + gc_args->timeout)) {\n\t\t\tRT6_TRACE(\"aging clone %p\\n\", rt);\n\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t\treturn;\n\t\t}\n\t} else if (time_after(jiffies, rt->dst.expires)) {\n\t\tRT6_TRACE(\"purging expired route %p\\n\", rt);\n\t\trt6_remove_exception(bucket, rt6_ex);\n\t\treturn;\n\t}\n\n\tif (rt->rt6i_flags & RTF_GATEWAY) {\n\t\tstruct neighbour *neigh;\n\t\t__u8 neigh_flags = 0;\n\n\t\tneigh = __ipv6_neigh_lookup_noref(rt->dst.dev, &rt->rt6i_gateway);\n\t\tif (neigh)\n\t\t\tneigh_flags = neigh->flags;\n\n\t\tif (!(neigh_flags & NTF_ROUTER)) {\n\t\t\tRT6_TRACE(\"purging route %p via non-router but gateway\\n\",\n\t\t\t\t  rt);\n\t\t\trt6_remove_exception(bucket, rt6_ex);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgc_args->more++;\n}\n\nstatic void fib6_nh_age_exceptions(const struct fib6_nh *nh,\n\t\t\t\t   struct fib6_gc_args *gc_args,\n\t\t\t\t   unsigned long now)\n{\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tstruct hlist_node *tmp;\n\tint i;\n\n\tif (!rcu_access_pointer(nh->rt6i_exception_bucket))\n\t\treturn;\n\n\trcu_read_lock_bh();\n\tspin_lock(&rt6_exception_lock);\n\tbucket = fib6_nh_get_excptn_bucket(nh, &rt6_exception_lock);\n\tif (bucket) {\n\t\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\t\thlist_for_each_entry_safe(rt6_ex, tmp,\n\t\t\t\t\t\t  &bucket->chain, hlist) {\n\t\t\t\trt6_age_examine_exception(bucket, rt6_ex,\n\t\t\t\t\t\t\t  gc_args, now);\n\t\t\t}\n\t\t\tbucket++;\n\t\t}\n\t}\n\tspin_unlock(&rt6_exception_lock);\n\trcu_read_unlock_bh();\n}\n\nstruct fib6_nh_age_excptn_arg {\n\tstruct fib6_gc_args\t*gc_args;\n\tunsigned long\t\tnow;\n};\n\nstatic int rt6_nh_age_exceptions(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_age_excptn_arg *arg = _arg;\n\n\tfib6_nh_age_exceptions(nh, arg->gc_args, arg->now);\n\treturn 0;\n}\n\nvoid rt6_age_exceptions(struct fib6_info *f6i,\n\t\t\tstruct fib6_gc_args *gc_args,\n\t\t\tunsigned long now)\n{\n\tif (f6i->nh) {\n\t\tstruct fib6_nh_age_excptn_arg arg = {\n\t\t\t.gc_args = gc_args,\n\t\t\t.now = now\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(f6i->nh, rt6_nh_age_exceptions,\n\t\t\t\t\t &arg);\n\t} else {\n\t\tfib6_nh_age_exceptions(f6i->fib6_nh, gc_args, now);\n\t}\n}\n\n/* must be called with rcu lock held */\nint fib6_table_lookup(struct net *net, struct fib6_table *table, int oif,\n\t\t      struct flowi6 *fl6, struct fib6_result *res, int strict)\n{\n\tstruct fib6_node *fn, *saved_fn;\n\n\tfn = fib6_node_lookup(&table->tb6_root, &fl6->daddr, &fl6->saddr);\n\tsaved_fn = fn;\n\n\tif (fl6->flowi6_flags & FLOWI_FLAG_SKIP_NH_OIF)\n\t\toif = 0;\n\nredo_rt6_select:\n\trt6_select(net, fn, oif, res, strict);\n\tif (res->f6i == net->ipv6.fib6_null_entry) {\n\t\tfn = fib6_backtrack(fn, &fl6->saddr);\n\t\tif (fn)\n\t\t\tgoto redo_rt6_select;\n\t\telse if (strict & RT6_LOOKUP_F_REACHABLE) {\n\t\t\t/* also consider unreachable route */\n\t\t\tstrict &= ~RT6_LOOKUP_F_REACHABLE;\n\t\t\tfn = saved_fn;\n\t\t\tgoto redo_rt6_select;\n\t\t}\n\t}\n\n\ttrace_fib6_table_lookup(net, res, table, fl6);\n\n\treturn 0;\n}\n\nstruct rt6_info *ip6_pol_route(struct net *net, struct fib6_table *table,\n\t\t\t       int oif, struct flowi6 *fl6,\n\t\t\t       const struct sk_buff *skb, int flags)\n{\n\tstruct fib6_result res = {};\n\tstruct rt6_info *rt = NULL;\n\tint strict = 0;\n\n\tWARN_ON_ONCE((flags & RT6_LOOKUP_F_DST_NOREF) &&\n\t\t     !rcu_read_lock_held());\n\n\tstrict |= flags & RT6_LOOKUP_F_IFACE;\n\tstrict |= flags & RT6_LOOKUP_F_IGNORE_LINKSTATE;\n\tif (net->ipv6.devconf_all->forwarding == 0)\n\t\tstrict |= RT6_LOOKUP_F_REACHABLE;\n\n\trcu_read_lock();\n\n\tfib6_table_lookup(net, table, oif, fl6, &res, strict);\n\tif (res.f6i == net->ipv6.fib6_null_entry)\n\t\tgoto out;\n\n\tfib6_select_path(net, &res, fl6, oif, false, skb, strict);\n\n\t/*Search through exception table */\n\trt = rt6_find_cached_rt(&res, &fl6->daddr, &fl6->saddr);\n\tif (rt) {\n\t\tgoto out;\n\t} else if (unlikely((fl6->flowi6_flags & FLOWI_FLAG_KNOWN_NH) &&\n\t\t\t    !res.nh->fib_nh_gw_family)) {\n\t\t/* Create a RTF_CACHE clone which will not be\n\t\t * owned by the fib6 tree.  It is for the special case where\n\t\t * the daddr in the skb during the neighbor look-up is different\n\t\t * from the fl6->daddr used to look-up route here.\n\t\t */\n\t\trt = ip6_rt_cache_alloc(&res, &fl6->daddr, NULL);\n\n\t\tif (rt) {\n\t\t\t/* 1 refcnt is taken during ip6_rt_cache_alloc().\n\t\t\t * As rt6_uncached_list_add() does not consume refcnt,\n\t\t\t * this refcnt is always returned to the caller even\n\t\t\t * if caller sets RT6_LOOKUP_F_DST_NOREF flag.\n\t\t\t */\n\t\t\trt6_uncached_list_add(rt);\n\t\t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_uncache);\n\t\t\trcu_read_unlock();\n\n\t\t\treturn rt;\n\t\t}\n\t} else {\n\t\t/* Get a percpu copy */\n\t\tlocal_bh_disable();\n\t\trt = rt6_get_pcpu_route(&res);\n\n\t\tif (!rt)\n\t\t\trt = rt6_make_pcpu_route(net, &res);\n\n\t\tlocal_bh_enable();\n\t}\nout:\n\tif (!rt)\n\t\trt = net->ipv6.ip6_null_entry;\n\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\tip6_hold_safe(net, &rt);\n\trcu_read_unlock();\n\n\treturn rt;\n}\nEXPORT_SYMBOL_GPL(ip6_pol_route);\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *ip6_pol_route_input(struct net *net,\n\t\t\t\t\t    struct fib6_table *table,\n\t\t\t\t\t    struct flowi6 *fl6,\n\t\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t\t    int flags)\n{\n\treturn ip6_pol_route(net, table, fl6->flowi6_iif, fl6, skb, flags);\n}\n\nstruct dst_entry *ip6_route_input_lookup(struct net *net,\n\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t const struct sk_buff *skb,\n\t\t\t\t\t int flags)\n{\n\tif (rt6_need_strict(&fl6->daddr) && dev->type != ARPHRD_PIMREG)\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\n\treturn fib6_rule_lookup(net, fl6, skb, flags, ip6_pol_route_input);\n}\nEXPORT_SYMBOL_GPL(ip6_route_input_lookup);\n\nstatic void ip6_multipath_l3_keys(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys,\n\t\t\t\t  struct flow_keys *flkeys)\n{\n\tconst struct ipv6hdr *outer_iph = ipv6_hdr(skb);\n\tconst struct ipv6hdr *key_iph = outer_iph;\n\tstruct flow_keys *_flkeys = flkeys;\n\tconst struct ipv6hdr *inner_iph;\n\tconst struct icmp6hdr *icmph;\n\tstruct ipv6hdr _inner_iph;\n\tstruct icmp6hdr _icmph;\n\n\tif (likely(outer_iph->nexthdr != IPPROTO_ICMPV6))\n\t\tgoto out;\n\n\ticmph = skb_header_pointer(skb, skb_transport_offset(skb),\n\t\t\t\t   sizeof(_icmph), &_icmph);\n\tif (!icmph)\n\t\tgoto out;\n\n\tif (!icmpv6_is_err(icmph->icmp6_type))\n\t\tgoto out;\n\n\tinner_iph = skb_header_pointer(skb,\n\t\t\t\t       skb_transport_offset(skb) + sizeof(*icmph),\n\t\t\t\t       sizeof(_inner_iph), &_inner_iph);\n\tif (!inner_iph)\n\t\tgoto out;\n\n\tkey_iph = inner_iph;\n\t_flkeys = NULL;\nout:\n\tif (_flkeys) {\n\t\tkeys->addrs.v6addrs.src = _flkeys->addrs.v6addrs.src;\n\t\tkeys->addrs.v6addrs.dst = _flkeys->addrs.v6addrs.dst;\n\t\tkeys->tags.flow_label = _flkeys->tags.flow_label;\n\t\tkeys->basic.ip_proto = _flkeys->basic.ip_proto;\n\t} else {\n\t\tkeys->addrs.v6addrs.src = key_iph->saddr;\n\t\tkeys->addrs.v6addrs.dst = key_iph->daddr;\n\t\tkeys->tags.flow_label = ip6_flowlabel(key_iph);\n\t\tkeys->basic.ip_proto = key_iph->nexthdr;\n\t}\n}\n\n/* if skb is set it will be used and fl6 can be NULL */\nu32 rt6_multipath_hash(const struct net *net, const struct flowi6 *fl6,\n\t\t       const struct sk_buff *skb, struct flow_keys *flkeys)\n{\n\tstruct flow_keys hash_keys;\n\tu32 mhash;\n\n\tswitch (ip6_multipath_hash_policy(net)) {\n\tcase 0:\n\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tif (skb) {\n\t\t\tip6_multipath_l3_keys(skb, &hash_keys, flkeys);\n\t\t} else {\n\t\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\t\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\t\t\thash_keys.tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);\n\t\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif (skb) {\n\t\t\tunsigned int flag = FLOW_DISSECTOR_F_STOP_AT_ENCAP;\n\t\t\tstruct flow_keys keys;\n\n\t\t\t/* short-circuit if we already have L4 hash present */\n\t\t\tif (skb->l4_hash)\n\t\t\t\treturn skb_get_hash_raw(skb) >> 1;\n\n\t\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\n                        if (!flkeys) {\n\t\t\t\tskb_flow_dissect_flow_keys(skb, &keys, flag);\n\t\t\t\tflkeys = &keys;\n\t\t\t}\n\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\thash_keys.addrs.v6addrs.src = flkeys->addrs.v6addrs.src;\n\t\t\thash_keys.addrs.v6addrs.dst = flkeys->addrs.v6addrs.dst;\n\t\t\thash_keys.ports.src = flkeys->ports.src;\n\t\t\thash_keys.ports.dst = flkeys->ports.dst;\n\t\t\thash_keys.basic.ip_proto = flkeys->basic.ip_proto;\n\t\t} else {\n\t\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\t\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\t\t\thash_keys.ports.src = fl6->fl6_sport;\n\t\t\thash_keys.ports.dst = fl6->fl6_dport;\n\t\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tmemset(&hash_keys, 0, sizeof(hash_keys));\n\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\tif (skb) {\n\t\t\tstruct flow_keys keys;\n\n\t\t\tif (!flkeys) {\n\t\t\t\tskb_flow_dissect_flow_keys(skb, &keys, 0);\n\t\t\t\tflkeys = &keys;\n\t\t\t}\n\n\t\t\t/* Inner can be v4 or v6 */\n\t\t\tif (flkeys->control.addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\t\t\thash_keys.addrs.v4addrs.src = flkeys->addrs.v4addrs.src;\n\t\t\t\thash_keys.addrs.v4addrs.dst = flkeys->addrs.v4addrs.dst;\n\t\t\t} else if (flkeys->control.addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\t\thash_keys.addrs.v6addrs.src = flkeys->addrs.v6addrs.src;\n\t\t\t\thash_keys.addrs.v6addrs.dst = flkeys->addrs.v6addrs.dst;\n\t\t\t\thash_keys.tags.flow_label = flkeys->tags.flow_label;\n\t\t\t\thash_keys.basic.ip_proto = flkeys->basic.ip_proto;\n\t\t\t} else {\n\t\t\t\t/* Same as case 0 */\n\t\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\t\tip6_multipath_l3_keys(skb, &hash_keys, flkeys);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Same as case 0 */\n\t\t\thash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t\thash_keys.addrs.v6addrs.src = fl6->saddr;\n\t\t\thash_keys.addrs.v6addrs.dst = fl6->daddr;\n\t\t\thash_keys.tags.flow_label = (__force u32)flowi6_get_flowlabel(fl6);\n\t\t\thash_keys.basic.ip_proto = fl6->flowi6_proto;\n\t\t}\n\t\tbreak;\n\t}\n\tmhash = flow_hash_from_keys(&hash_keys);\n\n\treturn mhash >> 1;\n}\n\n/* Called with rcu held */\nvoid ip6_route_input(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tstruct net *net = dev_net(skb->dev);\n\tint flags = RT6_LOOKUP_F_HAS_SADDR | RT6_LOOKUP_F_DST_NOREF;\n\tstruct ip_tunnel_info *tun_info;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = skb->dev->ifindex,\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t\t.flowlabel = ip6_flowinfo(iph),\n\t\t.flowi6_mark = skb->mark,\n\t\t.flowi6_proto = iph->nexthdr,\n\t};\n\tstruct flow_keys *flkeys = NULL, _flkeys;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (tun_info && !(tun_info->mode & IP_TUNNEL_INFO_TX))\n\t\tfl6.flowi6_tun_key.tun_id = tun_info->key.tun_id;\n\n\tif (fib6_rules_early_flow_dissect(net, skb, &fl6, &_flkeys))\n\t\tflkeys = &_flkeys;\n\n\tif (unlikely(fl6.flowi6_proto == IPPROTO_ICMPV6))\n\t\tfl6.mp_hash = rt6_multipath_hash(net, &fl6, skb, flkeys);\n\tskb_dst_drop(skb);\n\tskb_dst_set_noref(skb, ip6_route_input_lookup(net, skb->dev,\n\t\t\t\t\t\t      &fl6, skb, flags));\n}\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *ip6_pol_route_output(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags)\n{\n\treturn ip6_pol_route(net, table, fl6->flowi6_oif, fl6, skb, flags);\n}\n\nstruct dst_entry *ip6_route_output_flags_noref(struct net *net,\n\t\t\t\t\t       const struct sock *sk,\n\t\t\t\t\t       struct flowi6 *fl6, int flags)\n{\n\tbool any_src;\n\n\tif (ipv6_addr_type(&fl6->daddr) &\n\t    (IPV6_ADDR_MULTICAST | IPV6_ADDR_LINKLOCAL)) {\n\t\tstruct dst_entry *dst;\n\n\t\t/* This function does not take refcnt on the dst */\n\t\tdst = l3mdev_link_scope_lookup(net, fl6);\n\t\tif (dst)\n\t\t\treturn dst;\n\t}\n\n\tfl6->flowi6_iif = LOOPBACK_IFINDEX;\n\n\tflags |= RT6_LOOKUP_F_DST_NOREF;\n\tany_src = ipv6_addr_any(&fl6->saddr);\n\tif ((sk && sk->sk_bound_dev_if) || rt6_need_strict(&fl6->daddr) ||\n\t    (fl6->flowi6_oif && any_src))\n\t\tflags |= RT6_LOOKUP_F_IFACE;\n\n\tif (!any_src)\n\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\telse if (sk)\n\t\tflags |= rt6_srcprefs2flags(inet6_sk(sk)->srcprefs);\n\n\treturn fib6_rule_lookup(net, fl6, NULL, flags, ip6_pol_route_output);\n}\nEXPORT_SYMBOL_GPL(ip6_route_output_flags_noref);\n\nstruct dst_entry *ip6_route_output_flags(struct net *net,\n\t\t\t\t\t const struct sock *sk,\n\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t int flags)\n{\n        struct dst_entry *dst;\n        struct rt6_info *rt6;\n\n        rcu_read_lock();\n        dst = ip6_route_output_flags_noref(net, sk, fl6, flags);\n        rt6 = (struct rt6_info *)dst;\n        /* For dst cached in uncached_list, refcnt is already taken. */\n        if (list_empty(&rt6->rt6i_uncached) && !dst_hold_safe(dst)) {\n                dst = &net->ipv6.ip6_null_entry->dst;\n                dst_hold(dst);\n        }\n        rcu_read_unlock();\n\n        return dst;\n}\nEXPORT_SYMBOL_GPL(ip6_route_output_flags);\n\nstruct dst_entry *ip6_blackhole_route(struct net *net, struct dst_entry *dst_orig)\n{\n\tstruct rt6_info *rt, *ort = (struct rt6_info *) dst_orig;\n\tstruct net_device *loopback_dev = net->loopback_dev;\n\tstruct dst_entry *new = NULL;\n\n\trt = dst_alloc(&ip6_dst_blackhole_ops, loopback_dev, 1,\n\t\t       DST_OBSOLETE_DEAD, 0);\n\tif (rt) {\n\t\trt6_info_init(rt);\n\t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_alloc);\n\n\t\tnew = &rt->dst;\n\t\tnew->__use = 1;\n\t\tnew->input = dst_discard;\n\t\tnew->output = dst_discard_out;\n\n\t\tdst_copy_metrics(new, &ort->dst);\n\n\t\trt->rt6i_idev = in6_dev_get(loopback_dev);\n\t\trt->rt6i_gateway = ort->rt6i_gateway;\n\t\trt->rt6i_flags = ort->rt6i_flags & ~RTF_PCPU;\n\n\t\tmemcpy(&rt->rt6i_dst, &ort->rt6i_dst, sizeof(struct rt6key));\n#ifdef CONFIG_IPV6_SUBTREES\n\t\tmemcpy(&rt->rt6i_src, &ort->rt6i_src, sizeof(struct rt6key));\n#endif\n\t}\n\n\tdst_release(dst_orig);\n\treturn new ? new : ERR_PTR(-ENOMEM);\n}\n\n/*\n *\tDestination cache support functions\n */\n\nstatic bool fib6_check(struct fib6_info *f6i, u32 cookie)\n{\n\tu32 rt_cookie = 0;\n\n\tif (!fib6_get_cookie_safe(f6i, &rt_cookie) || rt_cookie != cookie)\n\t\treturn false;\n\n\tif (fib6_check_expired(f6i))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct dst_entry *rt6_check(struct rt6_info *rt,\n\t\t\t\t   struct fib6_info *from,\n\t\t\t\t   u32 cookie)\n{\n\tu32 rt_cookie = 0;\n\n\tif (!from || !fib6_get_cookie_safe(from, &rt_cookie) ||\n\t    rt_cookie != cookie)\n\t\treturn NULL;\n\n\tif (rt6_check_expired(rt))\n\t\treturn NULL;\n\n\treturn &rt->dst;\n}\n\nstatic struct dst_entry *rt6_dst_from_check(struct rt6_info *rt,\n\t\t\t\t\t    struct fib6_info *from,\n\t\t\t\t\t    u32 cookie)\n{\n\tif (!__rt6_check_expired(rt) &&\n\t    rt->dst.obsolete == DST_OBSOLETE_FORCE_CHK &&\n\t    fib6_check(from, cookie))\n\t\treturn &rt->dst;\n\telse\n\t\treturn NULL;\n}\n\nINDIRECT_CALLABLE_SCOPE struct dst_entry *ip6_dst_check(struct dst_entry *dst,\n\t\t\t\t\t\t\tu32 cookie)\n{\n\tstruct dst_entry *dst_ret;\n\tstruct fib6_info *from;\n\tstruct rt6_info *rt;\n\n\trt = container_of(dst, struct rt6_info, dst);\n\n\tif (rt->sernum)\n\t\treturn rt6_is_valid(rt) ? dst : NULL;\n\n\trcu_read_lock();\n\n\t/* All IPV6 dsts are created with ->obsolete set to the value\n\t * DST_OBSOLETE_FORCE_CHK which forces validation calls down\n\t * into this function always.\n\t */\n\n\tfrom = rcu_dereference(rt->from);\n\n\tif (from && (rt->rt6i_flags & RTF_PCPU ||\n\t    unlikely(!list_empty(&rt->rt6i_uncached))))\n\t\tdst_ret = rt6_dst_from_check(rt, from, cookie);\n\telse\n\t\tdst_ret = rt6_check(rt, from, cookie);\n\n\trcu_read_unlock();\n\n\treturn dst_ret;\n}\nEXPORT_INDIRECT_CALLABLE(ip6_dst_check);\n\nstatic struct dst_entry *ip6_negative_advice(struct dst_entry *dst)\n{\n\tstruct rt6_info *rt = (struct rt6_info *) dst;\n\n\tif (rt) {\n\t\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\t\trcu_read_lock();\n\t\t\tif (rt6_check_expired(rt)) {\n\t\t\t\trt6_remove_exception_rt(rt);\n\t\t\t\tdst = NULL;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t\tdst = NULL;\n\t\t}\n\t}\n\treturn dst;\n}\n\nstatic void ip6_link_failure(struct sk_buff *skb)\n{\n\tstruct rt6_info *rt;\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH, 0);\n\n\trt = (struct rt6_info *) skb_dst(skb);\n\tif (rt) {\n\t\trcu_read_lock();\n\t\tif (rt->rt6i_flags & RTF_CACHE) {\n\t\t\trt6_remove_exception_rt(rt);\n\t\t} else {\n\t\t\tstruct fib6_info *from;\n\t\t\tstruct fib6_node *fn;\n\n\t\t\tfrom = rcu_dereference(rt->from);\n\t\t\tif (from) {\n\t\t\t\tfn = rcu_dereference(from->fib6_node);\n\t\t\t\tif (fn && (rt->rt6i_flags & RTF_DEFAULT))\n\t\t\t\t\tfn->fn_sernum = -1;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void rt6_update_expires(struct rt6_info *rt0, int timeout)\n{\n\tif (!(rt0->rt6i_flags & RTF_EXPIRES)) {\n\t\tstruct fib6_info *from;\n\n\t\trcu_read_lock();\n\t\tfrom = rcu_dereference(rt0->from);\n\t\tif (from)\n\t\t\trt0->dst.expires = from->expires;\n\t\trcu_read_unlock();\n\t}\n\n\tdst_set_expires(&rt0->dst, timeout);\n\trt0->rt6i_flags |= RTF_EXPIRES;\n}\n\nstatic void rt6_do_update_pmtu(struct rt6_info *rt, u32 mtu)\n{\n\tstruct net *net = dev_net(rt->dst.dev);\n\n\tdst_metric_set(&rt->dst, RTAX_MTU, mtu);\n\trt->rt6i_flags |= RTF_MODIFIED;\n\trt6_update_expires(rt, net->ipv6.sysctl.ip6_rt_mtu_expires);\n}\n\nstatic bool rt6_cache_allowed_for_pmtu(const struct rt6_info *rt)\n{\n\treturn !(rt->rt6i_flags & RTF_CACHE) &&\n\t\t(rt->rt6i_flags & RTF_PCPU || rcu_access_pointer(rt->from));\n}\n\nstatic void __ip6_rt_update_pmtu(struct dst_entry *dst, const struct sock *sk,\n\t\t\t\t const struct ipv6hdr *iph, u32 mtu,\n\t\t\t\t bool confirm_neigh)\n{\n\tconst struct in6_addr *daddr, *saddr;\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\n\t/* Note: do *NOT* check dst_metric_locked(dst, RTAX_MTU)\n\t * IPv6 pmtu discovery isn't optional, so 'mtu lock' cannot disable it.\n\t * [see also comment in rt6_mtu_change_route()]\n\t */\n\n\tif (iph) {\n\t\tdaddr = &iph->daddr;\n\t\tsaddr = &iph->saddr;\n\t} else if (sk) {\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tsaddr = &inet6_sk(sk)->saddr;\n\t} else {\n\t\tdaddr = NULL;\n\t\tsaddr = NULL;\n\t}\n\n\tif (confirm_neigh)\n\t\tdst_confirm_neigh(dst, daddr);\n\n\tif (mtu < IPV6_MIN_MTU)\n\t\treturn;\n\tif (mtu >= dst_mtu(dst))\n\t\treturn;\n\n\tif (!rt6_cache_allowed_for_pmtu(rt6)) {\n\t\trt6_do_update_pmtu(rt6, mtu);\n\t\t/* update rt6_ex->stamp for cache */\n\t\tif (rt6->rt6i_flags & RTF_CACHE)\n\t\t\trt6_update_exception_stamp_rt(rt6);\n\t} else if (daddr) {\n\t\tstruct fib6_result res = {};\n\t\tstruct rt6_info *nrt6;\n\n\t\trcu_read_lock();\n\t\tres.f6i = rcu_dereference(rt6->from);\n\t\tif (!res.f6i)\n\t\t\tgoto out_unlock;\n\n\t\tres.fib6_flags = res.f6i->fib6_flags;\n\t\tres.fib6_type = res.f6i->fib6_type;\n\n\t\tif (res.f6i->nh) {\n\t\t\tstruct fib6_nh_match_arg arg = {\n\t\t\t\t.dev = dst->dev,\n\t\t\t\t.gw = &rt6->rt6i_gateway,\n\t\t\t};\n\n\t\t\tnexthop_for_each_fib6_nh(res.f6i->nh,\n\t\t\t\t\t\t fib6_nh_find_match, &arg);\n\n\t\t\t/* fib6_info uses a nexthop that does not have fib6_nh\n\t\t\t * using the dst->dev + gw. Should be impossible.\n\t\t\t */\n\t\t\tif (!arg.match)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tres.nh = arg.match;\n\t\t} else {\n\t\t\tres.nh = res.f6i->fib6_nh;\n\t\t}\n\n\t\tnrt6 = ip6_rt_cache_alloc(&res, daddr, saddr);\n\t\tif (nrt6) {\n\t\t\trt6_do_update_pmtu(nrt6, mtu);\n\t\t\tif (rt6_insert_exception(nrt6, &res))\n\t\t\t\tdst_release_immediate(&nrt6->dst);\n\t\t}\nout_unlock:\n\t\trcu_read_unlock();\n\t}\n}\n\nstatic void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu,\n\t\t\t       bool confirm_neigh)\n{\n\t__ip6_rt_update_pmtu(dst, sk, skb ? ipv6_hdr(skb) : NULL, mtu,\n\t\t\t     confirm_neigh);\n}\n\nvoid ip6_update_pmtu(struct sk_buff *skb, struct net *net, __be32 mtu,\n\t\t     int oif, u32 mark, kuid_t uid)\n{\n\tconst struct ipv6hdr *iph = (struct ipv6hdr *) skb->data;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = oif,\n\t\t.flowi6_mark = mark ? mark : IP6_REPLY_MARK(net, skb->mark),\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t\t.flowlabel = ip6_flowinfo(iph),\n\t\t.flowi6_uid = uid,\n\t};\n\n\tdst = ip6_route_output(net, NULL, &fl6);\n\tif (!dst->error)\n\t\t__ip6_rt_update_pmtu(dst, NULL, iph, ntohl(mtu), true);\n\tdst_release(dst);\n}\nEXPORT_SYMBOL_GPL(ip6_update_pmtu);\n\nvoid ip6_sk_update_pmtu(struct sk_buff *skb, struct sock *sk, __be32 mtu)\n{\n\tint oif = sk->sk_bound_dev_if;\n\tstruct dst_entry *dst;\n\n\tif (!oif && skb->dev)\n\t\toif = l3mdev_master_ifindex(skb->dev);\n\n\tip6_update_pmtu(skb, sock_net(sk), mtu, oif, sk->sk_mark, sk->sk_uid);\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete ||\n\t    dst->ops->check(dst, inet6_sk(sk)->dst_cookie))\n\t\treturn;\n\n\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk) && !ipv6_addr_v4mapped(&sk->sk_v6_daddr))\n\t\tip6_datagram_dst_update(sk, false);\n\tbh_unlock_sock(sk);\n}\nEXPORT_SYMBOL_GPL(ip6_sk_update_pmtu);\n\nvoid ip6_sk_dst_store_flow(struct sock *sk, struct dst_entry *dst,\n\t\t\t   const struct flowi6 *fl6)\n{\n#ifdef CONFIG_IPV6_SUBTREES\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n#endif\n\n\tip6_dst_store(sk, dst,\n\t\t      ipv6_addr_equal(&fl6->daddr, &sk->sk_v6_daddr) ?\n\t\t      &sk->sk_v6_daddr : NULL,\n#ifdef CONFIG_IPV6_SUBTREES\n\t\t      ipv6_addr_equal(&fl6->saddr, &np->saddr) ?\n\t\t      &np->saddr :\n#endif\n\t\t      NULL);\n}\n\nstatic bool ip6_redirect_nh_match(const struct fib6_result *res,\n\t\t\t\t  struct flowi6 *fl6,\n\t\t\t\t  const struct in6_addr *gw,\n\t\t\t\t  struct rt6_info **ret)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD || !nh->fib_nh_gw_family ||\n\t    fl6->flowi6_oif != nh->fib_nh_dev->ifindex)\n\t\treturn false;\n\n\t/* rt_cache's gateway might be different from its 'parent'\n\t * in the case of an ip redirect.\n\t * So we keep searching in the exception table if the gateway\n\t * is different.\n\t */\n\tif (!ipv6_addr_equal(gw, &nh->fib_nh_gw6)) {\n\t\tstruct rt6_info *rt_cache;\n\n\t\trt_cache = rt6_find_cached_rt(res, &fl6->daddr, &fl6->saddr);\n\t\tif (rt_cache &&\n\t\t    ipv6_addr_equal(gw, &rt_cache->rt6i_gateway)) {\n\t\t\t*ret = rt_cache;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstruct fib6_nh_rd_arg {\n\tstruct fib6_result\t*res;\n\tstruct flowi6\t\t*fl6;\n\tconst struct in6_addr\t*gw;\n\tstruct rt6_info\t\t**ret;\n};\n\nstatic int fib6_nh_redirect_match(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_rd_arg *arg = _arg;\n\n\targ->res->nh = nh;\n\treturn ip6_redirect_nh_match(arg->res, arg->fl6, arg->gw, arg->ret);\n}\n\n/* Handle redirects */\nstruct ip6rd_flowi {\n\tstruct flowi6 fl6;\n\tstruct in6_addr gateway;\n};\n\nINDIRECT_CALLABLE_SCOPE struct rt6_info *__ip6_route_redirect(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags)\n{\n\tstruct ip6rd_flowi *rdfl = (struct ip6rd_flowi *)fl6;\n\tstruct rt6_info *ret = NULL;\n\tstruct fib6_result res = {};\n\tstruct fib6_nh_rd_arg arg = {\n\t\t.res = &res,\n\t\t.fl6 = fl6,\n\t\t.gw  = &rdfl->gateway,\n\t\t.ret = &ret\n\t};\n\tstruct fib6_info *rt;\n\tstruct fib6_node *fn;\n\n\t/* l3mdev_update_flow overrides oif if the device is enslaved; in\n\t * this case we must match on the real ingress device, so reset it\n\t */\n\tif (fl6->flowi6_flags & FLOWI_FLAG_SKIP_NH_OIF)\n\t\tfl6->flowi6_oif = skb->dev->ifindex;\n\n\t/* Get the \"current\" route for this destination and\n\t * check if the redirect has come from appropriate router.\n\t *\n\t * RFC 4861 specifies that redirects should only be\n\t * accepted if they come from the nexthop to the target.\n\t * Due to the way the routes are chosen, this notion\n\t * is a bit fuzzy and one might need to check all possible\n\t * routes.\n\t */\n\n\trcu_read_lock();\n\tfn = fib6_node_lookup(&table->tb6_root, &fl6->daddr, &fl6->saddr);\nrestart:\n\tfor_each_fib6_node_rt_rcu(fn) {\n\t\tres.f6i = rt;\n\t\tif (fib6_check_expired(rt))\n\t\t\tcontinue;\n\t\tif (rt->fib6_flags & RTF_REJECT)\n\t\t\tbreak;\n\t\tif (unlikely(rt->nh)) {\n\t\t\tif (nexthop_is_blackhole(rt->nh))\n\t\t\t\tcontinue;\n\t\t\t/* on match, res->nh is filled in and potentially ret */\n\t\t\tif (nexthop_for_each_fib6_nh(rt->nh,\n\t\t\t\t\t\t     fib6_nh_redirect_match,\n\t\t\t\t\t\t     &arg))\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tres.nh = rt->fib6_nh;\n\t\t\tif (ip6_redirect_nh_match(&res, fl6, &rdfl->gateway,\n\t\t\t\t\t\t  &ret))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!rt)\n\t\trt = net->ipv6.fib6_null_entry;\n\telse if (rt->fib6_flags & RTF_REJECT) {\n\t\tret = net->ipv6.ip6_null_entry;\n\t\tgoto out;\n\t}\n\n\tif (rt == net->ipv6.fib6_null_entry) {\n\t\tfn = fib6_backtrack(fn, &fl6->saddr);\n\t\tif (fn)\n\t\t\tgoto restart;\n\t}\n\n\tres.f6i = rt;\n\tres.nh = rt->fib6_nh;\nout:\n\tif (ret) {\n\t\tip6_hold_safe(net, &ret);\n\t} else {\n\t\tres.fib6_flags = res.f6i->fib6_flags;\n\t\tres.fib6_type = res.f6i->fib6_type;\n\t\tret = ip6_create_rt_rcu(&res);\n\t}\n\n\trcu_read_unlock();\n\n\ttrace_fib6_table_lookup(net, &res, table, fl6);\n\treturn ret;\n};\n\nstatic struct dst_entry *ip6_route_redirect(struct net *net,\n\t\t\t\t\t    const struct flowi6 *fl6,\n\t\t\t\t\t    const struct sk_buff *skb,\n\t\t\t\t\t    const struct in6_addr *gateway)\n{\n\tint flags = RT6_LOOKUP_F_HAS_SADDR;\n\tstruct ip6rd_flowi rdfl;\n\n\trdfl.fl6 = *fl6;\n\trdfl.gateway = *gateway;\n\n\treturn fib6_rule_lookup(net, &rdfl.fl6, skb,\n\t\t\t\tflags, __ip6_route_redirect);\n}\n\nvoid ip6_redirect(struct sk_buff *skb, struct net *net, int oif, u32 mark,\n\t\t  kuid_t uid)\n{\n\tconst struct ipv6hdr *iph = (struct ipv6hdr *) skb->data;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_oif = oif,\n\t\t.flowi6_mark = mark,\n\t\t.daddr = iph->daddr,\n\t\t.saddr = iph->saddr,\n\t\t.flowlabel = ip6_flowinfo(iph),\n\t\t.flowi6_uid = uid,\n\t};\n\n\tdst = ip6_route_redirect(net, &fl6, skb, &ipv6_hdr(skb)->saddr);\n\trt6_do_redirect(dst, NULL, skb);\n\tdst_release(dst);\n}\nEXPORT_SYMBOL_GPL(ip6_redirect);\n\nvoid ip6_redirect_no_header(struct sk_buff *skb, struct net *net, int oif)\n{\n\tconst struct ipv6hdr *iph = ipv6_hdr(skb);\n\tconst struct rd_msg *msg = (struct rd_msg *)icmp6_hdr(skb);\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_iif = LOOPBACK_IFINDEX,\n\t\t.flowi6_oif = oif,\n\t\t.daddr = msg->dest,\n\t\t.saddr = iph->daddr,\n\t\t.flowi6_uid = sock_net_uid(net, NULL),\n\t};\n\n\tdst = ip6_route_redirect(net, &fl6, skb, &iph->saddr);\n\trt6_do_redirect(dst, NULL, skb);\n\tdst_release(dst);\n}\n\nvoid ip6_sk_redirect(struct sk_buff *skb, struct sock *sk)\n{\n\tip6_redirect(skb, sock_net(sk), sk->sk_bound_dev_if, sk->sk_mark,\n\t\t     sk->sk_uid);\n}\nEXPORT_SYMBOL_GPL(ip6_sk_redirect);\n\nstatic unsigned int ip6_default_advmss(const struct dst_entry *dst)\n{\n\tstruct net_device *dev = dst->dev;\n\tunsigned int mtu = dst_mtu(dst);\n\tstruct net *net = dev_net(dev);\n\n\tmtu -= sizeof(struct ipv6hdr) + sizeof(struct tcphdr);\n\n\tif (mtu < net->ipv6.sysctl.ip6_rt_min_advmss)\n\t\tmtu = net->ipv6.sysctl.ip6_rt_min_advmss;\n\n\t/*\n\t * Maximal non-jumbo IPv6 payload is IPV6_MAXPLEN and\n\t * corresponding MSS is IPV6_MAXPLEN - tcp_header_size.\n\t * IPV6_MAXPLEN is also valid and means: \"any MSS,\n\t * rely only on pmtu discovery\"\n\t */\n\tif (mtu > IPV6_MAXPLEN - sizeof(struct tcphdr))\n\t\tmtu = IPV6_MAXPLEN;\n\treturn mtu;\n}\n\nINDIRECT_CALLABLE_SCOPE unsigned int ip6_mtu(const struct dst_entry *dst)\n{\n\tstruct inet6_dev *idev;\n\tunsigned int mtu;\n\n\tmtu = dst_metric_raw(dst, RTAX_MTU);\n\tif (mtu)\n\t\tgoto out;\n\n\tmtu = IPV6_MIN_MTU;\n\n\trcu_read_lock();\n\tidev = __in6_dev_get(dst->dev);\n\tif (idev)\n\t\tmtu = idev->cnf.mtu6;\n\trcu_read_unlock();\n\nout:\n\tmtu = min_t(unsigned int, mtu, IP6_MAX_MTU);\n\n\treturn mtu - lwtunnel_headroom(dst->lwtstate, mtu);\n}\nEXPORT_INDIRECT_CALLABLE(ip6_mtu);\n\n/* MTU selection:\n * 1. mtu on route is locked - use it\n * 2. mtu from nexthop exception\n * 3. mtu from egress device\n *\n * based on ip6_dst_mtu_forward and exception logic of\n * rt6_find_cached_rt; called with rcu_read_lock\n */\nu32 ip6_mtu_from_fib6(const struct fib6_result *res,\n\t\t      const struct in6_addr *daddr,\n\t\t      const struct in6_addr *saddr)\n{\n\tconst struct fib6_nh *nh = res->nh;\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct inet6_dev *idev;\n\tstruct rt6_info *rt;\n\tu32 mtu = 0;\n\n\tif (unlikely(fib6_metric_locked(f6i, RTAX_MTU))) {\n\t\tmtu = f6i->fib6_pmtu;\n\t\tif (mtu)\n\t\t\tgoto out;\n\t}\n\n\trt = rt6_find_cached_rt(res, daddr, saddr);\n\tif (unlikely(rt)) {\n\t\tmtu = dst_metric_raw(&rt->dst, RTAX_MTU);\n\t} else {\n\t\tstruct net_device *dev = nh->fib_nh_dev;\n\n\t\tmtu = IPV6_MIN_MTU;\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev && idev->cnf.mtu6 > mtu)\n\t\t\tmtu = idev->cnf.mtu6;\n\t}\n\n\tmtu = min_t(unsigned int, mtu, IP6_MAX_MTU);\nout:\n\treturn mtu - lwtunnel_headroom(nh->fib_nh_lws, mtu);\n}\n\nstruct dst_entry *icmp6_dst_alloc(struct net_device *dev,\n\t\t\t\t  struct flowi6 *fl6)\n{\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt;\n\tstruct inet6_dev *idev = in6_dev_get(dev);\n\tstruct net *net = dev_net(dev);\n\n\tif (unlikely(!idev))\n\t\treturn ERR_PTR(-ENODEV);\n\n\trt = ip6_dst_alloc(net, dev, 0);\n\tif (unlikely(!rt)) {\n\t\tin6_dev_put(idev);\n\t\tdst = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\trt->dst.input = ip6_input;\n\trt->dst.output  = ip6_output;\n\trt->rt6i_gateway  = fl6->daddr;\n\trt->rt6i_dst.addr = fl6->daddr;\n\trt->rt6i_dst.plen = 128;\n\trt->rt6i_idev     = idev;\n\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT, 0);\n\n\t/* Add this dst into uncached_list so that rt6_disable_ip() can\n\t * do proper release of the net_device\n\t */\n\trt6_uncached_list_add(rt);\n\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_uncache);\n\n\tdst = xfrm_lookup(net, &rt->dst, flowi6_to_flowi(fl6), NULL, 0);\n\nout:\n\treturn dst;\n}\n\nstatic int ip6_dst_gc(struct dst_ops *ops)\n{\n\tstruct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);\n\tint rt_min_interval = net->ipv6.sysctl.ip6_rt_gc_min_interval;\n\tint rt_max_size = net->ipv6.sysctl.ip6_rt_max_size;\n\tint rt_elasticity = net->ipv6.sysctl.ip6_rt_gc_elasticity;\n\tint rt_gc_timeout = net->ipv6.sysctl.ip6_rt_gc_timeout;\n\tunsigned long rt_last_gc = net->ipv6.ip6_rt_last_gc;\n\tint entries;\n\n\tentries = dst_entries_get_fast(ops);\n\tif (entries > rt_max_size)\n\t\tentries = dst_entries_get_slow(ops);\n\n\tif (time_after(rt_last_gc + rt_min_interval, jiffies) &&\n\t    entries <= rt_max_size)\n\t\tgoto out;\n\n\tnet->ipv6.ip6_rt_gc_expire++;\n\tfib6_run_gc(net->ipv6.ip6_rt_gc_expire, net, true);\n\tentries = dst_entries_get_slow(ops);\n\tif (entries < ops->gc_thresh)\n\t\tnet->ipv6.ip6_rt_gc_expire = rt_gc_timeout>>1;\nout:\n\tnet->ipv6.ip6_rt_gc_expire -= net->ipv6.ip6_rt_gc_expire>>rt_elasticity;\n\treturn entries > rt_max_size;\n}\n\nstatic int ip6_nh_lookup_table(struct net *net, struct fib6_config *cfg,\n\t\t\t       const struct in6_addr *gw_addr, u32 tbid,\n\t\t\t       int flags, struct fib6_result *res)\n{\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = cfg->fc_ifindex,\n\t\t.daddr = *gw_addr,\n\t\t.saddr = cfg->fc_prefsrc,\n\t};\n\tstruct fib6_table *table;\n\tint err;\n\n\ttable = fib6_get_table(net, tbid);\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tif (!ipv6_addr_any(&cfg->fc_prefsrc))\n\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\n\tflags |= RT6_LOOKUP_F_IGNORE_LINKSTATE;\n\n\terr = fib6_table_lookup(net, table, cfg->fc_ifindex, &fl6, res, flags);\n\tif (!err && res->f6i != net->ipv6.fib6_null_entry)\n\t\tfib6_select_path(net, res, &fl6, cfg->fc_ifindex,\n\t\t\t\t cfg->fc_ifindex != 0, NULL, flags);\n\n\treturn err;\n}\n\nstatic int ip6_route_check_nh_onlink(struct net *net,\n\t\t\t\t     struct fib6_config *cfg,\n\t\t\t\t     const struct net_device *dev,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 tbid = l3mdev_fib_table_rcu(dev) ? : RT_TABLE_MAIN;\n\tconst struct in6_addr *gw_addr = &cfg->fc_gateway;\n\tstruct fib6_result res = {};\n\tint err;\n\n\terr = ip6_nh_lookup_table(net, cfg, gw_addr, tbid, 0, &res);\n\tif (!err && !(res.fib6_flags & RTF_REJECT) &&\n\t    /* ignore match if it is the default route */\n\t    !ipv6_addr_any(&res.f6i->fib6_dst.addr) &&\n\t    (res.fib6_type != RTN_UNICAST || dev != res.nh->fib_nh_dev)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Nexthop has invalid gateway or device mismatch\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nstatic int ip6_route_check_nh(struct net *net,\n\t\t\t      struct fib6_config *cfg,\n\t\t\t      struct net_device **_dev,\n\t\t\t      struct inet6_dev **idev)\n{\n\tconst struct in6_addr *gw_addr = &cfg->fc_gateway;\n\tstruct net_device *dev = _dev ? *_dev : NULL;\n\tint flags = RT6_LOOKUP_F_IFACE;\n\tstruct fib6_result res = {};\n\tint err = -EHOSTUNREACH;\n\n\tif (cfg->fc_table) {\n\t\terr = ip6_nh_lookup_table(net, cfg, gw_addr,\n\t\t\t\t\t  cfg->fc_table, flags, &res);\n\t\t/* gw_addr can not require a gateway or resolve to a reject\n\t\t * route. If a device is given, it must match the result.\n\t\t */\n\t\tif (err || res.fib6_flags & RTF_REJECT ||\n\t\t    res.nh->fib_nh_gw_family ||\n\t\t    (dev && dev != res.nh->fib_nh_dev))\n\t\t\terr = -EHOSTUNREACH;\n\t}\n\n\tif (err < 0) {\n\t\tstruct flowi6 fl6 = {\n\t\t\t.flowi6_oif = cfg->fc_ifindex,\n\t\t\t.daddr = *gw_addr,\n\t\t};\n\n\t\terr = fib6_lookup(net, cfg->fc_ifindex, &fl6, &res, flags);\n\t\tif (err || res.fib6_flags & RTF_REJECT ||\n\t\t    res.nh->fib_nh_gw_family)\n\t\t\terr = -EHOSTUNREACH;\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfib6_select_path(net, &res, &fl6, cfg->fc_ifindex,\n\t\t\t\t cfg->fc_ifindex != 0, NULL, flags);\n\t}\n\n\terr = 0;\n\tif (dev) {\n\t\tif (dev != res.nh->fib_nh_dev)\n\t\t\terr = -EHOSTUNREACH;\n\t} else {\n\t\t*_dev = dev = res.nh->fib_nh_dev;\n\t\tdev_hold(dev);\n\t\t*idev = in6_dev_get(dev);\n\t}\n\n\treturn err;\n}\n\nstatic int ip6_validate_gw(struct net *net, struct fib6_config *cfg,\n\t\t\t   struct net_device **_dev, struct inet6_dev **idev,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tconst struct in6_addr *gw_addr = &cfg->fc_gateway;\n\tint gwa_type = ipv6_addr_type(gw_addr);\n\tbool skip_dev = gwa_type & IPV6_ADDR_LINKLOCAL ? false : true;\n\tconst struct net_device *dev = *_dev;\n\tbool need_addr_check = !dev;\n\tint err = -EINVAL;\n\n\t/* if gw_addr is local we will fail to detect this in case\n\t * address is still TENTATIVE (DAD in progress). rt6_lookup()\n\t * will return already-added prefix route via interface that\n\t * prefix route was assigned to, which might be non-loopback.\n\t */\n\tif (dev &&\n\t    ipv6_chk_addr_and_flags(net, gw_addr, dev, skip_dev, 0, 0)) {\n\t\tNL_SET_ERR_MSG(extack, \"Gateway can not be a local address\");\n\t\tgoto out;\n\t}\n\n\tif (gwa_type != (IPV6_ADDR_LINKLOCAL | IPV6_ADDR_UNICAST)) {\n\t\t/* IPv6 strictly inhibits using not link-local\n\t\t * addresses as nexthop address.\n\t\t * Otherwise, router will not able to send redirects.\n\t\t * It is very good, but in some (rare!) circumstances\n\t\t * (SIT, PtP, NBMA NOARP links) it is handy to allow\n\t\t * some exceptions. --ANK\n\t\t * We allow IPv4-mapped nexthops to support RFC4798-type\n\t\t * addressing\n\t\t */\n\t\tif (!(gwa_type & (IPV6_ADDR_UNICAST | IPV6_ADDR_MAPPED))) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid gateway address\");\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\n\t\tif (cfg->fc_flags & RTNH_F_ONLINK)\n\t\t\terr = ip6_route_check_nh_onlink(net, cfg, dev, extack);\n\t\telse\n\t\t\terr = ip6_route_check_nh(net, cfg, _dev, idev);\n\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/* reload in case device was changed */\n\tdev = *_dev;\n\n\terr = -EINVAL;\n\tif (!dev) {\n\t\tNL_SET_ERR_MSG(extack, \"Egress device not specified\");\n\t\tgoto out;\n\t} else if (dev->flags & IFF_LOOPBACK) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Egress device can not be loopback device for this route\");\n\t\tgoto out;\n\t}\n\n\t/* if we did not check gw_addr above, do so now that the\n\t * egress device has been resolved.\n\t */\n\tif (need_addr_check &&\n\t    ipv6_chk_addr_and_flags(net, gw_addr, dev, skip_dev, 0, 0)) {\n\t\tNL_SET_ERR_MSG(extack, \"Gateway can not be a local address\");\n\t\tgoto out;\n\t}\n\n\terr = 0;\nout:\n\treturn err;\n}\n\nstatic bool fib6_is_reject(u32 flags, struct net_device *dev, int addr_type)\n{\n\tif ((flags & RTF_REJECT) ||\n\t    (dev && (dev->flags & IFF_LOOPBACK) &&\n\t     !(addr_type & IPV6_ADDR_LOOPBACK) &&\n\t     !(flags & (RTF_ANYCAST | RTF_LOCAL))))\n\t\treturn true;\n\n\treturn false;\n}\n\nint fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev = NULL;\n\tint addr_type;\n\tint err;\n\n\tfib6_nh->fib_nh_family = AF_INET6;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tfib6_nh->last_probe = jiffies;\n#endif\n\tif (cfg->fc_is_fdb) {\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t\treturn 0;\n\t}\n\n\terr = -ENODEV;\n\tif (cfg->fc_ifindex) {\n\t\tdev = dev_get_by_index(net, cfg->fc_ifindex);\n\t\tif (!dev)\n\t\t\tgoto out;\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tgoto out;\n\t}\n\n\tif (cfg->fc_flags & RTNH_F_ONLINK) {\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop device required for onlink\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_ONLINK;\n\t}\n\n\tfib6_nh->fib_nh_weight = 1;\n\n\t/* We cannot add true routes via loopback here,\n\t * they would result in kernel looping; promote them to reject routes\n\t */\n\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\tif (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {\n\t\t/* hold loopback dev/idev if we haven't done so. */\n\t\tif (dev != net->loopback_dev) {\n\t\t\tif (dev) {\n\t\t\t\tdev_put(dev);\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t\tdev = net->loopback_dev;\n\t\t\tdev_hold(dev);\n\t\t\tidev = in6_dev_get(dev);\n\t\t\tif (!idev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto pcpu_alloc;\n\t}\n\n\tif (cfg->fc_flags & RTF_GATEWAY) {\n\t\terr = ip6_validate_gw(net, cfg, &dev, &idev, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t}\n\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tif (idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 is disabled on nexthop device\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&\n\t    !netif_carrier_ok(dev))\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\n\terr = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,\n\t\t\t\t cfg->fc_encap_type, cfg, gfp_flags, extack);\n\tif (err)\n\t\tgoto out;\n\npcpu_alloc:\n\tfib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);\n\tif (!fib6_nh->rt6i_pcpu) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfib6_nh->fib_nh_dev = dev;\n\tfib6_nh->fib_nh_oif = dev->ifindex;\n\terr = 0;\nout:\n\tif (idev)\n\t\tin6_dev_put(idev);\n\n\tif (err) {\n\t\tlwtstate_put(fib6_nh->fib_nh_lws);\n\t\tfib6_nh->fib_nh_lws = NULL;\n\t\tif (dev)\n\t\t\tdev_put(dev);\n\t}\n\n\treturn err;\n}\n\nvoid fib6_nh_release(struct fib6_nh *fib6_nh)\n{\n\tstruct rt6_exception_bucket *bucket;\n\n\trcu_read_lock();\n\n\tfib6_nh_flush_exceptions(fib6_nh, NULL);\n\tbucket = fib6_nh_get_excptn_bucket(fib6_nh, NULL);\n\tif (bucket) {\n\t\trcu_assign_pointer(fib6_nh->rt6i_exception_bucket, NULL);\n\t\tkfree(bucket);\n\t}\n\n\trcu_read_unlock();\n\n\tif (fib6_nh->rt6i_pcpu) {\n\t\tint cpu;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct rt6_info **ppcpu_rt;\n\t\t\tstruct rt6_info *pcpu_rt;\n\n\t\t\tppcpu_rt = per_cpu_ptr(fib6_nh->rt6i_pcpu, cpu);\n\t\t\tpcpu_rt = *ppcpu_rt;\n\t\t\tif (pcpu_rt) {\n\t\t\t\tdst_dev_put(&pcpu_rt->dst);\n\t\t\t\tdst_release(&pcpu_rt->dst);\n\t\t\t\t*ppcpu_rt = NULL;\n\t\t\t}\n\t\t}\n\n\t\tfree_percpu(fib6_nh->rt6i_pcpu);\n\t}\n\n\tfib_nh_common_release(&fib6_nh->nh_common);\n}\n\nstatic struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,\n\t\t\t\t\t      gfp_t gfp_flags,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = cfg->fc_nlinfo.nl_net;\n\tstruct fib6_info *rt = NULL;\n\tstruct nexthop *nh = NULL;\n\tstruct fib6_table *table;\n\tstruct fib6_nh *fib6_nh;\n\tint err = -EINVAL;\n\tint addr_type;\n\n\t/* RTF_PCPU is an internal flag; can not be set by userspace */\n\tif (cfg->fc_flags & RTF_PCPU) {\n\t\tNL_SET_ERR_MSG(extack, \"Userspace can not set RTF_PCPU\");\n\t\tgoto out;\n\t}\n\n\t/* RTF_CACHE is an internal flag; can not be set by userspace */\n\tif (cfg->fc_flags & RTF_CACHE) {\n\t\tNL_SET_ERR_MSG(extack, \"Userspace can not set RTF_CACHE\");\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_type > RTN_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid route type\");\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_dst_len > 128) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid prefix length\");\n\t\tgoto out;\n\t}\n\tif (cfg->fc_src_len > 128) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid source address length\");\n\t\tgoto out;\n\t}\n#ifndef CONFIG_IPV6_SUBTREES\n\tif (cfg->fc_src_len) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Specifying source address requires IPV6_SUBTREES to be enabled\");\n\t\tgoto out;\n\t}\n#endif\n\tif (cfg->fc_nh_id) {\n\t\tnh = nexthop_find_by_id(net, cfg->fc_nh_id);\n\t\tif (!nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = fib6_check_nexthop(nh, cfg, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOBUFS;\n\tif (cfg->fc_nlinfo.nlh &&\n\t    !(cfg->fc_nlinfo.nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\ttable = fib6_get_table(net, cfg->fc_table);\n\t\tif (!table) {\n\t\t\tpr_warn(\"NLM_F_CREATE should be specified when creating new route\\n\");\n\t\t\ttable = fib6_new_table(net, cfg->fc_table);\n\t\t}\n\t} else {\n\t\ttable = fib6_new_table(net, cfg->fc_table);\n\t}\n\n\tif (!table)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\trt = fib6_info_alloc(gfp_flags, !nh);\n\tif (!rt)\n\t\tgoto out;\n\n\trt->fib6_metrics = ip_fib_metrics_init(net, cfg->fc_mx, cfg->fc_mx_len,\n\t\t\t\t\t       extack);\n\tif (IS_ERR(rt->fib6_metrics)) {\n\t\terr = PTR_ERR(rt->fib6_metrics);\n\t\t/* Do not leave garbage there. */\n\t\trt->fib6_metrics = (struct dst_metrics *)&dst_default_metrics;\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_flags & RTF_ADDRCONF)\n\t\trt->dst_nocount = true;\n\n\tif (cfg->fc_flags & RTF_EXPIRES)\n\t\tfib6_set_expires(rt, jiffies +\n\t\t\t\tclock_t_to_jiffies(cfg->fc_expires));\n\telse\n\t\tfib6_clean_expires(rt);\n\n\tif (cfg->fc_protocol == RTPROT_UNSPEC)\n\t\tcfg->fc_protocol = RTPROT_BOOT;\n\trt->fib6_protocol = cfg->fc_protocol;\n\n\trt->fib6_table = table;\n\trt->fib6_metric = cfg->fc_metric;\n\trt->fib6_type = cfg->fc_type ? : RTN_UNICAST;\n\trt->fib6_flags = cfg->fc_flags & ~RTF_GATEWAY;\n\n\tipv6_addr_prefix(&rt->fib6_dst.addr, &cfg->fc_dst, cfg->fc_dst_len);\n\trt->fib6_dst.plen = cfg->fc_dst_len;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tipv6_addr_prefix(&rt->fib6_src.addr, &cfg->fc_src, cfg->fc_src_len);\n\trt->fib6_src.plen = cfg->fc_src_len;\n#endif\n\tif (nh) {\n\t\tif (rt->fib6_src.plen) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthops can not be used with source routing\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!nexthop_get(nh)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has been deleted\");\n\t\t\tgoto out;\n\t\t}\n\t\trt->nh = nh;\n\t\tfib6_nh = nexthop_fib6_nh(rt->nh);\n\t} else {\n\t\terr = fib6_nh_init(net, rt->fib6_nh, cfg, gfp_flags, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh = rt->fib6_nh;\n\n\t\t/* We cannot add true routes via loopback here, they would\n\t\t * result in kernel looping; promote them to reject routes\n\t\t */\n\t\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\t\tif (fib6_is_reject(cfg->fc_flags, rt->fib6_nh->fib_nh_dev,\n\t\t\t\t   addr_type))\n\t\t\trt->fib6_flags = RTF_REJECT | RTF_NONEXTHOP;\n\t}\n\n\tif (!ipv6_addr_any(&cfg->fc_prefsrc)) {\n\t\tstruct net_device *dev = fib6_nh->fib_nh_dev;\n\n\t\tif (!ipv6_chk_addr(net, &cfg->fc_prefsrc, dev, 0)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid source address\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trt->fib6_prefsrc.addr = cfg->fc_prefsrc;\n\t\trt->fib6_prefsrc.plen = 128;\n\t} else\n\t\trt->fib6_prefsrc.plen = 0;\n\n\treturn rt;\nout:\n\tfib6_info_release(rt);\n\treturn ERR_PTR(err);\n}\n\nint ip6_route_add(struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *rt;\n\tint err;\n\n\trt = ip6_route_info_create(cfg, gfp_flags, extack);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\terr = __ip6_ins_rt(rt, &cfg->fc_nlinfo, extack);\n\tfib6_info_release(rt);\n\n\treturn err;\n}\n\nstatic int __ip6_del_rt(struct fib6_info *rt, struct nl_info *info)\n{\n\tstruct net *net = info->nl_net;\n\tstruct fib6_table *table;\n\tint err;\n\n\tif (rt == net->ipv6.fib6_null_entry) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttable = rt->fib6_table;\n\tspin_lock_bh(&table->tb6_lock);\n\terr = fib6_del(rt, info);\n\tspin_unlock_bh(&table->tb6_lock);\n\nout:\n\tfib6_info_release(rt);\n\treturn err;\n}\n\nint ip6_del_rt(struct net *net, struct fib6_info *rt, bool skip_notify)\n{\n\tstruct nl_info info = {\n\t\t.nl_net = net,\n\t\t.skip_notify = skip_notify\n\t};\n\n\treturn __ip6_del_rt(rt, &info);\n}\n\nstatic int __ip6_del_rt_siblings(struct fib6_info *rt, struct fib6_config *cfg)\n{\n\tstruct nl_info *info = &cfg->fc_nlinfo;\n\tstruct net *net = info->nl_net;\n\tstruct sk_buff *skb = NULL;\n\tstruct fib6_table *table;\n\tint err = -ENOENT;\n\n\tif (rt == net->ipv6.fib6_null_entry)\n\t\tgoto out_put;\n\ttable = rt->fib6_table;\n\tspin_lock_bh(&table->tb6_lock);\n\n\tif (rt->fib6_nsiblings && cfg->fc_delete_all_nh) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\t\tstruct fib6_node *fn;\n\n\t\t/* prefer to send a single notification with all hops */\n\t\tskb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());\n\t\tif (skb) {\n\t\t\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\n\t\t\tif (rt6_fill_node(net, skb, rt, NULL,\n\t\t\t\t\t  NULL, NULL, 0, RTM_DELROUTE,\n\t\t\t\t\t  info->portid, seq, 0) < 0) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t} else\n\t\t\t\tinfo->skip_notify = 1;\n\t\t}\n\n\t\t/* 'rt' points to the first sibling route. If it is not the\n\t\t * leaf, then we do not need to send a notification. Otherwise,\n\t\t * we need to check if the last sibling has a next route or not\n\t\t * and emit a replace or delete notification, respectively.\n\t\t */\n\t\tinfo->skip_notify_kernel = 1;\n\t\tfn = rcu_dereference_protected(rt->fib6_node,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\tif (rcu_access_pointer(fn->leaf) == rt) {\n\t\t\tstruct fib6_info *last_sibling, *replace_rt;\n\n\t\t\tlast_sibling = list_last_entry(&rt->fib6_siblings,\n\t\t\t\t\t\t       struct fib6_info,\n\t\t\t\t\t\t       fib6_siblings);\n\t\t\treplace_rt = rcu_dereference_protected(\n\t\t\t\t\t    last_sibling->fib6_next,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tif (replace_rt)\n\t\t\t\tcall_fib6_entry_notifiers_replace(net,\n\t\t\t\t\t\t\t\t  replace_rt);\n\t\t\telse\n\t\t\t\tcall_fib6_multipath_entry_notifiers(net,\n\t\t\t\t\t\t       FIB_EVENT_ENTRY_DEL,\n\t\t\t\t\t\t       rt, rt->fib6_nsiblings,\n\t\t\t\t\t\t       NULL);\n\t\t}\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->fib6_siblings,\n\t\t\t\t\t fib6_siblings) {\n\t\t\terr = fib6_del(sibling, info);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\terr = fib6_del(rt, info);\nout_unlock:\n\tspin_unlock_bh(&table->tb6_lock);\nout_put:\n\tfib6_info_release(rt);\n\n\tif (skb) {\n\t\trtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,\n\t\t\t    info->nlh, gfp_any());\n\t}\n\treturn err;\n}\n\nstatic int __ip6_del_cached_rt(struct rt6_info *rt, struct fib6_config *cfg)\n{\n\tint rc = -ESRCH;\n\n\tif (cfg->fc_ifindex && rt->dst.dev->ifindex != cfg->fc_ifindex)\n\t\tgoto out;\n\n\tif (cfg->fc_flags & RTF_GATEWAY &&\n\t    !ipv6_addr_equal(&cfg->fc_gateway, &rt->rt6i_gateway))\n\t\tgoto out;\n\n\trc = rt6_remove_exception_rt(rt);\nout:\n\treturn rc;\n}\n\nstatic int ip6_del_cached_rt(struct fib6_config *cfg, struct fib6_info *rt,\n\t\t\t     struct fib6_nh *nh)\n{\n\tstruct fib6_result res = {\n\t\t.f6i = rt,\n\t\t.nh = nh,\n\t};\n\tstruct rt6_info *rt_cache;\n\n\trt_cache = rt6_find_cached_rt(&res, &cfg->fc_dst, &cfg->fc_src);\n\tif (rt_cache)\n\t\treturn __ip6_del_cached_rt(rt_cache, cfg);\n\n\treturn 0;\n}\n\nstruct fib6_nh_del_cached_rt_arg {\n\tstruct fib6_config *cfg;\n\tstruct fib6_info *f6i;\n};\n\nstatic int fib6_nh_del_cached_rt(struct fib6_nh *nh, void *_arg)\n{\n\tstruct fib6_nh_del_cached_rt_arg *arg = _arg;\n\tint rc;\n\n\trc = ip6_del_cached_rt(arg->cfg, arg->f6i, nh);\n\treturn rc != -ESRCH ? rc : 0;\n}\n\nstatic int ip6_del_cached_rt_nh(struct fib6_config *cfg, struct fib6_info *f6i)\n{\n\tstruct fib6_nh_del_cached_rt_arg arg = {\n\t\t.cfg = cfg,\n\t\t.f6i = f6i\n\t};\n\n\treturn nexthop_for_each_fib6_nh(f6i->nh, fib6_nh_del_cached_rt, &arg);\n}\n\nstatic int ip6_route_del(struct fib6_config *cfg,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct fib6_table *table;\n\tstruct fib6_info *rt;\n\tstruct fib6_node *fn;\n\tint err = -ESRCH;\n\n\ttable = fib6_get_table(cfg->fc_nlinfo.nl_net, cfg->fc_table);\n\tif (!table) {\n\t\tNL_SET_ERR_MSG(extack, \"FIB table does not exist\");\n\t\treturn err;\n\t}\n\n\trcu_read_lock();\n\n\tfn = fib6_locate(&table->tb6_root,\n\t\t\t &cfg->fc_dst, cfg->fc_dst_len,\n\t\t\t &cfg->fc_src, cfg->fc_src_len,\n\t\t\t !(cfg->fc_flags & RTF_CACHE));\n\n\tif (fn) {\n\t\tfor_each_fib6_node_rt_rcu(fn) {\n\t\t\tstruct fib6_nh *nh;\n\n\t\t\tif (rt->nh && cfg->fc_nh_id &&\n\t\t\t    rt->nh->id != cfg->fc_nh_id)\n\t\t\t\tcontinue;\n\n\t\t\tif (cfg->fc_flags & RTF_CACHE) {\n\t\t\t\tint rc = 0;\n\n\t\t\t\tif (rt->nh) {\n\t\t\t\t\trc = ip6_del_cached_rt_nh(cfg, rt);\n\t\t\t\t} else if (cfg->fc_nh_id) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tnh = rt->fib6_nh;\n\t\t\t\t\trc = ip6_del_cached_rt(cfg, rt, nh);\n\t\t\t\t}\n\t\t\t\tif (rc != -ESRCH) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cfg->fc_metric && cfg->fc_metric != rt->fib6_metric)\n\t\t\t\tcontinue;\n\t\t\tif (cfg->fc_protocol &&\n\t\t\t    cfg->fc_protocol != rt->fib6_protocol)\n\t\t\t\tcontinue;\n\n\t\t\tif (rt->nh) {\n\t\t\t\tif (!fib6_info_hold_safe(rt))\n\t\t\t\t\tcontinue;\n\t\t\t\trcu_read_unlock();\n\n\t\t\t\treturn __ip6_del_rt(rt, &cfg->fc_nlinfo);\n\t\t\t}\n\t\t\tif (cfg->fc_nh_id)\n\t\t\t\tcontinue;\n\n\t\t\tnh = rt->fib6_nh;\n\t\t\tif (cfg->fc_ifindex &&\n\t\t\t    (!nh->fib_nh_dev ||\n\t\t\t     nh->fib_nh_dev->ifindex != cfg->fc_ifindex))\n\t\t\t\tcontinue;\n\t\t\tif (cfg->fc_flags & RTF_GATEWAY &&\n\t\t\t    !ipv6_addr_equal(&cfg->fc_gateway, &nh->fib_nh_gw6))\n\t\t\t\tcontinue;\n\t\t\tif (!fib6_info_hold_safe(rt))\n\t\t\t\tcontinue;\n\t\t\trcu_read_unlock();\n\n\t\t\t/* if gateway was specified only delete the one hop */\n\t\t\tif (cfg->fc_flags & RTF_GATEWAY)\n\t\t\t\treturn __ip6_del_rt(rt, &cfg->fc_nlinfo);\n\n\t\t\treturn __ip6_del_rt_siblings(rt, cfg);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic void rt6_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct netevent_redirect netevent;\n\tstruct rt6_info *rt, *nrt = NULL;\n\tstruct fib6_result res = {};\n\tstruct ndisc_options ndopts;\n\tstruct inet6_dev *in6_dev;\n\tstruct neighbour *neigh;\n\tstruct rd_msg *msg;\n\tint optlen, on_link;\n\tu8 *lladdr;\n\n\toptlen = skb_tail_pointer(skb) - skb_transport_header(skb);\n\toptlen -= sizeof(*msg);\n\n\tif (optlen < 0) {\n\t\tnet_dbg_ratelimited(\"rt6_do_redirect: packet too short\\n\");\n\t\treturn;\n\t}\n\n\tmsg = (struct rd_msg *)icmp6_hdr(skb);\n\n\tif (ipv6_addr_is_multicast(&msg->dest)) {\n\t\tnet_dbg_ratelimited(\"rt6_do_redirect: destination address is multicast\\n\");\n\t\treturn;\n\t}\n\n\ton_link = 0;\n\tif (ipv6_addr_equal(&msg->dest, &msg->target)) {\n\t\ton_link = 1;\n\t} else if (ipv6_addr_type(&msg->target) !=\n\t\t   (IPV6_ADDR_UNICAST|IPV6_ADDR_LINKLOCAL)) {\n\t\tnet_dbg_ratelimited(\"rt6_do_redirect: target address is not link-local unicast\\n\");\n\t\treturn;\n\t}\n\n\tin6_dev = __in6_dev_get(skb->dev);\n\tif (!in6_dev)\n\t\treturn;\n\tif (in6_dev->cnf.forwarding || !in6_dev->cnf.accept_redirects)\n\t\treturn;\n\n\t/* RFC2461 8.1:\n\t *\tThe IP source address of the Redirect MUST be the same as the current\n\t *\tfirst-hop router for the specified ICMP Destination Address.\n\t */\n\n\tif (!ndisc_parse_options(skb->dev, msg->opt, optlen, &ndopts)) {\n\t\tnet_dbg_ratelimited(\"rt6_redirect: invalid ND options\\n\");\n\t\treturn;\n\t}\n\n\tlladdr = NULL;\n\tif (ndopts.nd_opts_tgt_lladdr) {\n\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_tgt_lladdr,\n\t\t\t\t\t     skb->dev);\n\t\tif (!lladdr) {\n\t\t\tnet_dbg_ratelimited(\"rt6_redirect: invalid link-layer address length\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\trt = (struct rt6_info *) dst;\n\tif (rt->rt6i_flags & RTF_REJECT) {\n\t\tnet_dbg_ratelimited(\"rt6_redirect: source isn't a valid nexthop for redirect target\\n\");\n\t\treturn;\n\t}\n\n\t/* Redirect received -> path was valid.\n\t * Look, redirects are sent only in response to data packets,\n\t * so that this nexthop apparently is reachable. --ANK\n\t */\n\tdst_confirm_neigh(&rt->dst, &ipv6_hdr(skb)->saddr);\n\n\tneigh = __neigh_lookup(&nd_tbl, &msg->target, skb->dev, 1);\n\tif (!neigh)\n\t\treturn;\n\n\t/*\n\t *\tWe have finally decided to accept it.\n\t */\n\n\tndisc_update(skb->dev, neigh, lladdr, NUD_STALE,\n\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t     NEIGH_UPDATE_F_OVERRIDE|\n\t\t     (on_link ? 0 : (NEIGH_UPDATE_F_OVERRIDE_ISROUTER|\n\t\t\t\t     NEIGH_UPDATE_F_ISROUTER)),\n\t\t     NDISC_REDIRECT, &ndopts);\n\n\trcu_read_lock();\n\tres.f6i = rcu_dereference(rt->from);\n\tif (!res.f6i)\n\t\tgoto out;\n\n\tif (res.f6i->nh) {\n\t\tstruct fib6_nh_match_arg arg = {\n\t\t\t.dev = dst->dev,\n\t\t\t.gw = &rt->rt6i_gateway,\n\t\t};\n\n\t\tnexthop_for_each_fib6_nh(res.f6i->nh,\n\t\t\t\t\t fib6_nh_find_match, &arg);\n\n\t\t/* fib6_info uses a nexthop that does not have fib6_nh\n\t\t * using the dst->dev. Should be impossible\n\t\t */\n\t\tif (!arg.match)\n\t\t\tgoto out;\n\t\tres.nh = arg.match;\n\t} else {\n\t\tres.nh = res.f6i->fib6_nh;\n\t}\n\n\tres.fib6_flags = res.f6i->fib6_flags;\n\tres.fib6_type = res.f6i->fib6_type;\n\tnrt = ip6_rt_cache_alloc(&res, &msg->dest, NULL);\n\tif (!nrt)\n\t\tgoto out;\n\n\tnrt->rt6i_flags = RTF_GATEWAY|RTF_UP|RTF_DYNAMIC|RTF_CACHE;\n\tif (on_link)\n\t\tnrt->rt6i_flags &= ~RTF_GATEWAY;\n\n\tnrt->rt6i_gateway = *(struct in6_addr *)neigh->primary_key;\n\n\t/* rt6_insert_exception() will take care of duplicated exceptions */\n\tif (rt6_insert_exception(nrt, &res)) {\n\t\tdst_release_immediate(&nrt->dst);\n\t\tgoto out;\n\t}\n\n\tnetevent.old = &rt->dst;\n\tnetevent.new = &nrt->dst;\n\tnetevent.daddr = &msg->dest;\n\tnetevent.neigh = neigh;\n\tcall_netevent_notifiers(NETEVENT_REDIRECT, &netevent);\n\nout:\n\trcu_read_unlock();\n\tneigh_release(neigh);\n}\n\n#ifdef CONFIG_IPV6_ROUTE_INFO\nstatic struct fib6_info *rt6_get_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tu32 tb_id = l3mdev_fib_table(dev) ? : RT6_TABLE_INFO;\n\tint ifindex = dev->ifindex;\n\tstruct fib6_node *fn;\n\tstruct fib6_info *rt = NULL;\n\tstruct fib6_table *table;\n\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfn = fib6_locate(&table->tb6_root, prefix, prefixlen, NULL, 0, true);\n\tif (!fn)\n\t\tgoto out;\n\n\tfor_each_fib6_node_rt_rcu(fn) {\n\t\t/* these routes do not use nexthops */\n\t\tif (rt->nh)\n\t\t\tcontinue;\n\t\tif (rt->fib6_nh->fib_nh_dev->ifindex != ifindex)\n\t\t\tcontinue;\n\t\tif (!(rt->fib6_flags & RTF_ROUTEINFO) ||\n\t\t    !rt->fib6_nh->fib_nh_gw_family)\n\t\t\tcontinue;\n\t\tif (!ipv6_addr_equal(&rt->fib6_nh->fib_nh_gw6, gwaddr))\n\t\t\tcontinue;\n\t\tif (!fib6_info_hold_safe(rt))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\nout:\n\trcu_read_unlock();\n\treturn rt;\n}\n\nstatic struct fib6_info *rt6_add_route_info(struct net *net,\n\t\t\t\t\t   const struct in6_addr *prefix, int prefixlen,\n\t\t\t\t\t   const struct in6_addr *gwaddr,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   unsigned int pref)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_metric\t= IP6_RT_PRIO_USER,\n\t\t.fc_ifindex\t= dev->ifindex,\n\t\t.fc_dst_len\t= prefixlen,\n\t\t.fc_flags\t= RTF_GATEWAY | RTF_ADDRCONF | RTF_ROUTEINFO |\n\t\t\t\t  RTF_UP | RTF_PREF(pref),\n\t\t.fc_protocol = RTPROT_RA,\n\t\t.fc_type = RTN_UNICAST,\n\t\t.fc_nlinfo.portid = 0,\n\t\t.fc_nlinfo.nlh = NULL,\n\t\t.fc_nlinfo.nl_net = net,\n\t};\n\n\tcfg.fc_table = l3mdev_fib_table(dev) ? : RT6_TABLE_INFO;\n\tcfg.fc_dst = *prefix;\n\tcfg.fc_gateway = *gwaddr;\n\n\t/* We should treat it as a default route if prefix length is 0. */\n\tif (!prefixlen)\n\t\tcfg.fc_flags |= RTF_DEFAULT;\n\n\tip6_route_add(&cfg, GFP_ATOMIC, NULL);\n\n\treturn rt6_get_route_info(net, prefix, prefixlen, gwaddr, dev);\n}\n#endif\n\nstruct fib6_info *rt6_get_dflt_router(struct net *net,\n\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t     struct net_device *dev)\n{\n\tu32 tb_id = l3mdev_fib_table(dev) ? : RT6_TABLE_DFLT;\n\tstruct fib6_info *rt;\n\tstruct fib6_table *table;\n\n\ttable = fib6_get_table(net, tb_id);\n\tif (!table)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tfor_each_fib6_node_rt_rcu(&table->tb6_root) {\n\t\tstruct fib6_nh *nh;\n\n\t\t/* RA routes do not use nexthops */\n\t\tif (rt->nh)\n\t\t\tcontinue;\n\n\t\tnh = rt->fib6_nh;\n\t\tif (dev == nh->fib_nh_dev &&\n\t\t    ((rt->fib6_flags & (RTF_ADDRCONF | RTF_DEFAULT)) == (RTF_ADDRCONF | RTF_DEFAULT)) &&\n\t\t    ipv6_addr_equal(&nh->fib_nh_gw6, addr))\n\t\t\tbreak;\n\t}\n\tif (rt && !fib6_info_hold_safe(rt))\n\t\trt = NULL;\n\trcu_read_unlock();\n\treturn rt;\n}\n\nstruct fib6_info *rt6_add_dflt_router(struct net *net,\n\t\t\t\t     const struct in6_addr *gwaddr,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     unsigned int pref,\n\t\t\t\t     u32 defrtr_usr_metric)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table\t= l3mdev_fib_table(dev) ? : RT6_TABLE_DFLT,\n\t\t.fc_metric\t= defrtr_usr_metric,\n\t\t.fc_ifindex\t= dev->ifindex,\n\t\t.fc_flags\t= RTF_GATEWAY | RTF_ADDRCONF | RTF_DEFAULT |\n\t\t\t\t  RTF_UP | RTF_EXPIRES | RTF_PREF(pref),\n\t\t.fc_protocol = RTPROT_RA,\n\t\t.fc_type = RTN_UNICAST,\n\t\t.fc_nlinfo.portid = 0,\n\t\t.fc_nlinfo.nlh = NULL,\n\t\t.fc_nlinfo.nl_net = net,\n\t};\n\n\tcfg.fc_gateway = *gwaddr;\n\n\tif (!ip6_route_add(&cfg, GFP_ATOMIC, NULL)) {\n\t\tstruct fib6_table *table;\n\n\t\ttable = fib6_get_table(dev_net(dev), cfg.fc_table);\n\t\tif (table)\n\t\t\ttable->flags |= RT6_TABLE_HAS_DFLT_ROUTER;\n\t}\n\n\treturn rt6_get_dflt_router(net, gwaddr, dev);\n}\n\nstatic void __rt6_purge_dflt_routers(struct net *net,\n\t\t\t\t     struct fib6_table *table)\n{\n\tstruct fib6_info *rt;\n\nrestart:\n\trcu_read_lock();\n\tfor_each_fib6_node_rt_rcu(&table->tb6_root) {\n\t\tstruct net_device *dev = fib6_info_nh_dev(rt);\n\t\tstruct inet6_dev *idev = dev ? __in6_dev_get(dev) : NULL;\n\n\t\tif (rt->fib6_flags & (RTF_DEFAULT | RTF_ADDRCONF) &&\n\t\t    (!idev || idev->cnf.accept_ra != 2) &&\n\t\t    fib6_info_hold_safe(rt)) {\n\t\t\trcu_read_unlock();\n\t\t\tip6_del_rt(net, rt, false);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\ttable->flags &= ~RT6_TABLE_HAS_DFLT_ROUTER;\n}\n\nvoid rt6_purge_dflt_routers(struct net *net)\n{\n\tstruct fib6_table *table;\n\tstruct hlist_head *head;\n\tunsigned int h;\n\n\trcu_read_lock();\n\n\tfor (h = 0; h < FIB6_TABLE_HASHSZ; h++) {\n\t\thead = &net->ipv6.fib_table_hash[h];\n\t\thlist_for_each_entry_rcu(table, head, tb6_hlist) {\n\t\t\tif (table->flags & RT6_TABLE_HAS_DFLT_ROUTER)\n\t\t\t\t__rt6_purge_dflt_routers(net, table);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void rtmsg_to_fib6_config(struct net *net,\n\t\t\t\t struct in6_rtmsg *rtmsg,\n\t\t\t\t struct fib6_config *cfg)\n{\n\t*cfg = (struct fib6_config){\n\t\t.fc_table = l3mdev_fib_table_by_index(net, rtmsg->rtmsg_ifindex) ?\n\t\t\t : RT6_TABLE_MAIN,\n\t\t.fc_ifindex = rtmsg->rtmsg_ifindex,\n\t\t.fc_metric = rtmsg->rtmsg_metric ? : IP6_RT_PRIO_USER,\n\t\t.fc_expires = rtmsg->rtmsg_info,\n\t\t.fc_dst_len = rtmsg->rtmsg_dst_len,\n\t\t.fc_src_len = rtmsg->rtmsg_src_len,\n\t\t.fc_flags = rtmsg->rtmsg_flags,\n\t\t.fc_type = rtmsg->rtmsg_type,\n\n\t\t.fc_nlinfo.nl_net = net,\n\n\t\t.fc_dst = rtmsg->rtmsg_dst,\n\t\t.fc_src = rtmsg->rtmsg_src,\n\t\t.fc_gateway = rtmsg->rtmsg_gateway,\n\t};\n}\n\nint ipv6_route_ioctl(struct net *net, unsigned int cmd, struct in6_rtmsg *rtmsg)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\n\tif (cmd != SIOCADDRT && cmd != SIOCDELRT)\n\t\treturn -EINVAL;\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\trtmsg_to_fib6_config(net, rtmsg, &cfg);\n\n\trtnl_lock();\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\terr = ip6_route_add(&cfg, GFP_KERNEL, NULL);\n\t\tbreak;\n\tcase SIOCDELRT:\n\t\terr = ip6_route_del(&cfg, NULL);\n\t\tbreak;\n\t}\n\trtnl_unlock();\n\treturn err;\n}\n\n/*\n *\tDrop the packet on the floor\n */\n\nstatic int ip6_pkt_drop(struct sk_buff *skb, u8 code, int ipstats_mib_noroutes)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net *net = dev_net(dst->dev);\n\tstruct inet6_dev *idev;\n\tint type;\n\n\tif (netif_is_l3_master(skb->dev) &&\n\t    dst->dev == net->loopback_dev)\n\t\tidev = __in6_dev_get_safely(dev_get_by_index_rcu(net, IP6CB(skb)->iif));\n\telse\n\t\tidev = ip6_dst_idev(dst);\n\n\tswitch (ipstats_mib_noroutes) {\n\tcase IPSTATS_MIB_INNOROUTES:\n\t\ttype = ipv6_addr_type(&ipv6_hdr(skb)->daddr);\n\t\tif (type == IPV6_ADDR_ANY) {\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_INADDRERRORS);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase IPSTATS_MIB_OUTNOROUTES:\n\t\tIP6_INC_STATS(net, idev, ipstats_mib_noroutes);\n\t\tbreak;\n\t}\n\n\t/* Start over by dropping the dst for l3mdev case */\n\tif (netif_is_l3_master(skb->dev))\n\t\tskb_dst_drop(skb);\n\n\ticmpv6_send(skb, ICMPV6_DEST_UNREACH, code, 0);\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int ip6_pkt_discard(struct sk_buff *skb)\n{\n\treturn ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_INNOROUTES);\n}\n\nstatic int ip6_pkt_discard_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb->dev = skb_dst(skb)->dev;\n\treturn ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_OUTNOROUTES);\n}\n\nstatic int ip6_pkt_prohibit(struct sk_buff *skb)\n{\n\treturn ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_INNOROUTES);\n}\n\nstatic int ip6_pkt_prohibit_out(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tskb->dev = skb_dst(skb)->dev;\n\treturn ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);\n}\n\n/*\n *\tAllocate a dst for local (unicast / anycast) address.\n */\n\nstruct fib6_info *addrconf_f6i_alloc(struct net *net,\n\t\t\t\t     struct inet6_dev *idev,\n\t\t\t\t     const struct in6_addr *addr,\n\t\t\t\t     bool anycast, gfp_t gfp_flags)\n{\n\tstruct fib6_config cfg = {\n\t\t.fc_table = l3mdev_fib_table(idev->dev) ? : RT6_TABLE_LOCAL,\n\t\t.fc_ifindex = idev->dev->ifindex,\n\t\t.fc_flags = RTF_UP | RTF_NONEXTHOP,\n\t\t.fc_dst = *addr,\n\t\t.fc_dst_len = 128,\n\t\t.fc_protocol = RTPROT_KERNEL,\n\t\t.fc_nlinfo.nl_net = net,\n\t\t.fc_ignore_dev_down = true,\n\t};\n\tstruct fib6_info *f6i;\n\n\tif (anycast) {\n\t\tcfg.fc_type = RTN_ANYCAST;\n\t\tcfg.fc_flags |= RTF_ANYCAST;\n\t} else {\n\t\tcfg.fc_type = RTN_LOCAL;\n\t\tcfg.fc_flags |= RTF_LOCAL;\n\t}\n\n\tf6i = ip6_route_info_create(&cfg, gfp_flags, NULL);\n\tif (!IS_ERR(f6i))\n\t\tf6i->dst_nocount = true;\n\treturn f6i;\n}\n\n/* remove deleted ip from prefsrc entries */\nstruct arg_dev_net_ip {\n\tstruct net_device *dev;\n\tstruct net *net;\n\tstruct in6_addr *addr;\n};\n\nstatic int fib6_remove_prefsrc(struct fib6_info *rt, void *arg)\n{\n\tstruct net_device *dev = ((struct arg_dev_net_ip *)arg)->dev;\n\tstruct net *net = ((struct arg_dev_net_ip *)arg)->net;\n\tstruct in6_addr *addr = ((struct arg_dev_net_ip *)arg)->addr;\n\n\tif (!rt->nh &&\n\t    ((void *)rt->fib6_nh->fib_nh_dev == dev || !dev) &&\n\t    rt != net->ipv6.fib6_null_entry &&\n\t    ipv6_addr_equal(addr, &rt->fib6_prefsrc.addr)) {\n\t\tspin_lock_bh(&rt6_exception_lock);\n\t\t/* remove prefsrc entry */\n\t\trt->fib6_prefsrc.plen = 0;\n\t\tspin_unlock_bh(&rt6_exception_lock);\n\t}\n\treturn 0;\n}\n\nvoid rt6_remove_prefsrc(struct inet6_ifaddr *ifp)\n{\n\tstruct net *net = dev_net(ifp->idev->dev);\n\tstruct arg_dev_net_ip adni = {\n\t\t.dev = ifp->idev->dev,\n\t\t.net = net,\n\t\t.addr = &ifp->addr,\n\t};\n\tfib6_clean_all(net, fib6_remove_prefsrc, &adni);\n}\n\n#define RTF_RA_ROUTER\t\t(RTF_ADDRCONF | RTF_DEFAULT)\n\n/* Remove routers and update dst entries when gateway turn into host. */\nstatic int fib6_clean_tohost(struct fib6_info *rt, void *arg)\n{\n\tstruct in6_addr *gateway = (struct in6_addr *)arg;\n\tstruct fib6_nh *nh;\n\n\t/* RA routes do not use nexthops */\n\tif (rt->nh)\n\t\treturn 0;\n\n\tnh = rt->fib6_nh;\n\tif (((rt->fib6_flags & RTF_RA_ROUTER) == RTF_RA_ROUTER) &&\n\t    nh->fib_nh_gw_family && ipv6_addr_equal(gateway, &nh->fib_nh_gw6))\n\t\treturn -1;\n\n\t/* Further clean up cached routes in exception table.\n\t * This is needed because cached route may have a different\n\t * gateway than its 'parent' in the case of an ip redirect.\n\t */\n\tfib6_nh_exceptions_clean_tohost(nh, gateway);\n\n\treturn 0;\n}\n\nvoid rt6_clean_tohost(struct net *net, struct in6_addr *gateway)\n{\n\tfib6_clean_all(net, fib6_clean_tohost, gateway);\n}\n\nstruct arg_netdev_event {\n\tconst struct net_device *dev;\n\tunion {\n\t\tunsigned char nh_flags;\n\t\tunsigned long event;\n\t};\n};\n\nstatic struct fib6_info *rt6_multipath_first_sibling(const struct fib6_info *rt)\n{\n\tstruct fib6_info *iter;\n\tstruct fib6_node *fn;\n\n\tfn = rcu_dereference_protected(rt->fib6_node,\n\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\titer = rcu_dereference_protected(fn->leaf,\n\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\twhile (iter) {\n\t\tif (iter->fib6_metric == rt->fib6_metric &&\n\t\t    rt6_qualify_for_ecmp(iter))\n\t\t\treturn iter;\n\t\titer = rcu_dereference_protected(iter->fib6_next,\n\t\t\t\tlockdep_is_held(&rt->fib6_table->tb6_lock));\n\t}\n\n\treturn NULL;\n}\n\n/* only called for fib entries with builtin fib6_nh */\nstatic bool rt6_is_dead(const struct fib6_info *rt)\n{\n\tif (rt->fib6_nh->fib_nh_flags & RTNH_F_DEAD ||\n\t    (rt->fib6_nh->fib_nh_flags & RTNH_F_LINKDOWN &&\n\t     ip6_ignore_linkdown(rt->fib6_nh->fib_nh_dev)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int rt6_multipath_total_weight(const struct fib6_info *rt)\n{\n\tstruct fib6_info *iter;\n\tint total = 0;\n\n\tif (!rt6_is_dead(rt))\n\t\ttotal += rt->fib6_nh->fib_nh_weight;\n\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings) {\n\t\tif (!rt6_is_dead(iter))\n\t\t\ttotal += iter->fib6_nh->fib_nh_weight;\n\t}\n\n\treturn total;\n}\n\nstatic void rt6_upper_bound_set(struct fib6_info *rt, int *weight, int total)\n{\n\tint upper_bound = -1;\n\n\tif (!rt6_is_dead(rt)) {\n\t\t*weight += rt->fib6_nh->fib_nh_weight;\n\t\tupper_bound = DIV_ROUND_CLOSEST_ULL((u64) (*weight) << 31,\n\t\t\t\t\t\t    total) - 1;\n\t}\n\tatomic_set(&rt->fib6_nh->fib_nh_upper_bound, upper_bound);\n}\n\nstatic void rt6_multipath_upper_bound_set(struct fib6_info *rt, int total)\n{\n\tstruct fib6_info *iter;\n\tint weight = 0;\n\n\trt6_upper_bound_set(rt, &weight, total);\n\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\trt6_upper_bound_set(iter, &weight, total);\n}\n\nvoid rt6_multipath_rebalance(struct fib6_info *rt)\n{\n\tstruct fib6_info *first;\n\tint total;\n\n\t/* In case the entire multipath route was marked for flushing,\n\t * then there is no need to rebalance upon the removal of every\n\t * sibling route.\n\t */\n\tif (!rt->fib6_nsiblings || rt->should_flush)\n\t\treturn;\n\n\t/* During lookup routes are evaluated in order, so we need to\n\t * make sure upper bounds are assigned from the first sibling\n\t * onwards.\n\t */\n\tfirst = rt6_multipath_first_sibling(rt);\n\tif (WARN_ON_ONCE(!first))\n\t\treturn;\n\n\ttotal = rt6_multipath_total_weight(first);\n\trt6_multipath_upper_bound_set(first, total);\n}\n\nstatic int fib6_ifup(struct fib6_info *rt, void *p_arg)\n{\n\tconst struct arg_netdev_event *arg = p_arg;\n\tstruct net *net = dev_net(arg->dev);\n\n\tif (rt != net->ipv6.fib6_null_entry && !rt->nh &&\n\t    rt->fib6_nh->fib_nh_dev == arg->dev) {\n\t\trt->fib6_nh->fib_nh_flags &= ~arg->nh_flags;\n\t\tfib6_update_sernum_upto_root(net, rt);\n\t\trt6_multipath_rebalance(rt);\n\t}\n\n\treturn 0;\n}\n\nvoid rt6_sync_up(struct net_device *dev, unsigned char nh_flags)\n{\n\tstruct arg_netdev_event arg = {\n\t\t.dev = dev,\n\t\t{\n\t\t\t.nh_flags = nh_flags,\n\t\t},\n\t};\n\n\tif (nh_flags & RTNH_F_DEAD && netif_carrier_ok(dev))\n\t\targ.nh_flags |= RTNH_F_LINKDOWN;\n\n\tfib6_clean_all(dev_net(dev), fib6_ifup, &arg);\n}\n\n/* only called for fib entries with inline fib6_nh */\nstatic bool rt6_multipath_uses_dev(const struct fib6_info *rt,\n\t\t\t\t   const struct net_device *dev)\n{\n\tstruct fib6_info *iter;\n\n\tif (rt->fib6_nh->fib_nh_dev == dev)\n\t\treturn true;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\tif (iter->fib6_nh->fib_nh_dev == dev)\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void rt6_multipath_flush(struct fib6_info *rt)\n{\n\tstruct fib6_info *iter;\n\n\trt->should_flush = 1;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\titer->should_flush = 1;\n}\n\nstatic unsigned int rt6_multipath_dead_count(const struct fib6_info *rt,\n\t\t\t\t\t     const struct net_device *down_dev)\n{\n\tstruct fib6_info *iter;\n\tunsigned int dead = 0;\n\n\tif (rt->fib6_nh->fib_nh_dev == down_dev ||\n\t    rt->fib6_nh->fib_nh_flags & RTNH_F_DEAD)\n\t\tdead++;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\tif (iter->fib6_nh->fib_nh_dev == down_dev ||\n\t\t    iter->fib6_nh->fib_nh_flags & RTNH_F_DEAD)\n\t\t\tdead++;\n\n\treturn dead;\n}\n\nstatic void rt6_multipath_nh_flags_set(struct fib6_info *rt,\n\t\t\t\t       const struct net_device *dev,\n\t\t\t\t       unsigned char nh_flags)\n{\n\tstruct fib6_info *iter;\n\n\tif (rt->fib6_nh->fib_nh_dev == dev)\n\t\trt->fib6_nh->fib_nh_flags |= nh_flags;\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings)\n\t\tif (iter->fib6_nh->fib_nh_dev == dev)\n\t\t\titer->fib6_nh->fib_nh_flags |= nh_flags;\n}\n\n/* called with write lock held for table with rt */\nstatic int fib6_ifdown(struct fib6_info *rt, void *p_arg)\n{\n\tconst struct arg_netdev_event *arg = p_arg;\n\tconst struct net_device *dev = arg->dev;\n\tstruct net *net = dev_net(dev);\n\n\tif (rt == net->ipv6.fib6_null_entry || rt->nh)\n\t\treturn 0;\n\n\tswitch (arg->event) {\n\tcase NETDEV_UNREGISTER:\n\t\treturn rt->fib6_nh->fib_nh_dev == dev ? -1 : 0;\n\tcase NETDEV_DOWN:\n\t\tif (rt->should_flush)\n\t\t\treturn -1;\n\t\tif (!rt->fib6_nsiblings)\n\t\t\treturn rt->fib6_nh->fib_nh_dev == dev ? -1 : 0;\n\t\tif (rt6_multipath_uses_dev(rt, dev)) {\n\t\t\tunsigned int count;\n\n\t\t\tcount = rt6_multipath_dead_count(rt, dev);\n\t\t\tif (rt->fib6_nsiblings + 1 == count) {\n\t\t\t\trt6_multipath_flush(rt);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\trt6_multipath_nh_flags_set(rt, dev, RTNH_F_DEAD |\n\t\t\t\t\t\t   RTNH_F_LINKDOWN);\n\t\t\tfib6_update_sernum(net, rt);\n\t\t\trt6_multipath_rebalance(rt);\n\t\t}\n\t\treturn -2;\n\tcase NETDEV_CHANGE:\n\t\tif (rt->fib6_nh->fib_nh_dev != dev ||\n\t\t    rt->fib6_flags & (RTF_LOCAL | RTF_ANYCAST))\n\t\t\tbreak;\n\t\trt->fib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\t\trt6_multipath_rebalance(rt);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid rt6_sync_down_dev(struct net_device *dev, unsigned long event)\n{\n\tstruct arg_netdev_event arg = {\n\t\t.dev = dev,\n\t\t{\n\t\t\t.event = event,\n\t\t},\n\t};\n\tstruct net *net = dev_net(dev);\n\n\tif (net->ipv6.sysctl.skip_notify_on_dev_down)\n\t\tfib6_clean_all_skip_notify(net, fib6_ifdown, &arg);\n\telse\n\t\tfib6_clean_all(net, fib6_ifdown, &arg);\n}\n\nvoid rt6_disable_ip(struct net_device *dev, unsigned long event)\n{\n\trt6_sync_down_dev(dev, event);\n\trt6_uncached_list_flush_dev(dev_net(dev), dev);\n\tneigh_ifdown(&nd_tbl, dev);\n}\n\nstruct rt6_mtu_change_arg {\n\tstruct net_device *dev;\n\tunsigned int mtu;\n\tstruct fib6_info *f6i;\n};\n\nstatic int fib6_nh_mtu_change(struct fib6_nh *nh, void *_arg)\n{\n\tstruct rt6_mtu_change_arg *arg = (struct rt6_mtu_change_arg *)_arg;\n\tstruct fib6_info *f6i = arg->f6i;\n\n\t/* For administrative MTU increase, there is no way to discover\n\t * IPv6 PMTU increase, so PMTU increase should be updated here.\n\t * Since RFC 1981 doesn't include administrative MTU increase\n\t * update PMTU increase is a MUST. (i.e. jumbo frame)\n\t */\n\tif (nh->fib_nh_dev == arg->dev) {\n\t\tstruct inet6_dev *idev = __in6_dev_get(arg->dev);\n\t\tu32 mtu = f6i->fib6_pmtu;\n\n\t\tif (mtu >= arg->mtu ||\n\t\t    (mtu < arg->mtu && mtu == idev->cnf.mtu6))\n\t\t\tfib6_metric_set(f6i, RTAX_MTU, arg->mtu);\n\n\t\tspin_lock_bh(&rt6_exception_lock);\n\t\trt6_exceptions_update_pmtu(idev, nh, arg->mtu);\n\t\tspin_unlock_bh(&rt6_exception_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt6_mtu_change_route(struct fib6_info *f6i, void *p_arg)\n{\n\tstruct rt6_mtu_change_arg *arg = (struct rt6_mtu_change_arg *) p_arg;\n\tstruct inet6_dev *idev;\n\n\t/* In IPv6 pmtu discovery is not optional,\n\t   so that RTAX_MTU lock cannot disable it.\n\t   We still use this lock to block changes\n\t   caused by addrconf/ndisc.\n\t*/\n\n\tidev = __in6_dev_get(arg->dev);\n\tif (!idev)\n\t\treturn 0;\n\n\tif (fib6_metric_locked(f6i, RTAX_MTU))\n\t\treturn 0;\n\n\targ->f6i = f6i;\n\tif (f6i->nh) {\n\t\t/* fib6_nh_mtu_change only returns 0, so this is safe */\n\t\treturn nexthop_for_each_fib6_nh(f6i->nh, fib6_nh_mtu_change,\n\t\t\t\t\t\targ);\n\t}\n\n\treturn fib6_nh_mtu_change(f6i->fib6_nh, arg);\n}\n\nvoid rt6_mtu_change(struct net_device *dev, unsigned int mtu)\n{\n\tstruct rt6_mtu_change_arg arg = {\n\t\t.dev = dev,\n\t\t.mtu = mtu,\n\t};\n\n\tfib6_clean_all(dev_net(dev), rt6_mtu_change_route, &arg);\n}\n\nstatic const struct nla_policy rtm_ipv6_policy[RTA_MAX+1] = {\n\t[RTA_UNSPEC]\t\t= { .strict_start_type = RTA_DPORT + 1 },\n\t[RTA_GATEWAY]           = { .len = sizeof(struct in6_addr) },\n\t[RTA_PREFSRC]\t\t= { .len = sizeof(struct in6_addr) },\n\t[RTA_OIF]               = { .type = NLA_U32 },\n\t[RTA_IIF]\t\t= { .type = NLA_U32 },\n\t[RTA_PRIORITY]          = { .type = NLA_U32 },\n\t[RTA_METRICS]           = { .type = NLA_NESTED },\n\t[RTA_MULTIPATH]\t\t= { .len = sizeof(struct rtnexthop) },\n\t[RTA_PREF]              = { .type = NLA_U8 },\n\t[RTA_ENCAP_TYPE]\t= { .type = NLA_U16 },\n\t[RTA_ENCAP]\t\t= { .type = NLA_NESTED },\n\t[RTA_EXPIRES]\t\t= { .type = NLA_U32 },\n\t[RTA_UID]\t\t= { .type = NLA_U32 },\n\t[RTA_MARK]\t\t= { .type = NLA_U32 },\n\t[RTA_TABLE]\t\t= { .type = NLA_U32 },\n\t[RTA_IP_PROTO]\t\t= { .type = NLA_U8 },\n\t[RTA_SPORT]\t\t= { .type = NLA_U16 },\n\t[RTA_DPORT]\t\t= { .type = NLA_U16 },\n\t[RTA_NH_ID]\t\t= { .type = NLA_U32 },\n};\n\nstatic int rtm_to_fib6_config(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct fib6_config *cfg,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tstruct nlattr *tb[RTA_MAX+1];\n\tunsigned int pref;\n\tint err;\n\n\terr = nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t     rtm_ipv6_policy, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trtm = nlmsg_data(nlh);\n\n\t*cfg = (struct fib6_config){\n\t\t.fc_table = rtm->rtm_table,\n\t\t.fc_dst_len = rtm->rtm_dst_len,\n\t\t.fc_src_len = rtm->rtm_src_len,\n\t\t.fc_flags = RTF_UP,\n\t\t.fc_protocol = rtm->rtm_protocol,\n\t\t.fc_type = rtm->rtm_type,\n\n\t\t.fc_nlinfo.portid = NETLINK_CB(skb).portid,\n\t\t.fc_nlinfo.nlh = nlh,\n\t\t.fc_nlinfo.nl_net = sock_net(skb->sk),\n\t};\n\n\tif (rtm->rtm_type == RTN_UNREACHABLE ||\n\t    rtm->rtm_type == RTN_BLACKHOLE ||\n\t    rtm->rtm_type == RTN_PROHIBIT ||\n\t    rtm->rtm_type == RTN_THROW)\n\t\tcfg->fc_flags |= RTF_REJECT;\n\n\tif (rtm->rtm_type == RTN_LOCAL)\n\t\tcfg->fc_flags |= RTF_LOCAL;\n\n\tif (rtm->rtm_flags & RTM_F_CLONED)\n\t\tcfg->fc_flags |= RTF_CACHE;\n\n\tcfg->fc_flags |= (rtm->rtm_flags & RTNH_F_ONLINK);\n\n\tif (tb[RTA_NH_ID]) {\n\t\tif (tb[RTA_GATEWAY]   || tb[RTA_OIF] ||\n\t\t    tb[RTA_MULTIPATH] || tb[RTA_ENCAP]) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop specification and nexthop id are mutually exclusive\");\n\t\t\tgoto errout;\n\t\t}\n\t\tcfg->fc_nh_id = nla_get_u32(tb[RTA_NH_ID]);\n\t}\n\n\tif (tb[RTA_GATEWAY]) {\n\t\tcfg->fc_gateway = nla_get_in6_addr(tb[RTA_GATEWAY]);\n\t\tcfg->fc_flags |= RTF_GATEWAY;\n\t}\n\tif (tb[RTA_VIA]) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 does not support RTA_VIA attribute\");\n\t\tgoto errout;\n\t}\n\n\tif (tb[RTA_DST]) {\n\t\tint plen = (rtm->rtm_dst_len + 7) >> 3;\n\n\t\tif (nla_len(tb[RTA_DST]) < plen)\n\t\t\tgoto errout;\n\n\t\tnla_memcpy(&cfg->fc_dst, tb[RTA_DST], plen);\n\t}\n\n\tif (tb[RTA_SRC]) {\n\t\tint plen = (rtm->rtm_src_len + 7) >> 3;\n\n\t\tif (nla_len(tb[RTA_SRC]) < plen)\n\t\t\tgoto errout;\n\n\t\tnla_memcpy(&cfg->fc_src, tb[RTA_SRC], plen);\n\t}\n\n\tif (tb[RTA_PREFSRC])\n\t\tcfg->fc_prefsrc = nla_get_in6_addr(tb[RTA_PREFSRC]);\n\n\tif (tb[RTA_OIF])\n\t\tcfg->fc_ifindex = nla_get_u32(tb[RTA_OIF]);\n\n\tif (tb[RTA_PRIORITY])\n\t\tcfg->fc_metric = nla_get_u32(tb[RTA_PRIORITY]);\n\n\tif (tb[RTA_METRICS]) {\n\t\tcfg->fc_mx = nla_data(tb[RTA_METRICS]);\n\t\tcfg->fc_mx_len = nla_len(tb[RTA_METRICS]);\n\t}\n\n\tif (tb[RTA_TABLE])\n\t\tcfg->fc_table = nla_get_u32(tb[RTA_TABLE]);\n\n\tif (tb[RTA_MULTIPATH]) {\n\t\tcfg->fc_mp = nla_data(tb[RTA_MULTIPATH]);\n\t\tcfg->fc_mp_len = nla_len(tb[RTA_MULTIPATH]);\n\n\t\terr = lwtunnel_valid_encap_type_attr(cfg->fc_mp,\n\t\t\t\t\t\t     cfg->fc_mp_len, extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[RTA_PREF]) {\n\t\tpref = nla_get_u8(tb[RTA_PREF]);\n\t\tif (pref != ICMPV6_ROUTER_PREF_LOW &&\n\t\t    pref != ICMPV6_ROUTER_PREF_HIGH)\n\t\t\tpref = ICMPV6_ROUTER_PREF_MEDIUM;\n\t\tcfg->fc_flags |= RTF_PREF(pref);\n\t}\n\n\tif (tb[RTA_ENCAP])\n\t\tcfg->fc_encap = tb[RTA_ENCAP];\n\n\tif (tb[RTA_ENCAP_TYPE]) {\n\t\tcfg->fc_encap_type = nla_get_u16(tb[RTA_ENCAP_TYPE]);\n\n\t\terr = lwtunnel_valid_encap_type(cfg->fc_encap_type, extack);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\n\tif (tb[RTA_EXPIRES]) {\n\t\tunsigned long timeout = addrconf_timeout_fixup(nla_get_u32(tb[RTA_EXPIRES]), HZ);\n\n\t\tif (addrconf_finite_timeout(timeout)) {\n\t\t\tcfg->fc_expires = jiffies_to_clock_t(timeout * HZ);\n\t\t\tcfg->fc_flags |= RTF_EXPIRES;\n\t\t}\n\t}\n\n\terr = 0;\nerrout:\n\treturn err;\n}\n\nstruct rt6_nh {\n\tstruct fib6_info *fib6_info;\n\tstruct fib6_config r_cfg;\n\tstruct list_head next;\n};\n\nstatic int ip6_route_info_append(struct net *net,\n\t\t\t\t struct list_head *rt6_nh_list,\n\t\t\t\t struct fib6_info *rt,\n\t\t\t\t struct fib6_config *r_cfg)\n{\n\tstruct rt6_nh *nh;\n\tint err = -EEXIST;\n\n\tlist_for_each_entry(nh, rt6_nh_list, next) {\n\t\t/* check if fib6_info already exists */\n\t\tif (rt6_duplicate_nexthop(nh->fib6_info, rt))\n\t\t\treturn err;\n\t}\n\n\tnh = kzalloc(sizeof(*nh), GFP_KERNEL);\n\tif (!nh)\n\t\treturn -ENOMEM;\n\tnh->fib6_info = rt;\n\tmemcpy(&nh->r_cfg, r_cfg, sizeof(*r_cfg));\n\tlist_add_tail(&nh->next, rt6_nh_list);\n\n\treturn 0;\n}\n\nstatic void ip6_route_mpath_notify(struct fib6_info *rt,\n\t\t\t\t   struct fib6_info *rt_last,\n\t\t\t\t   struct nl_info *info,\n\t\t\t\t   __u16 nlflags)\n{\n\t/* if this is an APPEND route, then rt points to the first route\n\t * inserted and rt_last points to last route inserted. Userspace\n\t * wants a consistent dump of the route which starts at the first\n\t * nexthop. Since sibling routes are always added at the end of\n\t * the list, find the first sibling of the last route appended\n\t */\n\tif ((nlflags & NLM_F_APPEND) && rt_last && rt_last->fib6_nsiblings) {\n\t\trt = list_first_entry(&rt_last->fib6_siblings,\n\t\t\t\t      struct fib6_info,\n\t\t\t\t      fib6_siblings);\n\t}\n\n\tif (rt)\n\t\tinet6_rt_notify(RTM_NEWROUTE, rt, info, nlflags);\n}\n\nstatic bool ip6_route_mpath_should_notify(const struct fib6_info *rt)\n{\n\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n\tbool should_notify = false;\n\tstruct fib6_info *leaf;\n\tstruct fib6_node *fn;\n\n\trcu_read_lock();\n\tfn = rcu_dereference(rt->fib6_node);\n\tif (!fn)\n\t\tgoto out;\n\n\tleaf = rcu_dereference(fn->leaf);\n\tif (!leaf)\n\t\tgoto out;\n\n\tif (rt == leaf ||\n\t    (rt_can_ecmp && rt->fib6_metric == leaf->fib6_metric &&\n\t     rt6_qualify_for_ecmp(leaf)))\n\t\tshould_notify = true;\nout:\n\trcu_read_unlock();\n\n\treturn should_notify;\n}\n\nstatic int ip6_route_multipath_add(struct fib6_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *rt_notif = NULL, *rt_last = NULL;\n\tstruct nl_info *info = &cfg->fc_nlinfo;\n\tstruct fib6_config r_cfg;\n\tstruct rtnexthop *rtnh;\n\tstruct fib6_info *rt;\n\tstruct rt6_nh *err_nh;\n\tstruct rt6_nh *nh, *nh_safe;\n\t__u16 nlflags;\n\tint remaining;\n\tint attrlen;\n\tint err = 1;\n\tint nhn = 0;\n\tint replace = (cfg->fc_nlinfo.nlh &&\n\t\t       (cfg->fc_nlinfo.nlh->nlmsg_flags & NLM_F_REPLACE));\n\tLIST_HEAD(rt6_nh_list);\n\n\tnlflags = replace ? NLM_F_REPLACE : NLM_F_CREATE;\n\tif (info->nlh && info->nlh->nlmsg_flags & NLM_F_APPEND)\n\t\tnlflags |= NLM_F_APPEND;\n\n\tremaining = cfg->fc_mp_len;\n\trtnh = (struct rtnexthop *)cfg->fc_mp;\n\n\t/* Parse a Multipath Entry and build a list (rt6_nh_list) of\n\t * fib6_info structs per nexthop\n\t */\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tmemcpy(&r_cfg, cfg, sizeof(*cfg));\n\t\tif (rtnh->rtnh_ifindex)\n\t\t\tr_cfg.fc_ifindex = rtnh->rtnh_ifindex;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tif (nla) {\n\t\t\t\tr_cfg.fc_gateway = nla_get_in6_addr(nla);\n\t\t\t\tr_cfg.fc_flags |= RTF_GATEWAY;\n\t\t\t}\n\t\t\tr_cfg.fc_encap = nla_find(attrs, attrlen, RTA_ENCAP);\n\t\t\tnla = nla_find(attrs, attrlen, RTA_ENCAP_TYPE);\n\t\t\tif (nla)\n\t\t\t\tr_cfg.fc_encap_type = nla_get_u16(nla);\n\t\t}\n\n\t\tr_cfg.fc_flags |= (rtnh->rtnh_flags & RTNH_F_ONLINK);\n\t\trt = ip6_route_info_create(&r_cfg, GFP_KERNEL, extack);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!rt6_qualify_for_ecmp(rt)) {\n\t\t\terr = -EINVAL;\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Device only routes can not be added for IPv6 using the multipath API.\");\n\t\t\tfib6_info_release(rt);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\trt->fib6_nh->fib_nh_weight = rtnh->rtnh_hops + 1;\n\n\t\terr = ip6_route_info_append(info->nl_net, &rt6_nh_list,\n\t\t\t\t\t    rt, &r_cfg);\n\t\tif (err) {\n\t\t\tfib6_info_release(rt);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\tif (list_empty(&rt6_nh_list)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid nexthop configuration - no valid nexthops\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* for add and replace send one notification with all nexthops.\n\t * Skip the notification in fib6_add_rt2node and send one with\n\t * the full route when done\n\t */\n\tinfo->skip_notify = 1;\n\n\t/* For add and replace, send one notification with all nexthops. For\n\t * append, send one notification with all appended nexthops.\n\t */\n\tinfo->skip_notify_kernel = 1;\n\n\terr_nh = NULL;\n\tlist_for_each_entry(nh, &rt6_nh_list, next) {\n\t\terr = __ip6_ins_rt(nh->fib6_info, info, extack);\n\t\tfib6_info_release(nh->fib6_info);\n\n\t\tif (!err) {\n\t\t\t/* save reference to last route successfully inserted */\n\t\t\trt_last = nh->fib6_info;\n\n\t\t\t/* save reference to first route for notification */\n\t\t\tif (!rt_notif)\n\t\t\t\trt_notif = nh->fib6_info;\n\t\t}\n\n\t\t/* nh->fib6_info is used or freed at this point, reset to NULL*/\n\t\tnh->fib6_info = NULL;\n\t\tif (err) {\n\t\t\tif (replace && nhn)\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"multipath route replace failed (check consistency of installed routes)\");\n\t\t\terr_nh = nh;\n\t\t\tgoto add_errout;\n\t\t}\n\n\t\t/* Because each route is added like a single route we remove\n\t\t * these flags after the first nexthop: if there is a collision,\n\t\t * we have already failed to add the first nexthop:\n\t\t * fib6_add_rt2node() has rejected it; when replacing, old\n\t\t * nexthops have been replaced by first new, the rest should\n\t\t * be added to it.\n\t\t */\n\t\tcfg->fc_nlinfo.nlh->nlmsg_flags &= ~(NLM_F_EXCL |\n\t\t\t\t\t\t     NLM_F_REPLACE);\n\t\tcfg->fc_nlinfo.nlh->nlmsg_flags |= NLM_F_CREATE;\n\t\tnhn++;\n\t}\n\n\t/* An in-kernel notification should only be sent in case the new\n\t * multipath route is added as the first route in the node, or if\n\t * it was appended to it. We pass 'rt_notif' since it is the first\n\t * sibling and might allow us to skip some checks in the replace case.\n\t */\n\tif (ip6_route_mpath_should_notify(rt_notif)) {\n\t\tenum fib_event_type fib_event;\n\n\t\tif (rt_notif->fib6_nsiblings != nhn - 1)\n\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\telse\n\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\n\t\terr = call_fib6_multipath_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\t  fib_event, rt_notif,\n\t\t\t\t\t\t\t  nhn - 1, extack);\n\t\tif (err) {\n\t\t\t/* Delete all the siblings that were just added */\n\t\t\terr_nh = NULL;\n\t\t\tgoto add_errout;\n\t\t}\n\t}\n\n\t/* success ... tell user about new route */\n\tip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);\n\tgoto cleanup;\n\nadd_errout:\n\t/* send notification for routes that were added so that\n\t * the delete notifications sent by ip6_route_del are\n\t * coherent\n\t */\n\tif (rt_notif)\n\t\tip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);\n\n\t/* Delete routes that were already added */\n\tlist_for_each_entry(nh, &rt6_nh_list, next) {\n\t\tif (err_nh == nh)\n\t\t\tbreak;\n\t\tip6_route_del(&nh->r_cfg, extack);\n\t}\n\ncleanup:\n\tlist_for_each_entry_safe(nh, nh_safe, &rt6_nh_list, next) {\n\t\tif (nh->fib6_info)\n\t\t\tfib6_info_release(nh->fib6_info);\n\t\tlist_del(&nh->next);\n\t\tkfree(nh);\n\t}\n\n\treturn err;\n}\n\nstatic int ip6_route_multipath_del(struct fib6_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config r_cfg;\n\tstruct rtnexthop *rtnh;\n\tint last_err = 0;\n\tint remaining;\n\tint attrlen;\n\tint err;\n\n\tremaining = cfg->fc_mp_len;\n\trtnh = (struct rtnexthop *)cfg->fc_mp;\n\n\t/* Parse a Multipath Entry */\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tmemcpy(&r_cfg, cfg, sizeof(*cfg));\n\t\tif (rtnh->rtnh_ifindex)\n\t\t\tr_cfg.fc_ifindex = rtnh->rtnh_ifindex;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tif (nla) {\n\t\t\t\tnla_memcpy(&r_cfg.fc_gateway, nla, 16);\n\t\t\t\tr_cfg.fc_flags |= RTF_GATEWAY;\n\t\t\t}\n\t\t}\n\t\terr = ip6_route_del(&r_cfg, extack);\n\t\tif (err)\n\t\t\tlast_err = err;\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\treturn last_err;\n}\n\nstatic int inet6_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\n\terr = rtm_to_fib6_config(skb, nlh, &cfg, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cfg.fc_nh_id &&\n\t    !nexthop_find_by_id(sock_net(skb->sk), cfg.fc_nh_id)) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cfg.fc_mp)\n\t\treturn ip6_route_multipath_del(&cfg, extack);\n\telse {\n\t\tcfg.fc_delete_all_nh = 1;\n\t\treturn ip6_route_del(&cfg, extack);\n\t}\n}\n\nstatic int inet6_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\n\terr = rtm_to_fib6_config(skb, nlh, &cfg, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (cfg.fc_metric == 0)\n\t\tcfg.fc_metric = IP6_RT_PRIO_USER;\n\n\tif (cfg.fc_mp)\n\t\treturn ip6_route_multipath_add(&cfg, extack);\n\telse\n\t\treturn ip6_route_add(&cfg, GFP_KERNEL, extack);\n}\n\n/* add the overhead of this fib6_nh to nexthop_len */\nstatic int rt6_nh_nlmsg_size(struct fib6_nh *nh, void *arg)\n{\n\tint *nexthop_len = arg;\n\n\t*nexthop_len += nla_total_size(0)\t /* RTA_MULTIPATH */\n\t\t     + NLA_ALIGN(sizeof(struct rtnexthop))\n\t\t     + nla_total_size(16); /* RTA_GATEWAY */\n\n\tif (nh->fib_nh_lws) {\n\t\t/* RTA_ENCAP_TYPE */\n\t\t*nexthop_len += lwtunnel_get_encap_size(nh->fib_nh_lws);\n\t\t/* RTA_ENCAP */\n\t\t*nexthop_len += nla_total_size(2);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t rt6_nlmsg_size(struct fib6_info *f6i)\n{\n\tint nexthop_len;\n\n\tif (f6i->nh) {\n\t\tnexthop_len = nla_total_size(4); /* RTA_NH_ID */\n\t\tnexthop_for_each_fib6_nh(f6i->nh, rt6_nh_nlmsg_size,\n\t\t\t\t\t &nexthop_len);\n\t} else {\n\t\tstruct fib6_nh *nh = f6i->fib6_nh;\n\n\t\tnexthop_len = 0;\n\t\tif (f6i->fib6_nsiblings) {\n\t\t\tnexthop_len = nla_total_size(0)\t /* RTA_MULTIPATH */\n\t\t\t\t    + NLA_ALIGN(sizeof(struct rtnexthop))\n\t\t\t\t    + nla_total_size(16) /* RTA_GATEWAY */\n\t\t\t\t    + lwtunnel_get_encap_size(nh->fib_nh_lws);\n\n\t\t\tnexthop_len *= f6i->fib6_nsiblings;\n\t\t}\n\t\tnexthop_len += lwtunnel_get_encap_size(nh->fib_nh_lws);\n\t}\n\n\treturn NLMSG_ALIGN(sizeof(struct rtmsg))\n\t       + nla_total_size(16) /* RTA_SRC */\n\t       + nla_total_size(16) /* RTA_DST */\n\t       + nla_total_size(16) /* RTA_GATEWAY */\n\t       + nla_total_size(16) /* RTA_PREFSRC */\n\t       + nla_total_size(4) /* RTA_TABLE */\n\t       + nla_total_size(4) /* RTA_IIF */\n\t       + nla_total_size(4) /* RTA_OIF */\n\t       + nla_total_size(4) /* RTA_PRIORITY */\n\t       + RTAX_MAX * nla_total_size(4) /* RTA_METRICS */\n\t       + nla_total_size(sizeof(struct rta_cacheinfo))\n\t       + nla_total_size(TCP_CA_NAME_MAX) /* RTAX_CC_ALGO */\n\t       + nla_total_size(1) /* RTA_PREF */\n\t       + nexthop_len;\n}\n\nstatic int rt6_fill_node_nexthop(struct sk_buff *skb, struct nexthop *nh,\n\t\t\t\t unsigned char *flags)\n{\n\tif (nexthop_is_multipath(nh)) {\n\t\tstruct nlattr *mp;\n\n\t\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\t\tif (!mp)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nexthop_mpath_fill_node(skb, nh, AF_INET6))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(skb, mp);\n\t} else {\n\t\tstruct fib6_nh *fib6_nh;\n\n\t\tfib6_nh = nexthop_fib6_nh(nh);\n\t\tif (fib_nexthop_info(skb, &fib6_nh->nh_common, AF_INET6,\n\t\t\t\t     flags, false) < 0)\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int rt6_fill_node(struct net *net, struct sk_buff *skb,\n\t\t\t struct fib6_info *rt, struct dst_entry *dst,\n\t\t\t struct in6_addr *dest, struct in6_addr *src,\n\t\t\t int iif, int type, u32 portid, u32 seq,\n\t\t\t unsigned int flags)\n{\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\tstruct rt6key *rt6_dst, *rt6_src;\n\tu32 *pmetrics, table, rt6_flags;\n\tunsigned char nh_flags = 0;\n\tstruct nlmsghdr *nlh;\n\tstruct rtmsg *rtm;\n\tlong expires = 0;\n\n\tnlh = nlmsg_put(skb, portid, seq, type, sizeof(*rtm), flags);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tif (rt6) {\n\t\trt6_dst = &rt6->rt6i_dst;\n\t\trt6_src = &rt6->rt6i_src;\n\t\trt6_flags = rt6->rt6i_flags;\n\t} else {\n\t\trt6_dst = &rt->fib6_dst;\n\t\trt6_src = &rt->fib6_src;\n\t\trt6_flags = rt->fib6_flags;\n\t}\n\n\trtm = nlmsg_data(nlh);\n\trtm->rtm_family = AF_INET6;\n\trtm->rtm_dst_len = rt6_dst->plen;\n\trtm->rtm_src_len = rt6_src->plen;\n\trtm->rtm_tos = 0;\n\tif (rt->fib6_table)\n\t\ttable = rt->fib6_table->tb6_id;\n\telse\n\t\ttable = RT6_TABLE_UNSPEC;\n\trtm->rtm_table = table < 256 ? table : RT_TABLE_COMPAT;\n\tif (nla_put_u32(skb, RTA_TABLE, table))\n\t\tgoto nla_put_failure;\n\n\trtm->rtm_type = rt->fib6_type;\n\trtm->rtm_flags = 0;\n\trtm->rtm_scope = RT_SCOPE_UNIVERSE;\n\trtm->rtm_protocol = rt->fib6_protocol;\n\n\tif (rt6_flags & RTF_CACHE)\n\t\trtm->rtm_flags |= RTM_F_CLONED;\n\n\tif (dest) {\n\t\tif (nla_put_in6_addr(skb, RTA_DST, dest))\n\t\t\tgoto nla_put_failure;\n\t\trtm->rtm_dst_len = 128;\n\t} else if (rtm->rtm_dst_len)\n\t\tif (nla_put_in6_addr(skb, RTA_DST, &rt6_dst->addr))\n\t\t\tgoto nla_put_failure;\n#ifdef CONFIG_IPV6_SUBTREES\n\tif (src) {\n\t\tif (nla_put_in6_addr(skb, RTA_SRC, src))\n\t\t\tgoto nla_put_failure;\n\t\trtm->rtm_src_len = 128;\n\t} else if (rtm->rtm_src_len &&\n\t\t   nla_put_in6_addr(skb, RTA_SRC, &rt6_src->addr))\n\t\tgoto nla_put_failure;\n#endif\n\tif (iif) {\n#ifdef CONFIG_IPV6_MROUTE\n\t\tif (ipv6_addr_is_multicast(&rt6_dst->addr)) {\n\t\t\tint err = ip6mr_get_route(net, skb, rtm, portid);\n\n\t\t\tif (err == 0)\n\t\t\t\treturn 0;\n\t\t\tif (err < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t} else\n#endif\n\t\t\tif (nla_put_u32(skb, RTA_IIF, iif))\n\t\t\t\tgoto nla_put_failure;\n\t} else if (dest) {\n\t\tstruct in6_addr saddr_buf;\n\t\tif (ip6_route_get_saddr(net, rt, dest, 0, &saddr_buf) == 0 &&\n\t\t    nla_put_in6_addr(skb, RTA_PREFSRC, &saddr_buf))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif (rt->fib6_prefsrc.plen) {\n\t\tstruct in6_addr saddr_buf;\n\t\tsaddr_buf = rt->fib6_prefsrc.addr;\n\t\tif (nla_put_in6_addr(skb, RTA_PREFSRC, &saddr_buf))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tpmetrics = dst ? dst_metrics_ptr(dst) : rt->fib6_metrics->metrics;\n\tif (rtnetlink_put_metrics(skb, pmetrics) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, RTA_PRIORITY, rt->fib6_metric))\n\t\tgoto nla_put_failure;\n\n\t/* For multipath routes, walk the siblings list and add\n\t * each as a nexthop within RTA_MULTIPATH.\n\t */\n\tif (rt6) {\n\t\tif (rt6_flags & RTF_GATEWAY &&\n\t\t    nla_put_in6_addr(skb, RTA_GATEWAY, &rt6->rt6i_gateway))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (dst->dev && nla_put_u32(skb, RTA_OIF, dst->dev->ifindex))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (dst->lwtstate &&\n\t\t    lwtunnel_fill_encap(skb, dst->lwtstate, RTA_ENCAP, RTA_ENCAP_TYPE) < 0)\n\t\t\tgoto nla_put_failure;\n\t} else if (rt->fib6_nsiblings) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\t\tstruct nlattr *mp;\n\n\t\tmp = nla_nest_start_noflag(skb, RTA_MULTIPATH);\n\t\tif (!mp)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (fib_add_nexthop(skb, &rt->fib6_nh->nh_common,\n\t\t\t\t    rt->fib6_nh->fib_nh_weight, AF_INET6) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &rt->fib6_siblings, fib6_siblings) {\n\t\t\tif (fib_add_nexthop(skb, &sibling->fib6_nh->nh_common,\n\t\t\t\t\t    sibling->fib6_nh->fib_nh_weight,\n\t\t\t\t\t    AF_INET6) < 0)\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tnla_nest_end(skb, mp);\n\t} else if (rt->nh) {\n\t\tif (nla_put_u32(skb, RTA_NH_ID, rt->nh->id))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nexthop_is_blackhole(rt->nh))\n\t\t\trtm->rtm_type = RTN_BLACKHOLE;\n\n\t\tif (net->ipv4.sysctl_nexthop_compat_mode &&\n\t\t    rt6_fill_node_nexthop(skb, rt->nh, &nh_flags) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\trtm->rtm_flags |= nh_flags;\n\t} else {\n\t\tif (fib_nexthop_info(skb, &rt->fib6_nh->nh_common, AF_INET6,\n\t\t\t\t     &nh_flags, false) < 0)\n\t\t\tgoto nla_put_failure;\n\n\t\trtm->rtm_flags |= nh_flags;\n\t}\n\n\tif (rt6_flags & RTF_EXPIRES) {\n\t\texpires = dst ? dst->expires : rt->expires;\n\t\texpires -= jiffies;\n\t}\n\n\tif (!dst) {\n\t\tif (rt->offload)\n\t\t\trtm->rtm_flags |= RTM_F_OFFLOAD;\n\t\tif (rt->trap)\n\t\t\trtm->rtm_flags |= RTM_F_TRAP;\n\t\tif (rt->offload_failed)\n\t\t\trtm->rtm_flags |= RTM_F_OFFLOAD_FAILED;\n\t}\n\n\tif (rtnl_put_cacheinfo(skb, dst, 0, expires, dst ? dst->error : 0) < 0)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, RTA_PREF, IPV6_EXTRACT_PREF(rt6_flags)))\n\t\tgoto nla_put_failure;\n\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic int fib6_info_nh_uses_dev(struct fib6_nh *nh, void *arg)\n{\n\tconst struct net_device *dev = arg;\n\n\tif (nh->fib_nh_dev == dev)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool fib6_info_uses_dev(const struct fib6_info *f6i,\n\t\t\t       const struct net_device *dev)\n{\n\tif (f6i->nh) {\n\t\tstruct net_device *_dev = (struct net_device *)dev;\n\n\t\treturn !!nexthop_for_each_fib6_nh(f6i->nh,\n\t\t\t\t\t\t  fib6_info_nh_uses_dev,\n\t\t\t\t\t\t  _dev);\n\t}\n\n\tif (f6i->fib6_nh->fib_nh_dev == dev)\n\t\treturn true;\n\n\tif (f6i->fib6_nsiblings) {\n\t\tstruct fib6_info *sibling, *next_sibling;\n\n\t\tlist_for_each_entry_safe(sibling, next_sibling,\n\t\t\t\t\t &f6i->fib6_siblings, fib6_siblings) {\n\t\t\tif (sibling->fib6_nh->fib_nh_dev == dev)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstruct fib6_nh_exception_dump_walker {\n\tstruct rt6_rtnl_dump_arg *dump;\n\tstruct fib6_info *rt;\n\tunsigned int flags;\n\tunsigned int skip;\n\tunsigned int count;\n};\n\nstatic int rt6_nh_dump_exceptions(struct fib6_nh *nh, void *arg)\n{\n\tstruct fib6_nh_exception_dump_walker *w = arg;\n\tstruct rt6_rtnl_dump_arg *dump = w->dump;\n\tstruct rt6_exception_bucket *bucket;\n\tstruct rt6_exception *rt6_ex;\n\tint i, err;\n\n\tbucket = fib6_nh_get_excptn_bucket(nh, NULL);\n\tif (!bucket)\n\t\treturn 0;\n\n\tfor (i = 0; i < FIB6_EXCEPTION_BUCKET_SIZE; i++) {\n\t\thlist_for_each_entry(rt6_ex, &bucket->chain, hlist) {\n\t\t\tif (w->skip) {\n\t\t\t\tw->skip--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Expiration of entries doesn't bump sernum, insertion\n\t\t\t * does. Removal is triggered by insertion, so we can\n\t\t\t * rely on the fact that if entries change between two\n\t\t\t * partial dumps, this node is scanned again completely,\n\t\t\t * see rt6_insert_exception() and fib6_dump_table().\n\t\t\t *\n\t\t\t * Count expired entries we go through as handled\n\t\t\t * entries that we'll skip next time, in case of partial\n\t\t\t * node dump. Otherwise, if entries expire meanwhile,\n\t\t\t * we'll skip the wrong amount.\n\t\t\t */\n\t\t\tif (rt6_check_expired(rt6_ex->rt6i)) {\n\t\t\t\tw->count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = rt6_fill_node(dump->net, dump->skb, w->rt,\n\t\t\t\t\t    &rt6_ex->rt6i->dst, NULL, NULL, 0,\n\t\t\t\t\t    RTM_NEWROUTE,\n\t\t\t\t\t    NETLINK_CB(dump->cb->skb).portid,\n\t\t\t\t\t    dump->cb->nlh->nlmsg_seq, w->flags);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tw->count++;\n\t\t}\n\t\tbucket++;\n\t}\n\n\treturn 0;\n}\n\n/* Return -1 if done with node, number of handled routes on partial dump */\nint rt6_dump_route(struct fib6_info *rt, void *p_arg, unsigned int skip)\n{\n\tstruct rt6_rtnl_dump_arg *arg = (struct rt6_rtnl_dump_arg *) p_arg;\n\tstruct fib_dump_filter *filter = &arg->filter;\n\tunsigned int flags = NLM_F_MULTI;\n\tstruct net *net = arg->net;\n\tint count = 0;\n\n\tif (rt == net->ipv6.fib6_null_entry)\n\t\treturn -1;\n\n\tif ((filter->flags & RTM_F_PREFIX) &&\n\t    !(rt->fib6_flags & RTF_PREFIX_RT)) {\n\t\t/* success since this is not a prefix route */\n\t\treturn -1;\n\t}\n\tif (filter->filter_set &&\n\t    ((filter->rt_type  && rt->fib6_type != filter->rt_type) ||\n\t     (filter->dev      && !fib6_info_uses_dev(rt, filter->dev)) ||\n\t     (filter->protocol && rt->fib6_protocol != filter->protocol))) {\n\t\treturn -1;\n\t}\n\n\tif (filter->filter_set ||\n\t    !filter->dump_routes || !filter->dump_exceptions) {\n\t\tflags |= NLM_F_DUMP_FILTERED;\n\t}\n\n\tif (filter->dump_routes) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t} else {\n\t\t\tif (rt6_fill_node(net, arg->skb, rt, NULL, NULL, NULL,\n\t\t\t\t\t  0, RTM_NEWROUTE,\n\t\t\t\t\t  NETLINK_CB(arg->cb->skb).portid,\n\t\t\t\t\t  arg->cb->nlh->nlmsg_seq, flags)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (filter->dump_exceptions) {\n\t\tstruct fib6_nh_exception_dump_walker w = { .dump = arg,\n\t\t\t\t\t\t\t   .rt = rt,\n\t\t\t\t\t\t\t   .flags = flags,\n\t\t\t\t\t\t\t   .skip = skip,\n\t\t\t\t\t\t\t   .count = 0 };\n\t\tint err;\n\n\t\trcu_read_lock();\n\t\tif (rt->nh) {\n\t\t\terr = nexthop_for_each_fib6_nh(rt->nh,\n\t\t\t\t\t\t       rt6_nh_dump_exceptions,\n\t\t\t\t\t\t       &w);\n\t\t} else {\n\t\t\terr = rt6_nh_dump_exceptions(rt->fib6_nh, &w);\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (err)\n\t\t\treturn count += w.count;\n\t}\n\n\treturn -1;\n}\n\nstatic int inet6_rtm_valid_getroute_req(struct sk_buff *skb,\n\t\t\t\t\tconst struct nlmsghdr *nlh,\n\t\t\t\t\tstruct nlattr **tb,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct rtmsg *rtm;\n\tint i, err;\n\n\tif (nlh->nlmsg_len < nlmsg_msg_size(sizeof(*rtm))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!netlink_strict_get_check(skb))\n\t\treturn nlmsg_parse_deprecated(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t      rtm_ipv6_policy, extack);\n\n\trtm = nlmsg_data(nlh);\n\tif ((rtm->rtm_src_len && rtm->rtm_src_len != 128) ||\n\t    (rtm->rtm_dst_len && rtm->rtm_dst_len != 128) ||\n\t    rtm->rtm_table || rtm->rtm_protocol || rtm->rtm_scope ||\n\t    rtm->rtm_type) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid values in header for get route request\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtm->rtm_flags & ~RTM_F_FIB_MATCH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Invalid flags for get route request\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = nlmsg_parse_deprecated_strict(nlh, sizeof(*rtm), tb, RTA_MAX,\n\t\t\t\t\t    rtm_ipv6_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif ((tb[RTA_SRC] && !rtm->rtm_src_len) ||\n\t    (tb[RTA_DST] && !rtm->rtm_dst_len)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"rtm_src_len and rtm_dst_len must be 128 for IPv6\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i <= RTA_MAX; i++) {\n\t\tif (!tb[i])\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase RTA_SRC:\n\t\tcase RTA_DST:\n\t\tcase RTA_IIF:\n\t\tcase RTA_OIF:\n\t\tcase RTA_MARK:\n\t\tcase RTA_UID:\n\t\tcase RTA_SPORT:\n\t\tcase RTA_DPORT:\n\t\tcase RTA_IP_PROTO:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported attribute in get route request\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int inet6_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[RTA_MAX+1];\n\tint err, iif = 0, oif = 0;\n\tstruct fib6_info *from;\n\tstruct dst_entry *dst;\n\tstruct rt6_info *rt;\n\tstruct sk_buff *skb;\n\tstruct rtmsg *rtm;\n\tstruct flowi6 fl6 = {};\n\tbool fibmatch;\n\n\terr = inet6_rtm_valid_getroute_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -EINVAL;\n\trtm = nlmsg_data(nlh);\n\tfl6.flowlabel = ip6_make_flowinfo(rtm->rtm_tos, 0);\n\tfibmatch = !!(rtm->rtm_flags & RTM_F_FIB_MATCH);\n\n\tif (tb[RTA_SRC]) {\n\t\tif (nla_len(tb[RTA_SRC]) < sizeof(struct in6_addr))\n\t\t\tgoto errout;\n\n\t\tfl6.saddr = *(struct in6_addr *)nla_data(tb[RTA_SRC]);\n\t}\n\n\tif (tb[RTA_DST]) {\n\t\tif (nla_len(tb[RTA_DST]) < sizeof(struct in6_addr))\n\t\t\tgoto errout;\n\n\t\tfl6.daddr = *(struct in6_addr *)nla_data(tb[RTA_DST]);\n\t}\n\n\tif (tb[RTA_IIF])\n\t\tiif = nla_get_u32(tb[RTA_IIF]);\n\n\tif (tb[RTA_OIF])\n\t\toif = nla_get_u32(tb[RTA_OIF]);\n\n\tif (tb[RTA_MARK])\n\t\tfl6.flowi6_mark = nla_get_u32(tb[RTA_MARK]);\n\n\tif (tb[RTA_UID])\n\t\tfl6.flowi6_uid = make_kuid(current_user_ns(),\n\t\t\t\t\t   nla_get_u32(tb[RTA_UID]));\n\telse\n\t\tfl6.flowi6_uid = iif ? INVALID_UID : current_uid();\n\n\tif (tb[RTA_SPORT])\n\t\tfl6.fl6_sport = nla_get_be16(tb[RTA_SPORT]);\n\n\tif (tb[RTA_DPORT])\n\t\tfl6.fl6_dport = nla_get_be16(tb[RTA_DPORT]);\n\n\tif (tb[RTA_IP_PROTO]) {\n\t\terr = rtm_getroute_parse_ip_proto(tb[RTA_IP_PROTO],\n\t\t\t\t\t\t  &fl6.flowi6_proto, AF_INET6,\n\t\t\t\t\t\t  extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\n\tif (iif) {\n\t\tstruct net_device *dev;\n\t\tint flags = 0;\n\n\t\trcu_read_lock();\n\n\t\tdev = dev_get_by_index_rcu(net, iif);\n\t\tif (!dev) {\n\t\t\trcu_read_unlock();\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\tfl6.flowi6_iif = iif;\n\n\t\tif (!ipv6_addr_any(&fl6.saddr))\n\t\t\tflags |= RT6_LOOKUP_F_HAS_SADDR;\n\n\t\tdst = ip6_route_input_lookup(net, dev, &fl6, NULL, flags);\n\n\t\trcu_read_unlock();\n\t} else {\n\t\tfl6.flowi6_oif = oif;\n\n\t\tdst = ip6_route_output(net, NULL, &fl6);\n\t}\n\n\n\trt = container_of(dst, struct rt6_info, dst);\n\tif (rt->dst.error) {\n\t\terr = rt->dst.error;\n\t\tip6_rt_put(rt);\n\t\tgoto errout;\n\t}\n\n\tif (rt == net->ipv6.ip6_null_entry) {\n\t\terr = rt->dst.error;\n\t\tip6_rt_put(rt);\n\t\tgoto errout;\n\t}\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tip6_rt_put(rt);\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\n\trcu_read_lock();\n\tfrom = rcu_dereference(rt->from);\n\tif (from) {\n\t\tif (fibmatch)\n\t\t\terr = rt6_fill_node(net, skb, from, NULL, NULL, NULL,\n\t\t\t\t\t    iif, RTM_NEWROUTE,\n\t\t\t\t\t    NETLINK_CB(in_skb).portid,\n\t\t\t\t\t    nlh->nlmsg_seq, 0);\n\t\telse\n\t\t\terr = rt6_fill_node(net, skb, from, dst, &fl6.daddr,\n\t\t\t\t\t    &fl6.saddr, iif, RTM_NEWROUTE,\n\t\t\t\t\t    NETLINK_CB(in_skb).portid,\n\t\t\t\t\t    nlh->nlmsg_seq, 0);\n\t} else {\n\t\terr = -ENETUNREACH;\n\t}\n\trcu_read_unlock();\n\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n}\n\nvoid inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,\n\t\t     unsigned int nlm_flags)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = info->nl_net;\n\tu32 seq;\n\tint err;\n\n\terr = -ENOBUFS;\n\tseq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\n\tskb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = rt6_fill_node(net, skb, rt, NULL, NULL, NULL, 0,\n\t\t\t    event, info->portid, seq, nlm_flags);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in rt6_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,\n\t\t    info->nlh, gfp_any());\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);\n}\n\nvoid fib6_rt_update(struct net *net, struct fib6_info *rt,\n\t\t    struct nl_info *info)\n{\n\tu32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = rt6_fill_node(net, skb, rt, NULL, NULL, NULL, 0,\n\t\t\t    RTM_NEWROUTE, info->portid, seq, NLM_F_REPLACE);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in rt6_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,\n\t\t    info->nlh, gfp_any());\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);\n}\n\nvoid fib6_info_hw_flags_set(struct net *net, struct fib6_info *f6i,\n\t\t\t    bool offload, bool trap, bool offload_failed)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (f6i->offload == offload && f6i->trap == trap &&\n\t    f6i->offload_failed == offload_failed)\n\t\treturn;\n\n\tf6i->offload = offload;\n\tf6i->trap = trap;\n\n\t/* 2 means send notifications only if offload_failed was changed. */\n\tif (net->ipv6.sysctl.fib_notify_on_flag_change == 2 &&\n\t    f6i->offload_failed == offload_failed)\n\t\treturn;\n\n\tf6i->offload_failed = offload_failed;\n\n\tif (!rcu_access_pointer(f6i->fib6_node))\n\t\t/* The route was removed from the tree, do not send\n\t\t * notfication.\n\t\t */\n\t\treturn;\n\n\tif (!net->ipv6.sysctl.fib_notify_on_flag_change)\n\t\treturn;\n\n\tskb = nlmsg_new(rt6_nlmsg_size(f6i), GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout;\n\t}\n\n\terr = rt6_fill_node(net, skb, f6i, NULL, NULL, NULL, 0, RTM_NEWROUTE, 0,\n\t\t\t    0, 0);\n\tif (err < 0) {\n\t\t/* -EMSGSIZE implies BUG in rt6_nlmsg_size() */\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_ROUTE, NULL, GFP_KERNEL);\n\treturn;\n\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);\n}\nEXPORT_SYMBOL(fib6_info_hw_flags_set);\n\nstatic int ip6_route_dev_notify(struct notifier_block *this,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net *net = dev_net(dev);\n\n\tif (!(dev->flags & IFF_LOOPBACK))\n\t\treturn NOTIFY_OK;\n\n\tif (event == NETDEV_REGISTER) {\n\t\tnet->ipv6.fib6_null_entry->fib6_nh->fib_nh_dev = dev;\n\t\tnet->ipv6.ip6_null_entry->dst.dev = dev;\n\t\tnet->ipv6.ip6_null_entry->rt6i_idev = in6_dev_get(dev);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\t\tnet->ipv6.ip6_prohibit_entry->dst.dev = dev;\n\t\tnet->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);\n\t\tnet->ipv6.ip6_blk_hole_entry->dst.dev = dev;\n\t\tnet->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);\n#endif\n\t } else if (event == NETDEV_UNREGISTER &&\n\t\t    dev->reg_state != NETREG_UNREGISTERED) {\n\t\t/* NETDEV_UNREGISTER could be fired for multiple times by\n\t\t * netdev_wait_allrefs(). Make sure we only call this once.\n\t\t */\n\t\tin6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\t\tin6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);\n\t\tin6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);\n#endif\n\t}\n\n\treturn NOTIFY_OK;\n}\n\n/*\n *\t/proc\n */\n\n#ifdef CONFIG_PROC_FS\nstatic int rt6_stats_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net *net = (struct net *)seq->private;\n\tseq_printf(seq, \"%04x %04x %04x %04x %04x %04x %04x\\n\",\n\t\t   net->ipv6.rt6_stats->fib_nodes,\n\t\t   net->ipv6.rt6_stats->fib_route_nodes,\n\t\t   atomic_read(&net->ipv6.rt6_stats->fib_rt_alloc),\n\t\t   net->ipv6.rt6_stats->fib_rt_entries,\n\t\t   net->ipv6.rt6_stats->fib_rt_cache,\n\t\t   dst_entries_get_slow(&net->ipv6.ip6_dst_ops),\n\t\t   net->ipv6.rt6_stats->fib_discarded_routes);\n\n\treturn 0;\n}\n#endif\t/* CONFIG_PROC_FS */\n\n#ifdef CONFIG_SYSCTL\n\nstatic int ipv6_sysctl_rtcache_flush(struct ctl_table *ctl, int write,\n\t\t\t      void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct net *net;\n\tint delay;\n\tint ret;\n\tif (!write)\n\t\treturn -EINVAL;\n\n\tnet = (struct net *)ctl->extra1;\n\tdelay = net->ipv6.sysctl.flush_delay;\n\tret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tif (ret)\n\t\treturn ret;\n\n\tfib6_run_gc(delay <= 0 ? 0 : (unsigned long)delay, net, delay > 0);\n\treturn 0;\n}\n\nstatic struct ctl_table ipv6_route_table_template[] = {\n\t{\n\t\t.procname\t=\t\"flush\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.flush_delay,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0200,\n\t\t.proc_handler\t=\tipv6_sysctl_rtcache_flush\n\t},\n\t{\n\t\t.procname\t=\t\"gc_thresh\",\n\t\t.data\t\t=\t&ip6_dst_ops_template.gc_thresh,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"max_size\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_max_size,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_min_interval\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_min_interval,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_timeout\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_timeout,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_interval\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_interval,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_elasticity\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_elasticity,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"mtu_expires\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_mtu_expires,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"min_adv_mss\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_min_advmss,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec,\n\t},\n\t{\n\t\t.procname\t=\t\"gc_min_interval_ms\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.ip6_rt_gc_min_interval,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_ms_jiffies,\n\t},\n\t{\n\t\t.procname\t=\t\"skip_notify_on_dev_down\",\n\t\t.data\t\t=\t&init_net.ipv6.sysctl.skip_notify_on_dev_down,\n\t\t.maxlen\t\t=\tsizeof(int),\n\t\t.mode\t\t=\t0644,\n\t\t.proc_handler\t=\tproc_dointvec_minmax,\n\t\t.extra1\t\t=\tSYSCTL_ZERO,\n\t\t.extra2\t\t=\tSYSCTL_ONE,\n\t},\n\t{ }\n};\n\nstruct ctl_table * __net_init ipv6_route_sysctl_init(struct net *net)\n{\n\tstruct ctl_table *table;\n\n\ttable = kmemdup(ipv6_route_table_template,\n\t\t\tsizeof(ipv6_route_table_template),\n\t\t\tGFP_KERNEL);\n\n\tif (table) {\n\t\ttable[0].data = &net->ipv6.sysctl.flush_delay;\n\t\ttable[0].extra1 = net;\n\t\ttable[1].data = &net->ipv6.ip6_dst_ops.gc_thresh;\n\t\ttable[2].data = &net->ipv6.sysctl.ip6_rt_max_size;\n\t\ttable[3].data = &net->ipv6.sysctl.ip6_rt_gc_min_interval;\n\t\ttable[4].data = &net->ipv6.sysctl.ip6_rt_gc_timeout;\n\t\ttable[5].data = &net->ipv6.sysctl.ip6_rt_gc_interval;\n\t\ttable[6].data = &net->ipv6.sysctl.ip6_rt_gc_elasticity;\n\t\ttable[7].data = &net->ipv6.sysctl.ip6_rt_mtu_expires;\n\t\ttable[8].data = &net->ipv6.sysctl.ip6_rt_min_advmss;\n\t\ttable[9].data = &net->ipv6.sysctl.ip6_rt_gc_min_interval;\n\t\ttable[10].data = &net->ipv6.sysctl.skip_notify_on_dev_down;\n\n\t\t/* Don't export sysctls to unprivileged users */\n\t\tif (net->user_ns != &init_user_ns)\n\t\t\ttable[0].procname = NULL;\n\t}\n\n\treturn table;\n}\n#endif\n\nstatic int __net_init ip6_route_net_init(struct net *net)\n{\n\tint ret = -ENOMEM;\n\n\tmemcpy(&net->ipv6.ip6_dst_ops, &ip6_dst_ops_template,\n\t       sizeof(net->ipv6.ip6_dst_ops));\n\n\tif (dst_entries_init(&net->ipv6.ip6_dst_ops) < 0)\n\t\tgoto out_ip6_dst_ops;\n\n\tnet->ipv6.fib6_null_entry = fib6_info_alloc(GFP_KERNEL, true);\n\tif (!net->ipv6.fib6_null_entry)\n\t\tgoto out_ip6_dst_entries;\n\tmemcpy(net->ipv6.fib6_null_entry, &fib6_null_entry_template,\n\t       sizeof(*net->ipv6.fib6_null_entry));\n\n\tnet->ipv6.ip6_null_entry = kmemdup(&ip6_null_entry_template,\n\t\t\t\t\t   sizeof(*net->ipv6.ip6_null_entry),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!net->ipv6.ip6_null_entry)\n\t\tgoto out_fib6_null_entry;\n\tnet->ipv6.ip6_null_entry->dst.ops = &net->ipv6.ip6_dst_ops;\n\tdst_init_metrics(&net->ipv6.ip6_null_entry->dst,\n\t\t\t ip6_template_metrics, true);\n\tINIT_LIST_HEAD(&net->ipv6.ip6_null_entry->rt6i_uncached);\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tnet->ipv6.fib6_has_custom_rules = false;\n\tnet->ipv6.ip6_prohibit_entry = kmemdup(&ip6_prohibit_entry_template,\n\t\t\t\t\t       sizeof(*net->ipv6.ip6_prohibit_entry),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!net->ipv6.ip6_prohibit_entry)\n\t\tgoto out_ip6_null_entry;\n\tnet->ipv6.ip6_prohibit_entry->dst.ops = &net->ipv6.ip6_dst_ops;\n\tdst_init_metrics(&net->ipv6.ip6_prohibit_entry->dst,\n\t\t\t ip6_template_metrics, true);\n\tINIT_LIST_HEAD(&net->ipv6.ip6_prohibit_entry->rt6i_uncached);\n\n\tnet->ipv6.ip6_blk_hole_entry = kmemdup(&ip6_blk_hole_entry_template,\n\t\t\t\t\t       sizeof(*net->ipv6.ip6_blk_hole_entry),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!net->ipv6.ip6_blk_hole_entry)\n\t\tgoto out_ip6_prohibit_entry;\n\tnet->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;\n\tdst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,\n\t\t\t ip6_template_metrics, true);\n\tINIT_LIST_HEAD(&net->ipv6.ip6_blk_hole_entry->rt6i_uncached);\n#ifdef CONFIG_IPV6_SUBTREES\n\tnet->ipv6.fib6_routes_require_src = 0;\n#endif\n#endif\n\n\tnet->ipv6.sysctl.flush_delay = 0;\n\tnet->ipv6.sysctl.ip6_rt_max_size = 4096;\n\tnet->ipv6.sysctl.ip6_rt_gc_min_interval = HZ / 2;\n\tnet->ipv6.sysctl.ip6_rt_gc_timeout = 60*HZ;\n\tnet->ipv6.sysctl.ip6_rt_gc_interval = 30*HZ;\n\tnet->ipv6.sysctl.ip6_rt_gc_elasticity = 9;\n\tnet->ipv6.sysctl.ip6_rt_mtu_expires = 10*60*HZ;\n\tnet->ipv6.sysctl.ip6_rt_min_advmss = IPV6_MIN_MTU - 20 - 40;\n\tnet->ipv6.sysctl.skip_notify_on_dev_down = 0;\n\n\tnet->ipv6.ip6_rt_gc_expire = 30*HZ;\n\n\tret = 0;\nout:\n\treturn ret;\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nout_ip6_prohibit_entry:\n\tkfree(net->ipv6.ip6_prohibit_entry);\nout_ip6_null_entry:\n\tkfree(net->ipv6.ip6_null_entry);\n#endif\nout_fib6_null_entry:\n\tkfree(net->ipv6.fib6_null_entry);\nout_ip6_dst_entries:\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\nout_ip6_dst_ops:\n\tgoto out;\n}\n\nstatic void __net_exit ip6_route_net_exit(struct net *net)\n{\n\tkfree(net->ipv6.fib6_null_entry);\n\tkfree(net->ipv6.ip6_null_entry);\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tkfree(net->ipv6.ip6_prohibit_entry);\n\tkfree(net->ipv6.ip6_blk_hole_entry);\n#endif\n\tdst_entries_destroy(&net->ipv6.ip6_dst_ops);\n}\n\nstatic int __net_init ip6_route_net_init_late(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tproc_create_net(\"ipv6_route\", 0, net->proc_net, &ipv6_route_seq_ops,\n\t\t\tsizeof(struct ipv6_route_iter));\n\tproc_create_net_single(\"rt6_stats\", 0444, net->proc_net,\n\t\t\trt6_stats_seq_show, NULL);\n#endif\n\treturn 0;\n}\n\nstatic void __net_exit ip6_route_net_exit_late(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tremove_proc_entry(\"ipv6_route\", net->proc_net);\n\tremove_proc_entry(\"rt6_stats\", net->proc_net);\n#endif\n}\n\nstatic struct pernet_operations ip6_route_net_ops = {\n\t.init = ip6_route_net_init,\n\t.exit = ip6_route_net_exit,\n};\n\nstatic int __net_init ipv6_inetpeer_init(struct net *net)\n{\n\tstruct inet_peer_base *bp = kmalloc(sizeof(*bp), GFP_KERNEL);\n\n\tif (!bp)\n\t\treturn -ENOMEM;\n\tinet_peer_base_init(bp);\n\tnet->ipv6.peers = bp;\n\treturn 0;\n}\n\nstatic void __net_exit ipv6_inetpeer_exit(struct net *net)\n{\n\tstruct inet_peer_base *bp = net->ipv6.peers;\n\n\tnet->ipv6.peers = NULL;\n\tinetpeer_invalidate_tree(bp);\n\tkfree(bp);\n}\n\nstatic struct pernet_operations ipv6_inetpeer_ops = {\n\t.init\t=\tipv6_inetpeer_init,\n\t.exit\t=\tipv6_inetpeer_exit,\n};\n\nstatic struct pernet_operations ip6_route_net_late_ops = {\n\t.init = ip6_route_net_init_late,\n\t.exit = ip6_route_net_exit_late,\n};\n\nstatic struct notifier_block ip6_route_dev_notifier = {\n\t.notifier_call = ip6_route_dev_notify,\n\t.priority = ADDRCONF_NOTIFY_PRIORITY - 10,\n};\n\nvoid __init ip6_route_init_special_entries(void)\n{\n\t/* Registering of the loopback is done before this portion of code,\n\t * the loopback reference in rt6_info will not be taken, do it\n\t * manually for init_net */\n\tinit_net.ipv6.fib6_null_entry->fib6_nh->fib_nh_dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_null_entry->dst.dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_null_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);\n  #ifdef CONFIG_IPV6_MULTIPLE_TABLES\n\tinit_net.ipv6.ip6_prohibit_entry->dst.dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);\n\tinit_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;\n\tinit_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);\n  #endif\n}\n\n#if IS_BUILTIN(CONFIG_IPV6)\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)\nDEFINE_BPF_ITER_FUNC(ipv6_route, struct bpf_iter_meta *meta, struct fib6_info *rt)\n\nBTF_ID_LIST(btf_fib6_info_id)\nBTF_ID(struct, fib6_info)\n\nstatic const struct bpf_iter_seq_info ipv6_route_seq_info = {\n\t.seq_ops\t\t= &ipv6_route_seq_ops,\n\t.init_seq_private\t= bpf_iter_init_seq_net,\n\t.fini_seq_private\t= bpf_iter_fini_seq_net,\n\t.seq_priv_size\t\t= sizeof(struct ipv6_route_iter),\n};\n\nstatic struct bpf_iter_reg ipv6_route_reg_info = {\n\t.target\t\t\t= \"ipv6_route\",\n\t.ctx_arg_info_size\t= 1,\n\t.ctx_arg_info\t\t= {\n\t\t{ offsetof(struct bpf_iter__ipv6_route, rt),\n\t\t  PTR_TO_BTF_ID_OR_NULL },\n\t},\n\t.seq_info\t\t= &ipv6_route_seq_info,\n};\n\nstatic int __init bpf_iter_register(void)\n{\n\tipv6_route_reg_info.ctx_arg_info[0].btf_id = *btf_fib6_info_id;\n\treturn bpf_iter_reg_target(&ipv6_route_reg_info);\n}\n\nstatic void bpf_iter_unregister(void)\n{\n\tbpf_iter_unreg_target(&ipv6_route_reg_info);\n}\n#endif\n#endif\n\nint __init ip6_route_init(void)\n{\n\tint ret;\n\tint cpu;\n\n\tret = -ENOMEM;\n\tip6_dst_ops_template.kmem_cachep =\n\t\tkmem_cache_create(\"ip6_dst_cache\", sizeof(struct rt6_info), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN, NULL);\n\tif (!ip6_dst_ops_template.kmem_cachep)\n\t\tgoto out;\n\n\tret = dst_entries_init(&ip6_dst_blackhole_ops);\n\tif (ret)\n\t\tgoto out_kmem_cache;\n\n\tret = register_pernet_subsys(&ipv6_inetpeer_ops);\n\tif (ret)\n\t\tgoto out_dst_entries;\n\n\tret = register_pernet_subsys(&ip6_route_net_ops);\n\tif (ret)\n\t\tgoto out_register_inetpeer;\n\n\tip6_dst_blackhole_ops.kmem_cachep = ip6_dst_ops_template.kmem_cachep;\n\n\tret = fib6_init();\n\tif (ret)\n\t\tgoto out_register_subsys;\n\n\tret = xfrm6_init();\n\tif (ret)\n\t\tgoto out_fib6_init;\n\n\tret = fib6_rules_init();\n\tif (ret)\n\t\tgoto xfrm6_init;\n\n\tret = register_pernet_subsys(&ip6_route_net_late_ops);\n\tif (ret)\n\t\tgoto fib6_rules_init;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_NEWROUTE,\n\t\t\t\t   inet6_rtm_newroute, NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_register_late_subsys;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_DELROUTE,\n\t\t\t\t   inet6_rtm_delroute, NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_register_late_subsys;\n\n\tret = rtnl_register_module(THIS_MODULE, PF_INET6, RTM_GETROUTE,\n\t\t\t\t   inet6_rtm_getroute, NULL,\n\t\t\t\t   RTNL_FLAG_DOIT_UNLOCKED);\n\tif (ret < 0)\n\t\tgoto out_register_late_subsys;\n\n\tret = register_netdevice_notifier(&ip6_route_dev_notifier);\n\tif (ret)\n\t\tgoto out_register_late_subsys;\n\n#if IS_BUILTIN(CONFIG_IPV6)\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)\n\tret = bpf_iter_register();\n\tif (ret)\n\t\tgoto out_register_late_subsys;\n#endif\n#endif\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = per_cpu_ptr(&rt6_uncached_list, cpu);\n\n\t\tINIT_LIST_HEAD(&ul->head);\n\t\tspin_lock_init(&ul->lock);\n\t}\n\nout:\n\treturn ret;\n\nout_register_late_subsys:\n\trtnl_unregister_all(PF_INET6);\n\tunregister_pernet_subsys(&ip6_route_net_late_ops);\nfib6_rules_init:\n\tfib6_rules_cleanup();\nxfrm6_init:\n\txfrm6_fini();\nout_fib6_init:\n\tfib6_gc_cleanup();\nout_register_subsys:\n\tunregister_pernet_subsys(&ip6_route_net_ops);\nout_register_inetpeer:\n\tunregister_pernet_subsys(&ipv6_inetpeer_ops);\nout_dst_entries:\n\tdst_entries_destroy(&ip6_dst_blackhole_ops);\nout_kmem_cache:\n\tkmem_cache_destroy(ip6_dst_ops_template.kmem_cachep);\n\tgoto out;\n}\n\nvoid ip6_route_cleanup(void)\n{\n#if IS_BUILTIN(CONFIG_IPV6)\n#if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_PROC_FS)\n\tbpf_iter_unregister();\n#endif\n#endif\n\tunregister_netdevice_notifier(&ip6_route_dev_notifier);\n\tunregister_pernet_subsys(&ip6_route_net_late_ops);\n\tfib6_rules_cleanup();\n\txfrm6_fini();\n\tfib6_gc_cleanup();\n\tunregister_pernet_subsys(&ipv6_inetpeer_ops);\n\tunregister_pernet_subsys(&ip6_route_net_ops);\n\tdst_entries_destroy(&ip6_dst_blackhole_ops);\n\tkmem_cache_destroy(ip6_dst_ops_template.kmem_cachep);\n}\n"}, "1": {"id": 1, "path": "/src/include/net/ip6_fib.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n *\tLinux INET6 implementation \n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\t\n */\n\n#ifndef _IP6_FIB_H\n#define _IP6_FIB_H\n\n#include <linux/ipv6_route.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/notifier.h>\n#include <net/dst.h>\n#include <net/flow.h>\n#include <net/ip_fib.h>\n#include <net/netlink.h>\n#include <net/inetpeer.h>\n#include <net/fib_notifier.h>\n#include <linux/indirect_call_wrapper.h>\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n#define FIB6_TABLE_HASHSZ 256\n#else\n#define FIB6_TABLE_HASHSZ 1\n#endif\n\n#define RT6_DEBUG 2\n\n#if RT6_DEBUG >= 3\n#define RT6_TRACE(x...) pr_debug(x)\n#else\n#define RT6_TRACE(x...) do { ; } while (0)\n#endif\n\nstruct rt6_info;\nstruct fib6_info;\n\nstruct fib6_config {\n\tu32\t\tfc_table;\n\tu32\t\tfc_metric;\n\tint\t\tfc_dst_len;\n\tint\t\tfc_src_len;\n\tint\t\tfc_ifindex;\n\tu32\t\tfc_flags;\n\tu32\t\tfc_protocol;\n\tu16\t\tfc_type;        /* only 8 bits are used */\n\tu16\t\tfc_delete_all_nh : 1,\n\t\t\tfc_ignore_dev_down:1,\n\t\t\t__unused : 14;\n\tu32\t\tfc_nh_id;\n\n\tstruct in6_addr\tfc_dst;\n\tstruct in6_addr\tfc_src;\n\tstruct in6_addr\tfc_prefsrc;\n\tstruct in6_addr\tfc_gateway;\n\n\tunsigned long\tfc_expires;\n\tstruct nlattr\t*fc_mx;\n\tint\t\tfc_mx_len;\n\tint\t\tfc_mp_len;\n\tstruct nlattr\t*fc_mp;\n\n\tstruct nl_info\tfc_nlinfo;\n\tstruct nlattr\t*fc_encap;\n\tu16\t\tfc_encap_type;\n\tbool\t\tfc_is_fdb;\n};\n\nstruct fib6_node {\n\tstruct fib6_node __rcu\t*parent;\n\tstruct fib6_node __rcu\t*left;\n\tstruct fib6_node __rcu\t*right;\n#ifdef CONFIG_IPV6_SUBTREES\n\tstruct fib6_node __rcu\t*subtree;\n#endif\n\tstruct fib6_info __rcu\t*leaf;\n\n\t__u16\t\t\tfn_bit;\t\t/* bit key */\n\t__u16\t\t\tfn_flags;\n\tint\t\t\tfn_sernum;\n\tstruct fib6_info __rcu\t*rr_ptr;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct fib6_gc_args {\n\tint\t\t\ttimeout;\n\tint\t\t\tmore;\n};\n\n#ifndef CONFIG_IPV6_SUBTREES\n#define FIB6_SUBTREE(fn)\tNULL\n\nstatic inline bool fib6_routes_require_src(const struct net *net)\n{\n\treturn false;\n}\n\nstatic inline void fib6_routes_require_src_inc(struct net *net) {}\nstatic inline void fib6_routes_require_src_dec(struct net *net) {}\n\n#else\n\nstatic inline bool fib6_routes_require_src(const struct net *net)\n{\n\treturn net->ipv6.fib6_routes_require_src > 0;\n}\n\nstatic inline void fib6_routes_require_src_inc(struct net *net)\n{\n\tnet->ipv6.fib6_routes_require_src++;\n}\n\nstatic inline void fib6_routes_require_src_dec(struct net *net)\n{\n\tnet->ipv6.fib6_routes_require_src--;\n}\n\n#define FIB6_SUBTREE(fn)\t(rcu_dereference_protected((fn)->subtree, 1))\n#endif\n\n/*\n *\trouting information\n *\n */\n\nstruct rt6key {\n\tstruct in6_addr\taddr;\n\tint\t\tplen;\n};\n\nstruct fib6_table;\n\nstruct rt6_exception_bucket {\n\tstruct hlist_head\tchain;\n\tint\t\t\tdepth;\n};\n\nstruct rt6_exception {\n\tstruct hlist_node\thlist;\n\tstruct rt6_info\t\t*rt6i;\n\tunsigned long\t\tstamp;\n\tstruct rcu_head\t\trcu;\n};\n\n#define FIB6_EXCEPTION_BUCKET_SIZE_SHIFT 10\n#define FIB6_EXCEPTION_BUCKET_SIZE (1 << FIB6_EXCEPTION_BUCKET_SIZE_SHIFT)\n#define FIB6_MAX_DEPTH 5\n\nstruct fib6_nh {\n\tstruct fib_nh_common\tnh_common;\n\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tunsigned long\t\tlast_probe;\n#endif\n\n\tstruct rt6_info * __percpu *rt6i_pcpu;\n\tstruct rt6_exception_bucket __rcu *rt6i_exception_bucket;\n};\n\nstruct fib6_info {\n\tstruct fib6_table\t\t*fib6_table;\n\tstruct fib6_info __rcu\t\t*fib6_next;\n\tstruct fib6_node __rcu\t\t*fib6_node;\n\n\t/* Multipath routes:\n\t * siblings is a list of fib6_info that have the same metric/weight,\n\t * destination, but not the same gateway. nsiblings is just a cache\n\t * to speed up lookup.\n\t */\n\tunion {\n\t\tstruct list_head\tfib6_siblings;\n\t\tstruct list_head\tnh_list;\n\t};\n\tunsigned int\t\t\tfib6_nsiblings;\n\n\trefcount_t\t\t\tfib6_ref;\n\tunsigned long\t\t\texpires;\n\tstruct dst_metrics\t\t*fib6_metrics;\n#define fib6_pmtu\t\tfib6_metrics->metrics[RTAX_MTU-1]\n\n\tstruct rt6key\t\t\tfib6_dst;\n\tu32\t\t\t\tfib6_flags;\n\tstruct rt6key\t\t\tfib6_src;\n\tstruct rt6key\t\t\tfib6_prefsrc;\n\n\tu32\t\t\t\tfib6_metric;\n\tu8\t\t\t\tfib6_protocol;\n\tu8\t\t\t\tfib6_type;\n\tu8\t\t\t\tshould_flush:1,\n\t\t\t\t\tdst_nocount:1,\n\t\t\t\t\tdst_nopolicy:1,\n\t\t\t\t\tfib6_destroying:1,\n\t\t\t\t\toffload:1,\n\t\t\t\t\ttrap:1,\n\t\t\t\t\toffload_failed:1,\n\t\t\t\t\tunused:1;\n\n\tstruct rcu_head\t\t\trcu;\n\tstruct nexthop\t\t\t*nh;\n\tstruct fib6_nh\t\t\tfib6_nh[];\n};\n\nstruct rt6_info {\n\tstruct dst_entry\t\tdst;\n\tstruct fib6_info __rcu\t\t*from;\n\tint\t\t\t\tsernum;\n\n\tstruct rt6key\t\t\trt6i_dst;\n\tstruct rt6key\t\t\trt6i_src;\n\tstruct in6_addr\t\t\trt6i_gateway;\n\tstruct inet6_dev\t\t*rt6i_idev;\n\tu32\t\t\t\trt6i_flags;\n\n\tstruct list_head\t\trt6i_uncached;\n\tstruct uncached_list\t\t*rt6i_uncached_list;\n\n\t/* more non-fragment space at head required */\n\tunsigned short\t\t\trt6i_nfheader_len;\n};\n\nstruct fib6_result {\n\tstruct fib6_nh\t\t*nh;\n\tstruct fib6_info\t*f6i;\n\tu32\t\t\tfib6_flags;\n\tu8\t\t\tfib6_type;\n\tstruct rt6_info\t\t*rt6;\n};\n\n#define for_each_fib6_node_rt_rcu(fn)\t\t\t\t\t\\\n\tfor (rt = rcu_dereference((fn)->leaf); rt;\t\t\t\\\n\t     rt = rcu_dereference(rt->fib6_next))\n\n#define for_each_fib6_walker_rt(w)\t\t\t\t\t\\\n\tfor (rt = (w)->leaf; rt;\t\t\t\t\t\\\n\t     rt = rcu_dereference_protected(rt->fib6_next, 1))\n\nstatic inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)\n{\n\treturn ((struct rt6_info *)dst)->rt6i_idev;\n}\n\nstatic inline bool fib6_requires_src(const struct fib6_info *rt)\n{\n\treturn rt->fib6_src.plen > 0;\n}\n\nstatic inline void fib6_clean_expires(struct fib6_info *f6i)\n{\n\tf6i->fib6_flags &= ~RTF_EXPIRES;\n\tf6i->expires = 0;\n}\n\nstatic inline void fib6_set_expires(struct fib6_info *f6i,\n\t\t\t\t    unsigned long expires)\n{\n\tf6i->expires = expires;\n\tf6i->fib6_flags |= RTF_EXPIRES;\n}\n\nstatic inline bool fib6_check_expired(const struct fib6_info *f6i)\n{\n\tif (f6i->fib6_flags & RTF_EXPIRES)\n\t\treturn time_after(jiffies, f6i->expires);\n\treturn false;\n}\n\n/* Function to safely get fn->sernum for passed in rt\n * and store result in passed in cookie.\n * Return true if we can get cookie safely\n * Return false if not\n */\nstatic inline bool fib6_get_cookie_safe(const struct fib6_info *f6i,\n\t\t\t\t\tu32 *cookie)\n{\n\tstruct fib6_node *fn;\n\tbool status = false;\n\n\tfn = rcu_dereference(f6i->fib6_node);\n\n\tif (fn) {\n\t\t*cookie = fn->fn_sernum;\n\t\t/* pairs with smp_wmb() in fib6_update_sernum_upto_root() */\n\t\tsmp_rmb();\n\t\tstatus = true;\n\t}\n\n\treturn status;\n}\n\nstatic inline u32 rt6_get_cookie(const struct rt6_info *rt)\n{\n\tstruct fib6_info *from;\n\tu32 cookie = 0;\n\n\tif (rt->sernum)\n\t\treturn rt->sernum;\n\n\trcu_read_lock();\n\n\tfrom = rcu_dereference(rt->from);\n\tif (from)\n\t\tfib6_get_cookie_safe(from, &cookie);\n\n\trcu_read_unlock();\n\n\treturn cookie;\n}\n\nstatic inline void ip6_rt_put(struct rt6_info *rt)\n{\n\t/* dst_release() accepts a NULL parameter.\n\t * We rely on dst being first structure in struct rt6_info\n\t */\n\tBUILD_BUG_ON(offsetof(struct rt6_info, dst) != 0);\n\tdst_release(&rt->dst);\n}\n\nstruct fib6_info *fib6_info_alloc(gfp_t gfp_flags, bool with_fib6_nh);\nvoid fib6_info_destroy_rcu(struct rcu_head *head);\n\nstatic inline void fib6_info_hold(struct fib6_info *f6i)\n{\n\trefcount_inc(&f6i->fib6_ref);\n}\n\nstatic inline bool fib6_info_hold_safe(struct fib6_info *f6i)\n{\n\treturn refcount_inc_not_zero(&f6i->fib6_ref);\n}\n\nstatic inline void fib6_info_release(struct fib6_info *f6i)\n{\n\tif (f6i && refcount_dec_and_test(&f6i->fib6_ref))\n\t\tcall_rcu(&f6i->rcu, fib6_info_destroy_rcu);\n}\n\nenum fib6_walk_state {\n#ifdef CONFIG_IPV6_SUBTREES\n\tFWS_S,\n#endif\n\tFWS_L,\n\tFWS_R,\n\tFWS_C,\n\tFWS_U\n};\n\nstruct fib6_walker {\n\tstruct list_head lh;\n\tstruct fib6_node *root, *node;\n\tstruct fib6_info *leaf;\n\tenum fib6_walk_state state;\n\tunsigned int skip;\n\tunsigned int count;\n\tunsigned int skip_in_node;\n\tint (*func)(struct fib6_walker *);\n\tvoid *args;\n};\n\nstruct rt6_statistics {\n\t__u32\t\tfib_nodes;\t\t/* all fib6 nodes */\n\t__u32\t\tfib_route_nodes;\t/* intermediate nodes */\n\t__u32\t\tfib_rt_entries;\t\t/* rt entries in fib table */\n\t__u32\t\tfib_rt_cache;\t\t/* cached rt entries in exception table */\n\t__u32\t\tfib_discarded_routes;\t/* total number of routes delete */\n\n\t/* The following stats are not protected by any lock */\n\tatomic_t\tfib_rt_alloc;\t\t/* total number of routes alloced */\n\tatomic_t\tfib_rt_uncache;\t\t/* rt entries in uncached list */\n};\n\n#define RTN_TL_ROOT\t0x0001\n#define RTN_ROOT\t0x0002\t\t/* tree root node\t\t*/\n#define RTN_RTINFO\t0x0004\t\t/* node with valid routing info\t*/\n\n/*\n *\tpriority levels (or metrics)\n *\n */\n\n\nstruct fib6_table {\n\tstruct hlist_node\ttb6_hlist;\n\tu32\t\t\ttb6_id;\n\tspinlock_t\t\ttb6_lock;\n\tstruct fib6_node\ttb6_root;\n\tstruct inet_peer_base\ttb6_peers;\n\tunsigned int\t\tflags;\n\tunsigned int\t\tfib_seq;\n#define RT6_TABLE_HAS_DFLT_ROUTER\tBIT(0)\n};\n\n#define RT6_TABLE_UNSPEC\tRT_TABLE_UNSPEC\n#define RT6_TABLE_MAIN\t\tRT_TABLE_MAIN\n#define RT6_TABLE_DFLT\t\tRT6_TABLE_MAIN\n#define RT6_TABLE_INFO\t\tRT6_TABLE_MAIN\n#define RT6_TABLE_PREFIX\tRT6_TABLE_MAIN\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\n#define FIB6_TABLE_MIN\t\t1\n#define FIB6_TABLE_MAX\t\tRT_TABLE_MAX\n#define RT6_TABLE_LOCAL\t\tRT_TABLE_LOCAL\n#else\n#define FIB6_TABLE_MIN\t\tRT_TABLE_MAIN\n#define FIB6_TABLE_MAX\t\tFIB6_TABLE_MIN\n#define RT6_TABLE_LOCAL\t\tRT6_TABLE_MAIN\n#endif\n\ntypedef struct rt6_info *(*pol_lookup_t)(struct net *,\n\t\t\t\t\t struct fib6_table *,\n\t\t\t\t\t struct flowi6 *,\n\t\t\t\t\t const struct sk_buff *, int);\n\nstruct fib6_entry_notifier_info {\n\tstruct fib_notifier_info info; /* must be first */\n\tstruct fib6_info *rt;\n\tunsigned int nsiblings;\n};\n\n/*\n *\texported functions\n */\n\nstruct fib6_table *fib6_get_table(struct net *net, u32 id);\nstruct fib6_table *fib6_new_table(struct net *net, u32 id);\nstruct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup);\n\n/* called with rcu lock held; can return error pointer\n * caller needs to select path\n */\nint fib6_lookup(struct net *net, int oif, struct flowi6 *fl6,\n\t\tstruct fib6_result *res, int flags);\n\n/* called with rcu lock held; caller needs to select path */\nint fib6_table_lookup(struct net *net, struct fib6_table *table,\n\t\t      int oif, struct flowi6 *fl6, struct fib6_result *res,\n\t\t      int strict);\n\nvoid fib6_select_path(const struct net *net, struct fib6_result *res,\n\t\t      struct flowi6 *fl6, int oif, bool have_oif_match,\n\t\t      const struct sk_buff *skb, int strict);\nstruct fib6_node *fib6_node_lookup(struct fib6_node *root,\n\t\t\t\t   const struct in6_addr *daddr,\n\t\t\t\t   const struct in6_addr *saddr);\n\nstruct fib6_node *fib6_locate(struct fib6_node *root,\n\t\t\t      const struct in6_addr *daddr, int dst_len,\n\t\t\t      const struct in6_addr *saddr, int src_len,\n\t\t\t      bool exact_match);\n\nvoid fib6_clean_all(struct net *net, int (*func)(struct fib6_info *, void *arg),\n\t\t    void *arg);\nvoid fib6_clean_all_skip_notify(struct net *net,\n\t\t\t\tint (*func)(struct fib6_info *, void *arg),\n\t\t\t\tvoid *arg);\n\nint fib6_add(struct fib6_node *root, struct fib6_info *rt,\n\t     struct nl_info *info, struct netlink_ext_ack *extack);\nint fib6_del(struct fib6_info *rt, struct nl_info *info);\n\nstatic inline\nvoid rt6_get_prefsrc(const struct rt6_info *rt, struct in6_addr *addr)\n{\n\tconst struct fib6_info *from;\n\n\trcu_read_lock();\n\n\tfrom = rcu_dereference(rt->from);\n\tif (from) {\n\t\t*addr = from->fib6_prefsrc.addr;\n\t} else {\n\t\tstruct in6_addr in6_zero = {};\n\n\t\t*addr = in6_zero;\n\t}\n\n\trcu_read_unlock();\n}\n\nint fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack);\nvoid fib6_nh_release(struct fib6_nh *fib6_nh);\n\nint call_fib6_entry_notifiers(struct net *net,\n\t\t\t      enum fib_event_type event_type,\n\t\t\t      struct fib6_info *rt,\n\t\t\t      struct netlink_ext_ack *extack);\nint call_fib6_multipath_entry_notifiers(struct net *net,\n\t\t\t\t\tenum fib_event_type event_type,\n\t\t\t\t\tstruct fib6_info *rt,\n\t\t\t\t\tunsigned int nsiblings,\n\t\t\t\t\tstruct netlink_ext_ack *extack);\nint call_fib6_entry_notifiers_replace(struct net *net, struct fib6_info *rt);\nvoid fib6_rt_update(struct net *net, struct fib6_info *rt,\n\t\t    struct nl_info *info);\nvoid inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,\n\t\t     unsigned int flags);\n\nvoid fib6_run_gc(unsigned long expires, struct net *net, bool force);\n\nvoid fib6_gc_cleanup(void);\n\nint fib6_init(void);\n\nstruct ipv6_route_iter {\n\tstruct seq_net_private p;\n\tstruct fib6_walker w;\n\tloff_t skip;\n\tstruct fib6_table *tbl;\n\tint sernum;\n};\n\nextern const struct seq_operations ipv6_route_seq_ops;\n\nint call_fib6_notifier(struct notifier_block *nb,\n\t\t       enum fib_event_type event_type,\n\t\t       struct fib_notifier_info *info);\nint call_fib6_notifiers(struct net *net, enum fib_event_type event_type,\n\t\t\tstruct fib_notifier_info *info);\n\nint __net_init fib6_notifier_init(struct net *net);\nvoid __net_exit fib6_notifier_exit(struct net *net);\n\nunsigned int fib6_tables_seq_read(struct net *net);\nint fib6_tables_dump(struct net *net, struct notifier_block *nb,\n\t\t     struct netlink_ext_ack *extack);\n\nvoid fib6_update_sernum(struct net *net, struct fib6_info *rt);\nvoid fib6_update_sernum_upto_root(struct net *net, struct fib6_info *rt);\nvoid fib6_update_sernum_stub(struct net *net, struct fib6_info *f6i);\n\nvoid fib6_metric_set(struct fib6_info *f6i, int metric, u32 val);\nstatic inline bool fib6_metric_locked(struct fib6_info *f6i, int metric)\n{\n\treturn !!(f6i->fib6_metrics->metrics[RTAX_LOCK - 1] & (1 << metric));\n}\nvoid fib6_info_hw_flags_set(struct net *net, struct fib6_info *f6i,\n\t\t\t    bool offload, bool trap, bool offload_failed);\n\n#if IS_BUILTIN(CONFIG_IPV6) && defined(CONFIG_BPF_SYSCALL)\nstruct bpf_iter__ipv6_route {\n\t__bpf_md_ptr(struct bpf_iter_meta *, meta);\n\t__bpf_md_ptr(struct fib6_info *, rt);\n};\n#endif\n\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *ip6_pol_route_output(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *ip6_pol_route_input(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *__ip6_route_redirect(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nINDIRECT_CALLABLE_DECLARE(struct rt6_info *ip6_pol_route_lookup(struct net *net,\n\t\t\t\t\t     struct fib6_table *table,\n\t\t\t\t\t     struct flowi6 *fl6,\n\t\t\t\t\t     const struct sk_buff *skb,\n\t\t\t\t\t     int flags));\nstatic inline struct rt6_info *pol_lookup_func(pol_lookup_t lookup,\n\t\t\t\t\t\tstruct net *net,\n\t\t\t\t\t\tstruct fib6_table *table,\n\t\t\t\t\t\tstruct flowi6 *fl6,\n\t\t\t\t\t\tconst struct sk_buff *skb,\n\t\t\t\t\t\tint flags)\n{\n\treturn INDIRECT_CALL_4(lookup,\n\t\t\t       ip6_pol_route_output,\n\t\t\t       ip6_pol_route_input,\n\t\t\t       ip6_pol_route_lookup,\n\t\t\t       __ip6_route_redirect,\n\t\t\t       net, table, fl6, skb, flags);\n}\n\n#ifdef CONFIG_IPV6_MULTIPLE_TABLES\nstatic inline bool fib6_has_custom_rules(const struct net *net)\n{\n\treturn net->ipv6.fib6_has_custom_rules;\n}\n\nint fib6_rules_init(void);\nvoid fib6_rules_cleanup(void);\nbool fib6_rule_default(const struct fib_rule *rule);\nint fib6_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t    struct netlink_ext_ack *extack);\nunsigned int fib6_rules_seq_read(struct net *net);\n\nstatic inline bool fib6_rules_early_flow_dissect(struct net *net,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t\t struct flow_keys *flkeys)\n{\n\tunsigned int flag = FLOW_DISSECTOR_F_STOP_AT_ENCAP;\n\n\tif (!net->ipv6.fib6_rules_require_fldissect)\n\t\treturn false;\n\n\tskb_flow_dissect_flow_keys(skb, flkeys, flag);\n\tfl6->fl6_sport = flkeys->ports.src;\n\tfl6->fl6_dport = flkeys->ports.dst;\n\tfl6->flowi6_proto = flkeys->basic.ip_proto;\n\n\treturn true;\n}\n#else\nstatic inline bool fib6_has_custom_rules(const struct net *net)\n{\n\treturn false;\n}\nstatic inline int               fib6_rules_init(void)\n{\n\treturn 0;\n}\nstatic inline void              fib6_rules_cleanup(void)\n{\n\treturn ;\n}\nstatic inline bool fib6_rule_default(const struct fib_rule *rule)\n{\n\treturn true;\n}\nstatic inline int fib6_rules_dump(struct net *net, struct notifier_block *nb,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn 0;\n}\nstatic inline unsigned int fib6_rules_seq_read(struct net *net)\n{\n\treturn 0;\n}\nstatic inline bool fib6_rules_early_flow_dissect(struct net *net,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct flowi6 *fl6,\n\t\t\t\t\t\t struct flow_keys *flkeys)\n{\n\treturn false;\n}\n#endif\n#endif\n"}, "2": {"id": 2, "path": "/src/include/linux/rcupdate.h", "content": "/* SPDX-License-Identifier: GPL-2.0+ */\n/*\n * Read-Copy Update mechanism for mutual exclusion\n *\n * Copyright IBM Corporation, 2001\n *\n * Author: Dipankar Sarma <dipankar@in.ibm.com>\n *\n * Based on the original work by Paul McKenney <paulmck@vnet.ibm.com>\n * and inputs from Rusty Russell, Andrea Arcangeli and Andi Kleen.\n * Papers:\n * http://www.rdrop.com/users/paulmck/paper/rclockpdcsproof.pdf\n * http://lse.sourceforge.net/locking/rclock_OLS.2001.05.01c.sc.pdf (OLS2001)\n *\n * For detailed explanation of Read-Copy Update mechanism see -\n *\t\thttp://lse.sourceforge.net/locking/rcupdate.html\n *\n */\n\n#ifndef __LINUX_RCUPDATE_H\n#define __LINUX_RCUPDATE_H\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/atomic.h>\n#include <linux/irqflags.h>\n#include <linux/preempt.h>\n#include <linux/bottom_half.h>\n#include <linux/lockdep.h>\n#include <asm/processor.h>\n#include <linux/cpumask.h>\n\n#define ULONG_CMP_GE(a, b)\t(ULONG_MAX / 2 >= (a) - (b))\n#define ULONG_CMP_LT(a, b)\t(ULONG_MAX / 2 < (a) - (b))\n#define ulong2long(a)\t\t(*(long *)(&(a)))\n#define USHORT_CMP_GE(a, b)\t(USHRT_MAX / 2 >= (unsigned short)((a) - (b)))\n#define USHORT_CMP_LT(a, b)\t(USHRT_MAX / 2 < (unsigned short)((a) - (b)))\n\n/* Exported common interfaces */\nvoid call_rcu(struct rcu_head *head, rcu_callback_t func);\nvoid rcu_barrier_tasks(void);\nvoid rcu_barrier_tasks_rude(void);\nvoid synchronize_rcu(void);\n\n#ifdef CONFIG_PREEMPT_RCU\n\nvoid __rcu_read_lock(void);\nvoid __rcu_read_unlock(void);\n\n/*\n * Defined as a macro as it is a very low level header included from\n * areas that don't even know about current.  This gives the rcu_read_lock()\n * nesting depth, but makes sense only if CONFIG_PREEMPT_RCU -- in other\n * types of kernel builds, the rcu_read_lock() nesting depth is unknowable.\n */\n#define rcu_preempt_depth() (current->rcu_read_lock_nesting)\n\n#else /* #ifdef CONFIG_PREEMPT_RCU */\n\n#ifdef CONFIG_TINY_RCU\n#define rcu_read_unlock_strict() do { } while (0)\n#else\nvoid rcu_read_unlock_strict(void);\n#endif\n\nstatic inline void __rcu_read_lock(void)\n{\n\tpreempt_disable();\n}\n\nstatic inline void __rcu_read_unlock(void)\n{\n\tpreempt_enable();\n\trcu_read_unlock_strict();\n}\n\nstatic inline int rcu_preempt_depth(void)\n{\n\treturn 0;\n}\n\n#endif /* #else #ifdef CONFIG_PREEMPT_RCU */\n\n/* Internal to kernel */\nvoid rcu_init(void);\nextern int rcu_scheduler_active __read_mostly;\nvoid rcu_sched_clock_irq(int user);\nvoid rcu_report_dead(unsigned int cpu);\nvoid rcutree_migrate_callbacks(int cpu);\n\n#ifdef CONFIG_TASKS_RCU_GENERIC\nvoid rcu_init_tasks_generic(void);\n#else\nstatic inline void rcu_init_tasks_generic(void) { }\n#endif\n\n#ifdef CONFIG_RCU_STALL_COMMON\nvoid rcu_sysrq_start(void);\nvoid rcu_sysrq_end(void);\n#else /* #ifdef CONFIG_RCU_STALL_COMMON */\nstatic inline void rcu_sysrq_start(void) { }\nstatic inline void rcu_sysrq_end(void) { }\n#endif /* #else #ifdef CONFIG_RCU_STALL_COMMON */\n\n#ifdef CONFIG_NO_HZ_FULL\nvoid rcu_user_enter(void);\nvoid rcu_user_exit(void);\n#else\nstatic inline void rcu_user_enter(void) { }\nstatic inline void rcu_user_exit(void) { }\n#endif /* CONFIG_NO_HZ_FULL */\n\n#ifdef CONFIG_RCU_NOCB_CPU\nvoid rcu_init_nohz(void);\nint rcu_nocb_cpu_offload(int cpu);\nint rcu_nocb_cpu_deoffload(int cpu);\nvoid rcu_nocb_flush_deferred_wakeup(void);\n#else /* #ifdef CONFIG_RCU_NOCB_CPU */\nstatic inline void rcu_init_nohz(void) { }\nstatic inline int rcu_nocb_cpu_offload(int cpu) { return -EINVAL; }\nstatic inline int rcu_nocb_cpu_deoffload(int cpu) { return 0; }\nstatic inline void rcu_nocb_flush_deferred_wakeup(void) { }\n#endif /* #else #ifdef CONFIG_RCU_NOCB_CPU */\n\n/**\n * RCU_NONIDLE - Indicate idle-loop code that needs RCU readers\n * @a: Code that RCU needs to pay attention to.\n *\n * RCU read-side critical sections are forbidden in the inner idle loop,\n * that is, between the rcu_idle_enter() and the rcu_idle_exit() -- RCU\n * will happily ignore any such read-side critical sections.  However,\n * things like powertop need tracepoints in the inner idle loop.\n *\n * This macro provides the way out:  RCU_NONIDLE(do_something_with_RCU())\n * will tell RCU that it needs to pay attention, invoke its argument\n * (in this example, calling the do_something_with_RCU() function),\n * and then tell RCU to go back to ignoring this CPU.  It is permissible\n * to nest RCU_NONIDLE() wrappers, but not indefinitely (but the limit is\n * on the order of a million or so, even on 32-bit systems).  It is\n * not legal to block within RCU_NONIDLE(), nor is it permissible to\n * transfer control either into or out of RCU_NONIDLE()'s statement.\n */\n#define RCU_NONIDLE(a) \\\n\tdo { \\\n\t\trcu_irq_enter_irqson(); \\\n\t\tdo { a; } while (0); \\\n\t\trcu_irq_exit_irqson(); \\\n\t} while (0)\n\n/*\n * Note a quasi-voluntary context switch for RCU-tasks's benefit.\n * This is a macro rather than an inline function to avoid #include hell.\n */\n#ifdef CONFIG_TASKS_RCU_GENERIC\n\n# ifdef CONFIG_TASKS_RCU\n# define rcu_tasks_classic_qs(t, preempt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(preempt) && READ_ONCE((t)->rcu_tasks_holdout))\t\\\n\t\t\tWRITE_ONCE((t)->rcu_tasks_holdout, false);\t\\\n\t} while (0)\nvoid call_rcu_tasks(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks(void);\n# else\n# define rcu_tasks_classic_qs(t, preempt) do { } while (0)\n# define call_rcu_tasks call_rcu\n# define synchronize_rcu_tasks synchronize_rcu\n# endif\n\n# ifdef CONFIG_TASKS_RCU_TRACE\n# define rcu_tasks_trace_qs(t)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!likely(READ_ONCE((t)->trc_reader_checked)) &&\t\\\n\t\t    !unlikely(READ_ONCE((t)->trc_reader_nesting))) {\t\\\n\t\t\tsmp_store_release(&(t)->trc_reader_checked, true); \\\n\t\t\tsmp_mb(); /* Readers partitioned by store. */\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n# else\n# define rcu_tasks_trace_qs(t) do { } while (0)\n# endif\n\n#define rcu_tasks_qs(t, preempt)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_tasks_classic_qs((t), (preempt));\t\t\t\t\\\n\trcu_tasks_trace_qs((t));\t\t\t\t\t\\\n} while (0)\n\n# ifdef CONFIG_TASKS_RUDE_RCU\nvoid call_rcu_tasks_rude(struct rcu_head *head, rcu_callback_t func);\nvoid synchronize_rcu_tasks_rude(void);\n# endif\n\n#define rcu_note_voluntary_context_switch(t) rcu_tasks_qs(t, false)\nvoid exit_tasks_rcu_start(void);\nvoid exit_tasks_rcu_finish(void);\n#else /* #ifdef CONFIG_TASKS_RCU_GENERIC */\n#define rcu_tasks_qs(t, preempt) do { } while (0)\n#define rcu_note_voluntary_context_switch(t) do { } while (0)\n#define call_rcu_tasks call_rcu\n#define synchronize_rcu_tasks synchronize_rcu\nstatic inline void exit_tasks_rcu_start(void) { }\nstatic inline void exit_tasks_rcu_finish(void) { }\n#endif /* #else #ifdef CONFIG_TASKS_RCU_GENERIC */\n\n/**\n * cond_resched_tasks_rcu_qs - Report potential quiescent states to RCU\n *\n * This macro resembles cond_resched(), except that it is defined to\n * report potential quiescent states to RCU-tasks even if the cond_resched()\n * machinery were to be shut off, as some advocate for PREEMPTION kernels.\n */\n#define cond_resched_tasks_rcu_qs() \\\ndo { \\\n\trcu_tasks_qs(current, false); \\\n\tcond_resched(); \\\n} while (0)\n\n/*\n * Infrastructure to implement the synchronize_() primitives in\n * TREE_RCU and rcu_barrier_() primitives in TINY_RCU.\n */\n\n#if defined(CONFIG_TREE_RCU)\n#include <linux/rcutree.h>\n#elif defined(CONFIG_TINY_RCU)\n#include <linux/rcutiny.h>\n#else\n#error \"Unknown RCU implementation specified to kernel configuration\"\n#endif\n\n/*\n * The init_rcu_head_on_stack() and destroy_rcu_head_on_stack() calls\n * are needed for dynamic initialization and destruction of rcu_head\n * on the stack, and init_rcu_head()/destroy_rcu_head() are needed for\n * dynamic initialization and destruction of statically allocated rcu_head\n * structures.  However, rcu_head structures allocated dynamically in the\n * heap don't need any initialization.\n */\n#ifdef CONFIG_DEBUG_OBJECTS_RCU_HEAD\nvoid init_rcu_head(struct rcu_head *head);\nvoid destroy_rcu_head(struct rcu_head *head);\nvoid init_rcu_head_on_stack(struct rcu_head *head);\nvoid destroy_rcu_head_on_stack(struct rcu_head *head);\n#else /* !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\nstatic inline void init_rcu_head(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head(struct rcu_head *head) { }\nstatic inline void init_rcu_head_on_stack(struct rcu_head *head) { }\nstatic inline void destroy_rcu_head_on_stack(struct rcu_head *head) { }\n#endif\t/* #else !CONFIG_DEBUG_OBJECTS_RCU_HEAD */\n\n#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU)\nbool rcu_lockdep_current_cpu_online(void);\n#else /* #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\nstatic inline bool rcu_lockdep_current_cpu_online(void) { return true; }\n#endif /* #else #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PROVE_RCU) */\n\nextern struct lockdep_map rcu_lock_map;\nextern struct lockdep_map rcu_bh_lock_map;\nextern struct lockdep_map rcu_sched_lock_map;\nextern struct lockdep_map rcu_callback_map;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\nstatic inline void rcu_lock_acquire(struct lockdep_map *map)\n{\n\tlock_acquire(map, 0, 0, 2, 0, NULL, _THIS_IP_);\n}\n\nstatic inline void rcu_lock_release(struct lockdep_map *map)\n{\n\tlock_release(map, _THIS_IP_);\n}\n\nint debug_lockdep_rcu_enabled(void);\nint rcu_read_lock_held(void);\nint rcu_read_lock_bh_held(void);\nint rcu_read_lock_sched_held(void);\nint rcu_read_lock_any_held(void);\n\n#else /* #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n# define rcu_lock_acquire(a)\t\tdo { } while (0)\n# define rcu_lock_release(a)\t\tdo { } while (0)\n\nstatic inline int rcu_read_lock_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_bh_held(void)\n{\n\treturn 1;\n}\n\nstatic inline int rcu_read_lock_sched_held(void)\n{\n\treturn !preemptible();\n}\n\nstatic inline int rcu_read_lock_any_held(void)\n{\n\treturn !preemptible();\n}\n\n#endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n\n#ifdef CONFIG_PROVE_RCU\n\n/**\n * RCU_LOCKDEP_WARN - emit lockdep splat if specified condition is met\n * @c: condition to check\n * @s: informative message\n */\n#define RCU_LOCKDEP_WARN(c, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic bool __section(\".data.unlikely\") __warned;\t\\\n\t\tif (debug_lockdep_rcu_enabled() && !__warned && (c)) {\t\\\n\t\t\t__warned = true;\t\t\t\t\\\n\t\t\tlockdep_rcu_suspicious(__FILE__, __LINE__, s);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#if defined(CONFIG_PROVE_RCU) && !defined(CONFIG_PREEMPT_RCU)\nstatic inline void rcu_preempt_sleep_check(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_lock_map),\n\t\t\t \"Illegal context switch in RCU read-side critical section\");\n}\n#else /* #ifdef CONFIG_PROVE_RCU */\nstatic inline void rcu_preempt_sleep_check(void) { }\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n#define rcu_sleep_check()\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trcu_preempt_sleep_check();\t\t\t\t\\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-bh read-side critical section\"); \\\n\t\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_sched_lock_map),\t\\\n\t\t\t\t \"Illegal context switch in RCU-sched read-side critical section\"); \\\n\t} while (0)\n\n#else /* #ifdef CONFIG_PROVE_RCU */\n\n#define RCU_LOCKDEP_WARN(c, s) do { } while (0 && (c))\n#define rcu_sleep_check() do { } while (0)\n\n#endif /* #else #ifdef CONFIG_PROVE_RCU */\n\n/*\n * Helper functions for rcu_dereference_check(), rcu_dereference_protected()\n * and rcu_assign_pointer().  Some of these could be folded into their\n * callers, but they are left separate in order to ease introduction of\n * multiple pointers markings to match different RCU implementations\n * (e.g., __srcu), should this make sense in the future.\n */\n\n#ifdef __CHECKER__\n#define rcu_check_sparse(p, space) \\\n\t((void)(((typeof(*p) space *)p) == p))\n#else /* #ifdef __CHECKER__ */\n#define rcu_check_sparse(p, space)\n#endif /* #else #ifdef __CHECKER__ */\n\n#define __rcu_access_pointer(p, space) \\\n({ \\\n\ttypeof(*p) *_________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(_________p1)); \\\n})\n#define __rcu_dereference_check(p, c, space) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(*p) *________p1 = (typeof(*p) *__force)READ_ONCE(p); \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_check() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n#define __rcu_dereference_protected(p, c, space) \\\n({ \\\n\tRCU_LOCKDEP_WARN(!(c), \"suspicious rcu_dereference_protected() usage\"); \\\n\trcu_check_sparse(p, space); \\\n\t((typeof(*p) __force __kernel *)(p)); \\\n})\n#define rcu_dereference_raw(p) \\\n({ \\\n\t/* Dependency order vs. p above. */ \\\n\ttypeof(p) ________p1 = READ_ONCE(p); \\\n\t((typeof(*p) __force __kernel *)(________p1)); \\\n})\n\n/**\n * RCU_INITIALIZER() - statically initialize an RCU-protected global variable\n * @v: The value to statically initialize with.\n */\n#define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)\n\n/**\n * rcu_assign_pointer() - assign to RCU-protected pointer\n * @p: pointer to assign to\n * @v: value to assign (publish)\n *\n * Assigns the specified value to the specified RCU-protected\n * pointer, ensuring that any concurrent RCU readers will see\n * any prior initialization.\n *\n * Inserts memory barriers on architectures that require them\n * (which is most of them), and also prevents the compiler from\n * reordering the code that initializes the structure after the pointer\n * assignment.  More importantly, this call documents which pointers\n * will be dereferenced by RCU read-side code.\n *\n * In some special cases, you may use RCU_INIT_POINTER() instead\n * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due\n * to the fact that it does not constrain either the CPU or the compiler.\n * That said, using RCU_INIT_POINTER() when you should have used\n * rcu_assign_pointer() is a very bad thing that results in\n * impossible-to-diagnose memory corruption.  So please be careful.\n * See the RCU_INIT_POINTER() comment header for details.\n *\n * Note that rcu_assign_pointer() evaluates each of its arguments only\n * once, appearances notwithstanding.  One of the \"extra\" evaluations\n * is in typeof() and the other visible only to sparse (__CHECKER__),\n * neither of which actually execute the argument.  As with most cpp\n * macros, this execute-arguments-only-once property is important, so\n * please be careful when making changes to rcu_assign_pointer() and the\n * other macros that it invokes.\n */\n#define rcu_assign_pointer(p, v)\t\t\t\t\t      \\\ndo {\t\t\t\t\t\t\t\t\t      \\\n\tuintptr_t _r_a_p__v = (uintptr_t)(v);\t\t\t\t      \\\n\trcu_check_sparse(p, __rcu);\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_constant_p(v) && (_r_a_p__v) == (uintptr_t)NULL)\t      \\\n\t\tWRITE_ONCE((p), (typeof(p))(_r_a_p__v));\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t\tsmp_store_release(&p, RCU_INITIALIZER((typeof(p))_r_a_p__v)); \\\n} while (0)\n\n/**\n * rcu_replace_pointer() - replace an RCU pointer, returning its old value\n * @rcu_ptr: RCU pointer, whose old value is returned\n * @ptr: regular pointer\n * @c: the lockdep conditions under which the dereference will take place\n *\n * Perform a replacement, where @rcu_ptr is an RCU-annotated\n * pointer and @c is the lockdep argument that is passed to the\n * rcu_dereference_protected() call used to read that pointer.  The old\n * value of @rcu_ptr is returned, and @rcu_ptr is set to @ptr.\n */\n#define rcu_replace_pointer(rcu_ptr, ptr, c)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) __tmp = rcu_dereference_protected((rcu_ptr), (c));\t\\\n\trcu_assign_pointer((rcu_ptr), (ptr));\t\t\t\t\\\n\t__tmp;\t\t\t\t\t\t\t\t\\\n})\n\n/**\n * rcu_access_pointer() - fetch RCU pointer with no dereferencing\n * @p: The pointer to read\n *\n * Return the value of the specified RCU-protected pointer, but omit the\n * lockdep checks for being in an RCU read-side critical section.  This is\n * useful when the value of this pointer is accessed, but the pointer is\n * not dereferenced, for example, when testing an RCU-protected pointer\n * against NULL.  Although rcu_access_pointer() may also be used in cases\n * where update-side locks prevent the value of the pointer from changing,\n * you should instead use rcu_dereference_protected() for this use case.\n *\n * It is also permissible to use rcu_access_pointer() when read-side\n * access to the pointer was removed at least one grace period ago, as\n * is the case in the context of the RCU callback that is freeing up\n * the data, or after a synchronize_rcu() returns.  This can be useful\n * when tearing down multi-linked structures after a grace period\n * has elapsed.\n */\n#define rcu_access_pointer(p) __rcu_access_pointer((p), __rcu)\n\n/**\n * rcu_dereference_check() - rcu_dereference with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Do an rcu_dereference(), but check that the conditions under which the\n * dereference will take place are correct.  Typically the conditions\n * indicate the various locking conditions that should be held at that\n * point.  The check should return true if the conditions are satisfied.\n * An implicit check for being in an RCU read-side critical section\n * (rcu_read_lock()) is included.\n *\n * For example:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock));\n *\n * could be used to indicate to lockdep that foo->bar may only be dereferenced\n * if either rcu_read_lock() is held, or that the lock required to replace\n * the bar struct at foo->bar is held.\n *\n * Note that the list of conditions may also include indications of when a lock\n * need not be held, for example during initialisation or destruction of the\n * target struct:\n *\n *\tbar = rcu_dereference_check(foo->bar, lockdep_is_held(&foo->lock) ||\n *\t\t\t\t\t      atomic_read(&foo->usage) == 0);\n *\n * Inserts memory barriers on architectures that require them\n * (currently only the Alpha), prevents the compiler from refetching\n * (and from merging fetches), and, more importantly, documents exactly\n * which pointers are protected by RCU and checks that the pointer is\n * annotated as __rcu.\n */\n#define rcu_dereference_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_held(), __rcu)\n\n/**\n * rcu_dereference_bh_check() - rcu_dereference_bh with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-bh counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_bh_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_bh_held(), __rcu)\n\n/**\n * rcu_dereference_sched_check() - rcu_dereference_sched with debug checking\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * This is the RCU-sched counterpart to rcu_dereference_check().\n */\n#define rcu_dereference_sched_check(p, c) \\\n\t__rcu_dereference_check((p), (c) || rcu_read_lock_sched_held(), \\\n\t\t\t\t__rcu)\n\n/*\n * The tracing infrastructure traces RCU (we want that), but unfortunately\n * some of the RCU checks causes tracing to lock up the system.\n *\n * The no-tracing version of rcu_dereference_raw() must not call\n * rcu_read_lock_held().\n */\n#define rcu_dereference_raw_check(p) __rcu_dereference_check((p), 1, __rcu)\n\n/**\n * rcu_dereference_protected() - fetch RCU pointer when updates prevented\n * @p: The pointer to read, prior to dereferencing\n * @c: The conditions under which the dereference will take place\n *\n * Return the value of the specified RCU-protected pointer, but omit\n * the READ_ONCE().  This is useful in cases where update-side locks\n * prevent the value of the pointer from changing.  Please note that this\n * primitive does *not* prevent the compiler from repeating this reference\n * or combining it with other references, so it should not be used without\n * protection of appropriate locks.\n *\n * This function is only for update-side use.  Using this function\n * when protected only by rcu_read_lock() will result in infrequent\n * but very ugly failures.\n */\n#define rcu_dereference_protected(p, c) \\\n\t__rcu_dereference_protected((p), (c), __rcu)\n\n\n/**\n * rcu_dereference() - fetch RCU-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * This is a simple wrapper around rcu_dereference_check().\n */\n#define rcu_dereference(p) rcu_dereference_check(p, 0)\n\n/**\n * rcu_dereference_bh() - fetch an RCU-bh-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_bh(p) rcu_dereference_bh_check(p, 0)\n\n/**\n * rcu_dereference_sched() - fetch RCU-sched-protected pointer for dereferencing\n * @p: The pointer to read, prior to dereferencing\n *\n * Makes rcu_dereference_check() do the dirty work.\n */\n#define rcu_dereference_sched(p) rcu_dereference_sched_check(p, 0)\n\n/**\n * rcu_pointer_handoff() - Hand off a pointer from RCU to other mechanism\n * @p: The pointer to hand off\n *\n * This is simply an identity function, but it documents where a pointer\n * is handed off from RCU to some other synchronization mechanism, for\n * example, reference counting or locking.  In C11, it would map to\n * kill_dependency().  It could be used as follows::\n *\n *\trcu_read_lock();\n *\tp = rcu_dereference(gp);\n *\tlong_lived = is_long_lived(p);\n *\tif (long_lived) {\n *\t\tif (!atomic_inc_not_zero(p->refcnt))\n *\t\t\tlong_lived = false;\n *\t\telse\n *\t\t\tp = rcu_pointer_handoff(p);\n *\t}\n *\trcu_read_unlock();\n */\n#define rcu_pointer_handoff(p) (p)\n\n/**\n * rcu_read_lock() - mark the beginning of an RCU read-side critical section\n *\n * When synchronize_rcu() is invoked on one CPU while other CPUs\n * are within RCU read-side critical sections, then the\n * synchronize_rcu() is guaranteed to block until after all the other\n * CPUs exit their critical sections.  Similarly, if call_rcu() is invoked\n * on one CPU while other CPUs are within RCU read-side critical\n * sections, invocation of the corresponding RCU callback is deferred\n * until after the all the other CPUs exit their critical sections.\n *\n * Note, however, that RCU callbacks are permitted to run concurrently\n * with new RCU read-side critical sections.  One way that this can happen\n * is via the following sequence of events: (1) CPU 0 enters an RCU\n * read-side critical section, (2) CPU 1 invokes call_rcu() to register\n * an RCU callback, (3) CPU 0 exits the RCU read-side critical section,\n * (4) CPU 2 enters a RCU read-side critical section, (5) the RCU\n * callback is invoked.  This is legal, because the RCU read-side critical\n * section that was running concurrently with the call_rcu() (and which\n * therefore might be referencing something that the corresponding RCU\n * callback would free up) has completed before the corresponding\n * RCU callback is invoked.\n *\n * RCU read-side critical sections may be nested.  Any deferred actions\n * will be deferred until the outermost RCU read-side critical section\n * completes.\n *\n * You can avoid reading and understanding the next paragraph by\n * following this rule: don't put anything in an rcu_read_lock() RCU\n * read-side critical section that would block in a !PREEMPTION kernel.\n * But if you want the full story, read on!\n *\n * In non-preemptible RCU implementations (pure TREE_RCU and TINY_RCU),\n * it is illegal to block while in an RCU read-side critical section.\n * In preemptible RCU implementations (PREEMPT_RCU) in CONFIG_PREEMPTION\n * kernel builds, RCU read-side critical sections may be preempted,\n * but explicit blocking is illegal.  Finally, in preemptible RCU\n * implementations in real-time (with -rt patchset) kernel builds, RCU\n * read-side critical sections may be preempted and they may also block, but\n * only when acquiring spinlocks that are subject to priority inheritance.\n */\nstatic __always_inline void rcu_read_lock(void)\n{\n\t__rcu_read_lock();\n\t__acquire(RCU);\n\trcu_lock_acquire(&rcu_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock() used illegally while idle\");\n}\n\n/*\n * So where is rcu_write_lock()?  It does not exist, as there is no\n * way for writers to lock out RCU readers.  This is a feature, not\n * a bug -- this property is what provides RCU's performance benefits.\n * Of course, writers must coordinate with each other.  The normal\n * spinlock primitives work well for this, but any other technique may be\n * used as well.  RCU does not care how the writers keep out of each\n * others' way, as long as they do so.\n */\n\n/**\n * rcu_read_unlock() - marks the end of an RCU read-side critical section.\n *\n * In most situations, rcu_read_unlock() is immune from deadlock.\n * However, in kernels built with CONFIG_RCU_BOOST, rcu_read_unlock()\n * is responsible for deboosting, which it does via rt_mutex_unlock().\n * Unfortunately, this function acquires the scheduler's runqueue and\n * priority-inheritance spinlocks.  This means that deadlock could result\n * if the caller of rcu_read_unlock() already holds one of these locks or\n * any lock that is ever acquired while holding them.\n *\n * That said, RCU readers are never priority boosted unless they were\n * preempted.  Therefore, one way to avoid deadlock is to make sure\n * that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with one of\n * rt_mutex_unlock()'s locks held.  Such preemption can be avoided in\n * a number of ways, for example, by invoking preempt_disable() before\n * critical section's outermost rcu_read_lock().\n *\n * Given that the set of locks acquired by rt_mutex_unlock() might change\n * at any time, a somewhat more future-proofed approach is to make sure\n * that that preemption never happens within any RCU read-side critical\n * section whose outermost rcu_read_unlock() is called with irqs disabled.\n * This approach relies on the fact that rt_mutex_unlock() currently only\n * acquires irq-disabled locks.\n *\n * The second of these two approaches is best in most situations,\n * however, the first approach can also be useful, at least to those\n * developers willing to keep abreast of the set of locks acquired by\n * rt_mutex_unlock().\n *\n * See rcu_read_lock() for more information.\n */\nstatic inline void rcu_read_unlock(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock() used illegally while idle\");\n\t__release(RCU);\n\t__rcu_read_unlock();\n\trcu_lock_release(&rcu_lock_map); /* Keep acq info for rls diags. */\n}\n\n/**\n * rcu_read_lock_bh() - mark the beginning of an RCU-bh critical section\n *\n * This is equivalent of rcu_read_lock(), but also disables softirqs.\n * Note that anything else that disables softirqs can also serve as\n * an RCU read-side critical section.\n *\n * Note that rcu_read_lock_bh() and the matching rcu_read_unlock_bh()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_bh() from one task if the matching rcu_read_lock_bh()\n * was invoked from some other task.\n */\nstatic inline void rcu_read_lock_bh(void)\n{\n\tlocal_bh_disable();\n\t__acquire(RCU_BH);\n\trcu_lock_acquire(&rcu_bh_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_bh() used illegally while idle\");\n}\n\n/**\n * rcu_read_unlock_bh() - marks the end of a softirq-only RCU critical section\n *\n * See rcu_read_lock_bh() for more information.\n */\nstatic inline void rcu_read_unlock_bh(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_bh() used illegally while idle\");\n\trcu_lock_release(&rcu_bh_lock_map);\n\t__release(RCU_BH);\n\tlocal_bh_enable();\n}\n\n/**\n * rcu_read_lock_sched() - mark the beginning of a RCU-sched critical section\n *\n * This is equivalent of rcu_read_lock(), but disables preemption.\n * Read-side critical sections can also be introduced by anything else\n * that disables preemption, including local_irq_disable() and friends.\n *\n * Note that rcu_read_lock_sched() and the matching rcu_read_unlock_sched()\n * must occur in the same context, for example, it is illegal to invoke\n * rcu_read_unlock_sched() from process context if the matching\n * rcu_read_lock_sched() was invoked from an NMI handler.\n */\nstatic inline void rcu_read_lock_sched(void)\n{\n\tpreempt_disable();\n\t__acquire(RCU_SCHED);\n\trcu_lock_acquire(&rcu_sched_lock_map);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_lock_sched() used illegally while idle\");\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_lock_sched_notrace(void)\n{\n\tpreempt_disable_notrace();\n\t__acquire(RCU_SCHED);\n}\n\n/**\n * rcu_read_unlock_sched() - marks the end of a RCU-classic critical section\n *\n * See rcu_read_lock_sched() for more information.\n */\nstatic inline void rcu_read_unlock_sched(void)\n{\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t \"rcu_read_unlock_sched() used illegally while idle\");\n\trcu_lock_release(&rcu_sched_lock_map);\n\t__release(RCU_SCHED);\n\tpreempt_enable();\n}\n\n/* Used by lockdep and tracing: cannot be traced, cannot call lockdep. */\nstatic inline notrace void rcu_read_unlock_sched_notrace(void)\n{\n\t__release(RCU_SCHED);\n\tpreempt_enable_notrace();\n}\n\n/**\n * RCU_INIT_POINTER() - initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * Initialize an RCU-protected pointer in special cases where readers\n * do not need ordering constraints on the CPU or the compiler.  These\n * special cases are:\n *\n * 1.\tThis use of RCU_INIT_POINTER() is NULLing out the pointer *or*\n * 2.\tThe caller has taken whatever steps are required to prevent\n *\tRCU readers from concurrently accessing this pointer *or*\n * 3.\tThe referenced data structure has already been exposed to\n *\treaders either at compile time or via rcu_assign_pointer() *and*\n *\n *\ta.\tYou have not made *any* reader-visible changes to\n *\t\tthis structure since then *or*\n *\tb.\tIt is OK for readers accessing this structure from its\n *\t\tnew location to see the old state of the structure.  (For\n *\t\texample, the changes were to statistical counters or to\n *\t\tother state where exact synchronization is not required.)\n *\n * Failure to follow these rules governing use of RCU_INIT_POINTER() will\n * result in impossible-to-diagnose memory corruption.  As in the structures\n * will look OK in crash dumps, but any concurrent RCU readers might\n * see pre-initialized values of the referenced data structure.  So\n * please be very careful how you use RCU_INIT_POINTER()!!!\n *\n * If you are creating an RCU-protected linked structure that is accessed\n * by a single external-to-structure RCU-protected pointer, then you may\n * use RCU_INIT_POINTER() to initialize the internal RCU-protected\n * pointers, but you must use rcu_assign_pointer() to initialize the\n * external-to-structure pointer *after* you have completely initialized\n * the reader-accessible portions of the linked structure.\n *\n * Note that unlike rcu_assign_pointer(), RCU_INIT_POINTER() provides no\n * ordering guarantees for either the CPU or the compiler.\n */\n#define RCU_INIT_POINTER(p, v) \\\n\tdo { \\\n\t\trcu_check_sparse(p, __rcu); \\\n\t\tWRITE_ONCE(p, RCU_INITIALIZER(v)); \\\n\t} while (0)\n\n/**\n * RCU_POINTER_INITIALIZER() - statically initialize an RCU protected pointer\n * @p: The pointer to be initialized.\n * @v: The value to initialized the pointer to.\n *\n * GCC-style initialization for an RCU-protected pointer in a structure field.\n */\n#define RCU_POINTER_INITIALIZER(p, v) \\\n\t\t.p = RCU_INITIALIZER(v)\n\n/*\n * Does the specified offset indicate that the corresponding rcu_head\n * structure can be handled by kvfree_rcu()?\n */\n#define __is_kvfree_rcu_offset(offset) ((offset) < 4096)\n\n/**\n * kfree_rcu() - kfree an object after a grace period.\n * @ptr: pointer to kfree for both single- and double-argument invocations.\n * @rhf: the name of the struct rcu_head within the type of @ptr,\n *       but only for double-argument invocations.\n *\n * Many rcu callbacks functions just call kfree() on the base structure.\n * These functions are trivial, but their size adds up, and furthermore\n * when they are used in a kernel module, that module must invoke the\n * high-latency rcu_barrier() function at module-unload time.\n *\n * The kfree_rcu() function handles this issue.  Rather than encoding a\n * function address in the embedded rcu_head structure, kfree_rcu() instead\n * encodes the offset of the rcu_head structure within the base structure.\n * Because the functions are not allowed in the low-order 4096 bytes of\n * kernel virtual memory, offsets up to 4095 bytes can be accommodated.\n * If the offset is larger than 4095 bytes, a compile-time error will\n * be generated in kvfree_rcu_arg_2(). If this error is triggered, you can\n * either fall back to use of call_rcu() or rearrange the structure to\n * position the rcu_head structure into the first 4096 bytes.\n *\n * Note that the allowable offset might decrease in the future, for example,\n * to allow something like kmem_cache_free_rcu().\n *\n * The BUILD_BUG_ON check must not involve any function calls, hence the\n * checks are done in macros here.\n */\n#define kfree_rcu kvfree_rcu\n\n/**\n * kvfree_rcu() - kvfree an object after a grace period.\n *\n * This macro consists of one or two arguments and it is\n * based on whether an object is head-less or not. If it\n * has a head then a semantic stays the same as it used\n * to be before:\n *\n *     kvfree_rcu(ptr, rhf);\n *\n * where @ptr is a pointer to kvfree(), @rhf is the name\n * of the rcu_head structure within the type of @ptr.\n *\n * When it comes to head-less variant, only one argument\n * is passed and that is just a pointer which has to be\n * freed after a grace period. Therefore the semantic is\n *\n *     kvfree_rcu(ptr);\n *\n * where @ptr is a pointer to kvfree().\n *\n * Please note, head-less way of freeing is permitted to\n * use from a context that has to follow might_sleep()\n * annotation. Otherwise, please switch and embed the\n * rcu_head structure within the type of @ptr.\n */\n#define kvfree_rcu(...) KVFREE_GET_MACRO(__VA_ARGS__,\t\t\\\n\tkvfree_rcu_arg_2, kvfree_rcu_arg_1)(__VA_ARGS__)\n\n#define KVFREE_GET_MACRO(_1, _2, NAME, ...) NAME\n#define kvfree_rcu_arg_2(ptr, rhf)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\ttypeof (ptr) ___p = (ptr);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (___p) {\t\t\t\t\t\t\t\t\t\\\n\t\tBUILD_BUG_ON(!__is_kvfree_rcu_offset(offsetof(typeof(*(ptr)), rhf)));\t\\\n\t\tkvfree_call_rcu(&((___p)->rhf), (rcu_callback_t)(unsigned long)\t\t\\\n\t\t\t(offsetof(typeof(*(ptr)), rhf)));\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define kvfree_rcu_arg_1(ptr)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\ttypeof(ptr) ___p = (ptr);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (___p)\t\t\t\t\t\t\\\n\t\tkvfree_call_rcu(NULL, (rcu_callback_t) (___p));\t\\\n} while (0)\n\n/*\n * Place this after a lock-acquisition primitive to guarantee that\n * an UNLOCK+LOCK pair acts as a full barrier.  This guarantee applies\n * if the UNLOCK and LOCK are executed by the same CPU or if the\n * UNLOCK and LOCK operate on the same lock variable.\n */\n#ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE\n#define smp_mb__after_unlock_lock()\tsmp_mb()  /* Full ordering for lock. */\n#else /* #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n#define smp_mb__after_unlock_lock()\tdo { } while (0)\n#endif /* #else #ifdef CONFIG_ARCH_WEAK_RELEASE_ACQUIRE */\n\n\n/* Has the specified rcu_head structure been handed to call_rcu()? */\n\n/**\n * rcu_head_init - Initialize rcu_head for rcu_head_after_call_rcu()\n * @rhp: The rcu_head structure to initialize.\n *\n * If you intend to invoke rcu_head_after_call_rcu() to test whether a\n * given rcu_head structure has already been passed to call_rcu(), then\n * you must also invoke this rcu_head_init() function on it just after\n * allocating that structure.  Calls to this function must not race with\n * calls to call_rcu(), rcu_head_after_call_rcu(), or callback invocation.\n */\nstatic inline void rcu_head_init(struct rcu_head *rhp)\n{\n\trhp->func = (rcu_callback_t)~0L;\n}\n\n/**\n * rcu_head_after_call_rcu() - Has this rcu_head been passed to call_rcu()?\n * @rhp: The rcu_head structure to test.\n * @f: The function passed to call_rcu() along with @rhp.\n *\n * Returns @true if the @rhp has been passed to call_rcu() with @func,\n * and @false otherwise.  Emits a warning in any other case, including\n * the case where @rhp has already been invoked after a grace period.\n * Calls to this function must not race with callback invocation.  One way\n * to avoid such races is to enclose the call to rcu_head_after_call_rcu()\n * in an RCU read-side critical section that includes a read-side fetch\n * of the pointer to the structure containing @rhp.\n */\nstatic inline bool\nrcu_head_after_call_rcu(struct rcu_head *rhp, rcu_callback_t f)\n{\n\trcu_callback_t func = READ_ONCE(rhp->func);\n\n\tif (func == f)\n\t\treturn true;\n\tWARN_ON_ONCE(func != (rcu_callback_t)~0L);\n\treturn false;\n}\n\n/* kernel/ksysfs.c definitions */\nextern int rcu_expedited;\nextern int rcu_normal;\n\n#endif /* __LINUX_RCUPDATE_H */\n"}, "3": {"id": 3, "path": "/src/include/linux/math.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_MATH_H\n#define _LINUX_MATH_H\n\n#include <asm/div64.h>\n#include <uapi/linux/kernel.h>\n\n/*\n * This looks more complex than it should be. But we need to\n * get the type for the ~ right in round_down (it needs to be\n * as wide as the result!), and we want to evaluate the macro\n * arguments just once each.\n */\n#define __round_mask(x, y) ((__typeof__(x))((y)-1))\n\n/**\n * round_up - round up to next specified power of 2\n * @x: the value to round\n * @y: multiple to round up to (must be a power of 2)\n *\n * Rounds @x up to next multiple of @y (which must be a power of 2).\n * To perform arbitrary rounding up, use roundup() below.\n */\n#define round_up(x, y) ((((x)-1) | __round_mask(x, y))+1)\n\n/**\n * round_down - round down to next specified power of 2\n * @x: the value to round\n * @y: multiple to round down to (must be a power of 2)\n *\n * Rounds @x down to next multiple of @y (which must be a power of 2).\n * To perform arbitrary rounding down, use rounddown() below.\n */\n#define round_down(x, y) ((x) & ~__round_mask(x, y))\n\n#define DIV_ROUND_UP __KERNEL_DIV_ROUND_UP\n\n#define DIV_ROUND_DOWN_ULL(ll, d) \\\n\t({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })\n\n#define DIV_ROUND_UP_ULL(ll, d) \\\n\tDIV_ROUND_DOWN_ULL((unsigned long long)(ll) + (d) - 1, (d))\n\n#if BITS_PER_LONG == 32\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP_ULL(ll, d)\n#else\n# define DIV_ROUND_UP_SECTOR_T(ll,d) DIV_ROUND_UP(ll,d)\n#endif\n\n/**\n * roundup - round up to the next specified multiple\n * @x: the value to up\n * @y: multiple to round up to\n *\n * Rounds @x up to next multiple of @y. If @y will always be a power\n * of 2, consider using the faster round_up().\n */\n#define roundup(x, y) (\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(y) __y = y;\t\t\t\t\\\n\t(((x) + (__y - 1)) / __y) * __y;\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n/**\n * rounddown - round down to next specified multiple\n * @x: the value to round\n * @y: multiple to round down to\n *\n * Rounds @x down to next multiple of @y. If @y will always be a power\n * of 2, consider using the faster round_down().\n */\n#define rounddown(x, y) (\t\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = (x);\t\t\t\t\\\n\t__x - (__x % (y));\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n/*\n * Divide positive or negative dividend by positive or negative divisor\n * and round to closest integer. Result is undefined for negative\n * divisors if the dividend variable type is unsigned and for negative\n * dividends if the divisor variable type is unsigned.\n */\n#define DIV_ROUND_CLOSEST(x, divisor)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) __x = x;\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\t(((typeof(x))-1) > 0 ||\t\t\t\t\\\n\t ((typeof(divisor))-1) > 0 ||\t\t\t\\\n\t (((__x) > 0) == ((__d) > 0))) ?\t\t\\\n\t\t(((__x) + ((__d) / 2)) / (__d)) :\t\\\n\t\t(((__x) - ((__d) / 2)) / (__d));\t\\\n}\t\t\t\t\t\t\t\\\n)\n/*\n * Same as above but for u64 dividends. divisor must be a 32-bit\n * number.\n */\n#define DIV_ROUND_CLOSEST_ULL(x, divisor)(\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(divisor) __d = divisor;\t\t\t\\\n\tunsigned long long _tmp = (x) + (__d) / 2;\t\\\n\tdo_div(_tmp, __d);\t\t\t\t\\\n\t_tmp;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n/*\n * Multiplies an integer by a fraction, while avoiding unnecessary\n * overflow or loss of precision.\n */\n#define mult_frac(x, numer, denom)(\t\t\t\\\n{\t\t\t\t\t\t\t\\\n\ttypeof(x) quot = (x) / (denom);\t\t\t\\\n\ttypeof(x) rem  = (x) % (denom);\t\t\t\\\n\t(quot * (numer)) + ((rem * (numer)) / (denom));\t\\\n}\t\t\t\t\t\t\t\\\n)\n\n#define sector_div(a, b) do_div(a, b)\n\n/**\n * abs - return absolute value of an argument\n * @x: the value.  If it is unsigned type, it is converted to signed type first.\n *     char is treated as if it was signed (regardless of whether it really is)\n *     but the macro's return type is preserved as char.\n *\n * Return: an absolute value of x.\n */\n#define abs(x)\t__abs_choose_expr(x, long long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, long,\t\t\t\t\\\n\t\t__abs_choose_expr(x, int,\t\t\t\t\\\n\t\t__abs_choose_expr(x, short,\t\t\t\t\\\n\t\t__abs_choose_expr(x, char,\t\t\t\t\\\n\t\t__builtin_choose_expr(\t\t\t\t\t\\\n\t\t\t__builtin_types_compatible_p(typeof(x), char),\t\\\n\t\t\t(char)({ signed char __x = (x); __x<0?-__x:__x; }), \\\n\t\t\t((void)0)))))))\n\n#define __abs_choose_expr(x, type, other) __builtin_choose_expr(\t\\\n\t__builtin_types_compatible_p(typeof(x),   signed type) ||\t\\\n\t__builtin_types_compatible_p(typeof(x), unsigned type),\t\t\\\n\t({ signed type __x = (x); __x < 0 ? -__x : __x; }), other)\n\n/**\n * reciprocal_scale - \"scale\" a value into range [0, ep_ro)\n * @val: value\n * @ep_ro: right open interval endpoint\n *\n * Perform a \"reciprocal multiplication\" in order to \"scale\" a value into\n * range [0, @ep_ro), where the upper interval endpoint is right-open.\n * This is useful, e.g. for accessing a index of an array containing\n * @ep_ro elements, for example. Think of it as sort of modulus, only that\n * the result isn't that of modulo. ;) Note that if initial input is a\n * small value, then result will return 0.\n *\n * Return: a result based on @val in interval [0, @ep_ro).\n */\nstatic inline u32 reciprocal_scale(u32 val, u32 ep_ro)\n{\n\treturn (u32)(((u64) val * ep_ro) >> 32);\n}\n\nu64 int_pow(u64 base, unsigned int exp);\nunsigned long int_sqrt(unsigned long);\n\n#if BITS_PER_LONG < 64\nu32 int_sqrt64(u64 x);\n#else\nstatic inline u32 int_sqrt64(u64 x)\n{\n\treturn (u32)int_sqrt(x);\n}\n#endif\n\n#endif\t/* _LINUX_MATH_H */\n"}, "4": {"id": 4, "path": "/src/include/asm-generic/div64.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_DIV64_H\n#define _ASM_GENERIC_DIV64_H\n/*\n * Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>\n * Based on former asm-ppc/div64.h and asm-m68knommu/div64.h\n *\n * Optimization for constant divisors on 32-bit machines:\n * Copyright (C) 2006-2015 Nicolas Pitre\n *\n * The semantics of do_div() are:\n *\n * uint32_t do_div(uint64_t *n, uint32_t base)\n * {\n * \tuint32_t remainder = *n % base;\n * \t*n = *n / base;\n * \treturn remainder;\n * }\n *\n * NOTE: macro parameter n is evaluated multiple times,\n *       beware of side effects!\n */\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n\n#if BITS_PER_LONG == 64\n\n/**\n * do_div - returns 2 values: calculate remainder and update new dividend\n * @n: uint64_t dividend (will be updated)\n * @base: uint32_t divisor\n *\n * Summary:\n * ``uint32_t remainder = n % base;``\n * ``n = n / base;``\n *\n * Return: (uint32_t)remainder\n *\n * NOTE: macro parameter @n is evaluated multiple times,\n * beware of side effects!\n */\n# define do_div(n,base) ({\t\t\t\t\t\\\n\tuint32_t __base = (base);\t\t\t\t\\\n\tuint32_t __rem;\t\t\t\t\t\t\\\n\t__rem = ((uint64_t)(n)) % __base;\t\t\t\\\n\t(n) = ((uint64_t)(n)) / __base;\t\t\t\t\\\n\t__rem;\t\t\t\t\t\t\t\\\n })\n\n#elif BITS_PER_LONG == 32\n\n#include <linux/log2.h>\n\n/*\n * If the divisor happens to be constant, we determine the appropriate\n * inverse at compile time to turn the division into a few inline\n * multiplications which ought to be much faster. And yet only if compiling\n * with a sufficiently recent gcc version to perform proper 64-bit constant\n * propagation.\n *\n * (It is unfortunate that gcc doesn't perform all this internally.)\n */\n\n#ifndef __div64_const32_is_OK\n#define __div64_const32_is_OK (__GNUC__ >= 4)\n#endif\n\n#define __div64_const32(n, ___b)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Multiplication by reciprocal of b: n / b = n * (p / b) / p\t\\\n\t *\t\t\t\t\t\t\t\t\\\n\t * We rely on the fact that most of this code gets optimized\t\\\n\t * away at compile time due to constant propagation and only\t\\\n\t * a few multiplication instructions should remain.\t\t\\\n\t * Hence this monstrous macro (static inline doesn't always\t\\\n\t * do the trick here).\t\t\t\t\t\t\\\n\t */\t\t\t\t\t\t\t\t\\\n\tuint64_t ___res, ___x, ___t, ___m, ___n = (n);\t\t\t\\\n\tuint32_t ___p, ___bias;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/* determine MSB of b */\t\t\t\t\t\\\n\t___p = 1 << ilog2(___b);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/* compute m = ((p << 64) + b - 1) / b */\t\t\t\\\n\t___m = (~0ULL / ___b) * ___p;\t\t\t\t\t\\\n\t___m += (((~0ULL % ___b + 1) * ___p) + ___b - 1) / ___b;\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/* one less than the dividend with highest result */\t\t\\\n\t___x = ~0ULL / ___b * ___b - 1;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/* test our ___m with res = m * x / (p << 64) */\t\t\\\n\t___res = ((___m & 0xffffffff) * (___x & 0xffffffff)) >> 32;\t\\\n\t___t = ___res += (___m & 0xffffffff) * (___x >> 32);\t\t\\\n\t___res += (___x & 0xffffffff) * (___m >> 32);\t\t\t\\\n\t___t = (___res < ___t) ? (1ULL << 32) : 0;\t\t\t\\\n\t___res = (___res >> 32) + ___t;\t\t\t\t\t\\\n\t___res += (___m >> 32) * (___x >> 32);\t\t\t\t\\\n\t___res /= ___p;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/* Now sanitize and optimize what we've got. */\t\t\t\\\n\tif (~0ULL % (___b / (___b & -___b)) == 0) {\t\t\t\\\n\t\t/* special case, can be simplified to ... */\t\t\\\n\t\t___n /= (___b & -___b);\t\t\t\t\t\\\n\t\t___m = ~0ULL / (___b / (___b & -___b));\t\t\t\\\n\t\t___p = 1;\t\t\t\t\t\t\\\n\t\t___bias = 1;\t\t\t\t\t\t\\\n\t} else if (___res != ___x / ___b) {\t\t\t\t\\\n\t\t/*\t\t\t\t\t\t\t\\\n\t\t * We can't get away without a bias to compensate\t\\\n\t\t * for bit truncation errors.  To avoid it we'd need an\t\\\n\t\t * additional bit to represent m which would overflow\t\\\n\t\t * a 64-bit variable.\t\t\t\t\t\\\n\t\t *\t\t\t\t\t\t\t\\\n\t\t * Instead we do m = p / b and n / b = (n * m + m) / p.\t\\\n\t\t */\t\t\t\t\t\t\t\\\n\t\t___bias = 1;\t\t\t\t\t\t\\\n\t\t/* Compute m = (p << 64) / b */\t\t\t\t\\\n\t\t___m = (~0ULL / ___b) * ___p;\t\t\t\t\\\n\t\t___m += ((~0ULL % ___b + 1) * ___p) / ___b;\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\t/*\t\t\t\t\t\t\t\\\n\t\t * Reduce m / p, and try to clear bit 31 of m when\t\\\n\t\t * possible, otherwise that'll need extra overflow\t\\\n\t\t * handling later.\t\t\t\t\t\\\n\t\t */\t\t\t\t\t\t\t\\\n\t\tuint32_t ___bits = -(___m & -___m);\t\t\t\\\n\t\t___bits |= ___m >> 32;\t\t\t\t\t\\\n\t\t___bits = (~___bits) << 1;\t\t\t\t\\\n\t\t/*\t\t\t\t\t\t\t\\\n\t\t * If ___bits == 0 then setting bit 31 is  unavoidable.\t\\\n\t\t * Simply apply the maximum possible reduction in that\t\\\n\t\t * case. Otherwise the MSB of ___bits indicates the\t\\\n\t\t * best reduction we should apply.\t\t\t\\\n\t\t */\t\t\t\t\t\t\t\\\n\t\tif (!___bits) {\t\t\t\t\t\t\\\n\t\t\t___p /= (___m & -___m);\t\t\t\t\\\n\t\t\t___m /= (___m & -___m);\t\t\t\t\\\n\t\t} else {\t\t\t\t\t\t\\\n\t\t\t___p >>= ilog2(___bits);\t\t\t\\\n\t\t\t___m >>= ilog2(___bits);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t/* No bias needed. */\t\t\t\t\t\\\n\t\t___bias = 0;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t/*\t\t\t\t\t\t\t\t\\\n\t * Now we have a combination of 2 conditions:\t\t\t\\\n\t *\t\t\t\t\t\t\t\t\\\n\t * 1) whether or not we need to apply a bias, and\t\t\\\n\t *\t\t\t\t\t\t\t\t\\\n\t * 2) whether or not there might be an overflow in the cross\t\\\n\t *    product determined by (___m & ((1 << 63) | (1 << 31))).\t\\\n\t *\t\t\t\t\t\t\t\t\\\n\t * Select the best way to do (m_bias + m * n) / (1 << 64).\t\\\n\t * From now on there will be actual runtime code generated.\t\\\n\t */\t\t\t\t\t\t\t\t\\\n\t___res = __arch_xprod_64(___m, ___n, ___bias);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t___res /= ___p;\t\t\t\t\t\t\t\\\n})\n\n#ifndef __arch_xprod_64\n/*\n * Default C implementation for __arch_xprod_64()\n *\n * Prototype: uint64_t __arch_xprod_64(const uint64_t m, uint64_t n, bool bias)\n * Semantic:  retval = ((bias ? m : 0) + m * n) >> 64\n *\n * The product is a 128-bit value, scaled down to 64 bits.\n * Assuming constant propagation to optimize away unused conditional code.\n * Architectures may provide their own optimized assembly implementation.\n */\nstatic inline uint64_t __arch_xprod_64(const uint64_t m, uint64_t n, bool bias)\n{\n\tuint32_t m_lo = m;\n\tuint32_t m_hi = m >> 32;\n\tuint32_t n_lo = n;\n\tuint32_t n_hi = n >> 32;\n\tuint64_t res;\n\tuint32_t res_lo, res_hi, tmp;\n\n\tif (!bias) {\n\t\tres = ((uint64_t)m_lo * n_lo) >> 32;\n\t} else if (!(m & ((1ULL << 63) | (1ULL << 31)))) {\n\t\t/* there can't be any overflow here */\n\t\tres = (m + (uint64_t)m_lo * n_lo) >> 32;\n\t} else {\n\t\tres = m + (uint64_t)m_lo * n_lo;\n\t\tres_lo = res >> 32;\n\t\tres_hi = (res_lo < m_hi);\n\t\tres = res_lo | ((uint64_t)res_hi << 32);\n\t}\n\n\tif (!(m & ((1ULL << 63) | (1ULL << 31)))) {\n\t\t/* there can't be any overflow here */\n\t\tres += (uint64_t)m_lo * n_hi;\n\t\tres += (uint64_t)m_hi * n_lo;\n\t\tres >>= 32;\n\t} else {\n\t\tres += (uint64_t)m_lo * n_hi;\n\t\ttmp = res >> 32;\n\t\tres += (uint64_t)m_hi * n_lo;\n\t\tres_lo = res >> 32;\n\t\tres_hi = (res_lo < tmp);\n\t\tres = res_lo | ((uint64_t)res_hi << 32);\n\t}\n\n\tres += (uint64_t)m_hi * n_hi;\n\n\treturn res;\n}\n#endif\n\n#ifndef __div64_32\nextern uint32_t __div64_32(uint64_t *dividend, uint32_t divisor);\n#endif\n\n/* The unnecessary pointer compare is there\n * to check for type safety (n must be 64bit)\n */\n# define do_div(n,base) ({\t\t\t\t\\\n\tuint32_t __base = (base);\t\t\t\\\n\tuint32_t __rem;\t\t\t\t\t\\\n\t(void)(((typeof((n)) *)0) == ((uint64_t *)0));\t\\\n\tif (__builtin_constant_p(__base) &&\t\t\\\n\t    is_power_of_2(__base)) {\t\t\t\\\n\t\t__rem = (n) & (__base - 1);\t\t\\\n\t\t(n) >>= ilog2(__base);\t\t\t\\\n\t} else if (__div64_const32_is_OK &&\t\t\\\n\t\t   __builtin_constant_p(__base) &&\t\\\n\t\t   __base != 0) {\t\t\t\\\n\t\tuint32_t __res_lo, __n_lo = (n);\t\\\n\t\t(n) = __div64_const32(n, __base);\t\\\n\t\t/* the remainder can be computed with 32-bit regs */ \\\n\t\t__res_lo = (n);\t\t\t\t\\\n\t\t__rem = __n_lo - __res_lo * __base;\t\\\n\t} else if (likely(((n) >> 32) == 0)) {\t\t\\\n\t\t__rem = (uint32_t)(n) % __base;\t\t\\\n\t\t(n) = (uint32_t)(n) / __base;\t\t\\\n\t} else \t\t\t\t\t\t\\\n\t\t__rem = __div64_32(&(n), __base);\t\\\n\t__rem;\t\t\t\t\t\t\\\n })\n\n#else /* BITS_PER_LONG == ?? */\n\n# error do_div() does not yet support the C64\n\n#endif /* BITS_PER_LONG */\n\n#endif /* _ASM_GENERIC_DIV64_H */\n"}, "5": {"id": 5, "path": "/src/include/asm-generic/bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _ASM_GENERIC_BUG_H\n#define _ASM_GENERIC_BUG_H\n\n#include <linux/compiler.h>\n#include <linux/instrumentation.h>\n\n#define CUT_HERE\t\t\"------------[ cut here ]------------\\n\"\n\n#ifdef CONFIG_GENERIC_BUG\n#define BUGFLAG_WARNING\t\t(1 << 0)\n#define BUGFLAG_ONCE\t\t(1 << 1)\n#define BUGFLAG_DONE\t\t(1 << 2)\n#define BUGFLAG_NO_CUT_HERE\t(1 << 3)\t/* CUT_HERE already sent */\n#define BUGFLAG_TAINT(taint)\t((taint) << 8)\n#define BUG_GET_TAINT(bug)\t((bug)->flags >> 8)\n#endif\n\n#ifndef __ASSEMBLY__\n#include <linux/kernel.h>\n\n#ifdef CONFIG_BUG\n\n#ifdef CONFIG_GENERIC_BUG\nstruct bug_entry {\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tunsigned long\tbug_addr;\n#else\n\tsigned int\tbug_addr_disp;\n#endif\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n#ifndef CONFIG_GENERIC_BUG_RELATIVE_POINTERS\n\tconst char\t*file;\n#else\n\tsigned int\tfile_disp;\n#endif\n\tunsigned short\tline;\n#endif\n\tunsigned short\tflags;\n};\n#endif\t/* CONFIG_GENERIC_BUG */\n\n/*\n * Don't use BUG() or BUG_ON() unless there's really no way out; one\n * example might be detecting data structure corruption in the middle\n * of an operation that can't be backed out of.  If the (sub)system\n * can somehow continue operating, perhaps with reduced functionality,\n * it's probably not BUG-worthy.\n *\n * If you're tempted to BUG(), think again:  is completely giving up\n * really the *only* solution?  There are usually better options, where\n * users don't need to reboot ASAP and can mostly shut down cleanly.\n */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do { \\\n\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n\tbarrier_before_unreachable(); \\\n\tpanic(\"BUG!\"); \\\n} while (0)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n/*\n * WARN(), WARN_ON(), WARN_ON_ONCE, and so on can be used to report\n * significant kernel issues that need prompt attention if they should ever\n * appear at runtime.\n *\n * Do not use these macros when checking for invalid external inputs\n * (e.g. invalid system call arguments, or invalid data coming from\n * network/devices), and on transient conditions like ENOMEM or EAGAIN.\n * These macros should be used for recoverable kernel issues only.\n * For invalid external inputs, transient conditions, etc use\n * pr_err[_once/_ratelimited]() followed by dump_stack(), if necessary.\n * Do not include \"BUG\"/\"WARNING\" in format strings manually to make these\n * conditions distinguishable from kernel issues.\n *\n * Use the versions with printk format strings to provide better diagnostics.\n */\n#ifndef __WARN_FLAGS\nextern __printf(4, 5)\nvoid warn_slowpath_fmt(const char *file, const int line, unsigned taint,\n\t\t       const char *fmt, ...);\n#define __WARN()\t\t__WARN_printf(TAINT_WARN, NULL)\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\twarn_slowpath_fmt(__FILE__, __LINE__, taint, arg);\t\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#else\nextern __printf(1, 2) void __warn_printk(const char *fmt, ...);\n#define __WARN()\t\t__WARN_FLAGS(BUGFLAG_TAINT(TAINT_WARN))\n#define __WARN_printf(taint, arg...) do {\t\t\t\t\\\n\t\tinstrumentation_begin();\t\t\t\t\\\n\t\t__warn_printk(arg);\t\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_NO_CUT_HERE | BUGFLAG_TAINT(taint));\\\n\t\tinstrumentation_end();\t\t\t\t\t\\\n\t} while (0)\n#define WARN_ON_ONCE(condition) ({\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\\\n\t\t__WARN_FLAGS(BUGFLAG_ONCE |\t\t\t\\\n\t\t\t     BUGFLAG_TAINT(TAINT_WARN));\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\\\n})\n#endif\n\n/* used internally by panic.c */\nstruct warn_args;\nstruct pt_regs;\n\nvoid __warn(const char *file, int line, void *caller, unsigned taint,\n\t    struct pt_regs *regs, struct warn_args *args);\n\n#ifndef WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN();\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(TAINT_WARN, format);\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_TAINT(condition, taint, format...) ({\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tif (unlikely(__ret_warn_on))\t\t\t\t\t\\\n\t\t__WARN_printf(taint, format);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n\n#ifndef WARN_ON_ONCE\n#define WARN_ON_ONCE(condition)\t({\t\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_ON(1);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n#endif\n\n#define WARN_ONCE(condition, format...)\t({\t\t\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN(1, format);\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#define WARN_TAINT_ONCE(condition, taint, format...)\t({\t\\\n\tstatic bool __section(\".data.once\") __warned;\t\t\\\n\tint __ret_warn_once = !!(condition);\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tif (unlikely(__ret_warn_once && !__warned)) {\t\t\\\n\t\t__warned = true;\t\t\t\t\\\n\t\tWARN_TAINT(1, taint, format);\t\t\t\\\n\t}\t\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_once);\t\t\t\t\\\n})\n\n#else /* !CONFIG_BUG */\n#ifndef HAVE_ARCH_BUG\n#define BUG() do {} while (1)\n#endif\n\n#ifndef HAVE_ARCH_BUG_ON\n#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)\n#endif\n\n#ifndef HAVE_ARCH_WARN_ON\n#define WARN_ON(condition) ({\t\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#ifndef WARN\n#define WARN(condition, format...) ({\t\t\t\t\t\\\n\tint __ret_warn_on = !!(condition);\t\t\t\t\\\n\tno_printk(format);\t\t\t\t\t\t\\\n\tunlikely(__ret_warn_on);\t\t\t\t\t\\\n})\n#endif\n\n#define WARN_ON_ONCE(condition) WARN_ON(condition)\n#define WARN_ONCE(condition, format...) WARN(condition, format)\n#define WARN_TAINT(condition, taint, format...) WARN(condition, format)\n#define WARN_TAINT_ONCE(condition, taint, format...) WARN(condition, format)\n\n#endif\n\n/*\n * WARN_ON_SMP() is for cases that the warning is either\n * meaningless for !SMP or may even cause failures.\n * It can also be used with values that are only defined\n * on SMP:\n *\n * struct foo {\n *  [...]\n * #ifdef CONFIG_SMP\n *\tint bar;\n * #endif\n * };\n *\n * void func(struct foo *zoot)\n * {\n *\tWARN_ON_SMP(!zoot->bar);\n *\n * For CONFIG_SMP, WARN_ON_SMP() should act the same as WARN_ON(),\n * and should be a nop and return false for uniprocessor.\n *\n * if (WARN_ON_SMP(x)) returns true only when CONFIG_SMP is set\n * and x is true.\n */\n#ifdef CONFIG_SMP\n# define WARN_ON_SMP(x)\t\t\tWARN_ON(x)\n#else\n/*\n * Use of ({0;}) because WARN_ON_SMP(x) may be used either as\n * a stand alone line statement or as a condition in an if ()\n * statement.\n * A simple \"0\" would cause gcc to give a \"statement has no effect\"\n * warning.\n */\n# define WARN_ON_SMP(x)\t\t\t({0;})\n#endif\n\n#endif /* __ASSEMBLY__ */\n\n#endif\n"}, "6": {"id": 6, "path": "/src/include/linux/list.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_LIST_H\n#define _LINUX_LIST_H\n\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/poison.h>\n#include <linux/const.h>\n#include <linux/kernel.h>\n\n/*\n * Circular doubly linked list implementation.\n *\n * Some of the internal functions (\"__xxx\") are useful when\n * manipulating whole lists rather than single entries, as\n * sometimes we already know the next/prev entries and we can\n * generate better code by using them directly rather than\n * using the generic single-entry routines.\n */\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n\tstruct list_head name = LIST_HEAD_INIT(name)\n\n/**\n * INIT_LIST_HEAD - Initialize a list_head structure\n * @list: list_head structure to be initialized.\n *\n * Initializes the list_head to point to itself.  If it is a list header,\n * the result is an empty list.\n */\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n\tWRITE_ONCE(list->next, list);\n\tlist->prev = list;\n}\n\n#ifdef CONFIG_DEBUG_LIST\nextern bool __list_add_valid(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next);\nextern bool __list_del_entry_valid(struct list_head *entry);\n#else\nstatic inline bool __list_add_valid(struct list_head *new,\n\t\t\t\tstruct list_head *prev,\n\t\t\t\tstruct list_head *next)\n{\n\treturn true;\n}\nstatic inline bool __list_del_entry_valid(struct list_head *entry)\n{\n\treturn true;\n}\n#endif\n\n/*\n * Insert a new entry between two known consecutive entries.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_add(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next)\n{\n\tif (!__list_add_valid(new, prev, next))\n\t\treturn;\n\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tWRITE_ONCE(prev->next, new);\n}\n\n/**\n * list_add - add a new entry\n * @new: new entry to be added\n * @head: list head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head, head->next);\n}\n\n\n/**\n * list_add_tail - add a new entry\n * @new: new entry to be added\n * @head: list head to add it before\n *\n * Insert a new entry before the specified head.\n * This is useful for implementing queues.\n */\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head->prev, head);\n}\n\n/*\n * Delete a list entry by making the prev/next entries\n * point to each other.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)\n{\n\tnext->prev = prev;\n\tWRITE_ONCE(prev->next, next);\n}\n\n/*\n * Delete a list entry and clear the 'prev' pointer.\n *\n * This is a special-purpose list clearing method used in the networking code\n * for lists allocated as per-cpu, where we don't want to incur the extra\n * WRITE_ONCE() overhead of a regular list_del_init(). The code that uses this\n * needs to check the node 'prev' pointer instead of calling list_empty().\n */\nstatic inline void __list_del_clearprev(struct list_head *entry)\n{\n\t__list_del(entry->prev, entry->next);\n\tentry->prev = NULL;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n\tif (!__list_del_entry_valid(entry))\n\t\treturn;\n\n\t__list_del(entry->prev, entry->next);\n}\n\n/**\n * list_del - deletes entry from list.\n * @entry: the element to delete from the list.\n * Note: list_empty() on entry does not return true after this, the entry is\n * in an undefined state.\n */\nstatic inline void list_del(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n\n/**\n * list_replace - replace old entry by new one\n * @old : the element to be replaced\n * @new : the new element to insert\n *\n * If @old was empty, it will be overwritten.\n */\nstatic inline void list_replace(struct list_head *old,\n\t\t\t\tstruct list_head *new)\n{\n\tnew->next = old->next;\n\tnew->next->prev = new;\n\tnew->prev = old->prev;\n\tnew->prev->next = new;\n}\n\n/**\n * list_replace_init - replace old entry by new one and initialize the old one\n * @old : the element to be replaced\n * @new : the new element to insert\n *\n * If @old was empty, it will be overwritten.\n */\nstatic inline void list_replace_init(struct list_head *old,\n\t\t\t\t     struct list_head *new)\n{\n\tlist_replace(old, new);\n\tINIT_LIST_HEAD(old);\n}\n\n/**\n * list_swap - replace entry1 with entry2 and re-add entry1 at entry2's position\n * @entry1: the location to place entry2\n * @entry2: the location to place entry1\n */\nstatic inline void list_swap(struct list_head *entry1,\n\t\t\t     struct list_head *entry2)\n{\n\tstruct list_head *pos = entry2->prev;\n\n\tlist_del(entry2);\n\tlist_replace(entry1, entry2);\n\tif (pos == entry1)\n\t\tpos = entry2;\n\tlist_add(entry1, pos);\n}\n\n/**\n * list_del_init - deletes entry from list and reinitialize it.\n * @entry: the element to delete from the list.\n */\nstatic inline void list_del_init(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tINIT_LIST_HEAD(entry);\n}\n\n/**\n * list_move - delete from one list and add as another's head\n * @list: the entry to move\n * @head: the head that will precede our entry\n */\nstatic inline void list_move(struct list_head *list, struct list_head *head)\n{\n\t__list_del_entry(list);\n\tlist_add(list, head);\n}\n\n/**\n * list_move_tail - delete from one list and add as another's tail\n * @list: the entry to move\n * @head: the head that will follow our entry\n */\nstatic inline void list_move_tail(struct list_head *list,\n\t\t\t\t  struct list_head *head)\n{\n\t__list_del_entry(list);\n\tlist_add_tail(list, head);\n}\n\n/**\n * list_bulk_move_tail - move a subsection of a list to its tail\n * @head: the head that will follow our entry\n * @first: first entry to move\n * @last: last entry to move, can be the same as first\n *\n * Move all entries between @first and including @last before @head.\n * All three entries must belong to the same linked list.\n */\nstatic inline void list_bulk_move_tail(struct list_head *head,\n\t\t\t\t       struct list_head *first,\n\t\t\t\t       struct list_head *last)\n{\n\tfirst->prev->next = last->next;\n\tlast->next->prev = first->prev;\n\n\thead->prev->next = first;\n\tfirst->prev = head->prev;\n\n\tlast->next = head;\n\thead->prev = last;\n}\n\n/**\n * list_is_first -- tests whether @list is the first entry in list @head\n * @list: the entry to test\n * @head: the head of the list\n */\nstatic inline int list_is_first(const struct list_head *list,\n\t\t\t\t\tconst struct list_head *head)\n{\n\treturn list->prev == head;\n}\n\n/**\n * list_is_last - tests whether @list is the last entry in list @head\n * @list: the entry to test\n * @head: the head of the list\n */\nstatic inline int list_is_last(const struct list_head *list,\n\t\t\t\tconst struct list_head *head)\n{\n\treturn list->next == head;\n}\n\n/**\n * list_empty - tests whether a list is empty\n * @head: the list to test.\n */\nstatic inline int list_empty(const struct list_head *head)\n{\n\treturn READ_ONCE(head->next) == head;\n}\n\n/**\n * list_del_init_careful - deletes entry from list and reinitialize it.\n * @entry: the element to delete from the list.\n *\n * This is the same as list_del_init(), except designed to be used\n * together with list_empty_careful() in a way to guarantee ordering\n * of other memory operations.\n *\n * Any memory operations done before a list_del_init_careful() are\n * guaranteed to be visible after a list_empty_careful() test.\n */\nstatic inline void list_del_init_careful(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tentry->prev = entry;\n\tsmp_store_release(&entry->next, entry);\n}\n\n/**\n * list_empty_careful - tests whether a list is empty and not being modified\n * @head: the list to test\n *\n * Description:\n * tests whether a list is empty _and_ checks that no other CPU might be\n * in the process of modifying either member (next or prev)\n *\n * NOTE: using list_empty_careful() without synchronization\n * can only be safe if the only activity that can happen\n * to the list entry is list_del_init(). Eg. it cannot be used\n * if another CPU could re-list_add() it.\n */\nstatic inline int list_empty_careful(const struct list_head *head)\n{\n\tstruct list_head *next = smp_load_acquire(&head->next);\n\treturn (next == head) && (next == head->prev);\n}\n\n/**\n * list_rotate_left - rotate the list to the left\n * @head: the head of the list\n */\nstatic inline void list_rotate_left(struct list_head *head)\n{\n\tstruct list_head *first;\n\n\tif (!list_empty(head)) {\n\t\tfirst = head->next;\n\t\tlist_move_tail(first, head);\n\t}\n}\n\n/**\n * list_rotate_to_front() - Rotate list to specific item.\n * @list: The desired new front of the list.\n * @head: The head of the list.\n *\n * Rotates list so that @list becomes the new front of the list.\n */\nstatic inline void list_rotate_to_front(struct list_head *list,\n\t\t\t\t\tstruct list_head *head)\n{\n\t/*\n\t * Deletes the list head from the list denoted by @head and\n\t * places it as the tail of @list, this effectively rotates the\n\t * list so that @list is at the front.\n\t */\n\tlist_move_tail(head, list);\n}\n\n/**\n * list_is_singular - tests whether a list has just one entry.\n * @head: the list to test.\n */\nstatic inline int list_is_singular(const struct list_head *head)\n{\n\treturn !list_empty(head) && (head->next == head->prev);\n}\n\nstatic inline void __list_cut_position(struct list_head *list,\n\t\tstruct list_head *head, struct list_head *entry)\n{\n\tstruct list_head *new_first = entry->next;\n\tlist->next = head->next;\n\tlist->next->prev = list;\n\tlist->prev = entry;\n\tentry->next = list;\n\thead->next = new_first;\n\tnew_first->prev = head;\n}\n\n/**\n * list_cut_position - cut a list into two\n * @list: a new list to add all removed entries\n * @head: a list with entries\n * @entry: an entry within head, could be the head itself\n *\tand if so we won't cut the list\n *\n * This helper moves the initial part of @head, up to and\n * including @entry, from @head to @list. You should\n * pass on @entry an element you know is on @head. @list\n * should be an empty list or a list you do not care about\n * losing its data.\n *\n */\nstatic inline void list_cut_position(struct list_head *list,\n\t\tstruct list_head *head, struct list_head *entry)\n{\n\tif (list_empty(head))\n\t\treturn;\n\tif (list_is_singular(head) &&\n\t\t(head->next != entry && head != entry))\n\t\treturn;\n\tif (entry == head)\n\t\tINIT_LIST_HEAD(list);\n\telse\n\t\t__list_cut_position(list, head, entry);\n}\n\n/**\n * list_cut_before - cut a list into two, before given entry\n * @list: a new list to add all removed entries\n * @head: a list with entries\n * @entry: an entry within head, could be the head itself\n *\n * This helper moves the initial part of @head, up to but\n * excluding @entry, from @head to @list.  You should pass\n * in @entry an element you know is on @head.  @list should\n * be an empty list or a list you do not care about losing\n * its data.\n * If @entry == @head, all entries on @head are moved to\n * @list.\n */\nstatic inline void list_cut_before(struct list_head *list,\n\t\t\t\t   struct list_head *head,\n\t\t\t\t   struct list_head *entry)\n{\n\tif (head->next == entry) {\n\t\tINIT_LIST_HEAD(list);\n\t\treturn;\n\t}\n\tlist->next = head->next;\n\tlist->next->prev = list;\n\tlist->prev = entry->prev;\n\tlist->prev->next = list;\n\thead->next = entry;\n\tentry->prev = head;\n}\n\nstatic inline void __list_splice(const struct list_head *list,\n\t\t\t\t struct list_head *prev,\n\t\t\t\t struct list_head *next)\n{\n\tstruct list_head *first = list->next;\n\tstruct list_head *last = list->prev;\n\n\tfirst->prev = prev;\n\tprev->next = first;\n\n\tlast->next = next;\n\tnext->prev = last;\n}\n\n/**\n * list_splice - join two lists, this is designed for stacks\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n */\nstatic inline void list_splice(const struct list_head *list,\n\t\t\t\tstruct list_head *head)\n{\n\tif (!list_empty(list))\n\t\t__list_splice(list, head, head->next);\n}\n\n/**\n * list_splice_tail - join two lists, each list being a queue\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n */\nstatic inline void list_splice_tail(struct list_head *list,\n\t\t\t\tstruct list_head *head)\n{\n\tif (!list_empty(list))\n\t\t__list_splice(list, head->prev, head);\n}\n\n/**\n * list_splice_init - join two lists and reinitialise the emptied list.\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n *\n * The list at @list is reinitialised\n */\nstatic inline void list_splice_init(struct list_head *list,\n\t\t\t\t    struct list_head *head)\n{\n\tif (!list_empty(list)) {\n\t\t__list_splice(list, head, head->next);\n\t\tINIT_LIST_HEAD(list);\n\t}\n}\n\n/**\n * list_splice_tail_init - join two lists and reinitialise the emptied list\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n *\n * Each of the lists is a queue.\n * The list at @list is reinitialised\n */\nstatic inline void list_splice_tail_init(struct list_head *list,\n\t\t\t\t\t struct list_head *head)\n{\n\tif (!list_empty(list)) {\n\t\t__list_splice(list, head->prev, head);\n\t\tINIT_LIST_HEAD(list);\n\t}\n}\n\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n/**\n * list_first_entry - get the first element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_first_entry(ptr, type, member) \\\n\tlist_entry((ptr)->next, type, member)\n\n/**\n * list_last_entry - get the last element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_last_entry(ptr, type, member) \\\n\tlist_entry((ptr)->prev, type, member)\n\n/**\n * list_first_entry_or_null - get the first element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n *\n * Note that if the list is empty, it returns NULL.\n */\n#define list_first_entry_or_null(ptr, type, member) ({ \\\n\tstruct list_head *head__ = (ptr); \\\n\tstruct list_head *pos__ = READ_ONCE(head__->next); \\\n\tpos__ != head__ ? list_entry(pos__, type, member) : NULL; \\\n})\n\n/**\n * list_next_entry - get the next element in list\n * @pos:\tthe type * to cursor\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_next_entry(pos, member) \\\n\tlist_entry((pos)->member.next, typeof(*(pos)), member)\n\n/**\n * list_prev_entry - get the prev element in list\n * @pos:\tthe type * to cursor\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_prev_entry(pos, member) \\\n\tlist_entry((pos)->member.prev, typeof(*(pos)), member)\n\n/**\n * list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each(pos, head) \\\n\tfor (pos = (head)->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_continue - continue iteration over a list\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n *\n * Continue to iterate over a list, continuing after the current position.\n */\n#define list_for_each_continue(pos, head) \\\n\tfor (pos = pos->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_prev\t-\titerate over a list backwards\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev(pos, head) \\\n\tfor (pos = (head)->prev; pos != (head); pos = pos->prev)\n\n/**\n * list_for_each_safe - iterate over a list safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->next, n = pos->next; pos != (head); \\\n\t\tpos = n, n = pos->next)\n\n/**\n * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev_safe(pos, n, head) \\\n\tfor (pos = (head)->prev, n = pos->prev; \\\n\t     pos != (head); \\\n\t     pos = n, n = pos->prev)\n\n/**\n * list_entry_is_head - test if the entry points to the head of the list\n * @pos:\tthe type * to cursor\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_entry_is_head(pos, head, member)\t\t\t\t\\\n\t(&pos->member == (head))\n\n/**\n * list_for_each_entry\t-\titerate over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member);\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_reverse - iterate backwards over list of given type.\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_for_each_entry_reverse(pos, head, member)\t\t\t\\\n\tfor (pos = list_last_entry(head, typeof(*pos), member);\t\t\\\n\t     !list_entry_is_head(pos, head, member); \t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()\n * @pos:\tthe type * to use as a start point\n * @head:\tthe head of the list\n * @member:\tthe name of the list_head within the struct.\n *\n * Prepares a pos entry for use as a start point in list_for_each_entry_continue().\n */\n#define list_prepare_entry(pos, head, member) \\\n\t((pos) ? : list_entry(head, typeof(*pos), member))\n\n/**\n * list_for_each_entry_continue - continue iteration over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Continue to iterate over list of given type, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue(pos, head, member) \t\t\\\n\tfor (pos = list_next_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_continue_reverse - iterate backwards from the given point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Start to iterate over list of given type backwards, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue_reverse(pos, head, member)\t\t\\\n\tfor (pos = list_prev_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_for_each_entry_from - iterate over list of given type from the current point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate over list of given type, continuing from current position.\n */\n#define list_for_each_entry_from(pos, head, member) \t\t\t\\\n\tfor (; !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_from_reverse - iterate backwards over list of given type\n *                                    from the current point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate backwards over list of given type, continuing from current position.\n */\n#define list_for_each_entry_from_reverse(pos, head, member)\t\t\\\n\tfor (; !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_for_each_entry_safe(pos, n, head, member)\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member),\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member); \t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_continue - continue list iteration safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate over list of given type, continuing after current point,\n * safe against removal of list entry.\n */\n#define list_for_each_entry_safe_continue(pos, n, head, member) \t\t\\\n\tfor (pos = list_next_entry(pos, member), \t\t\t\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_from - iterate over list from current point safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate over list of given type from current point, safe against\n * removal of list entry.\n */\n#define list_for_each_entry_safe_from(pos, n, head, member) \t\t\t\\\n\tfor (n = list_next_entry(pos, member);\t\t\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_reverse - iterate backwards over list safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate backwards over list of given type, safe against removal\n * of list entry.\n */\n#define list_for_each_entry_safe_reverse(pos, n, head, member)\t\t\\\n\tfor (pos = list_last_entry(head, typeof(*pos), member),\t\t\\\n\t\tn = list_prev_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member); \t\t\t\\\n\t     pos = n, n = list_prev_entry(n, member))\n\n/**\n * list_safe_reset_next - reset a stale list_for_each_entry_safe loop\n * @pos:\tthe loop cursor used in the list_for_each_entry_safe loop\n * @n:\t\ttemporary storage used in list_for_each_entry_safe\n * @member:\tthe name of the list_head within the struct.\n *\n * list_safe_reset_next is not safe to use in general if the list may be\n * modified concurrently (eg. the lock is dropped in the loop body). An\n * exception to this is if the cursor element (pos) is pinned in the list,\n * and list_safe_reset_next is called after re-taking the lock and before\n * completing the current iteration of the loop body.\n */\n#define list_safe_reset_next(pos, n, member)\t\t\t\t\\\n\tn = list_next_entry(pos, member)\n\n/*\n * Double linked lists with a single pointer list head.\n * Mostly useful for hash tables where the two pointer list head is\n * too wasteful.\n * You lose the ability to access the tail in O(1).\n */\n\n#define HLIST_HEAD_INIT { .first = NULL }\n#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }\n#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)\nstatic inline void INIT_HLIST_NODE(struct hlist_node *h)\n{\n\th->next = NULL;\n\th->pprev = NULL;\n}\n\n/**\n * hlist_unhashed - Has node been removed from list and reinitialized?\n * @h: Node to be checked\n *\n * Not that not all removal functions will leave a node in unhashed\n * state.  For example, hlist_nulls_del_init_rcu() does leave the\n * node in unhashed state, but hlist_nulls_del() does not.\n */\nstatic inline int hlist_unhashed(const struct hlist_node *h)\n{\n\treturn !h->pprev;\n}\n\n/**\n * hlist_unhashed_lockless - Version of hlist_unhashed for lockless use\n * @h: Node to be checked\n *\n * This variant of hlist_unhashed() must be used in lockless contexts\n * to avoid potential load-tearing.  The READ_ONCE() is paired with the\n * various WRITE_ONCE() in hlist helpers that are defined below.\n */\nstatic inline int hlist_unhashed_lockless(const struct hlist_node *h)\n{\n\treturn !READ_ONCE(h->pprev);\n}\n\n/**\n * hlist_empty - Is the specified hlist_head structure an empty hlist?\n * @h: Structure to check.\n */\nstatic inline int hlist_empty(const struct hlist_head *h)\n{\n\treturn !READ_ONCE(h->first);\n}\n\nstatic inline void __hlist_del(struct hlist_node *n)\n{\n\tstruct hlist_node *next = n->next;\n\tstruct hlist_node **pprev = n->pprev;\n\n\tWRITE_ONCE(*pprev, next);\n\tif (next)\n\t\tWRITE_ONCE(next->pprev, pprev);\n}\n\n/**\n * hlist_del - Delete the specified hlist_node from its list\n * @n: Node to delete.\n *\n * Note that this function leaves the node in hashed state.  Use\n * hlist_del_init() or similar instead to unhash @n.\n */\nstatic inline void hlist_del(struct hlist_node *n)\n{\n\t__hlist_del(n);\n\tn->next = LIST_POISON1;\n\tn->pprev = LIST_POISON2;\n}\n\n/**\n * hlist_del_init - Delete the specified hlist_node from its list and initialize\n * @n: Node to delete.\n *\n * Note that this function leaves the node in unhashed state.\n */\nstatic inline void hlist_del_init(struct hlist_node *n)\n{\n\tif (!hlist_unhashed(n)) {\n\t\t__hlist_del(n);\n\t\tINIT_HLIST_NODE(n);\n\t}\n}\n\n/**\n * hlist_add_head - add a new entry at the beginning of the hlist\n * @n: new entry to be added\n * @h: hlist head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)\n{\n\tstruct hlist_node *first = h->first;\n\tWRITE_ONCE(n->next, first);\n\tif (first)\n\t\tWRITE_ONCE(first->pprev, &n->next);\n\tWRITE_ONCE(h->first, n);\n\tWRITE_ONCE(n->pprev, &h->first);\n}\n\n/**\n * hlist_add_before - add a new entry before the one specified\n * @n: new entry to be added\n * @next: hlist node to add it before, which must be non-NULL\n */\nstatic inline void hlist_add_before(struct hlist_node *n,\n\t\t\t\t    struct hlist_node *next)\n{\n\tWRITE_ONCE(n->pprev, next->pprev);\n\tWRITE_ONCE(n->next, next);\n\tWRITE_ONCE(next->pprev, &n->next);\n\tWRITE_ONCE(*(n->pprev), n);\n}\n\n/**\n * hlist_add_behind - add a new entry after the one specified\n * @n: new entry to be added\n * @prev: hlist node to add it after, which must be non-NULL\n */\nstatic inline void hlist_add_behind(struct hlist_node *n,\n\t\t\t\t    struct hlist_node *prev)\n{\n\tWRITE_ONCE(n->next, prev->next);\n\tWRITE_ONCE(prev->next, n);\n\tWRITE_ONCE(n->pprev, &prev->next);\n\n\tif (n->next)\n\t\tWRITE_ONCE(n->next->pprev, &n->next);\n}\n\n/**\n * hlist_add_fake - create a fake hlist consisting of a single headless node\n * @n: Node to make a fake list out of\n *\n * This makes @n appear to be its own predecessor on a headless hlist.\n * The point of this is to allow things like hlist_del() to work correctly\n * in cases where there is no list.\n */\nstatic inline void hlist_add_fake(struct hlist_node *n)\n{\n\tn->pprev = &n->next;\n}\n\n/**\n * hlist_fake: Is this node a fake hlist?\n * @h: Node to check for being a self-referential fake hlist.\n */\nstatic inline bool hlist_fake(struct hlist_node *h)\n{\n\treturn h->pprev == &h->next;\n}\n\n/**\n * hlist_is_singular_node - is node the only element of the specified hlist?\n * @n: Node to check for singularity.\n * @h: Header for potentially singular list.\n *\n * Check whether the node is the only node of the head without\n * accessing head, thus avoiding unnecessary cache misses.\n */\nstatic inline bool\nhlist_is_singular_node(struct hlist_node *n, struct hlist_head *h)\n{\n\treturn !n->next && n->pprev == &h->first;\n}\n\n/**\n * hlist_move_list - Move an hlist\n * @old: hlist_head for old list.\n * @new: hlist_head for new list.\n *\n * Move a list from one list head to another. Fixup the pprev\n * reference of the first entry if it exists.\n */\nstatic inline void hlist_move_list(struct hlist_head *old,\n\t\t\t\t   struct hlist_head *new)\n{\n\tnew->first = old->first;\n\tif (new->first)\n\t\tnew->first->pprev = &new->first;\n\told->first = NULL;\n}\n\n#define hlist_entry(ptr, type, member) container_of(ptr,type,member)\n\n#define hlist_for_each(pos, head) \\\n\tfor (pos = (head)->first; pos ; pos = pos->next)\n\n#define hlist_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->first; pos && ({ n = pos->next; 1; }); \\\n\t     pos = n)\n\n#define hlist_entry_safe(ptr, type, member) \\\n\t({ typeof(ptr) ____ptr = (ptr); \\\n\t   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \\\n\t})\n\n/**\n * hlist_for_each_entry\t- iterate over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\\\n\t     pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\n\n/**\n * hlist_for_each_entry_continue - iterate over a hlist continuing after current point\n * @pos:\tthe type * to use as a loop cursor.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry_continue(pos, member)\t\t\t\\\n\tfor (pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member);\\\n\t     pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\n\n/**\n * hlist_for_each_entry_from - iterate over a hlist continuing from current point\n * @pos:\tthe type * to use as a loop cursor.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry_from(pos, member)\t\t\t\t\\\n\tfor (; pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\n\n/**\n * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\ta &struct hlist_node to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry_safe(pos, n, head, member) \t\t\\\n\tfor (pos = hlist_entry_safe((head)->first, typeof(*pos), member);\\\n\t     pos && ({ n = pos->member.next; 1; });\t\t\t\\\n\t     pos = hlist_entry_safe(n, typeof(*pos), member))\n\n#endif\n"}, "7": {"id": 7, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n#include <linux/static_call_types.h>\n#include <asm/byteorder.h>\n\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\n\nextern int __cond_resched(void);\n# define might_resched() __cond_resched()\n\n#elif defined(CONFIG_PREEMPT_DYNAMIC)\n\nextern int __cond_resched(void);\n\nDECLARE_STATIC_CALL(might_resched, __cond_resched);\n\nstatic __always_inline void might_resched(void)\n{\n\tstatic_call_mod(might_resched)();\n}\n\n#else\n\n# define might_resched() do { } while (0)\n\n#endif /* CONFIG_PREEMPT_* */\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_migrate(const char *file, int line);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n\n/**\n * cant_migrate - annotation for functions that cannot migrate\n *\n * Will print a stack trace if executed in code which is migratable\n */\n# define cant_migrate()\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (IS_ENABLED(CONFIG_SMP))\t\t\t\t\\\n\t\t\t__cant_migrate(__FILE__, __LINE__);\t\t\\\n\t} while (0)\n\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define cant_migrate()\t\tdo { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_max_rcu_stall_to_panic;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 2, "file": 0, "line": 2932}, "message": "'res.nh' initialized to a null pointer value"}, {"location": {"col": 6, "file": 0, "line": 2945}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 2945}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 2961}, "message": "Left side of '||' is false"}, {"location": {"col": 12, "file": 1, "line": 233}, "message": "expanded from macro 'for_each_fib6_node_rt_rcu'"}, {"location": {"col": 28, "file": 2, "line": 571}, "message": "expanded from macro 'rcu_dereference'"}, {"location": {"col": 2, "file": 2, "line": 513}, "message": "expanded from macro 'rcu_dereference_check'"}, {"location": {"col": 27, "file": 0, "line": 1192}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/net/ipv6/route.c", "reportHash": "fa63700d17c51535c19f5b04de159230", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 0, "line": 3598}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3598}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3604}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3604}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3609}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3609}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3614}, "message": "Assuming field 'fc_dst_len' is <= 128"}, {"location": {"col": 2, "file": 0, "line": 3614}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3618}, "message": "Assuming field 'fc_src_len' is <= 128"}, {"location": {"col": 2, "file": 0, "line": 3618}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3623}, "message": "Assuming field 'fc_src_len' is 0"}, {"location": {"col": 2, "file": 0, "line": 3623}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3629}, "message": "Assuming field 'fc_nh_id' is 0"}, {"location": {"col": 2, "file": 0, "line": 3629}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3641}, "message": "Assuming field 'nlh' is null"}, {"location": {"col": 25, "file": 0, "line": 3641}, "message": "Left side of '&&' is false"}, {"location": {"col": 6, "file": 0, "line": 3652}, "message": "Assuming 'table' is non-null"}, {"location": {"col": 2, "file": 0, "line": 3652}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3657}, "message": "Assuming 'rt' is non-null"}, {"location": {"col": 2, "file": 0, "line": 3657}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 3662}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3669}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3669}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3672}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3672}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3678}, "message": "Assuming field 'fc_protocol' is not equal to RTPROT_UNSPEC"}, {"location": {"col": 2, "file": 0, "line": 3678}, "message": "Taking false branch"}, {"location": {"col": 18, "file": 0, "line": 3684}, "message": "'?' condition is true"}, {"location": {"col": 6, "file": 0, "line": 3694}, "message": "'nh' is null"}, {"location": {"col": 2, "file": 0, "line": 3694}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 0, "line": 3706}, "message": "Calling 'fib6_nh_init'"}, {"location": {"col": 2, "file": 0, "line": 3425}, "message": "'dev' initialized to a null pointer value"}, {"location": {"col": 6, "file": 0, "line": 3434}, "message": "Assuming field 'fc_is_fdb' is false"}, {"location": {"col": 2, "file": 0, "line": 3434}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3441}, "message": "Assuming field 'fc_ifindex' is 0"}, {"location": {"col": 2, "file": 0, "line": 3441}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3450}, "message": "Assuming the condition is false"}, {"location": {"col": 2, "file": 0, "line": 3450}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 3472}, "message": "Calling 'fib6_is_reject'"}, {"location": {"col": 7, "file": 0, "line": 3412}, "message": "Assuming the condition is true"}, {"location": {"col": 27, "file": 0, "line": 3412}, "message": "Left side of '||' is true"}, {"location": {"col": 3, "file": 0, "line": 3416}, "message": "Returning the value 1, which participates in a condition later"}, {"location": {"col": 6, "file": 0, "line": 3472}, "message": "Returning from 'fib6_is_reject'"}, {"location": {"col": 2, "file": 0, "line": 3472}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 0, "line": 3474}, "message": "Assuming 'dev' is equal to field 'loopback_dev'"}, {"location": {"col": 3, "file": 0, "line": 3474}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 3487}, "message": "Control jumps to line 3525"}, {"location": {"col": 6, "file": 0, "line": 3526}, "message": "Assuming field 'rt6i_pcpu' is non-null"}, {"location": {"col": 2, "file": 0, "line": 3526}, "message": "Taking false branch"}, {"location": {"col": 24, "file": 0, "line": 3532}, "message": "Access to field 'ifindex' results in a dereference of a null pointer (loaded from variable 'dev')"}, {"location": {"col": 24, "file": 0, "line": 3532}, "message": "Access to field 'ifindex' results in a dereference of a null pointer (loaded from variable 'dev')"}], "macros": [], "notes": [], "path": "/src/net/ipv6/route.c", "reportHash": "ccd45a059449fc02c87e4d750b6a4e75", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 2, "file": 3, "line": 104}, "message": "expanded from macro 'DIV_ROUND_CLOSEST_ULL'"}, {"location": {"col": 26, "file": 4, "line": 46}, "message": "expanded from macro 'do_div'"}, {"location": {"col": 6, "file": 0, "line": 4736}, "message": "Assuming 'rt' is not equal to field 'fib6_null_entry'"}, {"location": {"col": 6, "file": 0, "line": 4736}, "message": "Left side of '||' is false"}, {"location": {"col": 41, "file": 0, "line": 4736}, "message": "Assuming field 'nh' is null"}, {"location": {"col": 2, "file": 0, "line": 4736}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 4739}, "message": "Control jumps to 'case NETDEV_CHANGE:'  at line 4761"}, {"location": {"col": 7, "file": 0, "line": 4762}, "message": "Assuming 'dev' is equal to field 'nhc_dev'"}, {"location": {"col": 7, "file": 0, "line": 4762}, "message": "Left side of '||' is false"}, {"location": {"col": 7, "file": 0, "line": 4763}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 0, "line": 4762}, "message": "Taking false branch"}, {"location": {"col": 3, "file": 0, "line": 4766}, "message": "Calling 'rt6_multipath_rebalance'"}, {"location": {"col": 6, "file": 0, "line": 4630}, "message": "Assuming field 'fib6_nsiblings' is not equal to 0"}, {"location": {"col": 6, "file": 0, "line": 4630}, "message": "Left side of '||' is false"}, {"location": {"col": 29, "file": 0, "line": 4630}, "message": "Assuming field 'should_flush' is 0"}, {"location": {"col": 2, "file": 0, "line": 4630}, "message": "Taking false branch"}, {"location": {"col": 20, "file": 0, "line": 4638}, "message": "'first' is non-null"}, {"location": {"col": 25, "file": 5, "line": 102}, "message": "expanded from macro 'WARN_ON_ONCE'"}, {"location": {"col": 6, "file": 0, "line": 4638}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 5, "line": 103}, "message": "expanded from macro 'WARN_ON_ONCE'"}, {"location": {"col": 2, "file": 0, "line": 4638}, "message": "Taking false branch"}, {"location": {"col": 10, "file": 0, "line": 4641}, "message": "Calling 'rt6_multipath_total_weight'"}, {"location": {"col": 2, "file": 0, "line": 4585}, "message": "'total' initialized to 0"}, {"location": {"col": 2, "file": 0, "line": 4587}, "message": "Taking false branch"}, {"location": {"col": 2, "file": 0, "line": 4590}, "message": "Left side of '&&' is false"}, {"location": {"col": 13, "file": 6, "line": 628}, "message": "expanded from macro 'list_for_each_entry'"}, {"location": {"col": 2, "file": 6, "line": 522}, "message": "expanded from macro 'list_first_entry'"}, {"location": {"col": 2, "file": 6, "line": 511}, "message": "expanded from macro 'list_entry'"}, {"location": {"col": 61, "file": 7, "line": 709}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 2, "file": 0, "line": 4590}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 6, "line": 628}, "message": "expanded from macro 'list_for_each_entry'"}, {"location": {"col": 2, "file": 6, "line": 522}, "message": "expanded from macro 'list_first_entry'"}, {"location": {"col": 2, "file": 6, "line": 511}, "message": "expanded from macro 'list_entry'"}, {"location": {"col": 17, "file": 0, "line": 4604}, "message": "Division by zero"}], "macros": [], "notes": [], "path": "/src/net/ipv6/route.c", "reportHash": "4eb906fef2c1c495d87a802541436c4a", "checkerName": "clang-analyzer-core.DivideZero", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 11, "file": 0, "line": 5799}, "message": "Although the value stored to 'count' is used in the enclosing expression, the value is never actually read from 'count'"}, {"location": {"col": 11, "file": 0, "line": 5799}, "message": "Although the value stored to 'count' is used in the enclosing expression, the value is never actually read from 'count'"}], "macros": [], "notes": [], "path": "/src/net/ipv6/route.c", "reportHash": "16ccd2798591d961ad26c7e8f02928d4", "checkerName": "clang-analyzer-deadcode.DeadStores", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
