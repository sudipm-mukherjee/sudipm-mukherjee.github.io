<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/broadcom/tg3.c", "content": "/*\n * tg3.c: Broadcom Tigon3 ethernet driver.\n *\n * Copyright (C) 2001, 2002, 2003, 2004 David S. Miller (davem@redhat.com)\n * Copyright (C) 2001, 2002, 2003 Jeff Garzik (jgarzik@pobox.com)\n * Copyright (C) 2004 Sun Microsystems Inc.\n * Copyright (C) 2005-2016 Broadcom Corporation.\n * Copyright (C) 2016-2017 Broadcom Limited.\n * Copyright (C) 2018 Broadcom. All Rights Reserved. The term \"Broadcom\"\n * refers to Broadcom Inc. and/or its subsidiaries.\n *\n * Firmware is:\n *\tDerived from proprietary unpublished source code,\n *\tCopyright (C) 2000-2016 Broadcom Corporation.\n *\tCopyright (C) 2016-2017 Broadcom Ltd.\n *\tCopyright (C) 2018 Broadcom. All Rights Reserved. The term \"Broadcom\"\n *\trefers to Broadcom Inc. and/or its subsidiaries.\n *\n *\tPermission is hereby granted for the distribution of this firmware\n *\tdata in hexadecimal or equivalent format, provided this copyright\n *\tnotice is accompanying it.\n */\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/stringify.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/ethtool.h>\n#include <linux/mdio.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/brcmphy.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/workqueue.h>\n#include <linux/prefetch.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/ssb/ssb_driver_gige.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include <linux/crc32poly.h>\n\n#include <net/checksum.h>\n#include <net/ip.h>\n\n#include <linux/io.h>\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n\n#include <uapi/linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n\n#define BAR_0\t0\n#define BAR_2\t2\n\n#include \"tg3.h\"\n\n/* Functions & macros to verify TG3_FLAGS types */\n\nstatic inline int _tg3_flag(enum TG3_FLAGS flag, unsigned long *bits)\n{\n\treturn test_bit(flag, bits);\n}\n\nstatic inline void _tg3_flag_set(enum TG3_FLAGS flag, unsigned long *bits)\n{\n\tset_bit(flag, bits);\n}\n\nstatic inline void _tg3_flag_clear(enum TG3_FLAGS flag, unsigned long *bits)\n{\n\tclear_bit(flag, bits);\n}\n\n#define tg3_flag(tp, flag)\t\t\t\t\\\n\t_tg3_flag(TG3_FLAG_##flag, (tp)->tg3_flags)\n#define tg3_flag_set(tp, flag)\t\t\t\t\\\n\t_tg3_flag_set(TG3_FLAG_##flag, (tp)->tg3_flags)\n#define tg3_flag_clear(tp, flag)\t\t\t\\\n\t_tg3_flag_clear(TG3_FLAG_##flag, (tp)->tg3_flags)\n\n#define DRV_MODULE_NAME\t\t\"tg3\"\n/* DO NOT UPDATE TG3_*_NUM defines */\n#define TG3_MAJ_NUM\t\t\t3\n#define TG3_MIN_NUM\t\t\t137\n\n#define RESET_KIND_SHUTDOWN\t0\n#define RESET_KIND_INIT\t\t1\n#define RESET_KIND_SUSPEND\t2\n\n#define TG3_DEF_RX_MODE\t\t0\n#define TG3_DEF_TX_MODE\t\t0\n#define TG3_DEF_MSG_ENABLE\t  \\\n\t(NETIF_MSG_DRV\t\t| \\\n\t NETIF_MSG_PROBE\t| \\\n\t NETIF_MSG_LINK\t\t| \\\n\t NETIF_MSG_TIMER\t| \\\n\t NETIF_MSG_IFDOWN\t| \\\n\t NETIF_MSG_IFUP\t\t| \\\n\t NETIF_MSG_RX_ERR\t| \\\n\t NETIF_MSG_TX_ERR)\n\n#define TG3_GRC_LCLCTL_PWRSW_DELAY\t100\n\n/* length of time before we decide the hardware is borked,\n * and dev->tx_timeout() should be called to fix the problem\n */\n\n#define TG3_TX_TIMEOUT\t\t\t(5 * HZ)\n\n/* hardware minimum and maximum for a single frame's data payload */\n#define TG3_MIN_MTU\t\t\tETH_ZLEN\n#define TG3_MAX_MTU(tp)\t\\\n\t(tg3_flag(tp, JUMBO_CAPABLE) ? 9000 : 1500)\n\n/* These numbers seem to be hard coded in the NIC firmware somehow.\n * You can't change the ring sizes, but you can change where you place\n * them in the NIC onboard memory.\n */\n#define TG3_RX_STD_RING_SIZE(tp) \\\n\t(tg3_flag(tp, LRG_PROD_RING_CAP) ? \\\n\t TG3_RX_STD_MAX_SIZE_5717 : TG3_RX_STD_MAX_SIZE_5700)\n#define TG3_DEF_RX_RING_PENDING\t\t200\n#define TG3_RX_JMB_RING_SIZE(tp) \\\n\t(tg3_flag(tp, LRG_PROD_RING_CAP) ? \\\n\t TG3_RX_JMB_MAX_SIZE_5717 : TG3_RX_JMB_MAX_SIZE_5700)\n#define TG3_DEF_RX_JUMBO_RING_PENDING\t100\n\n/* Do not place this n-ring entries value into the tp struct itself,\n * we really want to expose these constants to GCC so that modulo et\n * al.  operations are done with shifts and masks instead of with\n * hw multiply/modulo instructions.  Another solution would be to\n * replace things like '% foo' with '& (foo - 1)'.\n */\n\n#define TG3_TX_RING_SIZE\t\t512\n#define TG3_DEF_TX_RING_PENDING\t\t(TG3_TX_RING_SIZE - 1)\n\n#define TG3_RX_STD_RING_BYTES(tp) \\\n\t(sizeof(struct tg3_rx_buffer_desc) * TG3_RX_STD_RING_SIZE(tp))\n#define TG3_RX_JMB_RING_BYTES(tp) \\\n\t(sizeof(struct tg3_ext_rx_buffer_desc) * TG3_RX_JMB_RING_SIZE(tp))\n#define TG3_RX_RCB_RING_BYTES(tp) \\\n\t(sizeof(struct tg3_rx_buffer_desc) * (tp->rx_ret_ring_mask + 1))\n#define TG3_TX_RING_BYTES\t(sizeof(struct tg3_tx_buffer_desc) * \\\n\t\t\t\t TG3_TX_RING_SIZE)\n#define NEXT_TX(N)\t\t(((N) + 1) & (TG3_TX_RING_SIZE - 1))\n\n#define TG3_DMA_BYTE_ENAB\t\t64\n\n#define TG3_RX_STD_DMA_SZ\t\t1536\n#define TG3_RX_JMB_DMA_SZ\t\t9046\n\n#define TG3_RX_DMA_TO_MAP_SZ(x)\t\t((x) + TG3_DMA_BYTE_ENAB)\n\n#define TG3_RX_STD_MAP_SZ\t\tTG3_RX_DMA_TO_MAP_SZ(TG3_RX_STD_DMA_SZ)\n#define TG3_RX_JMB_MAP_SZ\t\tTG3_RX_DMA_TO_MAP_SZ(TG3_RX_JMB_DMA_SZ)\n\n#define TG3_RX_STD_BUFF_RING_SIZE(tp) \\\n\t(sizeof(struct ring_info) * TG3_RX_STD_RING_SIZE(tp))\n\n#define TG3_RX_JMB_BUFF_RING_SIZE(tp) \\\n\t(sizeof(struct ring_info) * TG3_RX_JMB_RING_SIZE(tp))\n\n/* Due to a hardware bug, the 5701 can only DMA to memory addresses\n * that are at least dword aligned when used in PCIX mode.  The driver\n * works around this bug by double copying the packet.  This workaround\n * is built into the normal double copy length check for efficiency.\n *\n * However, the double copy is only necessary on those architectures\n * where unaligned memory accesses are inefficient.  For those architectures\n * where unaligned memory accesses incur little penalty, we can reintegrate\n * the 5701 in the normal rx path.  Doing so saves a device structure\n * dereference by hardcoding the double copy threshold in place.\n */\n#define TG3_RX_COPY_THRESHOLD\t\t256\n#if NET_IP_ALIGN == 0 || defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\n\t#define TG3_RX_COPY_THRESH(tp)\tTG3_RX_COPY_THRESHOLD\n#else\n\t#define TG3_RX_COPY_THRESH(tp)\t((tp)->rx_copy_thresh)\n#endif\n\n#if (NET_IP_ALIGN != 0)\n#define TG3_RX_OFFSET(tp)\t((tp)->rx_offset)\n#else\n#define TG3_RX_OFFSET(tp)\t(NET_SKB_PAD)\n#endif\n\n/* minimum number of free TX descriptors required to wake up TX process */\n#define TG3_TX_WAKEUP_THRESH(tnapi)\t\t((tnapi)->tx_pending / 4)\n#define TG3_TX_BD_DMA_MAX_2K\t\t2048\n#define TG3_TX_BD_DMA_MAX_4K\t\t4096\n\n#define TG3_RAW_IP_ALIGN 2\n\n#define TG3_MAX_UCAST_ADDR(tp) (tg3_flag((tp), ENABLE_ASF) ? 2 : 3)\n#define TG3_UCAST_ADDR_IDX(tp) (tg3_flag((tp), ENABLE_ASF) ? 2 : 1)\n\n#define TG3_FW_UPDATE_TIMEOUT_SEC\t5\n#define TG3_FW_UPDATE_FREQ_SEC\t\t(TG3_FW_UPDATE_TIMEOUT_SEC / 2)\n\n#define FIRMWARE_TG3\t\t\"tigon/tg3.bin\"\n#define FIRMWARE_TG357766\t\"tigon/tg357766.bin\"\n#define FIRMWARE_TG3TSO\t\t\"tigon/tg3_tso.bin\"\n#define FIRMWARE_TG3TSO5\t\"tigon/tg3_tso5.bin\"\n\nMODULE_AUTHOR(\"David S. Miller (davem@redhat.com) and Jeff Garzik (jgarzik@pobox.com)\");\nMODULE_DESCRIPTION(\"Broadcom Tigon3 ethernet driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_TG3);\nMODULE_FIRMWARE(FIRMWARE_TG3TSO);\nMODULE_FIRMWARE(FIRMWARE_TG3TSO5);\n\nstatic int tg3_debug = -1;\t/* -1 == use TG3_DEF_MSG_ENABLE as value */\nmodule_param(tg3_debug, int, 0);\nMODULE_PARM_DESC(tg3_debug, \"Tigon3 bitmapped debugging message enable value\");\n\n#define TG3_DRV_DATA_FLAG_10_100_ONLY\t0x0001\n#define TG3_DRV_DATA_FLAG_5705_10_100\t0x0002\n\nstatic const struct pci_device_id tg3_pci_tbl[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5700)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5701)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5704)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702FE)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5705)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5705_2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5705M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5705M_2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702X)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703X)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5704S)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5702A3)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5703A3)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5782)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5788)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5789)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5901),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY |\n\t\t\tTG3_DRV_DATA_FLAG_5705_10_100},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5901_2),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY |\n\t\t\tTG3_DRV_DATA_FLAG_5705_10_100},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5704S_2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5705F),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY |\n\t\t\tTG3_DRV_DATA_FLAG_5705_10_100},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5721)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5722)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5750)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5751)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5751M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5751F),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5752)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5752M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5753)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5753M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5753F),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5754)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5754M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5755)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5755M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5756)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5786)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5787)},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5787M,\n\t\t\tPCI_VENDOR_ID_LENOVO,\n\t\t\tTG3PCI_SUBDEVICE_ID_LENOVO_5787M),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5787M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5787F),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5714)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5714S)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5715)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5715S)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5780)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5780S)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5781)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5906)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5906M)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5784)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5764)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5723)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5761)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_TIGON3_5761E)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5761S)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5761SE)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5785_G)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5785_F)},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57780,\n\t\t\tPCI_VENDOR_ID_AI, TG3PCI_SUBDEVICE_ID_ACER_57780_A),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE_SUB(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57780,\n\t\t\tPCI_VENDOR_ID_AI, TG3PCI_SUBDEVICE_ID_ACER_57780_B),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57780)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57760)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57790),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57788)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5717)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5717_C)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5718)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57781)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57785)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57761)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57765)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57791),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57795),\n\t .driver_data = TG3_DRV_DATA_FLAG_10_100_ONLY},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5719)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5720)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57762)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57766)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5762)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5725)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_5727)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57764)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57767)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57787)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57782)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, TG3PCI_DEVICE_TIGON3_57786)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, PCI_DEVICE_ID_SYSKONNECT_9DXX)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_SYSKONNECT, PCI_DEVICE_ID_SYSKONNECT_9MXX)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ALTIMA, PCI_DEVICE_ID_ALTIMA_AC1000)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ALTIMA, PCI_DEVICE_ID_ALTIMA_AC1001)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ALTIMA, PCI_DEVICE_ID_ALTIMA_AC1003)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_ALTIMA, PCI_DEVICE_ID_ALTIMA_AC9100)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_TIGON3)},\n\t{PCI_DEVICE(0x10cf, 0x11a2)}, /* Fujitsu 1000base-SX with BCM5703SKHB */\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, tg3_pci_tbl);\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"rx_octets\" },\n\t{ \"rx_fragments\" },\n\t{ \"rx_ucast_packets\" },\n\t{ \"rx_mcast_packets\" },\n\t{ \"rx_bcast_packets\" },\n\t{ \"rx_fcs_errors\" },\n\t{ \"rx_align_errors\" },\n\t{ \"rx_xon_pause_rcvd\" },\n\t{ \"rx_xoff_pause_rcvd\" },\n\t{ \"rx_mac_ctrl_rcvd\" },\n\t{ \"rx_xoff_entered\" },\n\t{ \"rx_frame_too_long_errors\" },\n\t{ \"rx_jabbers\" },\n\t{ \"rx_undersize_packets\" },\n\t{ \"rx_in_length_errors\" },\n\t{ \"rx_out_length_errors\" },\n\t{ \"rx_64_or_less_octet_packets\" },\n\t{ \"rx_65_to_127_octet_packets\" },\n\t{ \"rx_128_to_255_octet_packets\" },\n\t{ \"rx_256_to_511_octet_packets\" },\n\t{ \"rx_512_to_1023_octet_packets\" },\n\t{ \"rx_1024_to_1522_octet_packets\" },\n\t{ \"rx_1523_to_2047_octet_packets\" },\n\t{ \"rx_2048_to_4095_octet_packets\" },\n\t{ \"rx_4096_to_8191_octet_packets\" },\n\t{ \"rx_8192_to_9022_octet_packets\" },\n\n\t{ \"tx_octets\" },\n\t{ \"tx_collisions\" },\n\n\t{ \"tx_xon_sent\" },\n\t{ \"tx_xoff_sent\" },\n\t{ \"tx_flow_control\" },\n\t{ \"tx_mac_errors\" },\n\t{ \"tx_single_collisions\" },\n\t{ \"tx_mult_collisions\" },\n\t{ \"tx_deferred\" },\n\t{ \"tx_excessive_collisions\" },\n\t{ \"tx_late_collisions\" },\n\t{ \"tx_collide_2times\" },\n\t{ \"tx_collide_3times\" },\n\t{ \"tx_collide_4times\" },\n\t{ \"tx_collide_5times\" },\n\t{ \"tx_collide_6times\" },\n\t{ \"tx_collide_7times\" },\n\t{ \"tx_collide_8times\" },\n\t{ \"tx_collide_9times\" },\n\t{ \"tx_collide_10times\" },\n\t{ \"tx_collide_11times\" },\n\t{ \"tx_collide_12times\" },\n\t{ \"tx_collide_13times\" },\n\t{ \"tx_collide_14times\" },\n\t{ \"tx_collide_15times\" },\n\t{ \"tx_ucast_packets\" },\n\t{ \"tx_mcast_packets\" },\n\t{ \"tx_bcast_packets\" },\n\t{ \"tx_carrier_sense_errors\" },\n\t{ \"tx_discards\" },\n\t{ \"tx_errors\" },\n\n\t{ \"dma_writeq_full\" },\n\t{ \"dma_write_prioq_full\" },\n\t{ \"rxbds_empty\" },\n\t{ \"rx_discards\" },\n\t{ \"rx_errors\" },\n\t{ \"rx_threshold_hit\" },\n\n\t{ \"dma_readq_full\" },\n\t{ \"dma_read_prioq_full\" },\n\t{ \"tx_comp_queue_full\" },\n\n\t{ \"ring_set_send_prod_index\" },\n\t{ \"ring_status_update\" },\n\t{ \"nic_irqs\" },\n\t{ \"nic_avoided_irqs\" },\n\t{ \"nic_tx_threshold_hit\" },\n\n\t{ \"mbuf_lwm_thresh_hit\" },\n};\n\n#define TG3_NUM_STATS\tARRAY_SIZE(ethtool_stats_keys)\n#define TG3_NVRAM_TEST\t\t0\n#define TG3_LINK_TEST\t\t1\n#define TG3_REGISTER_TEST\t2\n#define TG3_MEMORY_TEST\t\t3\n#define TG3_MAC_LOOPB_TEST\t4\n#define TG3_PHY_LOOPB_TEST\t5\n#define TG3_EXT_LOOPB_TEST\t6\n#define TG3_INTERRUPT_TEST\t7\n\n\nstatic const struct {\n\tconst char string[ETH_GSTRING_LEN];\n} ethtool_test_keys[] = {\n\t[TG3_NVRAM_TEST]\t= { \"nvram test        (online) \" },\n\t[TG3_LINK_TEST]\t\t= { \"link test         (online) \" },\n\t[TG3_REGISTER_TEST]\t= { \"register test     (offline)\" },\n\t[TG3_MEMORY_TEST]\t= { \"memory test       (offline)\" },\n\t[TG3_MAC_LOOPB_TEST]\t= { \"mac loopback test (offline)\" },\n\t[TG3_PHY_LOOPB_TEST]\t= { \"phy loopback test (offline)\" },\n\t[TG3_EXT_LOOPB_TEST]\t= { \"ext loopback test (offline)\" },\n\t[TG3_INTERRUPT_TEST]\t= { \"interrupt test    (offline)\" },\n};\n\n#define TG3_NUM_TEST\tARRAY_SIZE(ethtool_test_keys)\n\n\nstatic void tg3_write32(struct tg3 *tp, u32 off, u32 val)\n{\n\twritel(val, tp->regs + off);\n}\n\nstatic u32 tg3_read32(struct tg3 *tp, u32 off)\n{\n\treturn readl(tp->regs + off);\n}\n\nstatic void tg3_ape_write32(struct tg3 *tp, u32 off, u32 val)\n{\n\twritel(val, tp->aperegs + off);\n}\n\nstatic u32 tg3_ape_read32(struct tg3 *tp, u32 off)\n{\n\treturn readl(tp->aperegs + off);\n}\n\nstatic void tg3_write_indirect_reg32(struct tg3 *tp, u32 off, u32 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_DATA, val);\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n}\n\nstatic void tg3_write_flush_reg32(struct tg3 *tp, u32 off, u32 val)\n{\n\twritel(val, tp->regs + off);\n\treadl(tp->regs + off);\n}\n\nstatic u32 tg3_read_indirect_reg32(struct tg3 *tp, u32 off)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off);\n\tpci_read_config_dword(tp->pdev, TG3PCI_REG_DATA, &val);\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n\treturn val;\n}\n\nstatic void tg3_write_indirect_mbox(struct tg3 *tp, u32 off, u32 val)\n{\n\tunsigned long flags;\n\n\tif (off == (MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW)) {\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_RCV_RET_RING_CON_IDX +\n\t\t\t\t       TG3_64BIT_REG_LOW, val);\n\t\treturn;\n\t}\n\tif (off == TG3_RX_STD_PROD_IDX_REG) {\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_STD_RING_PROD_IDX +\n\t\t\t\t       TG3_64BIT_REG_LOW, val);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off + 0x5600);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_DATA, val);\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n\n\t/* In indirect mode when disabling interrupts, we also need\n\t * to clear the interrupt bit in the GRC local ctrl register.\n\t */\n\tif ((off == (MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW)) &&\n\t    (val == 0x1)) {\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MISC_LOCAL_CTRL,\n\t\t\t\t       tp->grc_local_ctrl|GRC_LCLCTRL_CLEARINT);\n\t}\n}\n\nstatic u32 tg3_read_indirect_mbox(struct tg3 *tp, u32 off)\n{\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tpci_write_config_dword(tp->pdev, TG3PCI_REG_BASE_ADDR, off + 0x5600);\n\tpci_read_config_dword(tp->pdev, TG3PCI_REG_DATA, &val);\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n\treturn val;\n}\n\n/* usec_wait specifies the wait time in usec when writing to certain registers\n * where it is unsafe to read back the register without some delay.\n * GRC_LOCAL_CTRL is one example if the GPIOs are toggled to switch power.\n * TG3PCI_CLOCK_CTRL is another example if the clock frequencies are changed.\n */\nstatic void _tw32_flush(struct tg3 *tp, u32 off, u32 val, u32 usec_wait)\n{\n\tif (tg3_flag(tp, PCIX_TARGET_HWBUG) || tg3_flag(tp, ICH_WORKAROUND))\n\t\t/* Non-posted methods */\n\t\ttp->write32(tp, off, val);\n\telse {\n\t\t/* Posted method */\n\t\ttg3_write32(tp, off, val);\n\t\tif (usec_wait)\n\t\t\tudelay(usec_wait);\n\t\ttp->read32(tp, off);\n\t}\n\t/* Wait again after the read for the posted method to guarantee that\n\t * the wait time is met.\n\t */\n\tif (usec_wait)\n\t\tudelay(usec_wait);\n}\n\nstatic inline void tw32_mailbox_flush(struct tg3 *tp, u32 off, u32 val)\n{\n\ttp->write32_mbox(tp, off, val);\n\tif (tg3_flag(tp, FLUSH_POSTED_WRITES) ||\n\t    (!tg3_flag(tp, MBOX_WRITE_REORDER) &&\n\t     !tg3_flag(tp, ICH_WORKAROUND)))\n\t\ttp->read32_mbox(tp, off);\n}\n\nstatic void tg3_write32_tx_mbox(struct tg3 *tp, u32 off, u32 val)\n{\n\tvoid __iomem *mbox = tp->regs + off;\n\twritel(val, mbox);\n\tif (tg3_flag(tp, TXD_MBOX_HWBUG))\n\t\twritel(val, mbox);\n\tif (tg3_flag(tp, MBOX_WRITE_REORDER) ||\n\t    tg3_flag(tp, FLUSH_POSTED_WRITES))\n\t\treadl(mbox);\n}\n\nstatic u32 tg3_read32_mbox_5906(struct tg3 *tp, u32 off)\n{\n\treturn readl(tp->regs + off + GRCMBOX_BASE);\n}\n\nstatic void tg3_write32_mbox_5906(struct tg3 *tp, u32 off, u32 val)\n{\n\twritel(val, tp->regs + off + GRCMBOX_BASE);\n}\n\n#define tw32_mailbox(reg, val)\t\ttp->write32_mbox(tp, reg, val)\n#define tw32_mailbox_f(reg, val)\ttw32_mailbox_flush(tp, (reg), (val))\n#define tw32_rx_mbox(reg, val)\t\ttp->write32_rx_mbox(tp, reg, val)\n#define tw32_tx_mbox(reg, val)\t\ttp->write32_tx_mbox(tp, reg, val)\n#define tr32_mailbox(reg)\t\ttp->read32_mbox(tp, reg)\n\n#define tw32(reg, val)\t\t\ttp->write32(tp, reg, val)\n#define tw32_f(reg, val)\t\t_tw32_flush(tp, (reg), (val), 0)\n#define tw32_wait_f(reg, val, us)\t_tw32_flush(tp, (reg), (val), (us))\n#define tr32(reg)\t\t\ttp->read32(tp, reg)\n\nstatic void tg3_write_mem(struct tg3 *tp, u32 off, u32 val)\n{\n\tunsigned long flags;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906 &&\n\t    (off >= NIC_SRAM_STATS_BLK) && (off < NIC_SRAM_TX_BUFFER_DESC))\n\t\treturn;\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tif (tg3_flag(tp, SRAM_USE_CONFIG)) {\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);\n\n\t\t/* Always leave this as zero. */\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\t} else {\n\t\ttw32_f(TG3PCI_MEM_WIN_BASE_ADDR, off);\n\t\ttw32_f(TG3PCI_MEM_WIN_DATA, val);\n\n\t\t/* Always leave this as zero. */\n\t\ttw32_f(TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\t}\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n}\n\nstatic void tg3_read_mem(struct tg3 *tp, u32 off, u32 *val)\n{\n\tunsigned long flags;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906 &&\n\t    (off >= NIC_SRAM_STATS_BLK) && (off < NIC_SRAM_TX_BUFFER_DESC)) {\n\t\t*val = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&tp->indirect_lock, flags);\n\tif (tg3_flag(tp, SRAM_USE_CONFIG)) {\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, off);\n\t\tpci_read_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);\n\n\t\t/* Always leave this as zero. */\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\t} else {\n\t\ttw32_f(TG3PCI_MEM_WIN_BASE_ADDR, off);\n\t\t*val = tr32(TG3PCI_MEM_WIN_DATA);\n\n\t\t/* Always leave this as zero. */\n\t\ttw32_f(TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\t}\n\tspin_unlock_irqrestore(&tp->indirect_lock, flags);\n}\n\nstatic void tg3_ape_lock_init(struct tg3 *tp)\n{\n\tint i;\n\tu32 regbase, bit;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5761)\n\t\tregbase = TG3_APE_LOCK_GRANT;\n\telse\n\t\tregbase = TG3_APE_PER_LOCK_GRANT;\n\n\t/* Make sure the driver hasn't any stale locks. */\n\tfor (i = TG3_APE_LOCK_PHY0; i <= TG3_APE_LOCK_GPIO; i++) {\n\t\tswitch (i) {\n\t\tcase TG3_APE_LOCK_PHY0:\n\t\tcase TG3_APE_LOCK_PHY1:\n\t\tcase TG3_APE_LOCK_PHY2:\n\t\tcase TG3_APE_LOCK_PHY3:\n\t\t\tbit = APE_LOCK_GRANT_DRIVER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!tp->pci_fn)\n\t\t\t\tbit = APE_LOCK_GRANT_DRIVER;\n\t\t\telse\n\t\t\t\tbit = 1 << tp->pci_fn;\n\t\t}\n\t\ttg3_ape_write32(tp, regbase + 4 * i, bit);\n\t}\n\n}\n\nstatic int tg3_ape_lock(struct tg3 *tp, int locknum)\n{\n\tint i, off;\n\tint ret = 0;\n\tu32 status, req, gnt, bit;\n\n\tif (!tg3_flag(tp, ENABLE_APE))\n\t\treturn 0;\n\n\tswitch (locknum) {\n\tcase TG3_APE_LOCK_GPIO:\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5761)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase TG3_APE_LOCK_GRC:\n\tcase TG3_APE_LOCK_MEM:\n\t\tif (!tp->pci_fn)\n\t\t\tbit = APE_LOCK_REQ_DRIVER;\n\t\telse\n\t\t\tbit = 1 << tp->pci_fn;\n\t\tbreak;\n\tcase TG3_APE_LOCK_PHY0:\n\tcase TG3_APE_LOCK_PHY1:\n\tcase TG3_APE_LOCK_PHY2:\n\tcase TG3_APE_LOCK_PHY3:\n\t\tbit = APE_LOCK_REQ_DRIVER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5761) {\n\t\treq = TG3_APE_LOCK_REQ;\n\t\tgnt = TG3_APE_LOCK_GRANT;\n\t} else {\n\t\treq = TG3_APE_PER_LOCK_REQ;\n\t\tgnt = TG3_APE_PER_LOCK_GRANT;\n\t}\n\n\toff = 4 * locknum;\n\n\ttg3_ape_write32(tp, req + off, bit);\n\n\t/* Wait for up to 1 millisecond to acquire lock. */\n\tfor (i = 0; i < 100; i++) {\n\t\tstatus = tg3_ape_read32(tp, gnt + off);\n\t\tif (status == bit)\n\t\t\tbreak;\n\t\tif (pci_channel_offline(tp->pdev))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (status != bit) {\n\t\t/* Revoke the lock request. */\n\t\ttg3_ape_write32(tp, gnt + off, bit);\n\t\tret = -EBUSY;\n\t}\n\n\treturn ret;\n}\n\nstatic void tg3_ape_unlock(struct tg3 *tp, int locknum)\n{\n\tu32 gnt, bit;\n\n\tif (!tg3_flag(tp, ENABLE_APE))\n\t\treturn;\n\n\tswitch (locknum) {\n\tcase TG3_APE_LOCK_GPIO:\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5761)\n\t\t\treturn;\n\t\tfallthrough;\n\tcase TG3_APE_LOCK_GRC:\n\tcase TG3_APE_LOCK_MEM:\n\t\tif (!tp->pci_fn)\n\t\t\tbit = APE_LOCK_GRANT_DRIVER;\n\t\telse\n\t\t\tbit = 1 << tp->pci_fn;\n\t\tbreak;\n\tcase TG3_APE_LOCK_PHY0:\n\tcase TG3_APE_LOCK_PHY1:\n\tcase TG3_APE_LOCK_PHY2:\n\tcase TG3_APE_LOCK_PHY3:\n\t\tbit = APE_LOCK_GRANT_DRIVER;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5761)\n\t\tgnt = TG3_APE_LOCK_GRANT;\n\telse\n\t\tgnt = TG3_APE_PER_LOCK_GRANT;\n\n\ttg3_ape_write32(tp, gnt + 4 * locknum, bit);\n}\n\nstatic int tg3_ape_event_lock(struct tg3 *tp, u32 timeout_us)\n{\n\tu32 apedata;\n\n\twhile (timeout_us) {\n\t\tif (tg3_ape_lock(tp, TG3_APE_LOCK_MEM))\n\t\t\treturn -EBUSY;\n\n\t\tapedata = tg3_ape_read32(tp, TG3_APE_EVENT_STATUS);\n\t\tif (!(apedata & APE_EVENT_STATUS_EVENT_PENDING))\n\t\t\tbreak;\n\n\t\ttg3_ape_unlock(tp, TG3_APE_LOCK_MEM);\n\n\t\tudelay(10);\n\t\ttimeout_us -= (timeout_us > 10) ? 10 : timeout_us;\n\t}\n\n\treturn timeout_us ? 0 : -EBUSY;\n}\n\n#ifdef CONFIG_TIGON3_HWMON\nstatic int tg3_ape_wait_for_event(struct tg3 *tp, u32 timeout_us)\n{\n\tu32 i, apedata;\n\n\tfor (i = 0; i < timeout_us / 10; i++) {\n\t\tapedata = tg3_ape_read32(tp, TG3_APE_EVENT_STATUS);\n\n\t\tif (!(apedata & APE_EVENT_STATUS_EVENT_PENDING))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\treturn i == timeout_us / 10;\n}\n\nstatic int tg3_ape_scratchpad_read(struct tg3 *tp, u32 *data, u32 base_off,\n\t\t\t\t   u32 len)\n{\n\tint err;\n\tu32 i, bufoff, msgoff, maxlen, apedata;\n\n\tif (!tg3_flag(tp, APE_HAS_NCSI))\n\t\treturn 0;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_SEG_SIG);\n\tif (apedata != APE_SEG_SIG_MAGIC)\n\t\treturn -ENODEV;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\n\tif (!(apedata & APE_FW_STATUS_READY))\n\t\treturn -EAGAIN;\n\n\tbufoff = tg3_ape_read32(tp, TG3_APE_SEG_MSG_BUF_OFF) +\n\t\t TG3_APE_SHMEM_BASE;\n\tmsgoff = bufoff + 2 * sizeof(u32);\n\tmaxlen = tg3_ape_read32(tp, TG3_APE_SEG_MSG_BUF_LEN);\n\n\twhile (len) {\n\t\tu32 length;\n\n\t\t/* Cap xfer sizes to scratchpad limits. */\n\t\tlength = (len > maxlen) ? maxlen : len;\n\t\tlen -= length;\n\n\t\tapedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\n\t\tif (!(apedata & APE_FW_STATUS_READY))\n\t\t\treturn -EAGAIN;\n\n\t\t/* Wait for up to 1 msec for APE to service previous event. */\n\t\terr = tg3_ape_event_lock(tp, 1000);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tapedata = APE_EVENT_STATUS_DRIVER_EVNT |\n\t\t\t  APE_EVENT_STATUS_SCRTCHPD_READ |\n\t\t\t  APE_EVENT_STATUS_EVENT_PENDING;\n\t\ttg3_ape_write32(tp, TG3_APE_EVENT_STATUS, apedata);\n\n\t\ttg3_ape_write32(tp, bufoff, base_off);\n\t\ttg3_ape_write32(tp, bufoff + sizeof(u32), length);\n\n\t\ttg3_ape_unlock(tp, TG3_APE_LOCK_MEM);\n\t\ttg3_ape_write32(tp, TG3_APE_EVENT, APE_EVENT_1);\n\n\t\tbase_off += length;\n\n\t\tif (tg3_ape_wait_for_event(tp, 30000))\n\t\t\treturn -EAGAIN;\n\n\t\tfor (i = 0; length; i += 4, length -= 4) {\n\t\t\tu32 val = tg3_ape_read32(tp, msgoff + i);\n\t\t\tmemcpy(data, &val, sizeof(u32));\n\t\t\tdata++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int tg3_ape_send_event(struct tg3 *tp, u32 event)\n{\n\tint err;\n\tu32 apedata;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_SEG_SIG);\n\tif (apedata != APE_SEG_SIG_MAGIC)\n\t\treturn -EAGAIN;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\n\tif (!(apedata & APE_FW_STATUS_READY))\n\t\treturn -EAGAIN;\n\n\t/* Wait for up to 20 millisecond for APE to service previous event. */\n\terr = tg3_ape_event_lock(tp, 20000);\n\tif (err)\n\t\treturn err;\n\n\ttg3_ape_write32(tp, TG3_APE_EVENT_STATUS,\n\t\t\tevent | APE_EVENT_STATUS_EVENT_PENDING);\n\n\ttg3_ape_unlock(tp, TG3_APE_LOCK_MEM);\n\ttg3_ape_write32(tp, TG3_APE_EVENT, APE_EVENT_1);\n\n\treturn 0;\n}\n\nstatic void tg3_ape_driver_state_change(struct tg3 *tp, int kind)\n{\n\tu32 event;\n\tu32 apedata;\n\n\tif (!tg3_flag(tp, ENABLE_APE))\n\t\treturn;\n\n\tswitch (kind) {\n\tcase RESET_KIND_INIT:\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_HEARTBEAT_COUNT, tp->ape_hb++);\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_SEG_SIG,\n\t\t\t\tAPE_HOST_SEG_SIG_MAGIC);\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_SEG_LEN,\n\t\t\t\tAPE_HOST_SEG_LEN_MAGIC);\n\t\tapedata = tg3_ape_read32(tp, TG3_APE_HOST_INIT_COUNT);\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_INIT_COUNT, ++apedata);\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_DRIVER_ID,\n\t\t\tAPE_HOST_DRIVER_ID_MAGIC(TG3_MAJ_NUM, TG3_MIN_NUM));\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_BEHAVIOR,\n\t\t\t\tAPE_HOST_BEHAV_NO_PHYLOCK);\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_DRVR_STATE,\n\t\t\t\t    TG3_APE_HOST_DRVR_STATE_START);\n\n\t\tevent = APE_EVENT_STATUS_STATE_START;\n\t\tbreak;\n\tcase RESET_KIND_SHUTDOWN:\n\t\tif (device_may_wakeup(&tp->pdev->dev) &&\n\t\t    tg3_flag(tp, WOL_ENABLE)) {\n\t\t\ttg3_ape_write32(tp, TG3_APE_HOST_WOL_SPEED,\n\t\t\t\t\t    TG3_APE_HOST_WOL_SPEED_AUTO);\n\t\t\tapedata = TG3_APE_HOST_DRVR_STATE_WOL;\n\t\t} else\n\t\t\tapedata = TG3_APE_HOST_DRVR_STATE_UNLOAD;\n\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_DRVR_STATE, apedata);\n\n\t\tevent = APE_EVENT_STATUS_STATE_UNLOAD;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tevent |= APE_EVENT_STATUS_DRIVER_EVNT | APE_EVENT_STATUS_STATE_CHNGE;\n\n\ttg3_ape_send_event(tp, event);\n}\n\nstatic void tg3_send_ape_heartbeat(struct tg3 *tp,\n\t\t\t\t   unsigned long interval)\n{\n\t/* Check if hb interval has exceeded */\n\tif (!tg3_flag(tp, ENABLE_APE) ||\n\t    time_before(jiffies, tp->ape_hb_jiffies + interval))\n\t\treturn;\n\n\ttg3_ape_write32(tp, TG3_APE_HOST_HEARTBEAT_COUNT, tp->ape_hb++);\n\ttp->ape_hb_jiffies = jiffies;\n}\n\nstatic void tg3_disable_ints(struct tg3 *tp)\n{\n\tint i;\n\n\ttw32(TG3PCI_MISC_HOST_CTRL,\n\t     (tp->misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT));\n\tfor (i = 0; i < tp->irq_max; i++)\n\t\ttw32_mailbox_f(tp->napi[i].int_mbox, 0x00000001);\n}\n\nstatic void tg3_enable_ints(struct tg3 *tp)\n{\n\tint i;\n\n\ttp->irq_sync = 0;\n\twmb();\n\n\ttw32(TG3PCI_MISC_HOST_CTRL,\n\t     (tp->misc_host_ctrl & ~MISC_HOST_CTRL_MASK_PCI_INT));\n\n\ttp->coal_now = tp->coalesce_mode | HOSTCC_MODE_ENABLE;\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\ttw32_mailbox_f(tnapi->int_mbox, tnapi->last_tag << 24);\n\t\tif (tg3_flag(tp, 1SHOT_MSI))\n\t\t\ttw32_mailbox_f(tnapi->int_mbox, tnapi->last_tag << 24);\n\n\t\ttp->coal_now |= tnapi->coal_now;\n\t}\n\n\t/* Force an initial interrupt */\n\tif (!tg3_flag(tp, TAGGED_STATUS) &&\n\t    (tp->napi[0].hw_status->status & SD_STATUS_UPDATED))\n\t\ttw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);\n\telse\n\t\ttw32(HOSTCC_MODE, tp->coal_now);\n\n\ttp->coal_now &= ~(tp->napi[0].coal_now | tp->napi[1].coal_now);\n}\n\nstatic inline unsigned int tg3_has_work(struct tg3_napi *tnapi)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\tunsigned int work_exists = 0;\n\n\t/* check for phy events */\n\tif (!(tg3_flag(tp, USE_LINKCHG_REG) || tg3_flag(tp, POLL_SERDES))) {\n\t\tif (sblk->status & SD_STATUS_LINK_CHG)\n\t\t\twork_exists = 1;\n\t}\n\n\t/* check for TX work to do */\n\tif (sblk->idx[0].tx_consumer != tnapi->tx_cons)\n\t\twork_exists = 1;\n\n\t/* check for RX work to do */\n\tif (tnapi->rx_rcb_prod_idx &&\n\t    *(tnapi->rx_rcb_prod_idx) != tnapi->rx_rcb_ptr)\n\t\twork_exists = 1;\n\n\treturn work_exists;\n}\n\n/* tg3_int_reenable\n *  similar to tg3_enable_ints, but it accurately determines whether there\n *  is new work pending and can return without flushing the PIO write\n *  which reenables interrupts\n */\nstatic void tg3_int_reenable(struct tg3_napi *tnapi)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\n\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\n\n\t/* When doing tagged status, this work check is unnecessary.\n\t * The last_tag we write above tells the chip which piece of\n\t * work we've completed.\n\t */\n\tif (!tg3_flag(tp, TAGGED_STATUS) && tg3_has_work(tnapi))\n\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t     HOSTCC_MODE_ENABLE | tnapi->coal_now);\n}\n\nstatic void tg3_switch_clocks(struct tg3 *tp)\n{\n\tu32 clock_ctrl;\n\tu32 orig_clock_ctrl;\n\n\tif (tg3_flag(tp, CPMU_PRESENT) || tg3_flag(tp, 5780_CLASS))\n\t\treturn;\n\n\tclock_ctrl = tr32(TG3PCI_CLOCK_CTRL);\n\n\torig_clock_ctrl = clock_ctrl;\n\tclock_ctrl &= (CLOCK_CTRL_FORCE_CLKRUN |\n\t\t       CLOCK_CTRL_CLKRUN_OENABLE |\n\t\t       0x1f);\n\ttp->pci_clock_ctrl = clock_ctrl;\n\n\tif (tg3_flag(tp, 5705_PLUS)) {\n\t\tif (orig_clock_ctrl & CLOCK_CTRL_625_CORE) {\n\t\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL,\n\t\t\t\t    clock_ctrl | CLOCK_CTRL_625_CORE, 40);\n\t\t}\n\t} else if ((orig_clock_ctrl & CLOCK_CTRL_44MHZ_CORE) != 0) {\n\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL,\n\t\t\t    clock_ctrl |\n\t\t\t    (CLOCK_CTRL_44MHZ_CORE | CLOCK_CTRL_ALTCLK),\n\t\t\t    40);\n\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL,\n\t\t\t    clock_ctrl | (CLOCK_CTRL_ALTCLK),\n\t\t\t    40);\n\t}\n\ttw32_wait_f(TG3PCI_CLOCK_CTRL, clock_ctrl, 40);\n}\n\n#define PHY_BUSY_LOOPS\t5000\n\nstatic int __tg3_readphy(struct tg3 *tp, unsigned int phy_addr, int reg,\n\t\t\t u32 *val)\n{\n\tu32 frame_val;\n\tunsigned int loops;\n\tint ret;\n\n\tif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\n\t\ttw32_f(MAC_MI_MODE,\n\t\t     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));\n\t\tudelay(80);\n\t}\n\n\ttg3_ape_lock(tp, tp->phy_ape_lock);\n\n\t*val = 0x0;\n\n\tframe_val  = ((phy_addr << MI_COM_PHY_ADDR_SHIFT) &\n\t\t      MI_COM_PHY_ADDR_MASK);\n\tframe_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &\n\t\t      MI_COM_REG_ADDR_MASK);\n\tframe_val |= (MI_COM_CMD_READ | MI_COM_START);\n\n\ttw32_f(MAC_MI_COM, frame_val);\n\n\tloops = PHY_BUSY_LOOPS;\n\twhile (loops != 0) {\n\t\tudelay(10);\n\t\tframe_val = tr32(MAC_MI_COM);\n\n\t\tif ((frame_val & MI_COM_BUSY) == 0) {\n\t\t\tudelay(5);\n\t\t\tframe_val = tr32(MAC_MI_COM);\n\t\t\tbreak;\n\t\t}\n\t\tloops -= 1;\n\t}\n\n\tret = -EBUSY;\n\tif (loops != 0) {\n\t\t*val = frame_val & MI_COM_DATA_MASK;\n\t\tret = 0;\n\t}\n\n\tif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\n\t\ttw32_f(MAC_MI_MODE, tp->mi_mode);\n\t\tudelay(80);\n\t}\n\n\ttg3_ape_unlock(tp, tp->phy_ape_lock);\n\n\treturn ret;\n}\n\nstatic int tg3_readphy(struct tg3 *tp, int reg, u32 *val)\n{\n\treturn __tg3_readphy(tp, tp->phy_addr, reg, val);\n}\n\nstatic int __tg3_writephy(struct tg3 *tp, unsigned int phy_addr, int reg,\n\t\t\t  u32 val)\n{\n\tu32 frame_val;\n\tunsigned int loops;\n\tint ret;\n\n\tif ((tp->phy_flags & TG3_PHYFLG_IS_FET) &&\n\t    (reg == MII_CTRL1000 || reg == MII_TG3_AUX_CTRL))\n\t\treturn 0;\n\n\tif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\n\t\ttw32_f(MAC_MI_MODE,\n\t\t     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));\n\t\tudelay(80);\n\t}\n\n\ttg3_ape_lock(tp, tp->phy_ape_lock);\n\n\tframe_val  = ((phy_addr << MI_COM_PHY_ADDR_SHIFT) &\n\t\t      MI_COM_PHY_ADDR_MASK);\n\tframe_val |= ((reg << MI_COM_REG_ADDR_SHIFT) &\n\t\t      MI_COM_REG_ADDR_MASK);\n\tframe_val |= (val & MI_COM_DATA_MASK);\n\tframe_val |= (MI_COM_CMD_WRITE | MI_COM_START);\n\n\ttw32_f(MAC_MI_COM, frame_val);\n\n\tloops = PHY_BUSY_LOOPS;\n\twhile (loops != 0) {\n\t\tudelay(10);\n\t\tframe_val = tr32(MAC_MI_COM);\n\t\tif ((frame_val & MI_COM_BUSY) == 0) {\n\t\t\tudelay(5);\n\t\t\tframe_val = tr32(MAC_MI_COM);\n\t\t\tbreak;\n\t\t}\n\t\tloops -= 1;\n\t}\n\n\tret = -EBUSY;\n\tif (loops != 0)\n\t\tret = 0;\n\n\tif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\n\t\ttw32_f(MAC_MI_MODE, tp->mi_mode);\n\t\tudelay(80);\n\t}\n\n\ttg3_ape_unlock(tp, tp->phy_ape_lock);\n\n\treturn ret;\n}\n\nstatic int tg3_writephy(struct tg3 *tp, int reg, u32 val)\n{\n\treturn __tg3_writephy(tp, tp->phy_addr, reg, val);\n}\n\nstatic int tg3_phy_cl45_write(struct tg3 *tp, u32 devad, u32 addr, u32 val)\n{\n\tint err;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_CTRL, devad);\n\tif (err)\n\t\tgoto done;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_ADDRESS, addr);\n\tif (err)\n\t\tgoto done;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_CTRL,\n\t\t\t   MII_TG3_MMD_CTRL_DATA_NOINC | devad);\n\tif (err)\n\t\tgoto done;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_ADDRESS, val);\n\ndone:\n\treturn err;\n}\n\nstatic int tg3_phy_cl45_read(struct tg3 *tp, u32 devad, u32 addr, u32 *val)\n{\n\tint err;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_CTRL, devad);\n\tif (err)\n\t\tgoto done;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_ADDRESS, addr);\n\tif (err)\n\t\tgoto done;\n\n\terr = tg3_writephy(tp, MII_TG3_MMD_CTRL,\n\t\t\t   MII_TG3_MMD_CTRL_DATA_NOINC | devad);\n\tif (err)\n\t\tgoto done;\n\n\terr = tg3_readphy(tp, MII_TG3_MMD_ADDRESS, val);\n\ndone:\n\treturn err;\n}\n\nstatic int tg3_phydsp_read(struct tg3 *tp, u32 reg, u32 *val)\n{\n\tint err;\n\n\terr = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, reg);\n\tif (!err)\n\t\terr = tg3_readphy(tp, MII_TG3_DSP_RW_PORT, val);\n\n\treturn err;\n}\n\nstatic int tg3_phydsp_write(struct tg3 *tp, u32 reg, u32 val)\n{\n\tint err;\n\n\terr = tg3_writephy(tp, MII_TG3_DSP_ADDRESS, reg);\n\tif (!err)\n\t\terr = tg3_writephy(tp, MII_TG3_DSP_RW_PORT, val);\n\n\treturn err;\n}\n\nstatic int tg3_phy_auxctl_read(struct tg3 *tp, int reg, u32 *val)\n{\n\tint err;\n\n\terr = tg3_writephy(tp, MII_TG3_AUX_CTRL,\n\t\t\t   (reg << MII_TG3_AUXCTL_MISC_RDSEL_SHIFT) |\n\t\t\t   MII_TG3_AUXCTL_SHDWSEL_MISC);\n\tif (!err)\n\t\terr = tg3_readphy(tp, MII_TG3_AUX_CTRL, val);\n\n\treturn err;\n}\n\nstatic int tg3_phy_auxctl_write(struct tg3 *tp, int reg, u32 set)\n{\n\tif (reg == MII_TG3_AUXCTL_SHDWSEL_MISC)\n\t\tset |= MII_TG3_AUXCTL_MISC_WREN;\n\n\treturn tg3_writephy(tp, MII_TG3_AUX_CTRL, set | reg);\n}\n\nstatic int tg3_phy_toggle_auxctl_smdsp(struct tg3 *tp, bool enable)\n{\n\tu32 val;\n\tint err;\n\n\terr = tg3_phy_auxctl_read(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);\n\n\tif (err)\n\t\treturn err;\n\n\tif (enable)\n\t\tval |= MII_TG3_AUXCTL_ACTL_SMDSP_ENA;\n\telse\n\t\tval &= ~MII_TG3_AUXCTL_ACTL_SMDSP_ENA;\n\n\terr = tg3_phy_auxctl_write((tp), MII_TG3_AUXCTL_SHDWSEL_AUXCTL,\n\t\t\t\t   val | MII_TG3_AUXCTL_ACTL_TX_6DB);\n\n\treturn err;\n}\n\nstatic int tg3_phy_shdw_write(struct tg3 *tp, int reg, u32 val)\n{\n\treturn tg3_writephy(tp, MII_TG3_MISC_SHDW,\n\t\t\t    reg | val | MII_TG3_MISC_SHDW_WREN);\n}\n\nstatic int tg3_bmcr_reset(struct tg3 *tp)\n{\n\tu32 phy_control;\n\tint limit, err;\n\n\t/* OK, reset it, and poll the BMCR_RESET bit until it\n\t * clears or we time out.\n\t */\n\tphy_control = BMCR_RESET;\n\terr = tg3_writephy(tp, MII_BMCR, phy_control);\n\tif (err != 0)\n\t\treturn -EBUSY;\n\n\tlimit = 5000;\n\twhile (limit--) {\n\t\terr = tg3_readphy(tp, MII_BMCR, &phy_control);\n\t\tif (err != 0)\n\t\t\treturn -EBUSY;\n\n\t\tif ((phy_control & BMCR_RESET) == 0) {\n\t\t\tudelay(40);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\tif (limit < 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int tg3_mdio_read(struct mii_bus *bp, int mii_id, int reg)\n{\n\tstruct tg3 *tp = bp->priv;\n\tu32 val;\n\n\tspin_lock_bh(&tp->lock);\n\n\tif (__tg3_readphy(tp, mii_id, reg, &val))\n\t\tval = -EIO;\n\n\tspin_unlock_bh(&tp->lock);\n\n\treturn val;\n}\n\nstatic int tg3_mdio_write(struct mii_bus *bp, int mii_id, int reg, u16 val)\n{\n\tstruct tg3 *tp = bp->priv;\n\tu32 ret = 0;\n\n\tspin_lock_bh(&tp->lock);\n\n\tif (__tg3_writephy(tp, mii_id, reg, val))\n\t\tret = -EIO;\n\n\tspin_unlock_bh(&tp->lock);\n\n\treturn ret;\n}\n\nstatic void tg3_mdio_config_5785(struct tg3 *tp)\n{\n\tu32 val;\n\tstruct phy_device *phydev;\n\n\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\tswitch (phydev->drv->phy_id & phydev->drv->phy_id_mask) {\n\tcase PHY_ID_BCM50610:\n\tcase PHY_ID_BCM50610M:\n\t\tval = MAC_PHYCFG2_50610_LED_MODES;\n\t\tbreak;\n\tcase PHY_ID_BCMAC131:\n\t\tval = MAC_PHYCFG2_AC131_LED_MODES;\n\t\tbreak;\n\tcase PHY_ID_RTL8211C:\n\t\tval = MAC_PHYCFG2_RTL8211C_LED_MODES;\n\t\tbreak;\n\tcase PHY_ID_RTL8201E:\n\t\tval = MAC_PHYCFG2_RTL8201E_LED_MODES;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (phydev->interface != PHY_INTERFACE_MODE_RGMII) {\n\t\ttw32(MAC_PHYCFG2, val);\n\n\t\tval = tr32(MAC_PHYCFG1);\n\t\tval &= ~(MAC_PHYCFG1_RGMII_INT |\n\t\t\t MAC_PHYCFG1_RXCLK_TO_MASK | MAC_PHYCFG1_TXCLK_TO_MASK);\n\t\tval |= MAC_PHYCFG1_RXCLK_TIMEOUT | MAC_PHYCFG1_TXCLK_TIMEOUT;\n\t\ttw32(MAC_PHYCFG1, val);\n\n\t\treturn;\n\t}\n\n\tif (!tg3_flag(tp, RGMII_INBAND_DISABLE))\n\t\tval |= MAC_PHYCFG2_EMODE_MASK_MASK |\n\t\t       MAC_PHYCFG2_FMODE_MASK_MASK |\n\t\t       MAC_PHYCFG2_GMODE_MASK_MASK |\n\t\t       MAC_PHYCFG2_ACT_MASK_MASK   |\n\t\t       MAC_PHYCFG2_QUAL_MASK_MASK |\n\t\t       MAC_PHYCFG2_INBAND_ENABLE;\n\n\ttw32(MAC_PHYCFG2, val);\n\n\tval = tr32(MAC_PHYCFG1);\n\tval &= ~(MAC_PHYCFG1_RXCLK_TO_MASK | MAC_PHYCFG1_TXCLK_TO_MASK |\n\t\t MAC_PHYCFG1_RGMII_EXT_RX_DEC | MAC_PHYCFG1_RGMII_SND_STAT_EN);\n\tif (!tg3_flag(tp, RGMII_INBAND_DISABLE)) {\n\t\tif (tg3_flag(tp, RGMII_EXT_IBND_RX_EN))\n\t\t\tval |= MAC_PHYCFG1_RGMII_EXT_RX_DEC;\n\t\tif (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))\n\t\t\tval |= MAC_PHYCFG1_RGMII_SND_STAT_EN;\n\t}\n\tval |= MAC_PHYCFG1_RXCLK_TIMEOUT | MAC_PHYCFG1_TXCLK_TIMEOUT |\n\t       MAC_PHYCFG1_RGMII_INT | MAC_PHYCFG1_TXC_DRV;\n\ttw32(MAC_PHYCFG1, val);\n\n\tval = tr32(MAC_EXT_RGMII_MODE);\n\tval &= ~(MAC_RGMII_MODE_RX_INT_B |\n\t\t MAC_RGMII_MODE_RX_QUALITY |\n\t\t MAC_RGMII_MODE_RX_ACTIVITY |\n\t\t MAC_RGMII_MODE_RX_ENG_DET |\n\t\t MAC_RGMII_MODE_TX_ENABLE |\n\t\t MAC_RGMII_MODE_TX_LOWPWR |\n\t\t MAC_RGMII_MODE_TX_RESET);\n\tif (!tg3_flag(tp, RGMII_INBAND_DISABLE)) {\n\t\tif (tg3_flag(tp, RGMII_EXT_IBND_RX_EN))\n\t\t\tval |= MAC_RGMII_MODE_RX_INT_B |\n\t\t\t       MAC_RGMII_MODE_RX_QUALITY |\n\t\t\t       MAC_RGMII_MODE_RX_ACTIVITY |\n\t\t\t       MAC_RGMII_MODE_RX_ENG_DET;\n\t\tif (tg3_flag(tp, RGMII_EXT_IBND_TX_EN))\n\t\t\tval |= MAC_RGMII_MODE_TX_ENABLE |\n\t\t\t       MAC_RGMII_MODE_TX_LOWPWR |\n\t\t\t       MAC_RGMII_MODE_TX_RESET;\n\t}\n\ttw32(MAC_EXT_RGMII_MODE, val);\n}\n\nstatic void tg3_mdio_start(struct tg3 *tp)\n{\n\ttp->mi_mode &= ~MAC_MI_MODE_AUTO_POLL;\n\ttw32_f(MAC_MI_MODE, tp->mi_mode);\n\tudelay(80);\n\n\tif (tg3_flag(tp, MDIOBUS_INITED) &&\n\t    tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\ttg3_mdio_config_5785(tp);\n}\n\nstatic int tg3_mdio_init(struct tg3 *tp)\n{\n\tint i;\n\tu32 reg;\n\tstruct phy_device *phydev;\n\n\tif (tg3_flag(tp, 5717_PLUS)) {\n\t\tu32 is_serdes;\n\n\t\ttp->phy_addr = tp->pci_fn + 1;\n\n\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5717_A0)\n\t\t\tis_serdes = tr32(SG_DIG_STATUS) & SG_DIG_IS_SERDES;\n\t\telse\n\t\t\tis_serdes = tr32(TG3_CPMU_PHY_STRAP) &\n\t\t\t\t    TG3_CPMU_PHY_STRAP_IS_SERDES;\n\t\tif (is_serdes)\n\t\t\ttp->phy_addr += 7;\n\t} else if (tg3_flag(tp, IS_SSB_CORE) && tg3_flag(tp, ROBOSWITCH)) {\n\t\tint addr;\n\n\t\taddr = ssb_gige_get_phyaddr(tp->pdev);\n\t\tif (addr < 0)\n\t\t\treturn addr;\n\t\ttp->phy_addr = addr;\n\t} else\n\t\ttp->phy_addr = TG3_PHY_MII_ADDR;\n\n\ttg3_mdio_start(tp);\n\n\tif (!tg3_flag(tp, USE_PHYLIB) || tg3_flag(tp, MDIOBUS_INITED))\n\t\treturn 0;\n\n\ttp->mdio_bus = mdiobus_alloc();\n\tif (tp->mdio_bus == NULL)\n\t\treturn -ENOMEM;\n\n\ttp->mdio_bus->name     = \"tg3 mdio bus\";\n\tsnprintf(tp->mdio_bus->id, MII_BUS_ID_SIZE, \"%x\",\n\t\t (tp->pdev->bus->number << 8) | tp->pdev->devfn);\n\ttp->mdio_bus->priv     = tp;\n\ttp->mdio_bus->parent   = &tp->pdev->dev;\n\ttp->mdio_bus->read     = &tg3_mdio_read;\n\ttp->mdio_bus->write    = &tg3_mdio_write;\n\ttp->mdio_bus->phy_mask = ~(1 << tp->phy_addr);\n\n\t/* The bus registration will look for all the PHYs on the mdio bus.\n\t * Unfortunately, it does not ensure the PHY is powered up before\n\t * accessing the PHY ID registers.  A chip reset is the\n\t * quickest way to bring the device back to an operational state..\n\t */\n\tif (tg3_readphy(tp, MII_BMCR, &reg) || (reg & BMCR_PDOWN))\n\t\ttg3_bmcr_reset(tp);\n\n\ti = mdiobus_register(tp->mdio_bus);\n\tif (i) {\n\t\tdev_warn(&tp->pdev->dev, \"mdiobus_reg failed (0x%x)\\n\", i);\n\t\tmdiobus_free(tp->mdio_bus);\n\t\treturn i;\n\t}\n\n\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\n\tif (!phydev || !phydev->drv) {\n\t\tdev_warn(&tp->pdev->dev, \"No PHY devices\\n\");\n\t\tmdiobus_unregister(tp->mdio_bus);\n\t\tmdiobus_free(tp->mdio_bus);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (phydev->drv->phy_id & phydev->drv->phy_id_mask) {\n\tcase PHY_ID_BCM57780:\n\t\tphydev->interface = PHY_INTERFACE_MODE_GMII;\n\t\tphydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;\n\t\tbreak;\n\tcase PHY_ID_BCM50610:\n\tcase PHY_ID_BCM50610M:\n\t\tphydev->dev_flags |= PHY_BRCM_CLEAR_RGMII_MODE |\n\t\t\t\t     PHY_BRCM_RX_REFCLK_UNUSED |\n\t\t\t\t     PHY_BRCM_DIS_TXCRXC_NOENRGY |\n\t\t\t\t     PHY_BRCM_AUTO_PWRDWN_ENABLE;\n\t\tfallthrough;\n\tcase PHY_ID_RTL8211C:\n\t\tphydev->interface = PHY_INTERFACE_MODE_RGMII;\n\t\tbreak;\n\tcase PHY_ID_RTL8201E:\n\tcase PHY_ID_BCMAC131:\n\t\tphydev->interface = PHY_INTERFACE_MODE_MII;\n\t\tphydev->dev_flags |= PHY_BRCM_AUTO_PWRDWN_ENABLE;\n\t\ttp->phy_flags |= TG3_PHYFLG_IS_FET;\n\t\tbreak;\n\t}\n\n\ttg3_flag_set(tp, MDIOBUS_INITED);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\ttg3_mdio_config_5785(tp);\n\n\treturn 0;\n}\n\nstatic void tg3_mdio_fini(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, MDIOBUS_INITED)) {\n\t\ttg3_flag_clear(tp, MDIOBUS_INITED);\n\t\tmdiobus_unregister(tp->mdio_bus);\n\t\tmdiobus_free(tp->mdio_bus);\n\t}\n}\n\n/* tp->lock is held. */\nstatic inline void tg3_generate_fw_event(struct tg3 *tp)\n{\n\tu32 val;\n\n\tval = tr32(GRC_RX_CPU_EVENT);\n\tval |= GRC_RX_CPU_DRIVER_EVENT;\n\ttw32_f(GRC_RX_CPU_EVENT, val);\n\n\ttp->last_event_jiffies = jiffies;\n}\n\n#define TG3_FW_EVENT_TIMEOUT_USEC 2500\n\n/* tp->lock is held. */\nstatic void tg3_wait_for_event_ack(struct tg3 *tp)\n{\n\tint i;\n\tunsigned int delay_cnt;\n\tlong time_remain;\n\n\t/* If enough time has passed, no wait is necessary. */\n\ttime_remain = (long)(tp->last_event_jiffies + 1 +\n\t\t      usecs_to_jiffies(TG3_FW_EVENT_TIMEOUT_USEC)) -\n\t\t      (long)jiffies;\n\tif (time_remain < 0)\n\t\treturn;\n\n\t/* Check if we can shorten the wait time. */\n\tdelay_cnt = jiffies_to_usecs(time_remain);\n\tif (delay_cnt > TG3_FW_EVENT_TIMEOUT_USEC)\n\t\tdelay_cnt = TG3_FW_EVENT_TIMEOUT_USEC;\n\tdelay_cnt = (delay_cnt >> 3) + 1;\n\n\tfor (i = 0; i < delay_cnt; i++) {\n\t\tif (!(tr32(GRC_RX_CPU_EVENT) & GRC_RX_CPU_DRIVER_EVENT))\n\t\t\tbreak;\n\t\tif (pci_channel_offline(tp->pdev))\n\t\t\tbreak;\n\n\t\tudelay(8);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_phy_gather_ump_data(struct tg3 *tp, u32 *data)\n{\n\tu32 reg, val;\n\n\tval = 0;\n\tif (!tg3_readphy(tp, MII_BMCR, &reg))\n\t\tval = reg << 16;\n\tif (!tg3_readphy(tp, MII_BMSR, &reg))\n\t\tval |= (reg & 0xffff);\n\t*data++ = val;\n\n\tval = 0;\n\tif (!tg3_readphy(tp, MII_ADVERTISE, &reg))\n\t\tval = reg << 16;\n\tif (!tg3_readphy(tp, MII_LPA, &reg))\n\t\tval |= (reg & 0xffff);\n\t*data++ = val;\n\n\tval = 0;\n\tif (!(tp->phy_flags & TG3_PHYFLG_MII_SERDES)) {\n\t\tif (!tg3_readphy(tp, MII_CTRL1000, &reg))\n\t\t\tval = reg << 16;\n\t\tif (!tg3_readphy(tp, MII_STAT1000, &reg))\n\t\t\tval |= (reg & 0xffff);\n\t}\n\t*data++ = val;\n\n\tif (!tg3_readphy(tp, MII_PHYADDR, &reg))\n\t\tval = reg << 16;\n\telse\n\t\tval = 0;\n\t*data++ = val;\n}\n\n/* tp->lock is held. */\nstatic void tg3_ump_link_report(struct tg3 *tp)\n{\n\tu32 data[4];\n\n\tif (!tg3_flag(tp, 5780_CLASS) || !tg3_flag(tp, ENABLE_ASF))\n\t\treturn;\n\n\ttg3_phy_gather_ump_data(tp, data);\n\n\ttg3_wait_for_event_ack(tp);\n\n\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_LINK_UPDATE);\n\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_LEN_MBOX, 14);\n\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0x0, data[0]);\n\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0x4, data[1]);\n\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0x8, data[2]);\n\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX + 0xc, data[3]);\n\n\ttg3_generate_fw_event(tp);\n}\n\n/* tp->lock is held. */\nstatic void tg3_stop_fw(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, ENABLE_ASF) && !tg3_flag(tp, ENABLE_APE)) {\n\t\t/* Wait for RX cpu to ACK the previous event. */\n\t\ttg3_wait_for_event_ack(tp);\n\n\t\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_MBOX, FWCMD_NICDRV_PAUSE_FW);\n\n\t\ttg3_generate_fw_event(tp);\n\n\t\t/* Wait for RX cpu to ACK this event. */\n\t\ttg3_wait_for_event_ack(tp);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_write_sig_pre_reset(struct tg3 *tp, int kind)\n{\n\ttg3_write_mem(tp, NIC_SRAM_FIRMWARE_MBOX,\n\t\t      NIC_SRAM_FIRMWARE_MBOX_MAGIC1);\n\n\tif (tg3_flag(tp, ASF_NEW_HANDSHAKE)) {\n\t\tswitch (kind) {\n\t\tcase RESET_KIND_INIT:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_START);\n\t\t\tbreak;\n\n\t\tcase RESET_KIND_SHUTDOWN:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_UNLOAD);\n\t\t\tbreak;\n\n\t\tcase RESET_KIND_SUSPEND:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_SUSPEND);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_write_sig_post_reset(struct tg3 *tp, int kind)\n{\n\tif (tg3_flag(tp, ASF_NEW_HANDSHAKE)) {\n\t\tswitch (kind) {\n\t\tcase RESET_KIND_INIT:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_START_DONE);\n\t\t\tbreak;\n\n\t\tcase RESET_KIND_SHUTDOWN:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_UNLOAD_DONE);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_write_sig_legacy(struct tg3 *tp, int kind)\n{\n\tif (tg3_flag(tp, ENABLE_ASF)) {\n\t\tswitch (kind) {\n\t\tcase RESET_KIND_INIT:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_START);\n\t\t\tbreak;\n\n\t\tcase RESET_KIND_SHUTDOWN:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_UNLOAD);\n\t\t\tbreak;\n\n\t\tcase RESET_KIND_SUSPEND:\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_DRV_STATE_MBOX,\n\t\t\t\t      DRV_STATE_SUSPEND);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int tg3_poll_fw(struct tg3 *tp)\n{\n\tint i;\n\tu32 val;\n\n\tif (tg3_flag(tp, NO_FWARE_REPORTED))\n\t\treturn 0;\n\n\tif (tg3_flag(tp, IS_SSB_CORE)) {\n\t\t/* We don't use firmware. */\n\t\treturn 0;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\t/* Wait up to 20ms for init done. */\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tif (tr32(VCPU_STATUS) & VCPU_STATUS_INIT_DONE)\n\t\t\t\treturn 0;\n\t\t\tif (pci_channel_offline(tp->pdev))\n\t\t\t\treturn -ENODEV;\n\n\t\t\tudelay(100);\n\t\t}\n\t\treturn -ENODEV;\n\t}\n\n\t/* Wait for firmware initialization to complete. */\n\tfor (i = 0; i < 100000; i++) {\n\t\ttg3_read_mem(tp, NIC_SRAM_FIRMWARE_MBOX, &val);\n\t\tif (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)\n\t\t\tbreak;\n\t\tif (pci_channel_offline(tp->pdev)) {\n\t\t\tif (!tg3_flag(tp, NO_FWARE_REPORTED)) {\n\t\t\t\ttg3_flag_set(tp, NO_FWARE_REPORTED);\n\t\t\t\tnetdev_info(tp->dev, \"No firmware running\\n\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(10);\n\t}\n\n\t/* Chip might not be fitted with firmware.  Some Sun onboard\n\t * parts are configured like that.  So don't signal the timeout\n\t * of the above loop as an error, but do report the lack of\n\t * running firmware once.\n\t */\n\tif (i >= 100000 && !tg3_flag(tp, NO_FWARE_REPORTED)) {\n\t\ttg3_flag_set(tp, NO_FWARE_REPORTED);\n\n\t\tnetdev_info(tp->dev, \"No firmware running\\n\");\n\t}\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0) {\n\t\t/* The 57765 A0 needs a little more\n\t\t * time to do some important work.\n\t\t */\n\t\tmdelay(10);\n\t}\n\n\treturn 0;\n}\n\nstatic void tg3_link_report(struct tg3 *tp)\n{\n\tif (!netif_carrier_ok(tp->dev)) {\n\t\tnetif_info(tp, link, tp->dev, \"Link is down\\n\");\n\t\ttg3_ump_link_report(tp);\n\t} else if (netif_msg_link(tp)) {\n\t\tnetdev_info(tp->dev, \"Link is up at %d Mbps, %s duplex\\n\",\n\t\t\t    (tp->link_config.active_speed == SPEED_1000 ?\n\t\t\t     1000 :\n\t\t\t     (tp->link_config.active_speed == SPEED_100 ?\n\t\t\t      100 : 10)),\n\t\t\t    (tp->link_config.active_duplex == DUPLEX_FULL ?\n\t\t\t     \"full\" : \"half\"));\n\n\t\tnetdev_info(tp->dev, \"Flow control is %s for TX and %s for RX\\n\",\n\t\t\t    (tp->link_config.active_flowctrl & FLOW_CTRL_TX) ?\n\t\t\t    \"on\" : \"off\",\n\t\t\t    (tp->link_config.active_flowctrl & FLOW_CTRL_RX) ?\n\t\t\t    \"on\" : \"off\");\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_EEE_CAP)\n\t\t\tnetdev_info(tp->dev, \"EEE is %s\\n\",\n\t\t\t\t    tp->setlpicnt ? \"enabled\" : \"disabled\");\n\n\t\ttg3_ump_link_report(tp);\n\t}\n\n\ttp->link_up = netif_carrier_ok(tp->dev);\n}\n\nstatic u32 tg3_decode_flowctrl_1000T(u32 adv)\n{\n\tu32 flowctrl = 0;\n\n\tif (adv & ADVERTISE_PAUSE_CAP) {\n\t\tflowctrl |= FLOW_CTRL_RX;\n\t\tif (!(adv & ADVERTISE_PAUSE_ASYM))\n\t\t\tflowctrl |= FLOW_CTRL_TX;\n\t} else if (adv & ADVERTISE_PAUSE_ASYM)\n\t\tflowctrl |= FLOW_CTRL_TX;\n\n\treturn flowctrl;\n}\n\nstatic u16 tg3_advert_flowctrl_1000X(u8 flow_ctrl)\n{\n\tu16 miireg;\n\n\tif ((flow_ctrl & FLOW_CTRL_TX) && (flow_ctrl & FLOW_CTRL_RX))\n\t\tmiireg = ADVERTISE_1000XPAUSE;\n\telse if (flow_ctrl & FLOW_CTRL_TX)\n\t\tmiireg = ADVERTISE_1000XPSE_ASYM;\n\telse if (flow_ctrl & FLOW_CTRL_RX)\n\t\tmiireg = ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM;\n\telse\n\t\tmiireg = 0;\n\n\treturn miireg;\n}\n\nstatic u32 tg3_decode_flowctrl_1000X(u32 adv)\n{\n\tu32 flowctrl = 0;\n\n\tif (adv & ADVERTISE_1000XPAUSE) {\n\t\tflowctrl |= FLOW_CTRL_RX;\n\t\tif (!(adv & ADVERTISE_1000XPSE_ASYM))\n\t\t\tflowctrl |= FLOW_CTRL_TX;\n\t} else if (adv & ADVERTISE_1000XPSE_ASYM)\n\t\tflowctrl |= FLOW_CTRL_TX;\n\n\treturn flowctrl;\n}\n\nstatic u8 tg3_resolve_flowctrl_1000X(u16 lcladv, u16 rmtadv)\n{\n\tu8 cap = 0;\n\n\tif (lcladv & rmtadv & ADVERTISE_1000XPAUSE) {\n\t\tcap = FLOW_CTRL_TX | FLOW_CTRL_RX;\n\t} else if (lcladv & rmtadv & ADVERTISE_1000XPSE_ASYM) {\n\t\tif (lcladv & ADVERTISE_1000XPAUSE)\n\t\t\tcap = FLOW_CTRL_RX;\n\t\tif (rmtadv & ADVERTISE_1000XPAUSE)\n\t\t\tcap = FLOW_CTRL_TX;\n\t}\n\n\treturn cap;\n}\n\nstatic void tg3_setup_flow_control(struct tg3 *tp, u32 lcladv, u32 rmtadv)\n{\n\tu8 autoneg;\n\tu8 flowctrl = 0;\n\tu32 old_rx_mode = tp->rx_mode;\n\tu32 old_tx_mode = tp->tx_mode;\n\n\tif (tg3_flag(tp, USE_PHYLIB))\n\t\tautoneg = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr)->autoneg;\n\telse\n\t\tautoneg = tp->link_config.autoneg;\n\n\tif (autoneg == AUTONEG_ENABLE && tg3_flag(tp, PAUSE_AUTONEG)) {\n\t\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\n\t\t\tflowctrl = tg3_resolve_flowctrl_1000X(lcladv, rmtadv);\n\t\telse\n\t\t\tflowctrl = mii_resolve_flowctrl_fdx(lcladv, rmtadv);\n\t} else\n\t\tflowctrl = tp->link_config.flowctrl;\n\n\ttp->link_config.active_flowctrl = flowctrl;\n\n\tif (flowctrl & FLOW_CTRL_RX)\n\t\ttp->rx_mode |= RX_MODE_FLOW_CTRL_ENABLE;\n\telse\n\t\ttp->rx_mode &= ~RX_MODE_FLOW_CTRL_ENABLE;\n\n\tif (old_rx_mode != tp->rx_mode)\n\t\ttw32_f(MAC_RX_MODE, tp->rx_mode);\n\n\tif (flowctrl & FLOW_CTRL_TX)\n\t\ttp->tx_mode |= TX_MODE_FLOW_CTRL_ENABLE;\n\telse\n\t\ttp->tx_mode &= ~TX_MODE_FLOW_CTRL_ENABLE;\n\n\tif (old_tx_mode != tp->tx_mode)\n\t\ttw32_f(MAC_TX_MODE, tp->tx_mode);\n}\n\nstatic void tg3_adjust_link(struct net_device *dev)\n{\n\tu8 oldflowctrl, linkmesg = 0;\n\tu32 mac_mode, lcl_adv, rmt_adv;\n\tstruct tg3 *tp = netdev_priv(dev);\n\tstruct phy_device *phydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\n\tspin_lock_bh(&tp->lock);\n\n\tmac_mode = tp->mac_mode & ~(MAC_MODE_PORT_MODE_MASK |\n\t\t\t\t    MAC_MODE_HALF_DUPLEX);\n\n\toldflowctrl = tp->link_config.active_flowctrl;\n\n\tif (phydev->link) {\n\t\tlcl_adv = 0;\n\t\trmt_adv = 0;\n\n\t\tif (phydev->speed == SPEED_100 || phydev->speed == SPEED_10)\n\t\t\tmac_mode |= MAC_MODE_PORT_MODE_MII;\n\t\telse if (phydev->speed == SPEED_1000 ||\n\t\t\t tg3_asic_rev(tp) != ASIC_REV_5785)\n\t\t\tmac_mode |= MAC_MODE_PORT_MODE_GMII;\n\t\telse\n\t\t\tmac_mode |= MAC_MODE_PORT_MODE_MII;\n\n\t\tif (phydev->duplex == DUPLEX_HALF)\n\t\t\tmac_mode |= MAC_MODE_HALF_DUPLEX;\n\t\telse {\n\t\t\tlcl_adv = mii_advertise_flowctrl(\n\t\t\t\t  tp->link_config.flowctrl);\n\n\t\t\tif (phydev->pause)\n\t\t\t\trmt_adv = LPA_PAUSE_CAP;\n\t\t\tif (phydev->asym_pause)\n\t\t\t\trmt_adv |= LPA_PAUSE_ASYM;\n\t\t}\n\n\t\ttg3_setup_flow_control(tp, lcl_adv, rmt_adv);\n\t} else\n\t\tmac_mode |= MAC_MODE_PORT_MODE_GMII;\n\n\tif (mac_mode != tp->mac_mode) {\n\t\ttp->mac_mode = mac_mode;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5785) {\n\t\tif (phydev->speed == SPEED_10)\n\t\t\ttw32(MAC_MI_STAT,\n\t\t\t     MAC_MI_STAT_10MBPS_MODE |\n\t\t\t     MAC_MI_STAT_LNKSTAT_ATTN_ENAB);\n\t\telse\n\t\t\ttw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);\n\t}\n\n\tif (phydev->speed == SPEED_1000 && phydev->duplex == DUPLEX_HALF)\n\t\ttw32(MAC_TX_LENGTHS,\n\t\t     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |\n\t\t      (6 << TX_LENGTHS_IPG_SHIFT) |\n\t\t      (0xff << TX_LENGTHS_SLOT_TIME_SHIFT)));\n\telse\n\t\ttw32(MAC_TX_LENGTHS,\n\t\t     ((2 << TX_LENGTHS_IPG_CRS_SHIFT) |\n\t\t      (6 << TX_LENGTHS_IPG_SHIFT) |\n\t\t      (32 << TX_LENGTHS_SLOT_TIME_SHIFT)));\n\n\tif (phydev->link != tp->old_link ||\n\t    phydev->speed != tp->link_config.active_speed ||\n\t    phydev->duplex != tp->link_config.active_duplex ||\n\t    oldflowctrl != tp->link_config.active_flowctrl)\n\t\tlinkmesg = 1;\n\n\ttp->old_link = phydev->link;\n\ttp->link_config.active_speed = phydev->speed;\n\ttp->link_config.active_duplex = phydev->duplex;\n\n\tspin_unlock_bh(&tp->lock);\n\n\tif (linkmesg)\n\t\ttg3_link_report(tp);\n}\n\nstatic int tg3_phy_init(struct tg3 *tp)\n{\n\tstruct phy_device *phydev;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED)\n\t\treturn 0;\n\n\t/* Bring the PHY back to a known state. */\n\ttg3_bmcr_reset(tp);\n\n\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\n\t/* Attach the MAC to the PHY. */\n\tphydev = phy_connect(tp->dev, phydev_name(phydev),\n\t\t\t     tg3_adjust_link, phydev->interface);\n\tif (IS_ERR(phydev)) {\n\t\tdev_err(&tp->pdev->dev, \"Could not attach to PHY\\n\");\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\t/* Mask with MAC supported features. */\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_GMII:\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\t\tphy_set_max_speed(phydev, SPEED_1000);\n\t\t\tphy_support_asym_pause(phydev);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tphy_set_max_speed(phydev, SPEED_100);\n\t\tphy_support_asym_pause(phydev);\n\t\tbreak;\n\tdefault:\n\t\tphy_disconnect(mdiobus_get_phy(tp->mdio_bus, tp->phy_addr));\n\t\treturn -EINVAL;\n\t}\n\n\ttp->phy_flags |= TG3_PHYFLG_IS_CONNECTED;\n\n\tphy_attached_info(phydev);\n\n\treturn 0;\n}\n\nstatic void tg3_phy_start(struct tg3 *tp)\n{\n\tstruct phy_device *phydev;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\n\t\treturn;\n\n\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) {\n\t\ttp->phy_flags &= ~TG3_PHYFLG_IS_LOW_POWER;\n\t\tphydev->speed = tp->link_config.speed;\n\t\tphydev->duplex = tp->link_config.duplex;\n\t\tphydev->autoneg = tp->link_config.autoneg;\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\tphydev->advertising, tp->link_config.advertising);\n\t}\n\n\tphy_start(phydev);\n\n\tphy_start_aneg(phydev);\n}\n\nstatic void tg3_phy_stop(struct tg3 *tp)\n{\n\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\n\t\treturn;\n\n\tphy_stop(mdiobus_get_phy(tp->mdio_bus, tp->phy_addr));\n}\n\nstatic void tg3_phy_fini(struct tg3 *tp)\n{\n\tif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\n\t\tphy_disconnect(mdiobus_get_phy(tp->mdio_bus, tp->phy_addr));\n\t\ttp->phy_flags &= ~TG3_PHYFLG_IS_CONNECTED;\n\t}\n}\n\nstatic int tg3_phy_set_extloopbk(struct tg3 *tp)\n{\n\tint err;\n\tu32 val;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET)\n\t\treturn 0;\n\n\tif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\n\t\t/* Cannot do read-modify-write on 5401 */\n\t\terr = tg3_phy_auxctl_write(tp,\n\t\t\t\t\t   MII_TG3_AUXCTL_SHDWSEL_AUXCTL,\n\t\t\t\t\t   MII_TG3_AUXCTL_ACTL_EXTLOOPBK |\n\t\t\t\t\t   0x4c20);\n\t\tgoto done;\n\t}\n\n\terr = tg3_phy_auxctl_read(tp,\n\t\t\t\t  MII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);\n\tif (err)\n\t\treturn err;\n\n\tval |= MII_TG3_AUXCTL_ACTL_EXTLOOPBK;\n\terr = tg3_phy_auxctl_write(tp,\n\t\t\t\t   MII_TG3_AUXCTL_SHDWSEL_AUXCTL, val);\n\ndone:\n\treturn err;\n}\n\nstatic void tg3_phy_fet_toggle_apd(struct tg3 *tp, bool enable)\n{\n\tu32 phytest;\n\n\tif (!tg3_readphy(tp, MII_TG3_FET_TEST, &phytest)) {\n\t\tu32 phy;\n\n\t\ttg3_writephy(tp, MII_TG3_FET_TEST,\n\t\t\t     phytest | MII_TG3_FET_SHADOW_EN);\n\t\tif (!tg3_readphy(tp, MII_TG3_FET_SHDW_AUXSTAT2, &phy)) {\n\t\t\tif (enable)\n\t\t\t\tphy |= MII_TG3_FET_SHDW_AUXSTAT2_APD;\n\t\t\telse\n\t\t\t\tphy &= ~MII_TG3_FET_SHDW_AUXSTAT2_APD;\n\t\t\ttg3_writephy(tp, MII_TG3_FET_SHDW_AUXSTAT2, phy);\n\t\t}\n\t\ttg3_writephy(tp, MII_TG3_FET_TEST, phytest);\n\t}\n}\n\nstatic void tg3_phy_toggle_apd(struct tg3 *tp, bool enable)\n{\n\tu32 reg;\n\n\tif (!tg3_flag(tp, 5705_PLUS) ||\n\t    (tg3_flag(tp, 5717_PLUS) &&\n\t     (tp->phy_flags & TG3_PHYFLG_MII_SERDES)))\n\t\treturn;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\ttg3_phy_fet_toggle_apd(tp, enable);\n\t\treturn;\n\t}\n\n\treg = MII_TG3_MISC_SHDW_SCR5_LPED |\n\t      MII_TG3_MISC_SHDW_SCR5_DLPTLM |\n\t      MII_TG3_MISC_SHDW_SCR5_SDTL |\n\t      MII_TG3_MISC_SHDW_SCR5_C125OE;\n\tif (tg3_asic_rev(tp) != ASIC_REV_5784 || !enable)\n\t\treg |= MII_TG3_MISC_SHDW_SCR5_DLLAPD;\n\n\ttg3_phy_shdw_write(tp, MII_TG3_MISC_SHDW_SCR5_SEL, reg);\n\n\n\treg = MII_TG3_MISC_SHDW_APD_WKTM_84MS;\n\tif (enable)\n\t\treg |= MII_TG3_MISC_SHDW_APD_ENABLE;\n\n\ttg3_phy_shdw_write(tp, MII_TG3_MISC_SHDW_APD_SEL, reg);\n}\n\nstatic void tg3_phy_toggle_automdix(struct tg3 *tp, bool enable)\n{\n\tu32 phy;\n\n\tif (!tg3_flag(tp, 5705_PLUS) ||\n\t    (tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\n\t\treturn;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\tu32 ephy;\n\n\t\tif (!tg3_readphy(tp, MII_TG3_FET_TEST, &ephy)) {\n\t\t\tu32 reg = MII_TG3_FET_SHDW_MISCCTRL;\n\n\t\t\ttg3_writephy(tp, MII_TG3_FET_TEST,\n\t\t\t\t     ephy | MII_TG3_FET_SHADOW_EN);\n\t\t\tif (!tg3_readphy(tp, reg, &phy)) {\n\t\t\t\tif (enable)\n\t\t\t\t\tphy |= MII_TG3_FET_SHDW_MISCCTRL_MDIX;\n\t\t\t\telse\n\t\t\t\t\tphy &= ~MII_TG3_FET_SHDW_MISCCTRL_MDIX;\n\t\t\t\ttg3_writephy(tp, reg, phy);\n\t\t\t}\n\t\t\ttg3_writephy(tp, MII_TG3_FET_TEST, ephy);\n\t\t}\n\t} else {\n\t\tint ret;\n\n\t\tret = tg3_phy_auxctl_read(tp,\n\t\t\t\t\t  MII_TG3_AUXCTL_SHDWSEL_MISC, &phy);\n\t\tif (!ret) {\n\t\t\tif (enable)\n\t\t\t\tphy |= MII_TG3_AUXCTL_MISC_FORCE_AMDIX;\n\t\t\telse\n\t\t\t\tphy &= ~MII_TG3_AUXCTL_MISC_FORCE_AMDIX;\n\t\t\ttg3_phy_auxctl_write(tp,\n\t\t\t\t\t     MII_TG3_AUXCTL_SHDWSEL_MISC, phy);\n\t\t}\n\t}\n}\n\nstatic void tg3_phy_set_wirespeed(struct tg3 *tp)\n{\n\tint ret;\n\tu32 val;\n\n\tif (tp->phy_flags & TG3_PHYFLG_NO_ETH_WIRE_SPEED)\n\t\treturn;\n\n\tret = tg3_phy_auxctl_read(tp, MII_TG3_AUXCTL_SHDWSEL_MISC, &val);\n\tif (!ret)\n\t\ttg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_MISC,\n\t\t\t\t     val | MII_TG3_AUXCTL_MISC_WIRESPD_EN);\n}\n\nstatic void tg3_phy_apply_otp(struct tg3 *tp)\n{\n\tu32 otp, phy;\n\n\tif (!tp->phy_otp)\n\t\treturn;\n\n\totp = tp->phy_otp;\n\n\tif (tg3_phy_toggle_auxctl_smdsp(tp, true))\n\t\treturn;\n\n\tphy = ((otp & TG3_OTP_AGCTGT_MASK) >> TG3_OTP_AGCTGT_SHIFT);\n\tphy |= MII_TG3_DSP_TAP1_AGCTGT_DFLT;\n\ttg3_phydsp_write(tp, MII_TG3_DSP_TAP1, phy);\n\n\tphy = ((otp & TG3_OTP_HPFFLTR_MASK) >> TG3_OTP_HPFFLTR_SHIFT) |\n\t      ((otp & TG3_OTP_HPFOVER_MASK) >> TG3_OTP_HPFOVER_SHIFT);\n\ttg3_phydsp_write(tp, MII_TG3_DSP_AADJ1CH0, phy);\n\n\tphy = ((otp & TG3_OTP_LPFDIS_MASK) >> TG3_OTP_LPFDIS_SHIFT);\n\tphy |= MII_TG3_DSP_AADJ1CH3_ADCCKADJ;\n\ttg3_phydsp_write(tp, MII_TG3_DSP_AADJ1CH3, phy);\n\n\tphy = ((otp & TG3_OTP_VDAC_MASK) >> TG3_OTP_VDAC_SHIFT);\n\ttg3_phydsp_write(tp, MII_TG3_DSP_EXP75, phy);\n\n\tphy = ((otp & TG3_OTP_10BTAMP_MASK) >> TG3_OTP_10BTAMP_SHIFT);\n\ttg3_phydsp_write(tp, MII_TG3_DSP_EXP96, phy);\n\n\tphy = ((otp & TG3_OTP_ROFF_MASK) >> TG3_OTP_ROFF_SHIFT) |\n\t      ((otp & TG3_OTP_RCOFF_MASK) >> TG3_OTP_RCOFF_SHIFT);\n\ttg3_phydsp_write(tp, MII_TG3_DSP_EXP97, phy);\n\n\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n}\n\nstatic void tg3_eee_pull_config(struct tg3 *tp, struct ethtool_eee *eee)\n{\n\tu32 val;\n\tstruct ethtool_eee *dest = &tp->eee;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\n\t\treturn;\n\n\tif (eee)\n\t\tdest = eee;\n\n\tif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, TG3_CL45_D7_EEERES_STAT, &val))\n\t\treturn;\n\n\t/* Pull eee_active */\n\tif (val == TG3_CL45_D7_EEERES_STAT_LP_1000T ||\n\t    val == TG3_CL45_D7_EEERES_STAT_LP_100TX) {\n\t\tdest->eee_active = 1;\n\t} else\n\t\tdest->eee_active = 0;\n\n\t/* Pull lp advertised settings */\n\tif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_LPABLE, &val))\n\t\treturn;\n\tdest->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\t/* Pull advertised and eee_enabled settings */\n\tif (tg3_phy_cl45_read(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, &val))\n\t\treturn;\n\tdest->eee_enabled = !!val;\n\tdest->advertised = mmd_eee_adv_to_ethtool_adv_t(val);\n\n\t/* Pull tx_lpi_enabled */\n\tval = tr32(TG3_CPMU_EEE_MODE);\n\tdest->tx_lpi_enabled = !!(val & TG3_CPMU_EEEMD_LPI_IN_TX);\n\n\t/* Pull lpi timer value */\n\tdest->tx_lpi_timer = tr32(TG3_CPMU_EEE_DBTMR1) & 0xffff;\n}\n\nstatic void tg3_phy_eee_adjust(struct tg3 *tp, bool current_link_up)\n{\n\tu32 val;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\n\t\treturn;\n\n\ttp->setlpicnt = 0;\n\n\tif (tp->link_config.autoneg == AUTONEG_ENABLE &&\n\t    current_link_up &&\n\t    tp->link_config.active_duplex == DUPLEX_FULL &&\n\t    (tp->link_config.active_speed == SPEED_100 ||\n\t     tp->link_config.active_speed == SPEED_1000)) {\n\t\tu32 eeectl;\n\n\t\tif (tp->link_config.active_speed == SPEED_1000)\n\t\t\teeectl = TG3_CPMU_EEE_CTRL_EXIT_16_5_US;\n\t\telse\n\t\t\teeectl = TG3_CPMU_EEE_CTRL_EXIT_36_US;\n\n\t\ttw32(TG3_CPMU_EEE_CTRL, eeectl);\n\n\t\ttg3_eee_pull_config(tp, NULL);\n\t\tif (tp->eee.eee_active)\n\t\t\ttp->setlpicnt = 2;\n\t}\n\n\tif (!tp->setlpicnt) {\n\t\tif (current_link_up &&\n\t\t   !tg3_phy_toggle_auxctl_smdsp(tp, true)) {\n\t\t\ttg3_phydsp_write(tp, MII_TG3_DSP_TAP26, 0x0000);\n\t\t\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n\t\t}\n\n\t\tval = tr32(TG3_CPMU_EEE_MODE);\n\t\ttw32(TG3_CPMU_EEE_MODE, val & ~TG3_CPMU_EEEMD_LPI_ENABLE);\n\t}\n}\n\nstatic void tg3_phy_eee_enable(struct tg3 *tp)\n{\n\tu32 val;\n\n\tif (tp->link_config.active_speed == SPEED_1000 &&\n\t    (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t     tg3_flag(tp, 57765_CLASS)) &&\n\t    !tg3_phy_toggle_auxctl_smdsp(tp, true)) {\n\t\tval = MII_TG3_DSP_TAP26_ALNOKO |\n\t\t      MII_TG3_DSP_TAP26_RMRXSTO;\n\t\ttg3_phydsp_write(tp, MII_TG3_DSP_TAP26, val);\n\t\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n\t}\n\n\tval = tr32(TG3_CPMU_EEE_MODE);\n\ttw32(TG3_CPMU_EEE_MODE, val | TG3_CPMU_EEEMD_LPI_ENABLE);\n}\n\nstatic int tg3_wait_macro_done(struct tg3 *tp)\n{\n\tint limit = 100;\n\n\twhile (limit--) {\n\t\tu32 tmp32;\n\n\t\tif (!tg3_readphy(tp, MII_TG3_DSP_CONTROL, &tmp32)) {\n\t\t\tif ((tmp32 & 0x1000) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (limit < 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int tg3_phy_write_and_check_testpat(struct tg3 *tp, int *resetp)\n{\n\tstatic const u32 test_pat[4][6] = {\n\t{ 0x00005555, 0x00000005, 0x00002aaa, 0x0000000a, 0x00003456, 0x00000003 },\n\t{ 0x00002aaa, 0x0000000a, 0x00003333, 0x00000003, 0x0000789a, 0x00000005 },\n\t{ 0x00005a5a, 0x00000005, 0x00002a6a, 0x0000000a, 0x00001bcd, 0x00000003 },\n\t{ 0x00002a5a, 0x0000000a, 0x000033c3, 0x00000003, 0x00002ef1, 0x00000005 }\n\t};\n\tint chan;\n\n\tfor (chan = 0; chan < 4; chan++) {\n\t\tint i;\n\n\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t     (chan * 0x2000) | 0x0200);\n\t\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0002);\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\ttg3_writephy(tp, MII_TG3_DSP_RW_PORT,\n\t\t\t\t     test_pat[chan][i]);\n\n\t\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0202);\n\t\tif (tg3_wait_macro_done(tp)) {\n\t\t\t*resetp = 1;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t     (chan * 0x2000) | 0x0200);\n\t\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0082);\n\t\tif (tg3_wait_macro_done(tp)) {\n\t\t\t*resetp = 1;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0802);\n\t\tif (tg3_wait_macro_done(tp)) {\n\t\t\t*resetp = 1;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tu32 low, high;\n\n\t\t\tif (tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &low) ||\n\t\t\t    tg3_readphy(tp, MII_TG3_DSP_RW_PORT, &high) ||\n\t\t\t    tg3_wait_macro_done(tp)) {\n\t\t\t\t*resetp = 1;\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\tlow &= 0x7fff;\n\t\t\thigh &= 0x000f;\n\t\t\tif (low != test_pat[chan][i] ||\n\t\t\t    high != test_pat[chan][i+1]) {\n\t\t\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000b);\n\t\t\t\ttg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4001);\n\t\t\t\ttg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x4005);\n\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tg3_phy_reset_chanpat(struct tg3 *tp)\n{\n\tint chan;\n\n\tfor (chan = 0; chan < 4; chan++) {\n\t\tint i;\n\n\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t     (chan * 0x2000) | 0x0200);\n\t\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0002);\n\t\tfor (i = 0; i < 6; i++)\n\t\t\ttg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x000);\n\t\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0202);\n\t\tif (tg3_wait_macro_done(tp))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int tg3_phy_reset_5703_4_5(struct tg3 *tp)\n{\n\tu32 reg32, phy9_orig;\n\tint retries, do_phy_reset, err;\n\n\tretries = 10;\n\tdo_phy_reset = 1;\n\tdo {\n\t\tif (do_phy_reset) {\n\t\t\terr = tg3_bmcr_reset(tp);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tdo_phy_reset = 0;\n\t\t}\n\n\t\t/* Disable transmitter and interrupt.  */\n\t\tif (tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32))\n\t\t\tcontinue;\n\n\t\treg32 |= 0x3000;\n\t\ttg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);\n\n\t\t/* Set full-duplex, 1000 mbps.  */\n\t\ttg3_writephy(tp, MII_BMCR,\n\t\t\t     BMCR_FULLDPLX | BMCR_SPEED1000);\n\n\t\t/* Set to master mode.  */\n\t\tif (tg3_readphy(tp, MII_CTRL1000, &phy9_orig))\n\t\t\tcontinue;\n\n\t\ttg3_writephy(tp, MII_CTRL1000,\n\t\t\t     CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER);\n\n\t\terr = tg3_phy_toggle_auxctl_smdsp(tp, true);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t/* Block the PHY control access.  */\n\t\ttg3_phydsp_write(tp, 0x8005, 0x0800);\n\n\t\terr = tg3_phy_write_and_check_testpat(tp, &do_phy_reset);\n\t\tif (!err)\n\t\t\tbreak;\n\t} while (--retries);\n\n\terr = tg3_phy_reset_chanpat(tp);\n\tif (err)\n\t\treturn err;\n\n\ttg3_phydsp_write(tp, 0x8005, 0x0000);\n\n\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x8200);\n\ttg3_writephy(tp, MII_TG3_DSP_CONTROL, 0x0000);\n\n\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n\n\ttg3_writephy(tp, MII_CTRL1000, phy9_orig);\n\n\terr = tg3_readphy(tp, MII_TG3_EXT_CTRL, &reg32);\n\tif (err)\n\t\treturn err;\n\n\treg32 &= ~0x3000;\n\ttg3_writephy(tp, MII_TG3_EXT_CTRL, reg32);\n\n\treturn 0;\n}\n\nstatic void tg3_carrier_off(struct tg3 *tp)\n{\n\tnetif_carrier_off(tp->dev);\n\ttp->link_up = false;\n}\n\nstatic void tg3_warn_mgmt_link_flap(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, ENABLE_ASF))\n\t\tnetdev_warn(tp->dev,\n\t\t\t    \"Management side-band traffic will be interrupted during phy settings change\\n\");\n}\n\n/* This will reset the tigon3 PHY if there is no valid\n * link unless the FORCE argument is non-zero.\n */\nstatic int tg3_phy_reset(struct tg3 *tp)\n{\n\tu32 val, cpmuctrl;\n\tint err;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tval = tr32(GRC_MISC_CFG);\n\t\ttw32_f(GRC_MISC_CFG, val & ~GRC_MISC_CFG_EPHY_IDDQ);\n\t\tudelay(40);\n\t}\n\terr  = tg3_readphy(tp, MII_BMSR, &val);\n\terr |= tg3_readphy(tp, MII_BMSR, &val);\n\tif (err != 0)\n\t\treturn -EBUSY;\n\n\tif (netif_running(tp->dev) && tp->link_up) {\n\t\tnetif_carrier_off(tp->dev);\n\t\ttg3_link_report(tp);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5704 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\terr = tg3_phy_reset_5703_4_5(tp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto out;\n\t}\n\n\tcpmuctrl = 0;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5784 &&\n\t    tg3_chip_rev(tp) != CHIPREV_5784_AX) {\n\t\tcpmuctrl = tr32(TG3_CPMU_CTRL);\n\t\tif (cpmuctrl & CPMU_CTRL_GPHY_10MB_RXONLY)\n\t\t\ttw32(TG3_CPMU_CTRL,\n\t\t\t     cpmuctrl & ~CPMU_CTRL_GPHY_10MB_RXONLY);\n\t}\n\n\terr = tg3_bmcr_reset(tp);\n\tif (err)\n\t\treturn err;\n\n\tif (cpmuctrl & CPMU_CTRL_GPHY_10MB_RXONLY) {\n\t\tval = MII_TG3_DSP_EXP8_AEDW | MII_TG3_DSP_EXP8_REJ2MHz;\n\t\ttg3_phydsp_write(tp, MII_TG3_DSP_EXP8, val);\n\n\t\ttw32(TG3_CPMU_CTRL, cpmuctrl);\n\t}\n\n\tif (tg3_chip_rev(tp) == CHIPREV_5784_AX ||\n\t    tg3_chip_rev(tp) == CHIPREV_5761_AX) {\n\t\tval = tr32(TG3_CPMU_LSPD_1000MB_CLK);\n\t\tif ((val & CPMU_LSPD_1000MB_MACCLK_MASK) ==\n\t\t    CPMU_LSPD_1000MB_MACCLK_12_5) {\n\t\t\tval &= ~CPMU_LSPD_1000MB_MACCLK_MASK;\n\t\t\tudelay(40);\n\t\t\ttw32_f(TG3_CPMU_LSPD_1000MB_CLK, val);\n\t\t}\n\t}\n\n\tif (tg3_flag(tp, 5717_PLUS) &&\n\t    (tp->phy_flags & TG3_PHYFLG_MII_SERDES))\n\t\treturn 0;\n\n\ttg3_phy_apply_otp(tp);\n\n\tif (tp->phy_flags & TG3_PHYFLG_ENABLE_APD)\n\t\ttg3_phy_toggle_apd(tp, true);\n\telse\n\t\ttg3_phy_toggle_apd(tp, false);\n\nout:\n\tif ((tp->phy_flags & TG3_PHYFLG_ADC_BUG) &&\n\t    !tg3_phy_toggle_auxctl_smdsp(tp, true)) {\n\t\ttg3_phydsp_write(tp, 0x201f, 0x2aaa);\n\t\ttg3_phydsp_write(tp, 0x000a, 0x0323);\n\t\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n\t}\n\n\tif (tp->phy_flags & TG3_PHYFLG_5704_A0_BUG) {\n\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8d68);\n\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8d68);\n\t}\n\n\tif (tp->phy_flags & TG3_PHYFLG_BER_BUG) {\n\t\tif (!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\n\t\t\ttg3_phydsp_write(tp, 0x000a, 0x310b);\n\t\t\ttg3_phydsp_write(tp, 0x201f, 0x9506);\n\t\t\ttg3_phydsp_write(tp, 0x401f, 0x14e2);\n\t\t\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n\t\t}\n\t} else if (tp->phy_flags & TG3_PHYFLG_JITTER_BUG) {\n\t\tif (!tg3_phy_toggle_auxctl_smdsp(tp, true)) {\n\t\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS, 0x000a);\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_ADJUST_TRIM) {\n\t\t\t\ttg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x110b);\n\t\t\t\ttg3_writephy(tp, MII_TG3_TEST1,\n\t\t\t\t\t     MII_TG3_TEST1_TRIM_EN | 0x4);\n\t\t\t} else\n\t\t\t\ttg3_writephy(tp, MII_TG3_DSP_RW_PORT, 0x010b);\n\n\t\t\ttg3_phy_toggle_auxctl_smdsp(tp, false);\n\t\t}\n\t}\n\n\t/* Set Extended packet length bit (bit 14) on all chips that */\n\t/* support jumbo frames */\n\tif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\n\t\t/* Cannot do read-modify-write on 5401 */\n\t\ttg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, 0x4c20);\n\t} else if (tg3_flag(tp, JUMBO_CAPABLE)) {\n\t\t/* Set bit 14 with read-modify-write to preserve other bits */\n\t\terr = tg3_phy_auxctl_read(tp,\n\t\t\t\t\t  MII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);\n\t\tif (!err)\n\t\t\ttg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL,\n\t\t\t\t\t   val | MII_TG3_AUXCTL_ACTL_EXTPKTLEN);\n\t}\n\n\t/* Set phy register 0x10 bit 0 to high fifo elasticity to support\n\t * jumbo frames transmission.\n\t */\n\tif (tg3_flag(tp, JUMBO_CAPABLE)) {\n\t\tif (!tg3_readphy(tp, MII_TG3_EXT_CTRL, &val))\n\t\t\ttg3_writephy(tp, MII_TG3_EXT_CTRL,\n\t\t\t\t     val | MII_TG3_EXT_CTRL_FIFO_ELASTIC);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\t/* adjust output voltage */\n\t\ttg3_writephy(tp, MII_TG3_FET_PTEST, 0x12);\n\t}\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5762_A0)\n\t\ttg3_phydsp_write(tp, 0xffb, 0x4000);\n\n\ttg3_phy_toggle_automdix(tp, true);\n\ttg3_phy_set_wirespeed(tp);\n\treturn 0;\n}\n\n#define TG3_GPIO_MSG_DRVR_PRES\t\t 0x00000001\n#define TG3_GPIO_MSG_NEED_VAUX\t\t 0x00000002\n#define TG3_GPIO_MSG_MASK\t\t (TG3_GPIO_MSG_DRVR_PRES | \\\n\t\t\t\t\t  TG3_GPIO_MSG_NEED_VAUX)\n#define TG3_GPIO_MSG_ALL_DRVR_PRES_MASK \\\n\t((TG3_GPIO_MSG_DRVR_PRES << 0) | \\\n\t (TG3_GPIO_MSG_DRVR_PRES << 4) | \\\n\t (TG3_GPIO_MSG_DRVR_PRES << 8) | \\\n\t (TG3_GPIO_MSG_DRVR_PRES << 12))\n\n#define TG3_GPIO_MSG_ALL_NEED_VAUX_MASK \\\n\t((TG3_GPIO_MSG_NEED_VAUX << 0) | \\\n\t (TG3_GPIO_MSG_NEED_VAUX << 4) | \\\n\t (TG3_GPIO_MSG_NEED_VAUX << 8) | \\\n\t (TG3_GPIO_MSG_NEED_VAUX << 12))\n\nstatic inline u32 tg3_set_function_status(struct tg3 *tp, u32 newstat)\n{\n\tu32 status, shift;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719)\n\t\tstatus = tg3_ape_read32(tp, TG3_APE_GPIO_MSG);\n\telse\n\t\tstatus = tr32(TG3_CPMU_DRV_STATUS);\n\n\tshift = TG3_APE_GPIO_MSG_SHIFT + 4 * tp->pci_fn;\n\tstatus &= ~(TG3_GPIO_MSG_MASK << shift);\n\tstatus |= (newstat << shift);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719)\n\t\ttg3_ape_write32(tp, TG3_APE_GPIO_MSG, status);\n\telse\n\t\ttw32(TG3_CPMU_DRV_STATUS, status);\n\n\treturn status >> TG3_APE_GPIO_MSG_SHIFT;\n}\n\nstatic inline int tg3_pwrsrc_switch_to_vmain(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, IS_NIC))\n\t\treturn 0;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720) {\n\t\tif (tg3_ape_lock(tp, TG3_APE_LOCK_GPIO))\n\t\t\treturn -EIO;\n\n\t\ttg3_set_function_status(tp, TG3_GPIO_MSG_DRVR_PRES);\n\n\t\ttw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\t\ttg3_ape_unlock(tp, TG3_APE_LOCK_GPIO);\n\t} else {\n\t\ttw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\t}\n\n\treturn 0;\n}\n\nstatic void tg3_pwrsrc_die_with_vmain(struct tg3 *tp)\n{\n\tu32 grc_local_ctrl;\n\n\tif (!tg3_flag(tp, IS_NIC) ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5701)\n\t\treturn;\n\n\tgrc_local_ctrl = tp->grc_local_ctrl | GRC_LCLCTRL_GPIO_OE1;\n\n\ttw32_wait_f(GRC_LOCAL_CTRL,\n\t\t    grc_local_ctrl | GRC_LCLCTRL_GPIO_OUTPUT1,\n\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\ttw32_wait_f(GRC_LOCAL_CTRL,\n\t\t    grc_local_ctrl,\n\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\ttw32_wait_f(GRC_LOCAL_CTRL,\n\t\t    grc_local_ctrl | GRC_LCLCTRL_GPIO_OUTPUT1,\n\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n}\n\nstatic void tg3_pwrsrc_switch_to_vaux(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, IS_NIC))\n\t\treturn;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5701) {\n\t\ttw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |\n\t\t\t    (GRC_LCLCTRL_GPIO_OE0 |\n\t\t\t     GRC_LCLCTRL_GPIO_OE1 |\n\t\t\t     GRC_LCLCTRL_GPIO_OE2 |\n\t\t\t     GRC_LCLCTRL_GPIO_OUTPUT0 |\n\t\t\t     GRC_LCLCTRL_GPIO_OUTPUT1),\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\t} else if (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||\n\t\t   tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S) {\n\t\t/* The 5761 non-e device swaps GPIO 0 and GPIO 2. */\n\t\tu32 grc_local_ctrl = GRC_LCLCTRL_GPIO_OE0 |\n\t\t\t\t     GRC_LCLCTRL_GPIO_OE1 |\n\t\t\t\t     GRC_LCLCTRL_GPIO_OE2 |\n\t\t\t\t     GRC_LCLCTRL_GPIO_OUTPUT0 |\n\t\t\t\t     GRC_LCLCTRL_GPIO_OUTPUT1 |\n\t\t\t\t     tp->grc_local_ctrl;\n\t\ttw32_wait_f(GRC_LOCAL_CTRL, grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\t\tgrc_local_ctrl |= GRC_LCLCTRL_GPIO_OUTPUT2;\n\t\ttw32_wait_f(GRC_LOCAL_CTRL, grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\t\tgrc_local_ctrl &= ~GRC_LCLCTRL_GPIO_OUTPUT0;\n\t\ttw32_wait_f(GRC_LOCAL_CTRL, grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\t} else {\n\t\tu32 no_gpio2;\n\t\tu32 grc_local_ctrl = 0;\n\n\t\t/* Workaround to prevent overdrawing Amps. */\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5714) {\n\t\t\tgrc_local_ctrl |= GRC_LCLCTRL_GPIO_OE3;\n\t\t\ttw32_wait_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl |\n\t\t\t\t    grc_local_ctrl,\n\t\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\t\t}\n\n\t\t/* On 5753 and variants, GPIO2 cannot be used. */\n\t\tno_gpio2 = tp->nic_sram_data_cfg &\n\t\t\t   NIC_SRAM_DATA_CFG_NO_GPIO2;\n\n\t\tgrc_local_ctrl |= GRC_LCLCTRL_GPIO_OE0 |\n\t\t\t\t  GRC_LCLCTRL_GPIO_OE1 |\n\t\t\t\t  GRC_LCLCTRL_GPIO_OE2 |\n\t\t\t\t  GRC_LCLCTRL_GPIO_OUTPUT1 |\n\t\t\t\t  GRC_LCLCTRL_GPIO_OUTPUT2;\n\t\tif (no_gpio2) {\n\t\t\tgrc_local_ctrl &= ~(GRC_LCLCTRL_GPIO_OE2 |\n\t\t\t\t\t    GRC_LCLCTRL_GPIO_OUTPUT2);\n\t\t}\n\t\ttw32_wait_f(GRC_LOCAL_CTRL,\n\t\t\t    tp->grc_local_ctrl | grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\t\tgrc_local_ctrl |= GRC_LCLCTRL_GPIO_OUTPUT0;\n\n\t\ttw32_wait_f(GRC_LOCAL_CTRL,\n\t\t\t    tp->grc_local_ctrl | grc_local_ctrl,\n\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\n\t\tif (!no_gpio2) {\n\t\t\tgrc_local_ctrl &= ~GRC_LCLCTRL_GPIO_OUTPUT2;\n\t\t\ttw32_wait_f(GRC_LOCAL_CTRL,\n\t\t\t\t    tp->grc_local_ctrl | grc_local_ctrl,\n\t\t\t\t    TG3_GRC_LCLCTL_PWRSW_DELAY);\n\t\t}\n\t}\n}\n\nstatic void tg3_frob_aux_power_5717(struct tg3 *tp, bool wol_enable)\n{\n\tu32 msg = 0;\n\n\t/* Serialize power state transitions */\n\tif (tg3_ape_lock(tp, TG3_APE_LOCK_GPIO))\n\t\treturn;\n\n\tif (tg3_flag(tp, ENABLE_ASF) || tg3_flag(tp, ENABLE_APE) || wol_enable)\n\t\tmsg = TG3_GPIO_MSG_NEED_VAUX;\n\n\tmsg = tg3_set_function_status(tp, msg);\n\n\tif (msg & TG3_GPIO_MSG_ALL_DRVR_PRES_MASK)\n\t\tgoto done;\n\n\tif (msg & TG3_GPIO_MSG_ALL_NEED_VAUX_MASK)\n\t\ttg3_pwrsrc_switch_to_vaux(tp);\n\telse\n\t\ttg3_pwrsrc_die_with_vmain(tp);\n\ndone:\n\ttg3_ape_unlock(tp, TG3_APE_LOCK_GPIO);\n}\n\nstatic void tg3_frob_aux_power(struct tg3 *tp, bool include_wol)\n{\n\tbool need_vaux = false;\n\n\t/* The GPIOs do something completely different on 57765. */\n\tif (!tg3_flag(tp, IS_NIC) || tg3_flag(tp, 57765_CLASS))\n\t\treturn;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720) {\n\t\ttg3_frob_aux_power_5717(tp, include_wol ?\n\t\t\t\t\ttg3_flag(tp, WOL_ENABLE) != 0 : 0);\n\t\treturn;\n\t}\n\n\tif (tp->pdev_peer && tp->pdev_peer != tp->pdev) {\n\t\tstruct net_device *dev_peer;\n\n\t\tdev_peer = pci_get_drvdata(tp->pdev_peer);\n\n\t\t/* remove_one() may have been run on the peer. */\n\t\tif (dev_peer) {\n\t\t\tstruct tg3 *tp_peer = netdev_priv(dev_peer);\n\n\t\t\tif (tg3_flag(tp_peer, INIT_COMPLETE))\n\t\t\t\treturn;\n\n\t\t\tif ((include_wol && tg3_flag(tp_peer, WOL_ENABLE)) ||\n\t\t\t    tg3_flag(tp_peer, ENABLE_ASF))\n\t\t\t\tneed_vaux = true;\n\t\t}\n\t}\n\n\tif ((include_wol && tg3_flag(tp, WOL_ENABLE)) ||\n\t    tg3_flag(tp, ENABLE_ASF))\n\t\tneed_vaux = true;\n\n\tif (need_vaux)\n\t\ttg3_pwrsrc_switch_to_vaux(tp);\n\telse\n\t\ttg3_pwrsrc_die_with_vmain(tp);\n}\n\nstatic int tg3_5700_link_polarity(struct tg3 *tp, u32 speed)\n{\n\tif (tp->led_ctrl == LED_CTRL_MODE_PHY_2)\n\t\treturn 1;\n\telse if ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5411) {\n\t\tif (speed != SPEED_10)\n\t\t\treturn 1;\n\t} else if (speed == SPEED_10)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool tg3_phy_power_bug(struct tg3 *tp)\n{\n\tswitch (tg3_asic_rev(tp)) {\n\tcase ASIC_REV_5700:\n\tcase ASIC_REV_5704:\n\t\treturn true;\n\tcase ASIC_REV_5780:\n\t\tif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\n\t\t\treturn true;\n\t\treturn false;\n\tcase ASIC_REV_5717:\n\t\tif (!tp->pci_fn)\n\t\t\treturn true;\n\t\treturn false;\n\tcase ASIC_REV_5719:\n\tcase ASIC_REV_5720:\n\t\tif ((tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\n\t\t    !tp->pci_fn)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic bool tg3_phy_led_bug(struct tg3 *tp)\n{\n\tswitch (tg3_asic_rev(tp)) {\n\tcase ASIC_REV_5719:\n\tcase ASIC_REV_5720:\n\t\tif ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\n\t\t    !tp->pci_fn)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic void tg3_power_down_phy(struct tg3 *tp, bool do_low_power)\n{\n\tu32 val;\n\n\tif (tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN)\n\t\treturn;\n\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5704) {\n\t\t\tu32 sg_dig_ctrl = tr32(SG_DIG_CTRL);\n\t\t\tu32 serdes_cfg = tr32(MAC_SERDES_CFG);\n\n\t\t\tsg_dig_ctrl |=\n\t\t\t\tSG_DIG_USING_HW_AUTONEG | SG_DIG_SOFT_RESET;\n\t\t\ttw32(SG_DIG_CTRL, sg_dig_ctrl);\n\t\t\ttw32(MAC_SERDES_CFG, serdes_cfg | (1 << 15));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\ttg3_bmcr_reset(tp);\n\t\tval = tr32(GRC_MISC_CFG);\n\t\ttw32_f(GRC_MISC_CFG, val | GRC_MISC_CFG_EPHY_IDDQ);\n\t\tudelay(40);\n\t\treturn;\n\t} else if (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\tu32 phytest;\n\t\tif (!tg3_readphy(tp, MII_TG3_FET_TEST, &phytest)) {\n\t\t\tu32 phy;\n\n\t\t\ttg3_writephy(tp, MII_ADVERTISE, 0);\n\t\t\ttg3_writephy(tp, MII_BMCR,\n\t\t\t\t     BMCR_ANENABLE | BMCR_ANRESTART);\n\n\t\t\ttg3_writephy(tp, MII_TG3_FET_TEST,\n\t\t\t\t     phytest | MII_TG3_FET_SHADOW_EN);\n\t\t\tif (!tg3_readphy(tp, MII_TG3_FET_SHDW_AUXMODE4, &phy)) {\n\t\t\t\tphy |= MII_TG3_FET_SHDW_AUXMODE4_SBPD;\n\t\t\t\ttg3_writephy(tp,\n\t\t\t\t\t     MII_TG3_FET_SHDW_AUXMODE4,\n\t\t\t\t\t     phy);\n\t\t\t}\n\t\t\ttg3_writephy(tp, MII_TG3_FET_TEST, phytest);\n\t\t}\n\t\treturn;\n\t} else if (do_low_power) {\n\t\tif (!tg3_phy_led_bug(tp))\n\t\t\ttg3_writephy(tp, MII_TG3_EXT_CTRL,\n\t\t\t\t     MII_TG3_EXT_CTRL_FORCE_LED_OFF);\n\n\t\tval = MII_TG3_AUXCTL_PCTL_100TX_LPWR |\n\t\t      MII_TG3_AUXCTL_PCTL_SPR_ISOLATE |\n\t\t      MII_TG3_AUXCTL_PCTL_VREG_11V;\n\t\ttg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_PWRCTL, val);\n\t}\n\n\t/* The PHY should not be powered down on some chips because\n\t * of bugs.\n\t */\n\tif (tg3_phy_power_bug(tp))\n\t\treturn;\n\n\tif (tg3_chip_rev(tp) == CHIPREV_5784_AX ||\n\t    tg3_chip_rev(tp) == CHIPREV_5761_AX) {\n\t\tval = tr32(TG3_CPMU_LSPD_1000MB_CLK);\n\t\tval &= ~CPMU_LSPD_1000MB_MACCLK_MASK;\n\t\tval |= CPMU_LSPD_1000MB_MACCLK_12_5;\n\t\ttw32_f(TG3_CPMU_LSPD_1000MB_CLK, val);\n\t}\n\n\ttg3_writephy(tp, MII_BMCR, BMCR_PDOWN);\n}\n\n/* tp->lock is held. */\nstatic int tg3_nvram_lock(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, NVRAM)) {\n\t\tint i;\n\n\t\tif (tp->nvram_lock_cnt == 0) {\n\t\t\ttw32(NVRAM_SWARB, SWARB_REQ_SET1);\n\t\t\tfor (i = 0; i < 8000; i++) {\n\t\t\t\tif (tr32(NVRAM_SWARB) & SWARB_GNT1)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(20);\n\t\t\t}\n\t\t\tif (i == 8000) {\n\t\t\t\ttw32(NVRAM_SWARB, SWARB_REQ_CLR1);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t\ttp->nvram_lock_cnt++;\n\t}\n\treturn 0;\n}\n\n/* tp->lock is held. */\nstatic void tg3_nvram_unlock(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, NVRAM)) {\n\t\tif (tp->nvram_lock_cnt > 0)\n\t\t\ttp->nvram_lock_cnt--;\n\t\tif (tp->nvram_lock_cnt == 0)\n\t\t\ttw32_f(NVRAM_SWARB, SWARB_REQ_CLR1);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_enable_nvram_access(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM)) {\n\t\tu32 nvaccess = tr32(NVRAM_ACCESS);\n\n\t\ttw32(NVRAM_ACCESS, nvaccess | ACCESS_ENABLE);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_disable_nvram_access(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM)) {\n\t\tu32 nvaccess = tr32(NVRAM_ACCESS);\n\n\t\ttw32(NVRAM_ACCESS, nvaccess & ~ACCESS_ENABLE);\n\t}\n}\n\nstatic int tg3_nvram_read_using_eeprom(struct tg3 *tp,\n\t\t\t\t\tu32 offset, u32 *val)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (offset > EEPROM_ADDR_ADDR_MASK || (offset % 4) != 0)\n\t\treturn -EINVAL;\n\n\ttmp = tr32(GRC_EEPROM_ADDR) & ~(EEPROM_ADDR_ADDR_MASK |\n\t\t\t\t\tEEPROM_ADDR_DEVID_MASK |\n\t\t\t\t\tEEPROM_ADDR_READ);\n\ttw32(GRC_EEPROM_ADDR,\n\t     tmp |\n\t     (0 << EEPROM_ADDR_DEVID_SHIFT) |\n\t     ((offset << EEPROM_ADDR_ADDR_SHIFT) &\n\t      EEPROM_ADDR_ADDR_MASK) |\n\t     EEPROM_ADDR_READ | EEPROM_ADDR_START);\n\n\tfor (i = 0; i < 1000; i++) {\n\t\ttmp = tr32(GRC_EEPROM_ADDR);\n\n\t\tif (tmp & EEPROM_ADDR_COMPLETE)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\tif (!(tmp & EEPROM_ADDR_COMPLETE))\n\t\treturn -EBUSY;\n\n\ttmp = tr32(GRC_EEPROM_DATA);\n\n\t/*\n\t * The data will always be opposite the native endian\n\t * format.  Perform a blind byteswap to compensate.\n\t */\n\t*val = swab32(tmp);\n\n\treturn 0;\n}\n\n#define NVRAM_CMD_TIMEOUT 10000\n\nstatic int tg3_nvram_exec_cmd(struct tg3 *tp, u32 nvram_cmd)\n{\n\tint i;\n\n\ttw32(NVRAM_CMD, nvram_cmd);\n\tfor (i = 0; i < NVRAM_CMD_TIMEOUT; i++) {\n\t\tusleep_range(10, 40);\n\t\tif (tr32(NVRAM_CMD) & NVRAM_CMD_DONE) {\n\t\t\tudelay(10);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == NVRAM_CMD_TIMEOUT)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic u32 tg3_nvram_phys_addr(struct tg3 *tp, u32 addr)\n{\n\tif (tg3_flag(tp, NVRAM) &&\n\t    tg3_flag(tp, NVRAM_BUFFERED) &&\n\t    tg3_flag(tp, FLASH) &&\n\t    !tg3_flag(tp, NO_NVRAM_ADDR_TRANS) &&\n\t    (tp->nvram_jedecnum == JEDEC_ATMEL))\n\n\t\taddr = ((addr / tp->nvram_pagesize) <<\n\t\t\tATMEL_AT45DB0X1B_PAGE_POS) +\n\t\t       (addr % tp->nvram_pagesize);\n\n\treturn addr;\n}\n\nstatic u32 tg3_nvram_logical_addr(struct tg3 *tp, u32 addr)\n{\n\tif (tg3_flag(tp, NVRAM) &&\n\t    tg3_flag(tp, NVRAM_BUFFERED) &&\n\t    tg3_flag(tp, FLASH) &&\n\t    !tg3_flag(tp, NO_NVRAM_ADDR_TRANS) &&\n\t    (tp->nvram_jedecnum == JEDEC_ATMEL))\n\n\t\taddr = ((addr >> ATMEL_AT45DB0X1B_PAGE_POS) *\n\t\t\ttp->nvram_pagesize) +\n\t\t       (addr & ((1 << ATMEL_AT45DB0X1B_PAGE_POS) - 1));\n\n\treturn addr;\n}\n\n/* NOTE: Data read in from NVRAM is byteswapped according to\n * the byteswapping settings for all other register accesses.\n * tg3 devices are BE devices, so on a BE machine, the data\n * returned will be exactly as it is seen in NVRAM.  On a LE\n * machine, the 32-bit value will be byteswapped.\n */\nstatic int tg3_nvram_read(struct tg3 *tp, u32 offset, u32 *val)\n{\n\tint ret;\n\n\tif (!tg3_flag(tp, NVRAM))\n\t\treturn tg3_nvram_read_using_eeprom(tp, offset, val);\n\n\toffset = tg3_nvram_phys_addr(tp, offset);\n\n\tif (offset > NVRAM_ADDR_MSK)\n\t\treturn -EINVAL;\n\n\tret = tg3_nvram_lock(tp);\n\tif (ret)\n\t\treturn ret;\n\n\ttg3_enable_nvram_access(tp);\n\n\ttw32(NVRAM_ADDR, offset);\n\tret = tg3_nvram_exec_cmd(tp, NVRAM_CMD_RD | NVRAM_CMD_GO |\n\t\tNVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_DONE);\n\n\tif (ret == 0)\n\t\t*val = tr32(NVRAM_RDDATA);\n\n\ttg3_disable_nvram_access(tp);\n\n\ttg3_nvram_unlock(tp);\n\n\treturn ret;\n}\n\n/* Ensures NVRAM data is in bytestream format. */\nstatic int tg3_nvram_read_be32(struct tg3 *tp, u32 offset, __be32 *val)\n{\n\tu32 v;\n\tint res = tg3_nvram_read(tp, offset, &v);\n\tif (!res)\n\t\t*val = cpu_to_be32(v);\n\treturn res;\n}\n\nstatic int tg3_nvram_write_block_using_eeprom(struct tg3 *tp,\n\t\t\t\t    u32 offset, u32 len, u8 *buf)\n{\n\tint i, j, rc = 0;\n\tu32 val;\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tu32 addr;\n\t\t__be32 data;\n\n\t\taddr = offset + i;\n\n\t\tmemcpy(&data, buf + i, 4);\n\n\t\t/*\n\t\t * The SEEPROM interface expects the data to always be opposite\n\t\t * the native endian format.  We accomplish this by reversing\n\t\t * all the operations that would have been performed on the\n\t\t * data from a call to tg3_nvram_read_be32().\n\t\t */\n\t\ttw32(GRC_EEPROM_DATA, swab32(be32_to_cpu(data)));\n\n\t\tval = tr32(GRC_EEPROM_ADDR);\n\t\ttw32(GRC_EEPROM_ADDR, val | EEPROM_ADDR_COMPLETE);\n\n\t\tval &= ~(EEPROM_ADDR_ADDR_MASK | EEPROM_ADDR_DEVID_MASK |\n\t\t\tEEPROM_ADDR_READ);\n\t\ttw32(GRC_EEPROM_ADDR, val |\n\t\t\t(0 << EEPROM_ADDR_DEVID_SHIFT) |\n\t\t\t(addr & EEPROM_ADDR_ADDR_MASK) |\n\t\t\tEEPROM_ADDR_START |\n\t\t\tEEPROM_ADDR_WRITE);\n\n\t\tfor (j = 0; j < 1000; j++) {\n\t\t\tval = tr32(GRC_EEPROM_ADDR);\n\n\t\t\tif (val & EEPROM_ADDR_COMPLETE)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\t\tif (!(val & EEPROM_ADDR_COMPLETE)) {\n\t\t\trc = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\n/* offset and length are dword aligned */\nstatic int tg3_nvram_write_block_unbuffered(struct tg3 *tp, u32 offset, u32 len,\n\t\tu8 *buf)\n{\n\tint ret = 0;\n\tu32 pagesize = tp->nvram_pagesize;\n\tu32 pagemask = pagesize - 1;\n\tu32 nvram_cmd;\n\tu8 *tmp;\n\n\ttmp = kmalloc(pagesize, GFP_KERNEL);\n\tif (tmp == NULL)\n\t\treturn -ENOMEM;\n\n\twhile (len) {\n\t\tint j;\n\t\tu32 phy_addr, page_off, size;\n\n\t\tphy_addr = offset & ~pagemask;\n\n\t\tfor (j = 0; j < pagesize; j += 4) {\n\t\t\tret = tg3_nvram_read_be32(tp, phy_addr + j,\n\t\t\t\t\t\t  (__be32 *) (tmp + j));\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpage_off = offset & pagemask;\n\t\tsize = pagesize;\n\t\tif (len < size)\n\t\t\tsize = len;\n\n\t\tlen -= size;\n\n\t\tmemcpy(tmp + page_off, buf, size);\n\n\t\toffset = offset + (pagesize - page_off);\n\n\t\ttg3_enable_nvram_access(tp);\n\n\t\t/*\n\t\t * Before we can erase the flash page, we need\n\t\t * to issue a special \"write enable\" command.\n\t\t */\n\t\tnvram_cmd = NVRAM_CMD_WREN | NVRAM_CMD_GO | NVRAM_CMD_DONE;\n\n\t\tif (tg3_nvram_exec_cmd(tp, nvram_cmd))\n\t\t\tbreak;\n\n\t\t/* Erase the target page */\n\t\ttw32(NVRAM_ADDR, phy_addr);\n\n\t\tnvram_cmd = NVRAM_CMD_GO | NVRAM_CMD_DONE | NVRAM_CMD_WR |\n\t\t\tNVRAM_CMD_FIRST | NVRAM_CMD_LAST | NVRAM_CMD_ERASE;\n\n\t\tif (tg3_nvram_exec_cmd(tp, nvram_cmd))\n\t\t\tbreak;\n\n\t\t/* Issue another write enable to start the write. */\n\t\tnvram_cmd = NVRAM_CMD_WREN | NVRAM_CMD_GO | NVRAM_CMD_DONE;\n\n\t\tif (tg3_nvram_exec_cmd(tp, nvram_cmd))\n\t\t\tbreak;\n\n\t\tfor (j = 0; j < pagesize; j += 4) {\n\t\t\t__be32 data;\n\n\t\t\tdata = *((__be32 *) (tmp + j));\n\n\t\t\ttw32(NVRAM_WRDATA, be32_to_cpu(data));\n\n\t\t\ttw32(NVRAM_ADDR, phy_addr + j);\n\n\t\t\tnvram_cmd = NVRAM_CMD_GO | NVRAM_CMD_DONE |\n\t\t\t\tNVRAM_CMD_WR;\n\n\t\t\tif (j == 0)\n\t\t\t\tnvram_cmd |= NVRAM_CMD_FIRST;\n\t\t\telse if (j == (pagesize - 4))\n\t\t\t\tnvram_cmd |= NVRAM_CMD_LAST;\n\n\t\t\tret = tg3_nvram_exec_cmd(tp, nvram_cmd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tnvram_cmd = NVRAM_CMD_WRDI | NVRAM_CMD_GO | NVRAM_CMD_DONE;\n\ttg3_nvram_exec_cmd(tp, nvram_cmd);\n\n\tkfree(tmp);\n\n\treturn ret;\n}\n\n/* offset and length are dword aligned */\nstatic int tg3_nvram_write_block_buffered(struct tg3 *tp, u32 offset, u32 len,\n\t\tu8 *buf)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < len; i += 4, offset += 4) {\n\t\tu32 page_off, phy_addr, nvram_cmd;\n\t\t__be32 data;\n\n\t\tmemcpy(&data, buf + i, 4);\n\t\ttw32(NVRAM_WRDATA, be32_to_cpu(data));\n\n\t\tpage_off = offset % tp->nvram_pagesize;\n\n\t\tphy_addr = tg3_nvram_phys_addr(tp, offset);\n\n\t\tnvram_cmd = NVRAM_CMD_GO | NVRAM_CMD_DONE | NVRAM_CMD_WR;\n\n\t\tif (page_off == 0 || i == 0)\n\t\t\tnvram_cmd |= NVRAM_CMD_FIRST;\n\t\tif (page_off == (tp->nvram_pagesize - 4))\n\t\t\tnvram_cmd |= NVRAM_CMD_LAST;\n\n\t\tif (i == (len - 4))\n\t\t\tnvram_cmd |= NVRAM_CMD_LAST;\n\n\t\tif ((nvram_cmd & NVRAM_CMD_FIRST) ||\n\t\t    !tg3_flag(tp, FLASH) ||\n\t\t    !tg3_flag(tp, 57765_PLUS))\n\t\t\ttw32(NVRAM_ADDR, phy_addr);\n\n\t\tif (tg3_asic_rev(tp) != ASIC_REV_5752 &&\n\t\t    !tg3_flag(tp, 5755_PLUS) &&\n\t\t    (tp->nvram_jedecnum == JEDEC_ST) &&\n\t\t    (nvram_cmd & NVRAM_CMD_FIRST)) {\n\t\t\tu32 cmd;\n\n\t\t\tcmd = NVRAM_CMD_WREN | NVRAM_CMD_GO | NVRAM_CMD_DONE;\n\t\t\tret = tg3_nvram_exec_cmd(tp, cmd);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!tg3_flag(tp, FLASH)) {\n\t\t\t/* We always do complete word writes to eeprom. */\n\t\t\tnvram_cmd |= (NVRAM_CMD_FIRST | NVRAM_CMD_LAST);\n\t\t}\n\n\t\tret = tg3_nvram_exec_cmd(tp, nvram_cmd);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n/* offset and length are dword aligned */\nstatic int tg3_nvram_write_block(struct tg3 *tp, u32 offset, u32 len, u8 *buf)\n{\n\tint ret;\n\n\tif (tg3_flag(tp, EEPROM_WRITE_PROT)) {\n\t\ttw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl &\n\t\t       ~GRC_LCLCTRL_GPIO_OUTPUT1);\n\t\tudelay(40);\n\t}\n\n\tif (!tg3_flag(tp, NVRAM)) {\n\t\tret = tg3_nvram_write_block_using_eeprom(tp, offset, len, buf);\n\t} else {\n\t\tu32 grc_mode;\n\n\t\tret = tg3_nvram_lock(tp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttg3_enable_nvram_access(tp);\n\t\tif (tg3_flag(tp, 5750_PLUS) && !tg3_flag(tp, PROTECTED_NVRAM))\n\t\t\ttw32(NVRAM_WRITE1, 0x406);\n\n\t\tgrc_mode = tr32(GRC_MODE);\n\t\ttw32(GRC_MODE, grc_mode | GRC_MODE_NVRAM_WR_ENABLE);\n\n\t\tif (tg3_flag(tp, NVRAM_BUFFERED) || !tg3_flag(tp, FLASH)) {\n\t\t\tret = tg3_nvram_write_block_buffered(tp, offset, len,\n\t\t\t\tbuf);\n\t\t} else {\n\t\t\tret = tg3_nvram_write_block_unbuffered(tp, offset, len,\n\t\t\t\tbuf);\n\t\t}\n\n\t\tgrc_mode = tr32(GRC_MODE);\n\t\ttw32(GRC_MODE, grc_mode & ~GRC_MODE_NVRAM_WR_ENABLE);\n\n\t\ttg3_disable_nvram_access(tp);\n\t\ttg3_nvram_unlock(tp);\n\t}\n\n\tif (tg3_flag(tp, EEPROM_WRITE_PROT)) {\n\t\ttw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl);\n\t\tudelay(40);\n\t}\n\n\treturn ret;\n}\n\n#define RX_CPU_SCRATCH_BASE\t0x30000\n#define RX_CPU_SCRATCH_SIZE\t0x04000\n#define TX_CPU_SCRATCH_BASE\t0x34000\n#define TX_CPU_SCRATCH_SIZE\t0x04000\n\n/* tp->lock is held. */\nstatic int tg3_pause_cpu(struct tg3 *tp, u32 cpu_base)\n{\n\tint i;\n\tconst int iters = 10000;\n\n\tfor (i = 0; i < iters; i++) {\n\t\ttw32(cpu_base + CPU_STATE, 0xffffffff);\n\t\ttw32(cpu_base + CPU_MODE,  CPU_MODE_HALT);\n\t\tif (tr32(cpu_base + CPU_MODE) & CPU_MODE_HALT)\n\t\t\tbreak;\n\t\tif (pci_channel_offline(tp->pdev))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn (i == iters) ? -EBUSY : 0;\n}\n\n/* tp->lock is held. */\nstatic int tg3_rxcpu_pause(struct tg3 *tp)\n{\n\tint rc = tg3_pause_cpu(tp, RX_CPU_BASE);\n\n\ttw32(RX_CPU_BASE + CPU_STATE, 0xffffffff);\n\ttw32_f(RX_CPU_BASE + CPU_MODE,  CPU_MODE_HALT);\n\tudelay(10);\n\n\treturn rc;\n}\n\n/* tp->lock is held. */\nstatic int tg3_txcpu_pause(struct tg3 *tp)\n{\n\treturn tg3_pause_cpu(tp, TX_CPU_BASE);\n}\n\n/* tp->lock is held. */\nstatic void tg3_resume_cpu(struct tg3 *tp, u32 cpu_base)\n{\n\ttw32(cpu_base + CPU_STATE, 0xffffffff);\n\ttw32_f(cpu_base + CPU_MODE,  0x00000000);\n}\n\n/* tp->lock is held. */\nstatic void tg3_rxcpu_resume(struct tg3 *tp)\n{\n\ttg3_resume_cpu(tp, RX_CPU_BASE);\n}\n\n/* tp->lock is held. */\nstatic int tg3_halt_cpu(struct tg3 *tp, u32 cpu_base)\n{\n\tint rc;\n\n\tBUG_ON(cpu_base == TX_CPU_BASE && tg3_flag(tp, 5705_PLUS));\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tu32 val = tr32(GRC_VCPU_EXT_CTRL);\n\n\t\ttw32(GRC_VCPU_EXT_CTRL, val | GRC_VCPU_EXT_CTRL_HALT_CPU);\n\t\treturn 0;\n\t}\n\tif (cpu_base == RX_CPU_BASE) {\n\t\trc = tg3_rxcpu_pause(tp);\n\t} else {\n\t\t/*\n\t\t * There is only an Rx CPU for the 5750 derivative in the\n\t\t * BCM4785.\n\t\t */\n\t\tif (tg3_flag(tp, IS_SSB_CORE))\n\t\t\treturn 0;\n\n\t\trc = tg3_txcpu_pause(tp);\n\t}\n\n\tif (rc) {\n\t\tnetdev_err(tp->dev, \"%s timed out, %s CPU\\n\",\n\t\t\t   __func__, cpu_base == RX_CPU_BASE ? \"RX\" : \"TX\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Clear firmware's nvram arbitration. */\n\tif (tg3_flag(tp, NVRAM))\n\t\ttw32(NVRAM_SWARB, SWARB_REQ_CLR0);\n\treturn 0;\n}\n\nstatic int tg3_fw_data_len(struct tg3 *tp,\n\t\t\t   const struct tg3_firmware_hdr *fw_hdr)\n{\n\tint fw_len;\n\n\t/* Non fragmented firmware have one firmware header followed by a\n\t * contiguous chunk of data to be written. The length field in that\n\t * header is not the length of data to be written but the complete\n\t * length of the bss. The data length is determined based on\n\t * tp->fw->size minus headers.\n\t *\n\t * Fragmented firmware have a main header followed by multiple\n\t * fragments. Each fragment is identical to non fragmented firmware\n\t * with a firmware header followed by a contiguous chunk of data. In\n\t * the main header, the length field is unused and set to 0xffffffff.\n\t * In each fragment header the length is the entire size of that\n\t * fragment i.e. fragment data + header length. Data length is\n\t * therefore length field in the header minus TG3_FW_HDR_LEN.\n\t */\n\tif (tp->fw_len == 0xffffffff)\n\t\tfw_len = be32_to_cpu(fw_hdr->len);\n\telse\n\t\tfw_len = tp->fw->size;\n\n\treturn (fw_len - TG3_FW_HDR_LEN) / sizeof(u32);\n}\n\n/* tp->lock is held. */\nstatic int tg3_load_firmware_cpu(struct tg3 *tp, u32 cpu_base,\n\t\t\t\t u32 cpu_scratch_base, int cpu_scratch_size,\n\t\t\t\t const struct tg3_firmware_hdr *fw_hdr)\n{\n\tint err, i;\n\tvoid (*write_op)(struct tg3 *, u32, u32);\n\tint total_len = tp->fw->size;\n\n\tif (cpu_base == TX_CPU_BASE && tg3_flag(tp, 5705_PLUS)) {\n\t\tnetdev_err(tp->dev,\n\t\t\t   \"%s: Trying to load TX cpu firmware which is 5705\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tg3_flag(tp, 5705_PLUS) && tg3_asic_rev(tp) != ASIC_REV_57766)\n\t\twrite_op = tg3_write_mem;\n\telse\n\t\twrite_op = tg3_write_indirect_reg32;\n\n\tif (tg3_asic_rev(tp) != ASIC_REV_57766) {\n\t\t/* It is possible that bootcode is still loading at this point.\n\t\t * Get the nvram lock first before halting the cpu.\n\t\t */\n\t\tint lock_err = tg3_nvram_lock(tp);\n\t\terr = tg3_halt_cpu(tp, cpu_base);\n\t\tif (!lock_err)\n\t\t\ttg3_nvram_unlock(tp);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < cpu_scratch_size; i += sizeof(u32))\n\t\t\twrite_op(tp, cpu_scratch_base + i, 0);\n\t\ttw32(cpu_base + CPU_STATE, 0xffffffff);\n\t\ttw32(cpu_base + CPU_MODE,\n\t\t     tr32(cpu_base + CPU_MODE) | CPU_MODE_HALT);\n\t} else {\n\t\t/* Subtract additional main header for fragmented firmware and\n\t\t * advance to the first fragment\n\t\t */\n\t\ttotal_len -= TG3_FW_HDR_LEN;\n\t\tfw_hdr++;\n\t}\n\n\tdo {\n\t\tu32 *fw_data = (u32 *)(fw_hdr + 1);\n\t\tfor (i = 0; i < tg3_fw_data_len(tp, fw_hdr); i++)\n\t\t\twrite_op(tp, cpu_scratch_base +\n\t\t\t\t     (be32_to_cpu(fw_hdr->base_addr) & 0xffff) +\n\t\t\t\t     (i * sizeof(u32)),\n\t\t\t\t be32_to_cpu(fw_data[i]));\n\n\t\ttotal_len -= be32_to_cpu(fw_hdr->len);\n\n\t\t/* Advance to next fragment */\n\t\tfw_hdr = (struct tg3_firmware_hdr *)\n\t\t\t ((void *)fw_hdr + be32_to_cpu(fw_hdr->len));\n\t} while (total_len > 0);\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\n/* tp->lock is held. */\nstatic int tg3_pause_cpu_and_set_pc(struct tg3 *tp, u32 cpu_base, u32 pc)\n{\n\tint i;\n\tconst int iters = 5;\n\n\ttw32(cpu_base + CPU_STATE, 0xffffffff);\n\ttw32_f(cpu_base + CPU_PC, pc);\n\n\tfor (i = 0; i < iters; i++) {\n\t\tif (tr32(cpu_base + CPU_PC) == pc)\n\t\t\tbreak;\n\t\ttw32(cpu_base + CPU_STATE, 0xffffffff);\n\t\ttw32(cpu_base + CPU_MODE,  CPU_MODE_HALT);\n\t\ttw32_f(cpu_base + CPU_PC, pc);\n\t\tudelay(1000);\n\t}\n\n\treturn (i == iters) ? -EBUSY : 0;\n}\n\n/* tp->lock is held. */\nstatic int tg3_load_5701_a0_firmware_fix(struct tg3 *tp)\n{\n\tconst struct tg3_firmware_hdr *fw_hdr;\n\tint err;\n\n\tfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\n\n\t/* Firmware blob starts with version numbers, followed by\n\t   start address and length. We are setting complete length.\n\t   length = end_address_of_bss - start_address_of_text.\n\t   Remainder is the blob to be loaded contiguously\n\t   from start address. */\n\n\terr = tg3_load_firmware_cpu(tp, RX_CPU_BASE,\n\t\t\t\t    RX_CPU_SCRATCH_BASE, RX_CPU_SCRATCH_SIZE,\n\t\t\t\t    fw_hdr);\n\tif (err)\n\t\treturn err;\n\n\terr = tg3_load_firmware_cpu(tp, TX_CPU_BASE,\n\t\t\t\t    TX_CPU_SCRATCH_BASE, TX_CPU_SCRATCH_SIZE,\n\t\t\t\t    fw_hdr);\n\tif (err)\n\t\treturn err;\n\n\t/* Now startup only the RX cpu. */\n\terr = tg3_pause_cpu_and_set_pc(tp, RX_CPU_BASE,\n\t\t\t\t       be32_to_cpu(fw_hdr->base_addr));\n\tif (err) {\n\t\tnetdev_err(tp->dev, \"%s fails to set RX CPU PC, is %08x \"\n\t\t\t   \"should be %08x\\n\", __func__,\n\t\t\t   tr32(RX_CPU_BASE + CPU_PC),\n\t\t\t\tbe32_to_cpu(fw_hdr->base_addr));\n\t\treturn -ENODEV;\n\t}\n\n\ttg3_rxcpu_resume(tp);\n\n\treturn 0;\n}\n\nstatic int tg3_validate_rxcpu_state(struct tg3 *tp)\n{\n\tconst int iters = 1000;\n\tint i;\n\tu32 val;\n\n\t/* Wait for boot code to complete initialization and enter service\n\t * loop. It is then safe to download service patches\n\t */\n\tfor (i = 0; i < iters; i++) {\n\t\tif (tr32(RX_CPU_HWBKPT) == TG3_SBROM_IN_SERVICE_LOOP)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (i == iters) {\n\t\tnetdev_err(tp->dev, \"Boot code not ready for service patches\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tval = tg3_read_indirect_reg32(tp, TG3_57766_FW_HANDSHAKE);\n\tif (val & 0xff) {\n\t\tnetdev_warn(tp->dev,\n\t\t\t    \"Other patches exist. Not downloading EEE patch\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\n/* tp->lock is held. */\nstatic void tg3_load_57766_firmware(struct tg3 *tp)\n{\n\tstruct tg3_firmware_hdr *fw_hdr;\n\n\tif (!tg3_flag(tp, NO_NVRAM))\n\t\treturn;\n\n\tif (tg3_validate_rxcpu_state(tp))\n\t\treturn;\n\n\tif (!tp->fw)\n\t\treturn;\n\n\t/* This firmware blob has a different format than older firmware\n\t * releases as given below. The main difference is we have fragmented\n\t * data to be written to non-contiguous locations.\n\t *\n\t * In the beginning we have a firmware header identical to other\n\t * firmware which consists of version, base addr and length. The length\n\t * here is unused and set to 0xffffffff.\n\t *\n\t * This is followed by a series of firmware fragments which are\n\t * individually identical to previous firmware. i.e. they have the\n\t * firmware header and followed by data for that fragment. The version\n\t * field of the individual fragment header is unused.\n\t */\n\n\tfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\n\tif (be32_to_cpu(fw_hdr->base_addr) != TG3_57766_FW_BASE_ADDR)\n\t\treturn;\n\n\tif (tg3_rxcpu_pause(tp))\n\t\treturn;\n\n\t/* tg3_load_firmware_cpu() will always succeed for the 57766 */\n\ttg3_load_firmware_cpu(tp, 0, TG3_57766_FW_BASE_ADDR, 0, fw_hdr);\n\n\ttg3_rxcpu_resume(tp);\n}\n\n/* tp->lock is held. */\nstatic int tg3_load_tso_firmware(struct tg3 *tp)\n{\n\tconst struct tg3_firmware_hdr *fw_hdr;\n\tunsigned long cpu_base, cpu_scratch_base, cpu_scratch_size;\n\tint err;\n\n\tif (!tg3_flag(tp, FW_TSO))\n\t\treturn 0;\n\n\tfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\n\n\t/* Firmware blob starts with version numbers, followed by\n\t   start address and length. We are setting complete length.\n\t   length = end_address_of_bss - start_address_of_text.\n\t   Remainder is the blob to be loaded contiguously\n\t   from start address. */\n\n\tcpu_scratch_size = tp->fw_len;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\tcpu_base = RX_CPU_BASE;\n\t\tcpu_scratch_base = NIC_SRAM_MBUF_POOL_BASE5705;\n\t} else {\n\t\tcpu_base = TX_CPU_BASE;\n\t\tcpu_scratch_base = TX_CPU_SCRATCH_BASE;\n\t\tcpu_scratch_size = TX_CPU_SCRATCH_SIZE;\n\t}\n\n\terr = tg3_load_firmware_cpu(tp, cpu_base,\n\t\t\t\t    cpu_scratch_base, cpu_scratch_size,\n\t\t\t\t    fw_hdr);\n\tif (err)\n\t\treturn err;\n\n\t/* Now startup the cpu. */\n\terr = tg3_pause_cpu_and_set_pc(tp, cpu_base,\n\t\t\t\t       be32_to_cpu(fw_hdr->base_addr));\n\tif (err) {\n\t\tnetdev_err(tp->dev,\n\t\t\t   \"%s fails to set CPU PC, is %08x should be %08x\\n\",\n\t\t\t   __func__, tr32(cpu_base + CPU_PC),\n\t\t\t   be32_to_cpu(fw_hdr->base_addr));\n\t\treturn -ENODEV;\n\t}\n\n\ttg3_resume_cpu(tp, cpu_base);\n\treturn 0;\n}\n\n/* tp->lock is held. */\nstatic void __tg3_set_one_mac_addr(struct tg3 *tp, u8 *mac_addr, int index)\n{\n\tu32 addr_high, addr_low;\n\n\taddr_high = ((mac_addr[0] << 8) | mac_addr[1]);\n\taddr_low = ((mac_addr[2] << 24) | (mac_addr[3] << 16) |\n\t\t    (mac_addr[4] <<  8) | mac_addr[5]);\n\n\tif (index < 4) {\n\t\ttw32(MAC_ADDR_0_HIGH + (index * 8), addr_high);\n\t\ttw32(MAC_ADDR_0_LOW + (index * 8), addr_low);\n\t} else {\n\t\tindex -= 4;\n\t\ttw32(MAC_EXTADDR_0_HIGH + (index * 8), addr_high);\n\t\ttw32(MAC_EXTADDR_0_LOW + (index * 8), addr_low);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void __tg3_set_mac_addr(struct tg3 *tp, bool skip_mac_1)\n{\n\tu32 addr_high;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (i == 1 && skip_mac_1)\n\t\t\tcontinue;\n\t\t__tg3_set_one_mac_addr(tp, tp->dev->dev_addr, i);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5704) {\n\t\tfor (i = 4; i < 16; i++)\n\t\t\t__tg3_set_one_mac_addr(tp, tp->dev->dev_addr, i);\n\t}\n\n\taddr_high = (tp->dev->dev_addr[0] +\n\t\t     tp->dev->dev_addr[1] +\n\t\t     tp->dev->dev_addr[2] +\n\t\t     tp->dev->dev_addr[3] +\n\t\t     tp->dev->dev_addr[4] +\n\t\t     tp->dev->dev_addr[5]) &\n\t\tTX_BACKOFF_SEED_MASK;\n\ttw32(MAC_TX_BACKOFF_SEED, addr_high);\n}\n\nstatic void tg3_enable_register_access(struct tg3 *tp)\n{\n\t/*\n\t * Make sure register accesses (indirect or otherwise) will function\n\t * correctly.\n\t */\n\tpci_write_config_dword(tp->pdev,\n\t\t\t       TG3PCI_MISC_HOST_CTRL, tp->misc_host_ctrl);\n}\n\nstatic int tg3_power_up(struct tg3 *tp)\n{\n\tint err;\n\n\ttg3_enable_register_access(tp);\n\n\terr = pci_set_power_state(tp->pdev, PCI_D0);\n\tif (!err) {\n\t\t/* Switch out of Vaux if it is a NIC */\n\t\ttg3_pwrsrc_switch_to_vmain(tp);\n\t} else {\n\t\tnetdev_err(tp->dev, \"Transition to D0 failed\\n\");\n\t}\n\n\treturn err;\n}\n\nstatic int tg3_setup_phy(struct tg3 *, bool);\n\nstatic int tg3_power_down_prepare(struct tg3 *tp)\n{\n\tu32 misc_host_ctrl;\n\tbool device_should_wake, do_low_power;\n\n\ttg3_enable_register_access(tp);\n\n\t/* Restore the CLKREQ setting. */\n\tif (tg3_flag(tp, CLKREQ_BUG))\n\t\tpcie_capability_set_word(tp->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t PCI_EXP_LNKCTL_CLKREQ_EN);\n\n\tmisc_host_ctrl = tr32(TG3PCI_MISC_HOST_CTRL);\n\ttw32(TG3PCI_MISC_HOST_CTRL,\n\t     misc_host_ctrl | MISC_HOST_CTRL_MASK_PCI_INT);\n\n\tdevice_should_wake = device_may_wakeup(&tp->pdev->dev) &&\n\t\t\t     tg3_flag(tp, WOL_ENABLE);\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tdo_low_power = false;\n\t\tif ((tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) &&\n\t\t    !(tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {\n\t\t\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising) = { 0, };\n\t\t\tstruct phy_device *phydev;\n\t\t\tu32 phyid;\n\n\t\t\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\n\t\t\ttp->phy_flags |= TG3_PHYFLG_IS_LOW_POWER;\n\n\t\t\ttp->link_config.speed = phydev->speed;\n\t\t\ttp->link_config.duplex = phydev->duplex;\n\t\t\ttp->link_config.autoneg = phydev->autoneg;\n\t\t\tethtool_convert_link_mode_to_legacy_u32(\n\t\t\t\t&tp->link_config.advertising,\n\t\t\t\tphydev->advertising);\n\n\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT, advertising);\n\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t\t advertising);\n\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t\t advertising);\n\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\t\t\t\t advertising);\n\n\t\t\tif (tg3_flag(tp, ENABLE_ASF) || device_should_wake) {\n\t\t\t\tif (tg3_flag(tp, WOL_SPEED_100MB)) {\n\t\t\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\t\t\t\t\t\t advertising);\n\t\t\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t\t\t\t\t\t advertising);\n\t\t\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t\t\t\t\t\t advertising);\n\t\t\t\t} else {\n\t\t\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t\t\t\t\t\t advertising);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlinkmode_copy(phydev->advertising, advertising);\n\t\t\tphy_start_aneg(phydev);\n\n\t\t\tphyid = phydev->drv->phy_id & phydev->drv->phy_id_mask;\n\t\t\tif (phyid != PHY_ID_BCMAC131) {\n\t\t\t\tphyid &= PHY_BCM_OUI_MASK;\n\t\t\t\tif (phyid == PHY_BCM_OUI_1 ||\n\t\t\t\t    phyid == PHY_BCM_OUI_2 ||\n\t\t\t\t    phyid == PHY_BCM_OUI_3)\n\t\t\t\t\tdo_low_power = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdo_low_power = true;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_IS_LOW_POWER;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\n\t\t\ttg3_setup_phy(tp, false);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tu32 val;\n\n\t\tval = tr32(GRC_VCPU_EXT_CTRL);\n\t\ttw32(GRC_VCPU_EXT_CTRL, val | GRC_VCPU_EXT_CTRL_DISABLE_WOL);\n\t} else if (!tg3_flag(tp, ENABLE_ASF)) {\n\t\tint i;\n\t\tu32 val;\n\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\ttg3_read_mem(tp, NIC_SRAM_FW_ASF_STATUS_MBOX, &val);\n\t\t\tif (val == ~NIC_SRAM_FIRMWARE_MBOX_MAGIC1)\n\t\t\t\tbreak;\n\t\t\tmsleep(1);\n\t\t}\n\t}\n\tif (tg3_flag(tp, WOL_CAP))\n\t\ttg3_write_mem(tp, NIC_SRAM_WOL_MBOX, WOL_SIGNATURE |\n\t\t\t\t\t\t     WOL_DRV_STATE_SHUTDOWN |\n\t\t\t\t\t\t     WOL_DRV_WOL |\n\t\t\t\t\t\t     WOL_SET_MAGIC_PKT);\n\n\tif (device_should_wake) {\n\t\tu32 mac_mode;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES)) {\n\t\t\tif (do_low_power &&\n\t\t\t    !(tp->phy_flags & TG3_PHYFLG_IS_FET)) {\n\t\t\t\ttg3_phy_auxctl_write(tp,\n\t\t\t\t\t       MII_TG3_AUXCTL_SHDWSEL_PWRCTL,\n\t\t\t\t\t       MII_TG3_AUXCTL_PCTL_WOL_EN |\n\t\t\t\t\t       MII_TG3_AUXCTL_PCTL_100TX_LPWR |\n\t\t\t\t\t       MII_TG3_AUXCTL_PCTL_CL_AB_TXDAC);\n\t\t\t\tudelay(40);\n\t\t\t}\n\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\n\t\t\t\tmac_mode = MAC_MODE_PORT_MODE_GMII;\n\t\t\telse if (tp->phy_flags &\n\t\t\t\t TG3_PHYFLG_KEEP_LINK_ON_PWRDN) {\n\t\t\t\tif (tp->link_config.active_speed == SPEED_1000)\n\t\t\t\t\tmac_mode = MAC_MODE_PORT_MODE_GMII;\n\t\t\t\telse\n\t\t\t\t\tmac_mode = MAC_MODE_PORT_MODE_MII;\n\t\t\t} else\n\t\t\t\tmac_mode = MAC_MODE_PORT_MODE_MII;\n\n\t\t\tmac_mode |= tp->mac_mode & MAC_MODE_LINK_POLARITY;\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5700) {\n\t\t\t\tu32 speed = tg3_flag(tp, WOL_SPEED_100MB) ?\n\t\t\t\t\t     SPEED_100 : SPEED_10;\n\t\t\t\tif (tg3_5700_link_polarity(tp, speed))\n\t\t\t\t\tmac_mode |= MAC_MODE_LINK_POLARITY;\n\t\t\t\telse\n\t\t\t\t\tmac_mode &= ~MAC_MODE_LINK_POLARITY;\n\t\t\t}\n\t\t} else {\n\t\t\tmac_mode = MAC_MODE_PORT_MODE_TBI;\n\t\t}\n\n\t\tif (!tg3_flag(tp, 5750_PLUS))\n\t\t\ttw32(MAC_LED_CTRL, tp->led_ctrl);\n\n\t\tmac_mode |= MAC_MODE_MAGIC_PKT_ENABLE;\n\t\tif ((tg3_flag(tp, 5705_PLUS) && !tg3_flag(tp, 5780_CLASS)) &&\n\t\t    (tg3_flag(tp, ENABLE_ASF) || tg3_flag(tp, ENABLE_APE)))\n\t\t\tmac_mode |= MAC_MODE_KEEP_FRAME_IN_WOL;\n\n\t\tif (tg3_flag(tp, ENABLE_APE))\n\t\t\tmac_mode |= MAC_MODE_APE_TX_EN |\n\t\t\t\t    MAC_MODE_APE_RX_EN |\n\t\t\t\t    MAC_MODE_TDE_ENABLE;\n\n\t\ttw32_f(MAC_MODE, mac_mode);\n\t\tudelay(100);\n\n\t\ttw32_f(MAC_RX_MODE, RX_MODE_ENABLE);\n\t\tudelay(10);\n\t}\n\n\tif (!tg3_flag(tp, WOL_SPEED_100MB) &&\n\t    (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5701)) {\n\t\tu32 base_val;\n\n\t\tbase_val = tp->pci_clock_ctrl;\n\t\tbase_val |= (CLOCK_CTRL_RXCLK_DISABLE |\n\t\t\t     CLOCK_CTRL_TXCLK_DISABLE);\n\n\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL, base_val | CLOCK_CTRL_ALTCLK |\n\t\t\t    CLOCK_CTRL_PWRDOWN_PLL133, 40);\n\t} else if (tg3_flag(tp, 5780_CLASS) ||\n\t\t   tg3_flag(tp, CPMU_PRESENT) ||\n\t\t   tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\t/* do nothing */\n\t} else if (!(tg3_flag(tp, 5750_PLUS) && tg3_flag(tp, ENABLE_ASF))) {\n\t\tu32 newbits1, newbits2;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5701) {\n\t\t\tnewbits1 = (CLOCK_CTRL_RXCLK_DISABLE |\n\t\t\t\t    CLOCK_CTRL_TXCLK_DISABLE |\n\t\t\t\t    CLOCK_CTRL_ALTCLK);\n\t\t\tnewbits2 = newbits1 | CLOCK_CTRL_44MHZ_CORE;\n\t\t} else if (tg3_flag(tp, 5705_PLUS)) {\n\t\t\tnewbits1 = CLOCK_CTRL_625_CORE;\n\t\t\tnewbits2 = newbits1 | CLOCK_CTRL_ALTCLK;\n\t\t} else {\n\t\t\tnewbits1 = CLOCK_CTRL_ALTCLK;\n\t\t\tnewbits2 = newbits1 | CLOCK_CTRL_44MHZ_CORE;\n\t\t}\n\n\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl | newbits1,\n\t\t\t    40);\n\n\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl | newbits2,\n\t\t\t    40);\n\n\t\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\t\tu32 newbits3;\n\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5701) {\n\t\t\t\tnewbits3 = (CLOCK_CTRL_RXCLK_DISABLE |\n\t\t\t\t\t    CLOCK_CTRL_TXCLK_DISABLE |\n\t\t\t\t\t    CLOCK_CTRL_44MHZ_CORE);\n\t\t\t} else {\n\t\t\t\tnewbits3 = CLOCK_CTRL_44MHZ_CORE;\n\t\t\t}\n\n\t\t\ttw32_wait_f(TG3PCI_CLOCK_CTRL,\n\t\t\t\t    tp->pci_clock_ctrl | newbits3, 40);\n\t\t}\n\t}\n\n\tif (!(device_should_wake) && !tg3_flag(tp, ENABLE_ASF))\n\t\ttg3_power_down_phy(tp, do_low_power);\n\n\ttg3_frob_aux_power(tp, true);\n\n\t/* Workaround for unstable PLL clock */\n\tif ((!tg3_flag(tp, IS_SSB_CORE)) &&\n\t    ((tg3_chip_rev(tp) == CHIPREV_5750_AX) ||\n\t     (tg3_chip_rev(tp) == CHIPREV_5750_BX))) {\n\t\tu32 val = tr32(0x7d00);\n\n\t\tval &= ~((1 << 16) | (1 << 4) | (1 << 2) | (1 << 1) | 1);\n\t\ttw32(0x7d00, val);\n\t\tif (!tg3_flag(tp, ENABLE_ASF)) {\n\t\t\tint err;\n\n\t\t\terr = tg3_nvram_lock(tp);\n\t\t\ttg3_halt_cpu(tp, RX_CPU_BASE);\n\t\t\tif (!err)\n\t\t\t\ttg3_nvram_unlock(tp);\n\t\t}\n\t}\n\n\ttg3_write_sig_post_reset(tp, RESET_KIND_SHUTDOWN);\n\n\ttg3_ape_driver_state_change(tp, RESET_KIND_SHUTDOWN);\n\n\treturn 0;\n}\n\nstatic void tg3_power_down(struct tg3 *tp)\n{\n\tpci_wake_from_d3(tp->pdev, tg3_flag(tp, WOL_ENABLE));\n\tpci_set_power_state(tp->pdev, PCI_D3hot);\n}\n\nstatic void tg3_aux_stat_to_speed_duplex(struct tg3 *tp, u32 val, u32 *speed, u8 *duplex)\n{\n\tswitch (val & MII_TG3_AUX_STAT_SPDMASK) {\n\tcase MII_TG3_AUX_STAT_10HALF:\n\t\t*speed = SPEED_10;\n\t\t*duplex = DUPLEX_HALF;\n\t\tbreak;\n\n\tcase MII_TG3_AUX_STAT_10FULL:\n\t\t*speed = SPEED_10;\n\t\t*duplex = DUPLEX_FULL;\n\t\tbreak;\n\n\tcase MII_TG3_AUX_STAT_100HALF:\n\t\t*speed = SPEED_100;\n\t\t*duplex = DUPLEX_HALF;\n\t\tbreak;\n\n\tcase MII_TG3_AUX_STAT_100FULL:\n\t\t*speed = SPEED_100;\n\t\t*duplex = DUPLEX_FULL;\n\t\tbreak;\n\n\tcase MII_TG3_AUX_STAT_1000HALF:\n\t\t*speed = SPEED_1000;\n\t\t*duplex = DUPLEX_HALF;\n\t\tbreak;\n\n\tcase MII_TG3_AUX_STAT_1000FULL:\n\t\t*speed = SPEED_1000;\n\t\t*duplex = DUPLEX_FULL;\n\t\tbreak;\n\n\tdefault:\n\t\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\t\t*speed = (val & MII_TG3_AUX_STAT_100) ? SPEED_100 :\n\t\t\t\t SPEED_10;\n\t\t\t*duplex = (val & MII_TG3_AUX_STAT_FULL) ? DUPLEX_FULL :\n\t\t\t\t  DUPLEX_HALF;\n\t\t\tbreak;\n\t\t}\n\t\t*speed = SPEED_UNKNOWN;\n\t\t*duplex = DUPLEX_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\nstatic int tg3_phy_autoneg_cfg(struct tg3 *tp, u32 advertise, u32 flowctrl)\n{\n\tint err = 0;\n\tu32 val, new_adv;\n\n\tnew_adv = ADVERTISE_CSMA;\n\tnew_adv |= ethtool_adv_to_mii_adv_t(advertise) & ADVERTISE_ALL;\n\tnew_adv |= mii_advertise_flowctrl(flowctrl);\n\n\terr = tg3_writephy(tp, MII_ADVERTISE, new_adv);\n\tif (err)\n\t\tgoto done;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\tnew_adv = ethtool_adv_to_mii_ctrl1000_t(advertise);\n\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\n\t\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0)\n\t\t\tnew_adv |= CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER;\n\n\t\terr = tg3_writephy(tp, MII_CTRL1000, new_adv);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\n\t\tgoto done;\n\n\ttw32(TG3_CPMU_EEE_MODE,\n\t     tr32(TG3_CPMU_EEE_MODE) & ~TG3_CPMU_EEEMD_LPI_ENABLE);\n\n\terr = tg3_phy_toggle_auxctl_smdsp(tp, true);\n\tif (!err) {\n\t\tu32 err2;\n\n\t\tval = 0;\n\t\t/* Advertise 100-BaseTX EEE ability */\n\t\tif (advertise & ADVERTISED_100baseT_Full)\n\t\t\tval |= MDIO_AN_EEE_ADV_100TX;\n\t\t/* Advertise 1000-BaseT EEE ability */\n\t\tif (advertise & ADVERTISED_1000baseT_Full)\n\t\t\tval |= MDIO_AN_EEE_ADV_1000T;\n\n\t\tif (!tp->eee.eee_enabled) {\n\t\t\tval = 0;\n\t\t\ttp->eee.advertised = 0;\n\t\t} else {\n\t\t\ttp->eee.advertised = advertise &\n\t\t\t\t\t     (ADVERTISED_100baseT_Full |\n\t\t\t\t\t      ADVERTISED_1000baseT_Full);\n\t\t}\n\n\t\terr = tg3_phy_cl45_write(tp, MDIO_MMD_AN, MDIO_AN_EEE_ADV, val);\n\t\tif (err)\n\t\t\tval = 0;\n\n\t\tswitch (tg3_asic_rev(tp)) {\n\t\tcase ASIC_REV_5717:\n\t\tcase ASIC_REV_57765:\n\t\tcase ASIC_REV_57766:\n\t\tcase ASIC_REV_5719:\n\t\t\t/* If we advertised any eee advertisements above... */\n\t\t\tif (val)\n\t\t\t\tval = MII_TG3_DSP_TAP26_ALNOKO |\n\t\t\t\t      MII_TG3_DSP_TAP26_RMRXSTO |\n\t\t\t\t      MII_TG3_DSP_TAP26_OPCSINPT;\n\t\t\ttg3_phydsp_write(tp, MII_TG3_DSP_TAP26, val);\n\t\t\tfallthrough;\n\t\tcase ASIC_REV_5720:\n\t\tcase ASIC_REV_5762:\n\t\t\tif (!tg3_phydsp_read(tp, MII_TG3_DSP_CH34TP2, &val))\n\t\t\t\ttg3_phydsp_write(tp, MII_TG3_DSP_CH34TP2, val |\n\t\t\t\t\t\t MII_TG3_DSP_CH34TP2_HIBW01);\n\t\t}\n\n\t\terr2 = tg3_phy_toggle_auxctl_smdsp(tp, false);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic void tg3_phy_copper_begin(struct tg3 *tp)\n{\n\tif (tp->link_config.autoneg == AUTONEG_ENABLE ||\n\t    (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {\n\t\tu32 adv, fc;\n\n\t\tif ((tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) &&\n\t\t    !(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN)) {\n\t\t\tadv = ADVERTISED_10baseT_Half |\n\t\t\t      ADVERTISED_10baseT_Full;\n\t\t\tif (tg3_flag(tp, WOL_SPEED_100MB))\n\t\t\t\tadv |= ADVERTISED_100baseT_Half |\n\t\t\t\t       ADVERTISED_100baseT_Full;\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_1G_ON_VAUX_OK) {\n\t\t\t\tif (!(tp->phy_flags &\n\t\t\t\t      TG3_PHYFLG_DISABLE_1G_HD_ADV))\n\t\t\t\t\tadv |= ADVERTISED_1000baseT_Half;\n\t\t\t\tadv |= ADVERTISED_1000baseT_Full;\n\t\t\t}\n\n\t\t\tfc = FLOW_CTRL_TX | FLOW_CTRL_RX;\n\t\t} else {\n\t\t\tadv = tp->link_config.advertising;\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)\n\t\t\t\tadv &= ~(ADVERTISED_1000baseT_Half |\n\t\t\t\t\t ADVERTISED_1000baseT_Full);\n\n\t\t\tfc = tp->link_config.flowctrl;\n\t\t}\n\n\t\ttg3_phy_autoneg_cfg(tp, adv, fc);\n\n\t\tif ((tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) &&\n\t\t    (tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN)) {\n\t\t\t/* Normally during power down we want to autonegotiate\n\t\t\t * the lowest possible speed for WOL. However, to avoid\n\t\t\t * link flap, we leave it untouched.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\ttg3_writephy(tp, MII_BMCR,\n\t\t\t     BMCR_ANENABLE | BMCR_ANRESTART);\n\t} else {\n\t\tint i;\n\t\tu32 bmcr, orig_bmcr;\n\n\t\ttp->link_config.active_speed = tp->link_config.speed;\n\t\ttp->link_config.active_duplex = tp->link_config.duplex;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5714) {\n\t\t\t/* With autoneg disabled, 5715 only links up when the\n\t\t\t * advertisement register has the configured speed\n\t\t\t * enabled.\n\t\t\t */\n\t\t\ttg3_writephy(tp, MII_ADVERTISE, ADVERTISE_ALL);\n\t\t}\n\n\t\tbmcr = 0;\n\t\tswitch (tp->link_config.speed) {\n\t\tdefault:\n\t\tcase SPEED_10:\n\t\t\tbreak;\n\n\t\tcase SPEED_100:\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t\tbreak;\n\n\t\tcase SPEED_1000:\n\t\t\tbmcr |= BMCR_SPEED1000;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tp->link_config.duplex == DUPLEX_FULL)\n\t\t\tbmcr |= BMCR_FULLDPLX;\n\n\t\tif (!tg3_readphy(tp, MII_BMCR, &orig_bmcr) &&\n\t\t    (bmcr != orig_bmcr)) {\n\t\t\ttg3_writephy(tp, MII_BMCR, BMCR_LOOPBACK);\n\t\t\tfor (i = 0; i < 1500; i++) {\n\t\t\t\tu32 tmp;\n\n\t\t\t\tudelay(10);\n\t\t\t\tif (tg3_readphy(tp, MII_BMSR, &tmp) ||\n\t\t\t\t    tg3_readphy(tp, MII_BMSR, &tmp))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!(tmp & BMSR_LSTATUS)) {\n\t\t\t\t\tudelay(40);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttg3_writephy(tp, MII_BMCR, bmcr);\n\t\t\tudelay(40);\n\t\t}\n\t}\n}\n\nstatic int tg3_phy_pull_config(struct tg3 *tp)\n{\n\tint err;\n\tu32 val;\n\n\terr = tg3_readphy(tp, MII_BMCR, &val);\n\tif (err)\n\t\tgoto done;\n\n\tif (!(val & BMCR_ANENABLE)) {\n\t\ttp->link_config.autoneg = AUTONEG_DISABLE;\n\t\ttp->link_config.advertising = 0;\n\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\n\t\terr = -EIO;\n\n\t\tswitch (val & (BMCR_SPEED1000 | BMCR_SPEED100)) {\n\t\tcase 0:\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\n\t\t\t\tgoto done;\n\n\t\t\ttp->link_config.speed = SPEED_10;\n\t\t\tbreak;\n\t\tcase BMCR_SPEED100:\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\n\t\t\t\tgoto done;\n\n\t\t\ttp->link_config.speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase BMCR_SPEED1000:\n\t\t\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\t\t\ttp->link_config.speed = SPEED_1000;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (val & BMCR_FULLDPLX)\n\t\t\ttp->link_config.duplex = DUPLEX_FULL;\n\t\telse\n\t\t\ttp->link_config.duplex = DUPLEX_HALF;\n\n\t\ttp->link_config.flowctrl = FLOW_CTRL_RX | FLOW_CTRL_TX;\n\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\ttp->link_config.autoneg = AUTONEG_ENABLE;\n\ttp->link_config.advertising = ADVERTISED_Autoneg;\n\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\n\t\tu32 adv;\n\n\t\terr = tg3_readphy(tp, MII_ADVERTISE, &val);\n\t\tif (err)\n\t\t\tgoto done;\n\n\t\tadv = mii_adv_to_ethtool_adv_t(val & ADVERTISE_ALL);\n\t\ttp->link_config.advertising |= adv | ADVERTISED_TP;\n\n\t\ttp->link_config.flowctrl = tg3_decode_flowctrl_1000T(val);\n\t} else {\n\t\ttp->link_config.advertising |= ADVERTISED_FIBRE;\n\t}\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\tu32 adv;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\n\t\t\terr = tg3_readphy(tp, MII_CTRL1000, &val);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\n\t\t\tadv = mii_ctrl1000_to_ethtool_adv_t(val);\n\t\t} else {\n\t\t\terr = tg3_readphy(tp, MII_ADVERTISE, &val);\n\t\t\tif (err)\n\t\t\t\tgoto done;\n\n\t\t\tadv = tg3_decode_flowctrl_1000X(val);\n\t\t\ttp->link_config.flowctrl = adv;\n\n\t\t\tval &= (ADVERTISE_1000XHALF | ADVERTISE_1000XFULL);\n\t\t\tadv = mii_adv_to_ethtool_adv_x(val);\n\t\t}\n\n\t\ttp->link_config.advertising |= adv;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int tg3_init_5401phy_dsp(struct tg3 *tp)\n{\n\tint err;\n\n\t/* Turn off tap power management. */\n\t/* Set Extended packet length bit */\n\terr = tg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, 0x4c20);\n\n\terr |= tg3_phydsp_write(tp, 0x0012, 0x1804);\n\terr |= tg3_phydsp_write(tp, 0x0013, 0x1204);\n\terr |= tg3_phydsp_write(tp, 0x8006, 0x0132);\n\terr |= tg3_phydsp_write(tp, 0x8006, 0x0232);\n\terr |= tg3_phydsp_write(tp, 0x201f, 0x0a20);\n\n\tudelay(40);\n\n\treturn err;\n}\n\nstatic bool tg3_phy_eee_config_ok(struct tg3 *tp)\n{\n\tstruct ethtool_eee eee;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP))\n\t\treturn true;\n\n\ttg3_eee_pull_config(tp, &eee);\n\n\tif (tp->eee.eee_enabled) {\n\t\tif (tp->eee.advertised != eee.advertised ||\n\t\t    tp->eee.tx_lpi_timer != eee.tx_lpi_timer ||\n\t\t    tp->eee.tx_lpi_enabled != eee.tx_lpi_enabled)\n\t\t\treturn false;\n\t} else {\n\t\t/* EEE is disabled but we're advertising */\n\t\tif (eee.advertised)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool tg3_phy_copper_an_config_ok(struct tg3 *tp, u32 *lcladv)\n{\n\tu32 advmsk, tgtadv, advertising;\n\n\tadvertising = tp->link_config.advertising;\n\ttgtadv = ethtool_adv_to_mii_adv_t(advertising) & ADVERTISE_ALL;\n\n\tadvmsk = ADVERTISE_ALL;\n\tif (tp->link_config.active_duplex == DUPLEX_FULL) {\n\t\ttgtadv |= mii_advertise_flowctrl(tp->link_config.flowctrl);\n\t\tadvmsk |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\n\t}\n\n\tif (tg3_readphy(tp, MII_ADVERTISE, lcladv))\n\t\treturn false;\n\n\tif ((*lcladv & advmsk) != tgtadv)\n\t\treturn false;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\tu32 tg3_ctrl;\n\n\t\ttgtadv = ethtool_adv_to_mii_ctrl1000_t(advertising);\n\n\t\tif (tg3_readphy(tp, MII_CTRL1000, &tg3_ctrl))\n\t\t\treturn false;\n\n\t\tif (tgtadv &&\n\t\t    (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\n\t\t     tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0)) {\n\t\t\ttgtadv |= CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER;\n\t\t\ttg3_ctrl &= (ADVERTISE_1000HALF | ADVERTISE_1000FULL |\n\t\t\t\t     CTL1000_AS_MASTER | CTL1000_ENABLE_MASTER);\n\t\t} else {\n\t\t\ttg3_ctrl &= (ADVERTISE_1000HALF | ADVERTISE_1000FULL);\n\t\t}\n\n\t\tif (tg3_ctrl != tgtadv)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool tg3_phy_copper_fetch_rmtadv(struct tg3 *tp, u32 *rmtadv)\n{\n\tu32 lpeth = 0;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\tu32 val;\n\n\t\tif (tg3_readphy(tp, MII_STAT1000, &val))\n\t\t\treturn false;\n\n\t\tlpeth = mii_stat1000_to_ethtool_lpa_t(val);\n\t}\n\n\tif (tg3_readphy(tp, MII_LPA, rmtadv))\n\t\treturn false;\n\n\tlpeth |= mii_lpa_to_ethtool_lpa_t(*rmtadv);\n\ttp->link_config.rmt_adv = lpeth;\n\n\treturn true;\n}\n\nstatic bool tg3_test_and_report_link_chg(struct tg3 *tp, bool curr_link_up)\n{\n\tif (curr_link_up != tp->link_up) {\n\t\tif (curr_link_up) {\n\t\t\tnetif_carrier_on(tp->dev);\n\t\t} else {\n\t\t\tnetif_carrier_off(tp->dev);\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\n\t\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\t\t}\n\n\t\ttg3_link_report(tp);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void tg3_clear_mac_status(struct tg3 *tp)\n{\n\ttw32(MAC_EVENT, 0);\n\n\ttw32_f(MAC_STATUS,\n\t       MAC_STATUS_SYNC_CHANGED |\n\t       MAC_STATUS_CFG_CHANGED |\n\t       MAC_STATUS_MI_COMPLETION |\n\t       MAC_STATUS_LNKSTATE_CHANGED);\n\tudelay(40);\n}\n\nstatic void tg3_setup_eee(struct tg3 *tp)\n{\n\tu32 val;\n\n\tval = TG3_CPMU_EEE_LNKIDL_PCIE_NL0 |\n\t      TG3_CPMU_EEE_LNKIDL_UART_IDL;\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0)\n\t\tval |= TG3_CPMU_EEE_LNKIDL_APE_TX_MT;\n\n\ttw32_f(TG3_CPMU_EEE_LNKIDL_CTRL, val);\n\n\ttw32_f(TG3_CPMU_EEE_CTRL,\n\t       TG3_CPMU_EEE_CTRL_EXIT_20_1_US);\n\n\tval = TG3_CPMU_EEEMD_ERLY_L1_XIT_DET |\n\t      (tp->eee.tx_lpi_enabled ? TG3_CPMU_EEEMD_LPI_IN_TX : 0) |\n\t      TG3_CPMU_EEEMD_LPI_IN_RX |\n\t      TG3_CPMU_EEEMD_EEE_ENABLE;\n\n\tif (tg3_asic_rev(tp) != ASIC_REV_5717)\n\t\tval |= TG3_CPMU_EEEMD_SND_IDX_DET_EN;\n\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\tval |= TG3_CPMU_EEEMD_APE_TX_DET_EN;\n\n\ttw32_f(TG3_CPMU_EEE_MODE, tp->eee.eee_enabled ? val : 0);\n\n\ttw32_f(TG3_CPMU_EEE_DBTMR1,\n\t       TG3_CPMU_DBTMR1_PCIEXIT_2047US |\n\t       (tp->eee.tx_lpi_timer & 0xffff));\n\n\ttw32_f(TG3_CPMU_EEE_DBTMR2,\n\t       TG3_CPMU_DBTMR2_APE_TX_2047US |\n\t       TG3_CPMU_DBTMR2_TXIDXEQ_2047US);\n}\n\nstatic int tg3_setup_copper_phy(struct tg3 *tp, bool force_reset)\n{\n\tbool current_link_up;\n\tu32 bmsr, val;\n\tu32 lcl_adv, rmt_adv;\n\tu32 current_speed;\n\tu8 current_duplex;\n\tint i, err;\n\n\ttg3_clear_mac_status(tp);\n\n\tif ((tp->mi_mode & MAC_MI_MODE_AUTO_POLL) != 0) {\n\t\ttw32_f(MAC_MI_MODE,\n\t\t     (tp->mi_mode & ~MAC_MI_MODE_AUTO_POLL));\n\t\tudelay(80);\n\t}\n\n\ttg3_phy_auxctl_write(tp, MII_TG3_AUXCTL_SHDWSEL_PWRCTL, 0);\n\n\t/* Some third-party PHYs need to be reset on link going\n\t * down.\n\t */\n\tif ((tg3_asic_rev(tp) == ASIC_REV_5703 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5704 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5705) &&\n\t    tp->link_up) {\n\t\ttg3_readphy(tp, MII_BMSR, &bmsr);\n\t\tif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\n\t\t    !(bmsr & BMSR_LSTATUS))\n\t\t\tforce_reset = true;\n\t}\n\tif (force_reset)\n\t\ttg3_phy_reset(tp);\n\n\tif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\n\t\ttg3_readphy(tp, MII_BMSR, &bmsr);\n\t\tif (tg3_readphy(tp, MII_BMSR, &bmsr) ||\n\t\t    !tg3_flag(tp, INIT_COMPLETE))\n\t\t\tbmsr = 0;\n\n\t\tif (!(bmsr & BMSR_LSTATUS)) {\n\t\t\terr = tg3_init_5401phy_dsp(tp);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\ttg3_readphy(tp, MII_BMSR, &bmsr);\n\t\t\tfor (i = 0; i < 1000; i++) {\n\t\t\t\tudelay(10);\n\t\t\t\tif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\n\t\t\t\t    (bmsr & BMSR_LSTATUS)) {\n\t\t\t\t\tudelay(40);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((tp->phy_id & TG3_PHY_ID_REV_MASK) ==\n\t\t\t    TG3_PHY_REV_BCM5401_B0 &&\n\t\t\t    !(bmsr & BMSR_LSTATUS) &&\n\t\t\t    tp->link_config.active_speed == SPEED_1000) {\n\t\t\t\terr = tg3_phy_reset(tp);\n\t\t\t\tif (!err)\n\t\t\t\t\terr = tg3_init_5401phy_dsp(tp);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t} else if (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\n\t\t   tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0) {\n\t\t/* 5701 {A0,B0} CRC bug workaround */\n\t\ttg3_writephy(tp, 0x15, 0x0a75);\n\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8c68);\n\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8d68);\n\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x8c68);\n\t}\n\n\t/* Clear pending interrupts... */\n\ttg3_readphy(tp, MII_TG3_ISTAT, &val);\n\ttg3_readphy(tp, MII_TG3_ISTAT, &val);\n\n\tif (tp->phy_flags & TG3_PHYFLG_USE_MI_INTERRUPT)\n\t\ttg3_writephy(tp, MII_TG3_IMASK, ~MII_TG3_INT_LINKCHG);\n\telse if (!(tp->phy_flags & TG3_PHYFLG_IS_FET))\n\t\ttg3_writephy(tp, MII_TG3_IMASK, ~0);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5701) {\n\t\tif (tp->led_ctrl == LED_CTRL_MODE_PHY_1)\n\t\t\ttg3_writephy(tp, MII_TG3_EXT_CTRL,\n\t\t\t\t     MII_TG3_EXT_CTRL_LNK3_LED_MODE);\n\t\telse\n\t\t\ttg3_writephy(tp, MII_TG3_EXT_CTRL, 0);\n\t}\n\n\tcurrent_link_up = false;\n\tcurrent_speed = SPEED_UNKNOWN;\n\tcurrent_duplex = DUPLEX_UNKNOWN;\n\ttp->phy_flags &= ~TG3_PHYFLG_MDIX_STATE;\n\ttp->link_config.rmt_adv = 0;\n\n\tif (tp->phy_flags & TG3_PHYFLG_CAPACITIVE_COUPLING) {\n\t\terr = tg3_phy_auxctl_read(tp,\n\t\t\t\t\t  MII_TG3_AUXCTL_SHDWSEL_MISCTEST,\n\t\t\t\t\t  &val);\n\t\tif (!err && !(val & (1 << 10))) {\n\t\t\ttg3_phy_auxctl_write(tp,\n\t\t\t\t\t     MII_TG3_AUXCTL_SHDWSEL_MISCTEST,\n\t\t\t\t\t     val | (1 << 10));\n\t\t\tgoto relink;\n\t\t}\n\t}\n\n\tbmsr = 0;\n\tfor (i = 0; i < 100; i++) {\n\t\ttg3_readphy(tp, MII_BMSR, &bmsr);\n\t\tif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\n\t\t    (bmsr & BMSR_LSTATUS))\n\t\t\tbreak;\n\t\tudelay(40);\n\t}\n\n\tif (bmsr & BMSR_LSTATUS) {\n\t\tu32 aux_stat, bmcr;\n\n\t\ttg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat);\n\t\tfor (i = 0; i < 2000; i++) {\n\t\t\tudelay(10);\n\t\t\tif (!tg3_readphy(tp, MII_TG3_AUX_STAT, &aux_stat) &&\n\t\t\t    aux_stat)\n\t\t\t\tbreak;\n\t\t}\n\n\t\ttg3_aux_stat_to_speed_duplex(tp, aux_stat,\n\t\t\t\t\t     &current_speed,\n\t\t\t\t\t     &current_duplex);\n\n\t\tbmcr = 0;\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\t\tif (tg3_readphy(tp, MII_BMCR, &bmcr))\n\t\t\t\tcontinue;\n\t\t\tif (bmcr && bmcr != 0x7fff)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\n\t\tlcl_adv = 0;\n\t\trmt_adv = 0;\n\n\t\ttp->link_config.active_speed = current_speed;\n\t\ttp->link_config.active_duplex = current_duplex;\n\n\t\tif (tp->link_config.autoneg == AUTONEG_ENABLE) {\n\t\t\tbool eee_config_ok = tg3_phy_eee_config_ok(tp);\n\n\t\t\tif ((bmcr & BMCR_ANENABLE) &&\n\t\t\t    eee_config_ok &&\n\t\t\t    tg3_phy_copper_an_config_ok(tp, &lcl_adv) &&\n\t\t\t    tg3_phy_copper_fetch_rmtadv(tp, &rmt_adv))\n\t\t\t\tcurrent_link_up = true;\n\n\t\t\t/* EEE settings changes take effect only after a phy\n\t\t\t * reset.  If we have skipped a reset due to Link Flap\n\t\t\t * Avoidance being enabled, do it now.\n\t\t\t */\n\t\t\tif (!eee_config_ok &&\n\t\t\t    (tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN) &&\n\t\t\t    !force_reset) {\n\t\t\t\ttg3_setup_eee(tp);\n\t\t\t\ttg3_phy_reset(tp);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(bmcr & BMCR_ANENABLE) &&\n\t\t\t    tp->link_config.speed == current_speed &&\n\t\t\t    tp->link_config.duplex == current_duplex) {\n\t\t\t\tcurrent_link_up = true;\n\t\t\t}\n\t\t}\n\n\t\tif (current_link_up &&\n\t\t    tp->link_config.active_duplex == DUPLEX_FULL) {\n\t\t\tu32 reg, bit;\n\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\t\t\treg = MII_TG3_FET_GEN_STAT;\n\t\t\t\tbit = MII_TG3_FET_GEN_STAT_MDIXSTAT;\n\t\t\t} else {\n\t\t\t\treg = MII_TG3_EXT_STAT;\n\t\t\t\tbit = MII_TG3_EXT_STAT_MDIX;\n\t\t\t}\n\n\t\t\tif (!tg3_readphy(tp, reg, &val) && (val & bit))\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_MDIX_STATE;\n\n\t\t\ttg3_setup_flow_control(tp, lcl_adv, rmt_adv);\n\t\t}\n\t}\n\nrelink:\n\tif (!current_link_up || (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)) {\n\t\ttg3_phy_copper_begin(tp);\n\n\t\tif (tg3_flag(tp, ROBOSWITCH)) {\n\t\t\tcurrent_link_up = true;\n\t\t\t/* FIXME: when BCM5325 switch is used use 100 MBit/s */\n\t\t\tcurrent_speed = SPEED_1000;\n\t\t\tcurrent_duplex = DUPLEX_FULL;\n\t\t\ttp->link_config.active_speed = current_speed;\n\t\t\ttp->link_config.active_duplex = current_duplex;\n\t\t}\n\n\t\ttg3_readphy(tp, MII_BMSR, &bmsr);\n\t\tif ((!tg3_readphy(tp, MII_BMSR, &bmsr) && (bmsr & BMSR_LSTATUS)) ||\n\t\t    (tp->mac_mode & MAC_MODE_PORT_INT_LPBACK))\n\t\t\tcurrent_link_up = true;\n\t}\n\n\ttp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;\n\tif (current_link_up) {\n\t\tif (tp->link_config.active_speed == SPEED_100 ||\n\t\t    tp->link_config.active_speed == SPEED_10)\n\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_MII;\n\t\telse\n\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\n\t} else if (tp->phy_flags & TG3_PHYFLG_IS_FET)\n\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_MII;\n\telse\n\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\n\n\t/* In order for the 5750 core in BCM4785 chip to work properly\n\t * in RGMII mode, the Led Control Register must be set up.\n\t */\n\tif (tg3_flag(tp, RGMII_MODE)) {\n\t\tu32 led_ctrl = tr32(MAC_LED_CTRL);\n\t\tled_ctrl &= ~(LED_CTRL_1000MBPS_ON | LED_CTRL_100MBPS_ON);\n\n\t\tif (tp->link_config.active_speed == SPEED_10)\n\t\t\tled_ctrl |= LED_CTRL_LNKLED_OVERRIDE;\n\t\telse if (tp->link_config.active_speed == SPEED_100)\n\t\t\tled_ctrl |= (LED_CTRL_LNKLED_OVERRIDE |\n\t\t\t\t     LED_CTRL_100MBPS_ON);\n\t\telse if (tp->link_config.active_speed == SPEED_1000)\n\t\t\tled_ctrl |= (LED_CTRL_LNKLED_OVERRIDE |\n\t\t\t\t     LED_CTRL_1000MBPS_ON);\n\n\t\ttw32(MAC_LED_CTRL, led_ctrl);\n\t\tudelay(40);\n\t}\n\n\ttp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;\n\tif (tp->link_config.active_duplex == DUPLEX_HALF)\n\t\ttp->mac_mode |= MAC_MODE_HALF_DUPLEX;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700) {\n\t\tif (current_link_up &&\n\t\t    tg3_5700_link_polarity(tp, tp->link_config.active_speed))\n\t\t\ttp->mac_mode |= MAC_MODE_LINK_POLARITY;\n\t\telse\n\t\t\ttp->mac_mode &= ~MAC_MODE_LINK_POLARITY;\n\t}\n\n\t/* ??? Without this setting Netgear GA302T PHY does not\n\t * ??? send/receive packets...\n\t */\n\tif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5411 &&\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5700_ALTIMA) {\n\t\ttp->mi_mode |= MAC_MI_MODE_AUTO_POLL;\n\t\ttw32_f(MAC_MI_MODE, tp->mi_mode);\n\t\tudelay(80);\n\t}\n\n\ttw32_f(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n\n\ttg3_phy_eee_adjust(tp, current_link_up);\n\n\tif (tg3_flag(tp, USE_LINKCHG_REG)) {\n\t\t/* Polled via timer. */\n\t\ttw32_f(MAC_EVENT, 0);\n\t} else {\n\t\ttw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\n\t}\n\tudelay(40);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 &&\n\t    current_link_up &&\n\t    tp->link_config.active_speed == SPEED_1000 &&\n\t    (tg3_flag(tp, PCIX_MODE) || tg3_flag(tp, PCI_HIGH_SPEED))) {\n\t\tudelay(120);\n\t\ttw32_f(MAC_STATUS,\n\t\t     (MAC_STATUS_SYNC_CHANGED |\n\t\t      MAC_STATUS_CFG_CHANGED));\n\t\tudelay(40);\n\t\ttg3_write_mem(tp,\n\t\t\t      NIC_SRAM_FIRMWARE_MBOX,\n\t\t\t      NIC_SRAM_FIRMWARE_MBOX_MAGIC2);\n\t}\n\n\t/* Prevent send BD corruption. */\n\tif (tg3_flag(tp, CLKREQ_BUG)) {\n\t\tif (tp->link_config.active_speed == SPEED_100 ||\n\t\t    tp->link_config.active_speed == SPEED_10)\n\t\t\tpcie_capability_clear_word(tp->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_CLKREQ_EN);\n\t\telse\n\t\t\tpcie_capability_set_word(tp->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t PCI_EXP_LNKCTL_CLKREQ_EN);\n\t}\n\n\ttg3_test_and_report_link_chg(tp, current_link_up);\n\n\treturn 0;\n}\n\nstruct tg3_fiber_aneginfo {\n\tint state;\n#define ANEG_STATE_UNKNOWN\t\t0\n#define ANEG_STATE_AN_ENABLE\t\t1\n#define ANEG_STATE_RESTART_INIT\t\t2\n#define ANEG_STATE_RESTART\t\t3\n#define ANEG_STATE_DISABLE_LINK_OK\t4\n#define ANEG_STATE_ABILITY_DETECT_INIT\t5\n#define ANEG_STATE_ABILITY_DETECT\t6\n#define ANEG_STATE_ACK_DETECT_INIT\t7\n#define ANEG_STATE_ACK_DETECT\t\t8\n#define ANEG_STATE_COMPLETE_ACK_INIT\t9\n#define ANEG_STATE_COMPLETE_ACK\t\t10\n#define ANEG_STATE_IDLE_DETECT_INIT\t11\n#define ANEG_STATE_IDLE_DETECT\t\t12\n#define ANEG_STATE_LINK_OK\t\t13\n#define ANEG_STATE_NEXT_PAGE_WAIT_INIT\t14\n#define ANEG_STATE_NEXT_PAGE_WAIT\t15\n\n\tu32 flags;\n#define MR_AN_ENABLE\t\t0x00000001\n#define MR_RESTART_AN\t\t0x00000002\n#define MR_AN_COMPLETE\t\t0x00000004\n#define MR_PAGE_RX\t\t0x00000008\n#define MR_NP_LOADED\t\t0x00000010\n#define MR_TOGGLE_TX\t\t0x00000020\n#define MR_LP_ADV_FULL_DUPLEX\t0x00000040\n#define MR_LP_ADV_HALF_DUPLEX\t0x00000080\n#define MR_LP_ADV_SYM_PAUSE\t0x00000100\n#define MR_LP_ADV_ASYM_PAUSE\t0x00000200\n#define MR_LP_ADV_REMOTE_FAULT1\t0x00000400\n#define MR_LP_ADV_REMOTE_FAULT2\t0x00000800\n#define MR_LP_ADV_NEXT_PAGE\t0x00001000\n#define MR_TOGGLE_RX\t\t0x00002000\n#define MR_NP_RX\t\t0x00004000\n\n#define MR_LINK_OK\t\t0x80000000\n\n\tunsigned long link_time, cur_time;\n\n\tu32 ability_match_cfg;\n\tint ability_match_count;\n\n\tchar ability_match, idle_match, ack_match;\n\n\tu32 txconfig, rxconfig;\n#define ANEG_CFG_NP\t\t0x00000080\n#define ANEG_CFG_ACK\t\t0x00000040\n#define ANEG_CFG_RF2\t\t0x00000020\n#define ANEG_CFG_RF1\t\t0x00000010\n#define ANEG_CFG_PS2\t\t0x00000001\n#define ANEG_CFG_PS1\t\t0x00008000\n#define ANEG_CFG_HD\t\t0x00004000\n#define ANEG_CFG_FD\t\t0x00002000\n#define ANEG_CFG_INVAL\t\t0x00001f06\n\n};\n#define ANEG_OK\t\t0\n#define ANEG_DONE\t1\n#define ANEG_TIMER_ENAB\t2\n#define ANEG_FAILED\t-1\n\n#define ANEG_STATE_SETTLE_TIME\t10000\n\nstatic int tg3_fiber_aneg_smachine(struct tg3 *tp,\n\t\t\t\t   struct tg3_fiber_aneginfo *ap)\n{\n\tu16 flowctrl;\n\tunsigned long delta;\n\tu32 rx_cfg_reg;\n\tint ret;\n\n\tif (ap->state == ANEG_STATE_UNKNOWN) {\n\t\tap->rxconfig = 0;\n\t\tap->link_time = 0;\n\t\tap->cur_time = 0;\n\t\tap->ability_match_cfg = 0;\n\t\tap->ability_match_count = 0;\n\t\tap->ability_match = 0;\n\t\tap->idle_match = 0;\n\t\tap->ack_match = 0;\n\t}\n\tap->cur_time++;\n\n\tif (tr32(MAC_STATUS) & MAC_STATUS_RCVD_CFG) {\n\t\trx_cfg_reg = tr32(MAC_RX_AUTO_NEG);\n\n\t\tif (rx_cfg_reg != ap->ability_match_cfg) {\n\t\t\tap->ability_match_cfg = rx_cfg_reg;\n\t\t\tap->ability_match = 0;\n\t\t\tap->ability_match_count = 0;\n\t\t} else {\n\t\t\tif (++ap->ability_match_count > 1) {\n\t\t\t\tap->ability_match = 1;\n\t\t\t\tap->ability_match_cfg = rx_cfg_reg;\n\t\t\t}\n\t\t}\n\t\tif (rx_cfg_reg & ANEG_CFG_ACK)\n\t\t\tap->ack_match = 1;\n\t\telse\n\t\t\tap->ack_match = 0;\n\n\t\tap->idle_match = 0;\n\t} else {\n\t\tap->idle_match = 1;\n\t\tap->ability_match_cfg = 0;\n\t\tap->ability_match_count = 0;\n\t\tap->ability_match = 0;\n\t\tap->ack_match = 0;\n\n\t\trx_cfg_reg = 0;\n\t}\n\n\tap->rxconfig = rx_cfg_reg;\n\tret = ANEG_OK;\n\n\tswitch (ap->state) {\n\tcase ANEG_STATE_UNKNOWN:\n\t\tif (ap->flags & (MR_AN_ENABLE | MR_RESTART_AN))\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\n\t\tfallthrough;\n\tcase ANEG_STATE_AN_ENABLE:\n\t\tap->flags &= ~(MR_AN_COMPLETE | MR_PAGE_RX);\n\t\tif (ap->flags & MR_AN_ENABLE) {\n\t\t\tap->link_time = 0;\n\t\t\tap->cur_time = 0;\n\t\t\tap->ability_match_cfg = 0;\n\t\t\tap->ability_match_count = 0;\n\t\t\tap->ability_match = 0;\n\t\t\tap->idle_match = 0;\n\t\t\tap->ack_match = 0;\n\n\t\t\tap->state = ANEG_STATE_RESTART_INIT;\n\t\t} else {\n\t\t\tap->state = ANEG_STATE_DISABLE_LINK_OK;\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_RESTART_INIT:\n\t\tap->link_time = ap->cur_time;\n\t\tap->flags &= ~(MR_NP_LOADED);\n\t\tap->txconfig = 0;\n\t\ttw32(MAC_TX_AUTO_NEG, 0);\n\t\ttp->mac_mode |= MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tret = ANEG_TIMER_ENAB;\n\t\tap->state = ANEG_STATE_RESTART;\n\n\t\tfallthrough;\n\tcase ANEG_STATE_RESTART:\n\t\tdelta = ap->cur_time - ap->link_time;\n\t\tif (delta > ANEG_STATE_SETTLE_TIME)\n\t\t\tap->state = ANEG_STATE_ABILITY_DETECT_INIT;\n\t\telse\n\t\t\tret = ANEG_TIMER_ENAB;\n\t\tbreak;\n\n\tcase ANEG_STATE_DISABLE_LINK_OK:\n\t\tret = ANEG_DONE;\n\t\tbreak;\n\n\tcase ANEG_STATE_ABILITY_DETECT_INIT:\n\t\tap->flags &= ~(MR_TOGGLE_TX);\n\t\tap->txconfig = ANEG_CFG_FD;\n\t\tflowctrl = tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\n\t\tif (flowctrl & ADVERTISE_1000XPAUSE)\n\t\t\tap->txconfig |= ANEG_CFG_PS1;\n\t\tif (flowctrl & ADVERTISE_1000XPSE_ASYM)\n\t\t\tap->txconfig |= ANEG_CFG_PS2;\n\t\ttw32(MAC_TX_AUTO_NEG, ap->txconfig);\n\t\ttp->mac_mode |= MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tap->state = ANEG_STATE_ABILITY_DETECT;\n\t\tbreak;\n\n\tcase ANEG_STATE_ABILITY_DETECT:\n\t\tif (ap->ability_match != 0 && ap->rxconfig != 0)\n\t\t\tap->state = ANEG_STATE_ACK_DETECT_INIT;\n\t\tbreak;\n\n\tcase ANEG_STATE_ACK_DETECT_INIT:\n\t\tap->txconfig |= ANEG_CFG_ACK;\n\t\ttw32(MAC_TX_AUTO_NEG, ap->txconfig);\n\t\ttp->mac_mode |= MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tap->state = ANEG_STATE_ACK_DETECT;\n\n\t\tfallthrough;\n\tcase ANEG_STATE_ACK_DETECT:\n\t\tif (ap->ack_match != 0) {\n\t\t\tif ((ap->rxconfig & ~ANEG_CFG_ACK) ==\n\t\t\t    (ap->ability_match_cfg & ~ANEG_CFG_ACK)) {\n\t\t\t\tap->state = ANEG_STATE_COMPLETE_ACK_INIT;\n\t\t\t} else {\n\t\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t\t}\n\t\t} else if (ap->ability_match != 0 &&\n\t\t\t   ap->rxconfig == 0) {\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_COMPLETE_ACK_INIT:\n\t\tif (ap->rxconfig & ANEG_CFG_INVAL) {\n\t\t\tret = ANEG_FAILED;\n\t\t\tbreak;\n\t\t}\n\t\tap->flags &= ~(MR_LP_ADV_FULL_DUPLEX |\n\t\t\t       MR_LP_ADV_HALF_DUPLEX |\n\t\t\t       MR_LP_ADV_SYM_PAUSE |\n\t\t\t       MR_LP_ADV_ASYM_PAUSE |\n\t\t\t       MR_LP_ADV_REMOTE_FAULT1 |\n\t\t\t       MR_LP_ADV_REMOTE_FAULT2 |\n\t\t\t       MR_LP_ADV_NEXT_PAGE |\n\t\t\t       MR_TOGGLE_RX |\n\t\t\t       MR_NP_RX);\n\t\tif (ap->rxconfig & ANEG_CFG_FD)\n\t\t\tap->flags |= MR_LP_ADV_FULL_DUPLEX;\n\t\tif (ap->rxconfig & ANEG_CFG_HD)\n\t\t\tap->flags |= MR_LP_ADV_HALF_DUPLEX;\n\t\tif (ap->rxconfig & ANEG_CFG_PS1)\n\t\t\tap->flags |= MR_LP_ADV_SYM_PAUSE;\n\t\tif (ap->rxconfig & ANEG_CFG_PS2)\n\t\t\tap->flags |= MR_LP_ADV_ASYM_PAUSE;\n\t\tif (ap->rxconfig & ANEG_CFG_RF1)\n\t\t\tap->flags |= MR_LP_ADV_REMOTE_FAULT1;\n\t\tif (ap->rxconfig & ANEG_CFG_RF2)\n\t\t\tap->flags |= MR_LP_ADV_REMOTE_FAULT2;\n\t\tif (ap->rxconfig & ANEG_CFG_NP)\n\t\t\tap->flags |= MR_LP_ADV_NEXT_PAGE;\n\n\t\tap->link_time = ap->cur_time;\n\n\t\tap->flags ^= (MR_TOGGLE_TX);\n\t\tif (ap->rxconfig & 0x0008)\n\t\t\tap->flags |= MR_TOGGLE_RX;\n\t\tif (ap->rxconfig & ANEG_CFG_NP)\n\t\t\tap->flags |= MR_NP_RX;\n\t\tap->flags |= MR_PAGE_RX;\n\n\t\tap->state = ANEG_STATE_COMPLETE_ACK;\n\t\tret = ANEG_TIMER_ENAB;\n\t\tbreak;\n\n\tcase ANEG_STATE_COMPLETE_ACK:\n\t\tif (ap->ability_match != 0 &&\n\t\t    ap->rxconfig == 0) {\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t\tbreak;\n\t\t}\n\t\tdelta = ap->cur_time - ap->link_time;\n\t\tif (delta > ANEG_STATE_SETTLE_TIME) {\n\t\t\tif (!(ap->flags & (MR_LP_ADV_NEXT_PAGE))) {\n\t\t\t\tap->state = ANEG_STATE_IDLE_DETECT_INIT;\n\t\t\t} else {\n\t\t\t\tif ((ap->txconfig & ANEG_CFG_NP) == 0 &&\n\t\t\t\t    !(ap->flags & MR_NP_RX)) {\n\t\t\t\t\tap->state = ANEG_STATE_IDLE_DETECT_INIT;\n\t\t\t\t} else {\n\t\t\t\t\tret = ANEG_FAILED;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_IDLE_DETECT_INIT:\n\t\tap->link_time = ap->cur_time;\n\t\ttp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\tap->state = ANEG_STATE_IDLE_DETECT;\n\t\tret = ANEG_TIMER_ENAB;\n\t\tbreak;\n\n\tcase ANEG_STATE_IDLE_DETECT:\n\t\tif (ap->ability_match != 0 &&\n\t\t    ap->rxconfig == 0) {\n\t\t\tap->state = ANEG_STATE_AN_ENABLE;\n\t\t\tbreak;\n\t\t}\n\t\tdelta = ap->cur_time - ap->link_time;\n\t\tif (delta > ANEG_STATE_SETTLE_TIME) {\n\t\t\t/* XXX another gem from the Broadcom driver :( */\n\t\t\tap->state = ANEG_STATE_LINK_OK;\n\t\t}\n\t\tbreak;\n\n\tcase ANEG_STATE_LINK_OK:\n\t\tap->flags |= (MR_AN_COMPLETE | MR_LINK_OK);\n\t\tret = ANEG_DONE;\n\t\tbreak;\n\n\tcase ANEG_STATE_NEXT_PAGE_WAIT_INIT:\n\t\t/* ??? unimplemented */\n\t\tbreak;\n\n\tcase ANEG_STATE_NEXT_PAGE_WAIT:\n\t\t/* ??? unimplemented */\n\t\tbreak;\n\n\tdefault:\n\t\tret = ANEG_FAILED;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fiber_autoneg(struct tg3 *tp, u32 *txflags, u32 *rxflags)\n{\n\tint res = 0;\n\tstruct tg3_fiber_aneginfo aninfo;\n\tint status = ANEG_FAILED;\n\tunsigned int tick;\n\tu32 tmp;\n\n\ttw32_f(MAC_TX_AUTO_NEG, 0);\n\n\ttmp = tp->mac_mode & ~MAC_MODE_PORT_MODE_MASK;\n\ttw32_f(MAC_MODE, tmp | MAC_MODE_PORT_MODE_GMII);\n\tudelay(40);\n\n\ttw32_f(MAC_MODE, tp->mac_mode | MAC_MODE_SEND_CONFIGS);\n\tudelay(40);\n\n\tmemset(&aninfo, 0, sizeof(aninfo));\n\taninfo.flags |= MR_AN_ENABLE;\n\taninfo.state = ANEG_STATE_UNKNOWN;\n\taninfo.cur_time = 0;\n\ttick = 0;\n\twhile (++tick < 195000) {\n\t\tstatus = tg3_fiber_aneg_smachine(tp, &aninfo);\n\t\tif (status == ANEG_DONE || status == ANEG_FAILED)\n\t\t\tbreak;\n\n\t\tudelay(1);\n\t}\n\n\ttp->mac_mode &= ~MAC_MODE_SEND_CONFIGS;\n\ttw32_f(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n\n\t*txflags = aninfo.txconfig;\n\t*rxflags = aninfo.flags;\n\n\tif (status == ANEG_DONE &&\n\t    (aninfo.flags & (MR_AN_COMPLETE | MR_LINK_OK |\n\t\t\t     MR_LP_ADV_FULL_DUPLEX)))\n\t\tres = 1;\n\n\treturn res;\n}\n\nstatic void tg3_init_bcm8002(struct tg3 *tp)\n{\n\tu32 mac_status = tr32(MAC_STATUS);\n\tint i;\n\n\t/* Reset when initting first time or we have a link. */\n\tif (tg3_flag(tp, INIT_COMPLETE) &&\n\t    !(mac_status & MAC_STATUS_PCS_SYNCED))\n\t\treturn;\n\n\t/* Set PLL lock range. */\n\ttg3_writephy(tp, 0x16, 0x8007);\n\n\t/* SW reset */\n\ttg3_writephy(tp, MII_BMCR, BMCR_RESET);\n\n\t/* Wait for reset to complete. */\n\t/* XXX schedule_timeout() ... */\n\tfor (i = 0; i < 500; i++)\n\t\tudelay(10);\n\n\t/* Config mode; select PMA/Ch 1 regs. */\n\ttg3_writephy(tp, 0x10, 0x8411);\n\n\t/* Enable auto-lock and comdet, select txclk for tx. */\n\ttg3_writephy(tp, 0x11, 0x0a10);\n\n\ttg3_writephy(tp, 0x18, 0x00a0);\n\ttg3_writephy(tp, 0x16, 0x41ff);\n\n\t/* Assert and deassert POR. */\n\ttg3_writephy(tp, 0x13, 0x0400);\n\tudelay(40);\n\ttg3_writephy(tp, 0x13, 0x0000);\n\n\ttg3_writephy(tp, 0x11, 0x0a50);\n\tudelay(40);\n\ttg3_writephy(tp, 0x11, 0x0a10);\n\n\t/* Wait for signal to stabilize */\n\t/* XXX schedule_timeout() ... */\n\tfor (i = 0; i < 15000; i++)\n\t\tudelay(10);\n\n\t/* Deselect the channel register so we can read the PHYID\n\t * later.\n\t */\n\ttg3_writephy(tp, 0x10, 0x8011);\n}\n\nstatic bool tg3_setup_fiber_hw_autoneg(struct tg3 *tp, u32 mac_status)\n{\n\tu16 flowctrl;\n\tbool current_link_up;\n\tu32 sg_dig_ctrl, sg_dig_status;\n\tu32 serdes_cfg, expected_sg_dig_ctrl;\n\tint workaround, port_a;\n\n\tserdes_cfg = 0;\n\texpected_sg_dig_ctrl = 0;\n\tworkaround = 0;\n\tport_a = 1;\n\tcurrent_link_up = false;\n\n\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5704_A0 &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5704_A1) {\n\t\tworkaround = 1;\n\t\tif (tr32(TG3PCI_DUAL_MAC_CTRL) & DUAL_MAC_CTRL_ID)\n\t\t\tport_a = 0;\n\n\t\t/* preserve bits 0-11,13,14 for signal pre-emphasis */\n\t\t/* preserve bits 20-23 for voltage regulator */\n\t\tserdes_cfg = tr32(MAC_SERDES_CFG) & 0x00f06fff;\n\t}\n\n\tsg_dig_ctrl = tr32(SG_DIG_CTRL);\n\n\tif (tp->link_config.autoneg != AUTONEG_ENABLE) {\n\t\tif (sg_dig_ctrl & SG_DIG_USING_HW_AUTONEG) {\n\t\t\tif (workaround) {\n\t\t\t\tu32 val = serdes_cfg;\n\n\t\t\t\tif (port_a)\n\t\t\t\t\tval |= 0xc010000;\n\t\t\t\telse\n\t\t\t\t\tval |= 0x4010000;\n\t\t\t\ttw32_f(MAC_SERDES_CFG, val);\n\t\t\t}\n\n\t\t\ttw32_f(SG_DIG_CTRL, SG_DIG_COMMON_SETUP);\n\t\t}\n\t\tif (mac_status & MAC_STATUS_PCS_SYNCED) {\n\t\t\ttg3_setup_flow_control(tp, 0, 0);\n\t\t\tcurrent_link_up = true;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Want auto-negotiation.  */\n\texpected_sg_dig_ctrl = SG_DIG_USING_HW_AUTONEG | SG_DIG_COMMON_SETUP;\n\n\tflowctrl = tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\n\tif (flowctrl & ADVERTISE_1000XPAUSE)\n\t\texpected_sg_dig_ctrl |= SG_DIG_PAUSE_CAP;\n\tif (flowctrl & ADVERTISE_1000XPSE_ASYM)\n\t\texpected_sg_dig_ctrl |= SG_DIG_ASYM_PAUSE;\n\n\tif (sg_dig_ctrl != expected_sg_dig_ctrl) {\n\t\tif ((tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT) &&\n\t\t    tp->serdes_counter &&\n\t\t    ((mac_status & (MAC_STATUS_PCS_SYNCED |\n\t\t\t\t    MAC_STATUS_RCVD_CFG)) ==\n\t\t     MAC_STATUS_PCS_SYNCED)) {\n\t\t\ttp->serdes_counter--;\n\t\t\tcurrent_link_up = true;\n\t\t\tgoto out;\n\t\t}\nrestart_autoneg:\n\t\tif (workaround)\n\t\t\ttw32_f(MAC_SERDES_CFG, serdes_cfg | 0xc011000);\n\t\ttw32_f(SG_DIG_CTRL, expected_sg_dig_ctrl | SG_DIG_SOFT_RESET);\n\t\tudelay(5);\n\t\ttw32_f(SG_DIG_CTRL, expected_sg_dig_ctrl);\n\n\t\ttp->serdes_counter = SERDES_AN_TIMEOUT_5704S;\n\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\t} else if (mac_status & (MAC_STATUS_PCS_SYNCED |\n\t\t\t\t MAC_STATUS_SIGNAL_DET)) {\n\t\tsg_dig_status = tr32(SG_DIG_STATUS);\n\t\tmac_status = tr32(MAC_STATUS);\n\n\t\tif ((sg_dig_status & SG_DIG_AUTONEG_COMPLETE) &&\n\t\t    (mac_status & MAC_STATUS_PCS_SYNCED)) {\n\t\t\tu32 local_adv = 0, remote_adv = 0;\n\n\t\t\tif (sg_dig_ctrl & SG_DIG_PAUSE_CAP)\n\t\t\t\tlocal_adv |= ADVERTISE_1000XPAUSE;\n\t\t\tif (sg_dig_ctrl & SG_DIG_ASYM_PAUSE)\n\t\t\t\tlocal_adv |= ADVERTISE_1000XPSE_ASYM;\n\n\t\t\tif (sg_dig_status & SG_DIG_PARTNER_PAUSE_CAPABLE)\n\t\t\t\tremote_adv |= LPA_1000XPAUSE;\n\t\t\tif (sg_dig_status & SG_DIG_PARTNER_ASYM_PAUSE)\n\t\t\t\tremote_adv |= LPA_1000XPAUSE_ASYM;\n\n\t\t\ttp->link_config.rmt_adv =\n\t\t\t\t\t   mii_adv_to_ethtool_adv_x(remote_adv);\n\n\t\t\ttg3_setup_flow_control(tp, local_adv, remote_adv);\n\t\t\tcurrent_link_up = true;\n\t\t\ttp->serdes_counter = 0;\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\t\t} else if (!(sg_dig_status & SG_DIG_AUTONEG_COMPLETE)) {\n\t\t\tif (tp->serdes_counter)\n\t\t\t\ttp->serdes_counter--;\n\t\t\telse {\n\t\t\t\tif (workaround) {\n\t\t\t\t\tu32 val = serdes_cfg;\n\n\t\t\t\t\tif (port_a)\n\t\t\t\t\t\tval |= 0xc010000;\n\t\t\t\t\telse\n\t\t\t\t\t\tval |= 0x4010000;\n\n\t\t\t\t\ttw32_f(MAC_SERDES_CFG, val);\n\t\t\t\t}\n\n\t\t\t\ttw32_f(SG_DIG_CTRL, SG_DIG_COMMON_SETUP);\n\t\t\t\tudelay(40);\n\n\t\t\t\t/* Link parallel detection - link is up */\n\t\t\t\t/* only if we have PCS_SYNC and not */\n\t\t\t\t/* receiving config code words */\n\t\t\t\tmac_status = tr32(MAC_STATUS);\n\t\t\t\tif ((mac_status & MAC_STATUS_PCS_SYNCED) &&\n\t\t\t\t    !(mac_status & MAC_STATUS_RCVD_CFG)) {\n\t\t\t\t\ttg3_setup_flow_control(tp, 0, 0);\n\t\t\t\t\tcurrent_link_up = true;\n\t\t\t\t\ttp->phy_flags |=\n\t\t\t\t\t\tTG3_PHYFLG_PARALLEL_DETECT;\n\t\t\t\t\ttp->serdes_counter =\n\t\t\t\t\t\tSERDES_PARALLEL_DET_TIMEOUT;\n\t\t\t\t} else\n\t\t\t\t\tgoto restart_autoneg;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttp->serdes_counter = SERDES_AN_TIMEOUT_5704S;\n\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\t}\n\nout:\n\treturn current_link_up;\n}\n\nstatic bool tg3_setup_fiber_by_hand(struct tg3 *tp, u32 mac_status)\n{\n\tbool current_link_up = false;\n\n\tif (!(mac_status & MAC_STATUS_PCS_SYNCED))\n\t\tgoto out;\n\n\tif (tp->link_config.autoneg == AUTONEG_ENABLE) {\n\t\tu32 txflags, rxflags;\n\t\tint i;\n\n\t\tif (fiber_autoneg(tp, &txflags, &rxflags)) {\n\t\t\tu32 local_adv = 0, remote_adv = 0;\n\n\t\t\tif (txflags & ANEG_CFG_PS1)\n\t\t\t\tlocal_adv |= ADVERTISE_1000XPAUSE;\n\t\t\tif (txflags & ANEG_CFG_PS2)\n\t\t\t\tlocal_adv |= ADVERTISE_1000XPSE_ASYM;\n\n\t\t\tif (rxflags & MR_LP_ADV_SYM_PAUSE)\n\t\t\t\tremote_adv |= LPA_1000XPAUSE;\n\t\t\tif (rxflags & MR_LP_ADV_ASYM_PAUSE)\n\t\t\t\tremote_adv |= LPA_1000XPAUSE_ASYM;\n\n\t\t\ttp->link_config.rmt_adv =\n\t\t\t\t\t   mii_adv_to_ethtool_adv_x(remote_adv);\n\n\t\t\ttg3_setup_flow_control(tp, local_adv, remote_adv);\n\n\t\t\tcurrent_link_up = true;\n\t\t}\n\t\tfor (i = 0; i < 30; i++) {\n\t\t\tudelay(20);\n\t\t\ttw32_f(MAC_STATUS,\n\t\t\t       (MAC_STATUS_SYNC_CHANGED |\n\t\t\t\tMAC_STATUS_CFG_CHANGED));\n\t\t\tudelay(40);\n\t\t\tif ((tr32(MAC_STATUS) &\n\t\t\t     (MAC_STATUS_SYNC_CHANGED |\n\t\t\t      MAC_STATUS_CFG_CHANGED)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tmac_status = tr32(MAC_STATUS);\n\t\tif (!current_link_up &&\n\t\t    (mac_status & MAC_STATUS_PCS_SYNCED) &&\n\t\t    !(mac_status & MAC_STATUS_RCVD_CFG))\n\t\t\tcurrent_link_up = true;\n\t} else {\n\t\ttg3_setup_flow_control(tp, 0, 0);\n\n\t\t/* Forcing 1000FD link up. */\n\t\tcurrent_link_up = true;\n\n\t\ttw32_f(MAC_MODE, (tp->mac_mode | MAC_MODE_SEND_CONFIGS));\n\t\tudelay(40);\n\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\t}\n\nout:\n\treturn current_link_up;\n}\n\nstatic int tg3_setup_fiber_phy(struct tg3 *tp, bool force_reset)\n{\n\tu32 orig_pause_cfg;\n\tu32 orig_active_speed;\n\tu8 orig_active_duplex;\n\tu32 mac_status;\n\tbool current_link_up;\n\tint i;\n\n\torig_pause_cfg = tp->link_config.active_flowctrl;\n\torig_active_speed = tp->link_config.active_speed;\n\torig_active_duplex = tp->link_config.active_duplex;\n\n\tif (!tg3_flag(tp, HW_AUTONEG) &&\n\t    tp->link_up &&\n\t    tg3_flag(tp, INIT_COMPLETE)) {\n\t\tmac_status = tr32(MAC_STATUS);\n\t\tmac_status &= (MAC_STATUS_PCS_SYNCED |\n\t\t\t       MAC_STATUS_SIGNAL_DET |\n\t\t\t       MAC_STATUS_CFG_CHANGED |\n\t\t\t       MAC_STATUS_RCVD_CFG);\n\t\tif (mac_status == (MAC_STATUS_PCS_SYNCED |\n\t\t\t\t   MAC_STATUS_SIGNAL_DET)) {\n\t\t\ttw32_f(MAC_STATUS, (MAC_STATUS_SYNC_CHANGED |\n\t\t\t\t\t    MAC_STATUS_CFG_CHANGED));\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\ttw32_f(MAC_TX_AUTO_NEG, 0);\n\n\ttp->mac_mode &= ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);\n\ttp->mac_mode |= MAC_MODE_PORT_MODE_TBI;\n\ttw32_f(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n\n\tif (tp->phy_id == TG3_PHY_ID_BCM8002)\n\t\ttg3_init_bcm8002(tp);\n\n\t/* Enable link change event even when serdes polling.  */\n\ttw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\n\tudelay(40);\n\n\tcurrent_link_up = false;\n\ttp->link_config.rmt_adv = 0;\n\tmac_status = tr32(MAC_STATUS);\n\n\tif (tg3_flag(tp, HW_AUTONEG))\n\t\tcurrent_link_up = tg3_setup_fiber_hw_autoneg(tp, mac_status);\n\telse\n\t\tcurrent_link_up = tg3_setup_fiber_by_hand(tp, mac_status);\n\n\ttp->napi[0].hw_status->status =\n\t\t(SD_STATUS_UPDATED |\n\t\t (tp->napi[0].hw_status->status & ~SD_STATUS_LINK_CHG));\n\n\tfor (i = 0; i < 100; i++) {\n\t\ttw32_f(MAC_STATUS, (MAC_STATUS_SYNC_CHANGED |\n\t\t\t\t    MAC_STATUS_CFG_CHANGED));\n\t\tudelay(5);\n\t\tif ((tr32(MAC_STATUS) & (MAC_STATUS_SYNC_CHANGED |\n\t\t\t\t\t MAC_STATUS_CFG_CHANGED |\n\t\t\t\t\t MAC_STATUS_LNKSTATE_CHANGED)) == 0)\n\t\t\tbreak;\n\t}\n\n\tmac_status = tr32(MAC_STATUS);\n\tif ((mac_status & MAC_STATUS_PCS_SYNCED) == 0) {\n\t\tcurrent_link_up = false;\n\t\tif (tp->link_config.autoneg == AUTONEG_ENABLE &&\n\t\t    tp->serdes_counter == 0) {\n\t\t\ttw32_f(MAC_MODE, (tp->mac_mode |\n\t\t\t\t\t  MAC_MODE_SEND_CONFIGS));\n\t\t\tudelay(1);\n\t\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\t}\n\t}\n\n\tif (current_link_up) {\n\t\ttp->link_config.active_speed = SPEED_1000;\n\t\ttp->link_config.active_duplex = DUPLEX_FULL;\n\t\ttw32(MAC_LED_CTRL, (tp->led_ctrl |\n\t\t\t\t    LED_CTRL_LNKLED_OVERRIDE |\n\t\t\t\t    LED_CTRL_1000MBPS_ON));\n\t} else {\n\t\ttp->link_config.active_speed = SPEED_UNKNOWN;\n\t\ttp->link_config.active_duplex = DUPLEX_UNKNOWN;\n\t\ttw32(MAC_LED_CTRL, (tp->led_ctrl |\n\t\t\t\t    LED_CTRL_LNKLED_OVERRIDE |\n\t\t\t\t    LED_CTRL_TRAFFIC_OVERRIDE));\n\t}\n\n\tif (!tg3_test_and_report_link_chg(tp, current_link_up)) {\n\t\tu32 now_pause_cfg = tp->link_config.active_flowctrl;\n\t\tif (orig_pause_cfg != now_pause_cfg ||\n\t\t    orig_active_speed != tp->link_config.active_speed ||\n\t\t    orig_active_duplex != tp->link_config.active_duplex)\n\t\t\ttg3_link_report(tp);\n\t}\n\n\treturn 0;\n}\n\nstatic int tg3_setup_fiber_mii_phy(struct tg3 *tp, bool force_reset)\n{\n\tint err = 0;\n\tu32 bmsr, bmcr;\n\tu32 current_speed = SPEED_UNKNOWN;\n\tu8 current_duplex = DUPLEX_UNKNOWN;\n\tbool current_link_up = false;\n\tu32 local_adv, remote_adv, sgsr;\n\n\tif ((tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5720) &&\n\t     !tg3_readphy(tp, SERDES_TG3_1000X_STATUS, &sgsr) &&\n\t     (sgsr & SERDES_TG3_SGMII_MODE)) {\n\n\t\tif (force_reset)\n\t\t\ttg3_phy_reset(tp);\n\n\t\ttp->mac_mode &= ~MAC_MODE_PORT_MODE_MASK;\n\n\t\tif (!(sgsr & SERDES_TG3_LINK_UP)) {\n\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\n\t\t} else {\n\t\t\tcurrent_link_up = true;\n\t\t\tif (sgsr & SERDES_TG3_SPEED_1000) {\n\t\t\t\tcurrent_speed = SPEED_1000;\n\t\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\n\t\t\t} else if (sgsr & SERDES_TG3_SPEED_100) {\n\t\t\t\tcurrent_speed = SPEED_100;\n\t\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_MII;\n\t\t\t} else {\n\t\t\t\tcurrent_speed = SPEED_10;\n\t\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_MII;\n\t\t\t}\n\n\t\t\tif (sgsr & SERDES_TG3_FULL_DUPLEX)\n\t\t\t\tcurrent_duplex = DUPLEX_FULL;\n\t\t\telse\n\t\t\t\tcurrent_duplex = DUPLEX_HALF;\n\t\t}\n\n\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\tudelay(40);\n\n\t\ttg3_clear_mac_status(tp);\n\n\t\tgoto fiber_setup_done;\n\t}\n\n\ttp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\n\ttw32_f(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n\n\ttg3_clear_mac_status(tp);\n\n\tif (force_reset)\n\t\ttg3_phy_reset(tp);\n\n\ttp->link_config.rmt_adv = 0;\n\n\terr |= tg3_readphy(tp, MII_BMSR, &bmsr);\n\terr |= tg3_readphy(tp, MII_BMSR, &bmsr);\n\tif (tg3_asic_rev(tp) == ASIC_REV_5714) {\n\t\tif (tr32(MAC_TX_STATUS) & TX_STATUS_LINK_UP)\n\t\t\tbmsr |= BMSR_LSTATUS;\n\t\telse\n\t\t\tbmsr &= ~BMSR_LSTATUS;\n\t}\n\n\terr |= tg3_readphy(tp, MII_BMCR, &bmcr);\n\n\tif ((tp->link_config.autoneg == AUTONEG_ENABLE) && !force_reset &&\n\t    (tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT)) {\n\t\t/* do nothing, just check for link up at the end */\n\t} else if (tp->link_config.autoneg == AUTONEG_ENABLE) {\n\t\tu32 adv, newadv;\n\n\t\terr |= tg3_readphy(tp, MII_ADVERTISE, &adv);\n\t\tnewadv = adv & ~(ADVERTISE_1000XFULL | ADVERTISE_1000XHALF |\n\t\t\t\t ADVERTISE_1000XPAUSE |\n\t\t\t\t ADVERTISE_1000XPSE_ASYM |\n\t\t\t\t ADVERTISE_SLCT);\n\n\t\tnewadv |= tg3_advert_flowctrl_1000X(tp->link_config.flowctrl);\n\t\tnewadv |= ethtool_adv_to_mii_adv_x(tp->link_config.advertising);\n\n\t\tif ((newadv != adv) || !(bmcr & BMCR_ANENABLE)) {\n\t\t\ttg3_writephy(tp, MII_ADVERTISE, newadv);\n\t\t\tbmcr |= BMCR_ANENABLE | BMCR_ANRESTART;\n\t\t\ttg3_writephy(tp, MII_BMCR, bmcr);\n\n\t\t\ttw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\n\t\t\ttp->serdes_counter = SERDES_AN_TIMEOUT_5714S;\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tu32 new_bmcr;\n\n\t\tbmcr &= ~BMCR_SPEED1000;\n\t\tnew_bmcr = bmcr & ~(BMCR_ANENABLE | BMCR_FULLDPLX);\n\n\t\tif (tp->link_config.duplex == DUPLEX_FULL)\n\t\t\tnew_bmcr |= BMCR_FULLDPLX;\n\n\t\tif (new_bmcr != bmcr) {\n\t\t\t/* BMCR_SPEED1000 is a reserved bit that needs\n\t\t\t * to be set on write.\n\t\t\t */\n\t\t\tnew_bmcr |= BMCR_SPEED1000;\n\n\t\t\t/* Force a linkdown */\n\t\t\tif (tp->link_up) {\n\t\t\t\tu32 adv;\n\n\t\t\t\terr |= tg3_readphy(tp, MII_ADVERTISE, &adv);\n\t\t\t\tadv &= ~(ADVERTISE_1000XFULL |\n\t\t\t\t\t ADVERTISE_1000XHALF |\n\t\t\t\t\t ADVERTISE_SLCT);\n\t\t\t\ttg3_writephy(tp, MII_ADVERTISE, adv);\n\t\t\t\ttg3_writephy(tp, MII_BMCR, bmcr |\n\t\t\t\t\t\t\t   BMCR_ANRESTART |\n\t\t\t\t\t\t\t   BMCR_ANENABLE);\n\t\t\t\tudelay(10);\n\t\t\t\ttg3_carrier_off(tp);\n\t\t\t}\n\t\t\ttg3_writephy(tp, MII_BMCR, new_bmcr);\n\t\t\tbmcr = new_bmcr;\n\t\t\terr |= tg3_readphy(tp, MII_BMSR, &bmsr);\n\t\t\terr |= tg3_readphy(tp, MII_BMSR, &bmsr);\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5714) {\n\t\t\t\tif (tr32(MAC_TX_STATUS) & TX_STATUS_LINK_UP)\n\t\t\t\t\tbmsr |= BMSR_LSTATUS;\n\t\t\t\telse\n\t\t\t\t\tbmsr &= ~BMSR_LSTATUS;\n\t\t\t}\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\t\t}\n\t}\n\n\tif (bmsr & BMSR_LSTATUS) {\n\t\tcurrent_speed = SPEED_1000;\n\t\tcurrent_link_up = true;\n\t\tif (bmcr & BMCR_FULLDPLX)\n\t\t\tcurrent_duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tcurrent_duplex = DUPLEX_HALF;\n\n\t\tlocal_adv = 0;\n\t\tremote_adv = 0;\n\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tu32 common;\n\n\t\t\terr |= tg3_readphy(tp, MII_ADVERTISE, &local_adv);\n\t\t\terr |= tg3_readphy(tp, MII_LPA, &remote_adv);\n\t\t\tcommon = local_adv & remote_adv;\n\t\t\tif (common & (ADVERTISE_1000XHALF |\n\t\t\t\t      ADVERTISE_1000XFULL)) {\n\t\t\t\tif (common & ADVERTISE_1000XFULL)\n\t\t\t\t\tcurrent_duplex = DUPLEX_FULL;\n\t\t\t\telse\n\t\t\t\t\tcurrent_duplex = DUPLEX_HALF;\n\n\t\t\t\ttp->link_config.rmt_adv =\n\t\t\t\t\t   mii_adv_to_ethtool_adv_x(remote_adv);\n\t\t\t} else if (!tg3_flag(tp, 5780_CLASS)) {\n\t\t\t\t/* Link is up via parallel detect */\n\t\t\t} else {\n\t\t\t\tcurrent_link_up = false;\n\t\t\t}\n\t\t}\n\t}\n\nfiber_setup_done:\n\tif (current_link_up && current_duplex == DUPLEX_FULL)\n\t\ttg3_setup_flow_control(tp, local_adv, remote_adv);\n\n\ttp->mac_mode &= ~MAC_MODE_HALF_DUPLEX;\n\tif (tp->link_config.active_duplex == DUPLEX_HALF)\n\t\ttp->mac_mode |= MAC_MODE_HALF_DUPLEX;\n\n\ttw32_f(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n\n\ttw32_f(MAC_EVENT, MAC_EVENT_LNKSTATE_CHANGED);\n\n\ttp->link_config.active_speed = current_speed;\n\ttp->link_config.active_duplex = current_duplex;\n\n\ttg3_test_and_report_link_chg(tp, current_link_up);\n\treturn err;\n}\n\nstatic void tg3_serdes_parallel_detect(struct tg3 *tp)\n{\n\tif (tp->serdes_counter) {\n\t\t/* Give autoneg time to complete. */\n\t\ttp->serdes_counter--;\n\t\treturn;\n\t}\n\n\tif (!tp->link_up &&\n\t    (tp->link_config.autoneg == AUTONEG_ENABLE)) {\n\t\tu32 bmcr;\n\n\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tu32 phy1, phy2;\n\n\t\t\t/* Select shadow register 0x1f */\n\t\t\ttg3_writephy(tp, MII_TG3_MISC_SHDW, 0x7c00);\n\t\t\ttg3_readphy(tp, MII_TG3_MISC_SHDW, &phy1);\n\n\t\t\t/* Select expansion interrupt status register */\n\t\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t\t\t MII_TG3_DSP_EXP1_INT_STAT);\n\t\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\t\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\n\t\t\tif ((phy1 & 0x10) && !(phy2 & 0x20)) {\n\t\t\t\t/* We have signal detect and not receiving\n\t\t\t\t * config code words, link is up by parallel\n\t\t\t\t * detection.\n\t\t\t\t */\n\n\t\t\t\tbmcr &= ~BMCR_ANENABLE;\n\t\t\t\tbmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;\n\t\t\t\ttg3_writephy(tp, MII_BMCR, bmcr);\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_PARALLEL_DETECT;\n\t\t\t}\n\t\t}\n\t} else if (tp->link_up &&\n\t\t   (tp->link_config.autoneg == AUTONEG_ENABLE) &&\n\t\t   (tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT)) {\n\t\tu32 phy2;\n\n\t\t/* Select expansion interrupt status register */\n\t\ttg3_writephy(tp, MII_TG3_DSP_ADDRESS,\n\t\t\t\t MII_TG3_DSP_EXP1_INT_STAT);\n\t\ttg3_readphy(tp, MII_TG3_DSP_RW_PORT, &phy2);\n\t\tif (phy2 & 0x20) {\n\t\t\tu32 bmcr;\n\n\t\t\t/* Config code words received, turn on autoneg. */\n\t\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\t\ttg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANENABLE);\n\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\n\t\t}\n\t}\n}\n\nstatic int tg3_setup_phy(struct tg3 *tp, bool force_reset)\n{\n\tu32 val;\n\tint err;\n\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\n\t\terr = tg3_setup_fiber_phy(tp, force_reset);\n\telse if (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\n\t\terr = tg3_setup_fiber_mii_phy(tp, force_reset);\n\telse\n\t\terr = tg3_setup_copper_phy(tp, force_reset);\n\n\tif (tg3_chip_rev(tp) == CHIPREV_5784_AX) {\n\t\tu32 scale;\n\n\t\tval = tr32(TG3_CPMU_CLCK_STAT) & CPMU_CLCK_STAT_MAC_CLCK_MASK;\n\t\tif (val == CPMU_CLCK_STAT_MAC_CLCK_62_5)\n\t\t\tscale = 65;\n\t\telse if (val == CPMU_CLCK_STAT_MAC_CLCK_6_25)\n\t\t\tscale = 6;\n\t\telse\n\t\t\tscale = 12;\n\n\t\tval = tr32(GRC_MISC_CFG) & ~GRC_MISC_CFG_PRESCALAR_MASK;\n\t\tval |= (scale << GRC_MISC_CFG_PRESCALAR_SHIFT);\n\t\ttw32(GRC_MISC_CFG, val);\n\t}\n\n\tval = (2 << TX_LENGTHS_IPG_CRS_SHIFT) |\n\t      (6 << TX_LENGTHS_IPG_SHIFT);\n\tif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\tval |= tr32(MAC_TX_LENGTHS) &\n\t\t       (TX_LENGTHS_JMB_FRM_LEN_MSK |\n\t\t\tTX_LENGTHS_CNT_DWN_VAL_MSK);\n\n\tif (tp->link_config.active_speed == SPEED_1000 &&\n\t    tp->link_config.active_duplex == DUPLEX_HALF)\n\t\ttw32(MAC_TX_LENGTHS, val |\n\t\t     (0xff << TX_LENGTHS_SLOT_TIME_SHIFT));\n\telse\n\t\ttw32(MAC_TX_LENGTHS, val |\n\t\t     (32 << TX_LENGTHS_SLOT_TIME_SHIFT));\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\tif (tp->link_up) {\n\t\t\ttw32(HOSTCC_STAT_COAL_TICKS,\n\t\t\t     tp->coal.stats_block_coalesce_usecs);\n\t\t} else {\n\t\t\ttw32(HOSTCC_STAT_COAL_TICKS, 0);\n\t\t}\n\t}\n\n\tif (tg3_flag(tp, ASPM_WORKAROUND)) {\n\t\tval = tr32(PCIE_PWR_MGMT_THRESH);\n\t\tif (!tp->link_up)\n\t\t\tval = (val & ~PCIE_PWR_MGMT_L1_THRESH_MSK) |\n\t\t\t      tp->pwrmgmt_thresh;\n\t\telse\n\t\t\tval |= PCIE_PWR_MGMT_L1_THRESH_MSK;\n\t\ttw32(PCIE_PWR_MGMT_THRESH, val);\n\t}\n\n\treturn err;\n}\n\n/* tp->lock must be held */\nstatic u64 tg3_refclk_read(struct tg3 *tp, struct ptp_system_timestamp *sts)\n{\n\tu64 stamp;\n\n\tptp_read_system_prets(sts);\n\tstamp = tr32(TG3_EAV_REF_CLCK_LSB);\n\tptp_read_system_postts(sts);\n\tstamp |= (u64)tr32(TG3_EAV_REF_CLCK_MSB) << 32;\n\n\treturn stamp;\n}\n\n/* tp->lock must be held */\nstatic void tg3_refclk_write(struct tg3 *tp, u64 newval)\n{\n\tu32 clock_ctl = tr32(TG3_EAV_REF_CLCK_CTL);\n\n\ttw32(TG3_EAV_REF_CLCK_CTL, clock_ctl | TG3_EAV_REF_CLCK_CTL_STOP);\n\ttw32(TG3_EAV_REF_CLCK_LSB, newval & 0xffffffff);\n\ttw32(TG3_EAV_REF_CLCK_MSB, newval >> 32);\n\ttw32_f(TG3_EAV_REF_CLCK_CTL, clock_ctl | TG3_EAV_REF_CLCK_CTL_RESUME);\n}\n\nstatic inline void tg3_full_lock(struct tg3 *tp, int irq_sync);\nstatic inline void tg3_full_unlock(struct tg3 *tp);\nstatic int tg3_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\n\tif (tg3_flag(tp, PTP_CAPABLE)) {\n\t\tinfo->so_timestamping |= SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\t}\n\n\tif (tp->ptp_clock)\n\t\tinfo->phc_index = ptp_clock_index(tp->ptp_clock);\n\telse\n\t\tinfo->phc_index = -1;\n\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\n\treturn 0;\n}\n\nstatic int tg3_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\n{\n\tstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\n\tbool neg_adj = false;\n\tu32 correction = 0;\n\n\tif (ppb < 0) {\n\t\tneg_adj = true;\n\t\tppb = -ppb;\n\t}\n\n\t/* Frequency adjustment is performed using hardware with a 24 bit\n\t * accumulator and a programmable correction value. On each clk, the\n\t * correction value gets added to the accumulator and when it\n\t * overflows, the time counter is incremented/decremented.\n\t *\n\t * So conversion from ppb to correction value is\n\t *\t\tppb * (1 << 24) / 1000000000\n\t */\n\tcorrection = div_u64((u64)ppb * (1 << 24), 1000000000ULL) &\n\t\t     TG3_EAV_REF_CLK_CORRECT_MASK;\n\n\ttg3_full_lock(tp, 0);\n\n\tif (correction)\n\t\ttw32(TG3_EAV_REF_CLK_CORRECT_CTL,\n\t\t     TG3_EAV_REF_CLK_CORRECT_EN |\n\t\t     (neg_adj ? TG3_EAV_REF_CLK_CORRECT_NEG : 0) | correction);\n\telse\n\t\ttw32(TG3_EAV_REF_CLK_CORRECT_CTL, 0);\n\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n\nstatic int tg3_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\n\n\ttg3_full_lock(tp, 0);\n\ttp->ptp_adjust += delta;\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n\nstatic int tg3_ptp_gettimex(struct ptp_clock_info *ptp, struct timespec64 *ts,\n\t\t\t    struct ptp_system_timestamp *sts)\n{\n\tu64 ns;\n\tstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\n\n\ttg3_full_lock(tp, 0);\n\tns = tg3_refclk_read(tp, sts);\n\tns += tp->ptp_adjust;\n\ttg3_full_unlock(tp);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int tg3_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\tu64 ns;\n\tstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\n\n\tns = timespec64_to_ns(ts);\n\n\ttg3_full_lock(tp, 0);\n\ttg3_refclk_write(tp, ns);\n\ttp->ptp_adjust = 0;\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n\nstatic int tg3_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\tstruct tg3 *tp = container_of(ptp, struct tg3, ptp_info);\n\tu32 clock_ctl;\n\tint rval = 0;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t/* Reject requests with unsupported flags */\n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (rq->perout.index != 0)\n\t\t\treturn -EINVAL;\n\n\t\ttg3_full_lock(tp, 0);\n\t\tclock_ctl = tr32(TG3_EAV_REF_CLCK_CTL);\n\t\tclock_ctl &= ~TG3_EAV_CTL_TSYNC_GPIO_MASK;\n\n\t\tif (on) {\n\t\t\tu64 nsec;\n\n\t\t\tnsec = rq->perout.start.sec * 1000000000ULL +\n\t\t\t       rq->perout.start.nsec;\n\n\t\t\tif (rq->perout.period.sec || rq->perout.period.nsec) {\n\t\t\t\tnetdev_warn(tp->dev,\n\t\t\t\t\t    \"Device supports only a one-shot timesync output, period must be 0\\n\");\n\t\t\t\trval = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif (nsec & (1ULL << 63)) {\n\t\t\t\tnetdev_warn(tp->dev,\n\t\t\t\t\t    \"Start value (nsec) is over limit. Maximum size of start is only 63 bits\\n\");\n\t\t\t\trval = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\ttw32(TG3_EAV_WATCHDOG0_LSB, (nsec & 0xffffffff));\n\t\t\ttw32(TG3_EAV_WATCHDOG0_MSB,\n\t\t\t     TG3_EAV_WATCHDOG0_EN |\n\t\t\t     ((nsec >> 32) & TG3_EAV_WATCHDOG_MSB_MASK));\n\n\t\t\ttw32(TG3_EAV_REF_CLCK_CTL,\n\t\t\t     clock_ctl | TG3_EAV_CTL_TSYNC_WDOG0);\n\t\t} else {\n\t\t\ttw32(TG3_EAV_WATCHDOG0_MSB, 0);\n\t\t\ttw32(TG3_EAV_REF_CLCK_CTL, clock_ctl);\n\t\t}\n\nerr_out:\n\t\ttg3_full_unlock(tp);\n\t\treturn rval;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info tg3_ptp_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"tg3 clock\",\n\t.max_adj\t= 250000000,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 1,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfreq\t= tg3_ptp_adjfreq,\n\t.adjtime\t= tg3_ptp_adjtime,\n\t.gettimex64\t= tg3_ptp_gettimex,\n\t.settime64\t= tg3_ptp_settime,\n\t.enable\t\t= tg3_ptp_enable,\n};\n\nstatic void tg3_hwclock_to_timestamp(struct tg3 *tp, u64 hwclock,\n\t\t\t\t     struct skb_shared_hwtstamps *timestamp)\n{\n\tmemset(timestamp, 0, sizeof(struct skb_shared_hwtstamps));\n\ttimestamp->hwtstamp  = ns_to_ktime((hwclock & TG3_TSTAMP_MASK) +\n\t\t\t\t\t   tp->ptp_adjust);\n}\n\n/* tp->lock must be held */\nstatic void tg3_ptp_init(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn;\n\n\t/* Initialize the hardware clock to the system time. */\n\ttg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));\n\ttp->ptp_adjust = 0;\n\ttp->ptp_info = tg3_ptp_caps;\n}\n\n/* tp->lock must be held */\nstatic void tg3_ptp_resume(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn;\n\n\ttg3_refclk_write(tp, ktime_to_ns(ktime_get_real()) + tp->ptp_adjust);\n\ttp->ptp_adjust = 0;\n}\n\nstatic void tg3_ptp_fini(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, PTP_CAPABLE) || !tp->ptp_clock)\n\t\treturn;\n\n\tptp_clock_unregister(tp->ptp_clock);\n\ttp->ptp_clock = NULL;\n\ttp->ptp_adjust = 0;\n}\n\nstatic inline int tg3_irq_sync(struct tg3 *tp)\n{\n\treturn tp->irq_sync;\n}\n\nstatic inline void tg3_rd32_loop(struct tg3 *tp, u32 *dst, u32 off, u32 len)\n{\n\tint i;\n\n\tdst = (u32 *)((u8 *)dst + off);\n\tfor (i = 0; i < len; i += sizeof(u32))\n\t\t*dst++ = tr32(off + i);\n}\n\nstatic void tg3_dump_legacy_regs(struct tg3 *tp, u32 *regs)\n{\n\ttg3_rd32_loop(tp, regs, TG3PCI_VENDOR, 0xb0);\n\ttg3_rd32_loop(tp, regs, MAILBOX_INTERRUPT_0, 0x200);\n\ttg3_rd32_loop(tp, regs, MAC_MODE, 0x4f0);\n\ttg3_rd32_loop(tp, regs, SNDDATAI_MODE, 0xe0);\n\ttg3_rd32_loop(tp, regs, SNDDATAC_MODE, 0x04);\n\ttg3_rd32_loop(tp, regs, SNDBDS_MODE, 0x80);\n\ttg3_rd32_loop(tp, regs, SNDBDI_MODE, 0x48);\n\ttg3_rd32_loop(tp, regs, SNDBDC_MODE, 0x04);\n\ttg3_rd32_loop(tp, regs, RCVLPC_MODE, 0x20);\n\ttg3_rd32_loop(tp, regs, RCVLPC_SELLST_BASE, 0x15c);\n\ttg3_rd32_loop(tp, regs, RCVDBDI_MODE, 0x0c);\n\ttg3_rd32_loop(tp, regs, RCVDBDI_JUMBO_BD, 0x3c);\n\ttg3_rd32_loop(tp, regs, RCVDBDI_BD_PROD_IDX_0, 0x44);\n\ttg3_rd32_loop(tp, regs, RCVDCC_MODE, 0x04);\n\ttg3_rd32_loop(tp, regs, RCVBDI_MODE, 0x20);\n\ttg3_rd32_loop(tp, regs, RCVCC_MODE, 0x14);\n\ttg3_rd32_loop(tp, regs, RCVLSC_MODE, 0x08);\n\ttg3_rd32_loop(tp, regs, MBFREE_MODE, 0x08);\n\ttg3_rd32_loop(tp, regs, HOSTCC_MODE, 0x100);\n\n\tif (tg3_flag(tp, SUPPORT_MSIX))\n\t\ttg3_rd32_loop(tp, regs, HOSTCC_RXCOL_TICKS_VEC1, 0x180);\n\n\ttg3_rd32_loop(tp, regs, MEMARB_MODE, 0x10);\n\ttg3_rd32_loop(tp, regs, BUFMGR_MODE, 0x58);\n\ttg3_rd32_loop(tp, regs, RDMAC_MODE, 0x08);\n\ttg3_rd32_loop(tp, regs, WDMAC_MODE, 0x08);\n\ttg3_rd32_loop(tp, regs, RX_CPU_MODE, 0x04);\n\ttg3_rd32_loop(tp, regs, RX_CPU_STATE, 0x04);\n\ttg3_rd32_loop(tp, regs, RX_CPU_PGMCTR, 0x04);\n\ttg3_rd32_loop(tp, regs, RX_CPU_HWBKPT, 0x04);\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\ttg3_rd32_loop(tp, regs, TX_CPU_MODE, 0x04);\n\t\ttg3_rd32_loop(tp, regs, TX_CPU_STATE, 0x04);\n\t\ttg3_rd32_loop(tp, regs, TX_CPU_PGMCTR, 0x04);\n\t}\n\n\ttg3_rd32_loop(tp, regs, GRCMBOX_INTERRUPT_0, 0x110);\n\ttg3_rd32_loop(tp, regs, FTQ_RESET, 0x120);\n\ttg3_rd32_loop(tp, regs, MSGINT_MODE, 0x0c);\n\ttg3_rd32_loop(tp, regs, DMAC_MODE, 0x04);\n\ttg3_rd32_loop(tp, regs, GRC_MODE, 0x4c);\n\n\tif (tg3_flag(tp, NVRAM))\n\t\ttg3_rd32_loop(tp, regs, NVRAM_CMD, 0x24);\n}\n\nstatic void tg3_dump_state(struct tg3 *tp)\n{\n\tint i;\n\tu32 *regs;\n\n\tregs = kzalloc(TG3_REG_BLK_SIZE, GFP_ATOMIC);\n\tif (!regs)\n\t\treturn;\n\n\tif (tg3_flag(tp, PCI_EXPRESS)) {\n\t\t/* Read up to but not including private PCI registers */\n\t\tfor (i = 0; i < TG3_PCIE_TLDLPL_PORT; i += sizeof(u32))\n\t\t\tregs[i / sizeof(u32)] = tr32(i);\n\t} else\n\t\ttg3_dump_legacy_regs(tp, regs);\n\n\tfor (i = 0; i < TG3_REG_BLK_SIZE / sizeof(u32); i += 4) {\n\t\tif (!regs[i + 0] && !regs[i + 1] &&\n\t\t    !regs[i + 2] && !regs[i + 3])\n\t\t\tcontinue;\n\n\t\tnetdev_err(tp->dev, \"0x%08x: 0x%08x, 0x%08x, 0x%08x, 0x%08x\\n\",\n\t\t\t   i * 4,\n\t\t\t   regs[i + 0], regs[i + 1], regs[i + 2], regs[i + 3]);\n\t}\n\n\tkfree(regs);\n\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\t/* SW status block */\n\t\tnetdev_err(tp->dev,\n\t\t\t \"%d: Host status block [%08x:%08x:(%04x:%04x:%04x):(%04x:%04x)]\\n\",\n\t\t\t   i,\n\t\t\t   tnapi->hw_status->status,\n\t\t\t   tnapi->hw_status->status_tag,\n\t\t\t   tnapi->hw_status->rx_jumbo_consumer,\n\t\t\t   tnapi->hw_status->rx_consumer,\n\t\t\t   tnapi->hw_status->rx_mini_consumer,\n\t\t\t   tnapi->hw_status->idx[0].rx_producer,\n\t\t\t   tnapi->hw_status->idx[0].tx_consumer);\n\n\t\tnetdev_err(tp->dev,\n\t\t\"%d: NAPI info [%08x:%08x:(%04x:%04x:%04x):%04x:(%04x:%04x:%04x:%04x)]\\n\",\n\t\t\t   i,\n\t\t\t   tnapi->last_tag, tnapi->last_irq_tag,\n\t\t\t   tnapi->tx_prod, tnapi->tx_cons, tnapi->tx_pending,\n\t\t\t   tnapi->rx_rcb_ptr,\n\t\t\t   tnapi->prodring.rx_std_prod_idx,\n\t\t\t   tnapi->prodring.rx_std_cons_idx,\n\t\t\t   tnapi->prodring.rx_jmb_prod_idx,\n\t\t\t   tnapi->prodring.rx_jmb_cons_idx);\n\t}\n}\n\n/* This is called whenever we suspect that the system chipset is re-\n * ordering the sequence of MMIO to the tx send mailbox. The symptom\n * is bogus tx completions. We try to recover by setting the\n * TG3_FLAG_MBOX_WRITE_REORDER flag and resetting the chip later\n * in the workqueue.\n */\nstatic void tg3_tx_recover(struct tg3 *tp)\n{\n\tBUG_ON(tg3_flag(tp, MBOX_WRITE_REORDER) ||\n\t       tp->write32_tx_mbox == tg3_write_indirect_mbox);\n\n\tnetdev_warn(tp->dev,\n\t\t    \"The system may be re-ordering memory-mapped I/O \"\n\t\t    \"cycles to the network device, attempting to recover. \"\n\t\t    \"Please report the problem to the driver maintainer \"\n\t\t    \"and include system chipset information.\\n\");\n\n\ttg3_flag_set(tp, TX_RECOVERY_PENDING);\n}\n\nstatic inline u32 tg3_tx_avail(struct tg3_napi *tnapi)\n{\n\t/* Tell compiler to fetch tx indices from memory. */\n\tbarrier();\n\treturn tnapi->tx_pending -\n\t       ((tnapi->tx_prod - tnapi->tx_cons) & (TG3_TX_RING_SIZE - 1));\n}\n\n/* Tigon3 never reports partial packet sends.  So we do not\n * need special logic to handle SKBs that have not had all\n * of their frags sent yet, like SunGEM does.\n */\nstatic void tg3_tx(struct tg3_napi *tnapi)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\tu32 hw_idx = tnapi->hw_status->idx[0].tx_consumer;\n\tu32 sw_idx = tnapi->tx_cons;\n\tstruct netdev_queue *txq;\n\tint index = tnapi - tp->napi;\n\tunsigned int pkts_compl = 0, bytes_compl = 0;\n\n\tif (tg3_flag(tp, ENABLE_TSS))\n\t\tindex--;\n\n\ttxq = netdev_get_tx_queue(tp->dev, index);\n\n\twhile (sw_idx != hw_idx) {\n\t\tstruct tg3_tx_ring_info *ri = &tnapi->tx_buffers[sw_idx];\n\t\tstruct sk_buff *skb = ri->skb;\n\t\tint i, tx_bug = 0;\n\n\t\tif (unlikely(skb == NULL)) {\n\t\t\ttg3_tx_recover(tp);\n\t\t\treturn;\n\t\t}\n\n\t\tif (tnapi->tx_ring[sw_idx].len_flags & TXD_FLAG_HWTSTAMP) {\n\t\t\tstruct skb_shared_hwtstamps timestamp;\n\t\t\tu64 hwclock = tr32(TG3_TX_TSTAMP_LSB);\n\t\t\thwclock |= (u64)tr32(TG3_TX_TSTAMP_MSB) << 32;\n\n\t\t\ttg3_hwclock_to_timestamp(tp, hwclock, &timestamp);\n\n\t\t\tskb_tstamp_tx(skb, &timestamp);\n\t\t}\n\n\t\tpci_unmap_single(tp->pdev,\n\t\t\t\t dma_unmap_addr(ri, mapping),\n\t\t\t\t skb_headlen(skb),\n\t\t\t\t PCI_DMA_TODEVICE);\n\n\t\tri->skb = NULL;\n\n\t\twhile (ri->fragmented) {\n\t\t\tri->fragmented = false;\n\t\t\tsw_idx = NEXT_TX(sw_idx);\n\t\t\tri = &tnapi->tx_buffers[sw_idx];\n\t\t}\n\n\t\tsw_idx = NEXT_TX(sw_idx);\n\n\t\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\t\tri = &tnapi->tx_buffers[sw_idx];\n\t\t\tif (unlikely(ri->skb != NULL || sw_idx == hw_idx))\n\t\t\t\ttx_bug = 1;\n\n\t\t\tpci_unmap_page(tp->pdev,\n\t\t\t\t       dma_unmap_addr(ri, mapping),\n\t\t\t\t       skb_frag_size(&skb_shinfo(skb)->frags[i]),\n\t\t\t\t       PCI_DMA_TODEVICE);\n\n\t\t\twhile (ri->fragmented) {\n\t\t\t\tri->fragmented = false;\n\t\t\t\tsw_idx = NEXT_TX(sw_idx);\n\t\t\t\tri = &tnapi->tx_buffers[sw_idx];\n\t\t\t}\n\n\t\t\tsw_idx = NEXT_TX(sw_idx);\n\t\t}\n\n\t\tpkts_compl++;\n\t\tbytes_compl += skb->len;\n\n\t\tdev_consume_skb_any(skb);\n\n\t\tif (unlikely(tx_bug)) {\n\t\t\ttg3_tx_recover(tp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tnetdev_tx_completed_queue(txq, pkts_compl, bytes_compl);\n\n\ttnapi->tx_cons = sw_idx;\n\n\t/* Need to make the tx_cons update visible to tg3_start_xmit()\n\t * before checking for netif_queue_stopped().  Without the\n\t * memory barrier, there is a small possibility that tg3_start_xmit()\n\t * will miss it and cause the queue to be stopped forever.\n\t */\n\tsmp_mb();\n\n\tif (unlikely(netif_tx_queue_stopped(txq) &&\n\t\t     (tg3_tx_avail(tnapi) > TG3_TX_WAKEUP_THRESH(tnapi)))) {\n\t\t__netif_tx_lock(txq, smp_processor_id());\n\t\tif (netif_tx_queue_stopped(txq) &&\n\t\t    (tg3_tx_avail(tnapi) > TG3_TX_WAKEUP_THRESH(tnapi)))\n\t\t\tnetif_tx_wake_queue(txq);\n\t\t__netif_tx_unlock(txq);\n\t}\n}\n\nstatic void tg3_frag_free(bool is_frag, void *data)\n{\n\tif (is_frag)\n\t\tskb_free_frag(data);\n\telse\n\t\tkfree(data);\n}\n\nstatic void tg3_rx_data_free(struct tg3 *tp, struct ring_info *ri, u32 map_sz)\n{\n\tunsigned int skb_size = SKB_DATA_ALIGN(map_sz + TG3_RX_OFFSET(tp)) +\n\t\t   SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\n\tif (!ri->data)\n\t\treturn;\n\n\tpci_unmap_single(tp->pdev, dma_unmap_addr(ri, mapping),\n\t\t\t map_sz, PCI_DMA_FROMDEVICE);\n\ttg3_frag_free(skb_size <= PAGE_SIZE, ri->data);\n\tri->data = NULL;\n}\n\n\n/* Returns size of skb allocated or < 0 on error.\n *\n * We only need to fill in the address because the other members\n * of the RX descriptor are invariant, see tg3_init_rings.\n *\n * Note the purposeful assymetry of cpu vs. chip accesses.  For\n * posting buffers we only dirty the first cache line of the RX\n * descriptor (containing the address).  Whereas for the RX status\n * buffers the cpu only reads the last cacheline of the RX descriptor\n * (to fetch the error flags, vlan tag, checksum, and opaque cookie).\n */\nstatic int tg3_alloc_rx_data(struct tg3 *tp, struct tg3_rx_prodring_set *tpr,\n\t\t\t     u32 opaque_key, u32 dest_idx_unmasked,\n\t\t\t     unsigned int *frag_size)\n{\n\tstruct tg3_rx_buffer_desc *desc;\n\tstruct ring_info *map;\n\tu8 *data;\n\tdma_addr_t mapping;\n\tint skb_size, data_size, dest_idx;\n\n\tswitch (opaque_key) {\n\tcase RXD_OPAQUE_RING_STD:\n\t\tdest_idx = dest_idx_unmasked & tp->rx_std_ring_mask;\n\t\tdesc = &tpr->rx_std[dest_idx];\n\t\tmap = &tpr->rx_std_buffers[dest_idx];\n\t\tdata_size = tp->rx_pkt_map_sz;\n\t\tbreak;\n\n\tcase RXD_OPAQUE_RING_JUMBO:\n\t\tdest_idx = dest_idx_unmasked & tp->rx_jmb_ring_mask;\n\t\tdesc = &tpr->rx_jmb[dest_idx].std;\n\t\tmap = &tpr->rx_jmb_buffers[dest_idx];\n\t\tdata_size = TG3_RX_JMB_MAP_SZ;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* Do not overwrite any of the map or rp information\n\t * until we are sure we can commit to a new buffer.\n\t *\n\t * Callers depend upon this behavior and assume that\n\t * we leave everything unchanged if we fail.\n\t */\n\tskb_size = SKB_DATA_ALIGN(data_size + TG3_RX_OFFSET(tp)) +\n\t\t   SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\tif (skb_size <= PAGE_SIZE) {\n\t\tdata = napi_alloc_frag(skb_size);\n\t\t*frag_size = skb_size;\n\t} else {\n\t\tdata = kmalloc(skb_size, GFP_ATOMIC);\n\t\t*frag_size = 0;\n\t}\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmapping = pci_map_single(tp->pdev,\n\t\t\t\t data + TG3_RX_OFFSET(tp),\n\t\t\t\t data_size,\n\t\t\t\t PCI_DMA_FROMDEVICE);\n\tif (unlikely(pci_dma_mapping_error(tp->pdev, mapping))) {\n\t\ttg3_frag_free(skb_size <= PAGE_SIZE, data);\n\t\treturn -EIO;\n\t}\n\n\tmap->data = data;\n\tdma_unmap_addr_set(map, mapping, mapping);\n\n\tdesc->addr_hi = ((u64)mapping >> 32);\n\tdesc->addr_lo = ((u64)mapping & 0xffffffff);\n\n\treturn data_size;\n}\n\n/* We only need to move over in the address because the other\n * members of the RX descriptor are invariant.  See notes above\n * tg3_alloc_rx_data for full details.\n */\nstatic void tg3_recycle_rx(struct tg3_napi *tnapi,\n\t\t\t   struct tg3_rx_prodring_set *dpr,\n\t\t\t   u32 opaque_key, int src_idx,\n\t\t\t   u32 dest_idx_unmasked)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\tstruct tg3_rx_buffer_desc *src_desc, *dest_desc;\n\tstruct ring_info *src_map, *dest_map;\n\tstruct tg3_rx_prodring_set *spr = &tp->napi[0].prodring;\n\tint dest_idx;\n\n\tswitch (opaque_key) {\n\tcase RXD_OPAQUE_RING_STD:\n\t\tdest_idx = dest_idx_unmasked & tp->rx_std_ring_mask;\n\t\tdest_desc = &dpr->rx_std[dest_idx];\n\t\tdest_map = &dpr->rx_std_buffers[dest_idx];\n\t\tsrc_desc = &spr->rx_std[src_idx];\n\t\tsrc_map = &spr->rx_std_buffers[src_idx];\n\t\tbreak;\n\n\tcase RXD_OPAQUE_RING_JUMBO:\n\t\tdest_idx = dest_idx_unmasked & tp->rx_jmb_ring_mask;\n\t\tdest_desc = &dpr->rx_jmb[dest_idx].std;\n\t\tdest_map = &dpr->rx_jmb_buffers[dest_idx];\n\t\tsrc_desc = &spr->rx_jmb[src_idx].std;\n\t\tsrc_map = &spr->rx_jmb_buffers[src_idx];\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tdest_map->data = src_map->data;\n\tdma_unmap_addr_set(dest_map, mapping,\n\t\t\t   dma_unmap_addr(src_map, mapping));\n\tdest_desc->addr_hi = src_desc->addr_hi;\n\tdest_desc->addr_lo = src_desc->addr_lo;\n\n\t/* Ensure that the update to the skb happens after the physical\n\t * addresses have been transferred to the new BD location.\n\t */\n\tsmp_wmb();\n\n\tsrc_map->data = NULL;\n}\n\n/* The RX ring scheme is composed of multiple rings which post fresh\n * buffers to the chip, and one special ring the chip uses to report\n * status back to the host.\n *\n * The special ring reports the status of received packets to the\n * host.  The chip does not write into the original descriptor the\n * RX buffer was obtained from.  The chip simply takes the original\n * descriptor as provided by the host, updates the status and length\n * field, then writes this into the next status ring entry.\n *\n * Each ring the host uses to post buffers to the chip is described\n * by a TG3_BDINFO entry in the chips SRAM area.  When a packet arrives,\n * it is first placed into the on-chip ram.  When the packet's length\n * is known, it walks down the TG3_BDINFO entries to select the ring.\n * Each TG3_BDINFO specifies a MAXLEN field and the first TG3_BDINFO\n * which is within the range of the new packet's length is chosen.\n *\n * The \"separate ring for rx status\" scheme may sound queer, but it makes\n * sense from a cache coherency perspective.  If only the host writes\n * to the buffer post rings, and only the chip writes to the rx status\n * rings, then cache lines never move beyond shared-modified state.\n * If both the host and chip were to write into the same ring, cache line\n * eviction could occur since both entities want it in an exclusive state.\n */\nstatic int tg3_rx(struct tg3_napi *tnapi, int budget)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\tu32 work_mask, rx_std_posted = 0;\n\tu32 std_prod_idx, jmb_prod_idx;\n\tu32 sw_idx = tnapi->rx_rcb_ptr;\n\tu16 hw_idx;\n\tint received;\n\tstruct tg3_rx_prodring_set *tpr = &tnapi->prodring;\n\n\thw_idx = *(tnapi->rx_rcb_prod_idx);\n\t/*\n\t * We need to order the read of hw_idx and the read of\n\t * the opaque cookie.\n\t */\n\trmb();\n\twork_mask = 0;\n\treceived = 0;\n\tstd_prod_idx = tpr->rx_std_prod_idx;\n\tjmb_prod_idx = tpr->rx_jmb_prod_idx;\n\twhile (sw_idx != hw_idx && budget > 0) {\n\t\tstruct ring_info *ri;\n\t\tstruct tg3_rx_buffer_desc *desc = &tnapi->rx_rcb[sw_idx];\n\t\tunsigned int len;\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t dma_addr;\n\t\tu32 opaque_key, desc_idx, *post_ptr;\n\t\tu8 *data;\n\t\tu64 tstamp = 0;\n\n\t\tdesc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;\n\t\topaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;\n\t\tif (opaque_key == RXD_OPAQUE_RING_STD) {\n\t\t\tri = &tp->napi[0].prodring.rx_std_buffers[desc_idx];\n\t\t\tdma_addr = dma_unmap_addr(ri, mapping);\n\t\t\tdata = ri->data;\n\t\t\tpost_ptr = &std_prod_idx;\n\t\t\trx_std_posted++;\n\t\t} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {\n\t\t\tri = &tp->napi[0].prodring.rx_jmb_buffers[desc_idx];\n\t\t\tdma_addr = dma_unmap_addr(ri, mapping);\n\t\t\tdata = ri->data;\n\t\t\tpost_ptr = &jmb_prod_idx;\n\t\t} else\n\t\t\tgoto next_pkt_nopost;\n\n\t\twork_mask |= opaque_key;\n\n\t\tif (desc->err_vlan & RXD_ERR_MASK) {\n\t\tdrop_it:\n\t\t\ttg3_recycle_rx(tnapi, tpr, opaque_key,\n\t\t\t\t       desc_idx, *post_ptr);\n\t\tdrop_it_no_recycle:\n\t\t\t/* Other statistics kept track of by card. */\n\t\t\ttp->rx_dropped++;\n\t\t\tgoto next_pkt;\n\t\t}\n\n\t\tprefetch(data + TG3_RX_OFFSET(tp));\n\t\tlen = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT) -\n\t\t      ETH_FCS_LEN;\n\n\t\tif ((desc->type_flags & RXD_FLAG_PTPSTAT_MASK) ==\n\t\t     RXD_FLAG_PTPSTAT_PTPV1 ||\n\t\t    (desc->type_flags & RXD_FLAG_PTPSTAT_MASK) ==\n\t\t     RXD_FLAG_PTPSTAT_PTPV2) {\n\t\t\ttstamp = tr32(TG3_RX_TSTAMP_LSB);\n\t\t\ttstamp |= (u64)tr32(TG3_RX_TSTAMP_MSB) << 32;\n\t\t}\n\n\t\tif (len > TG3_RX_COPY_THRESH(tp)) {\n\t\t\tint skb_size;\n\t\t\tunsigned int frag_size;\n\n\t\t\tskb_size = tg3_alloc_rx_data(tp, tpr, opaque_key,\n\t\t\t\t\t\t    *post_ptr, &frag_size);\n\t\t\tif (skb_size < 0)\n\t\t\t\tgoto drop_it;\n\n\t\t\tpci_unmap_single(tp->pdev, dma_addr, skb_size,\n\t\t\t\t\t PCI_DMA_FROMDEVICE);\n\n\t\t\t/* Ensure that the update to the data happens\n\t\t\t * after the usage of the old DMA mapping.\n\t\t\t */\n\t\t\tsmp_wmb();\n\n\t\t\tri->data = NULL;\n\n\t\t\tskb = build_skb(data, frag_size);\n\t\t\tif (!skb) {\n\t\t\t\ttg3_frag_free(frag_size != 0, data);\n\t\t\t\tgoto drop_it_no_recycle;\n\t\t\t}\n\t\t\tskb_reserve(skb, TG3_RX_OFFSET(tp));\n\t\t} else {\n\t\t\ttg3_recycle_rx(tnapi, tpr, opaque_key,\n\t\t\t\t       desc_idx, *post_ptr);\n\n\t\t\tskb = netdev_alloc_skb(tp->dev,\n\t\t\t\t\t       len + TG3_RAW_IP_ALIGN);\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto drop_it_no_recycle;\n\n\t\t\tskb_reserve(skb, TG3_RAW_IP_ALIGN);\n\t\t\tpci_dma_sync_single_for_cpu(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);\n\t\t\tmemcpy(skb->data,\n\t\t\t       data + TG3_RX_OFFSET(tp),\n\t\t\t       len);\n\t\t\tpci_dma_sync_single_for_device(tp->pdev, dma_addr, len, PCI_DMA_FROMDEVICE);\n\t\t}\n\n\t\tskb_put(skb, len);\n\t\tif (tstamp)\n\t\t\ttg3_hwclock_to_timestamp(tp, tstamp,\n\t\t\t\t\t\t skb_hwtstamps(skb));\n\n\t\tif ((tp->dev->features & NETIF_F_RXCSUM) &&\n\t\t    (desc->type_flags & RXD_FLAG_TCPUDP_CSUM) &&\n\t\t    (((desc->ip_tcp_csum & RXD_TCPCSUM_MASK)\n\t\t      >> RXD_TCPCSUM_SHIFT) == 0xffff))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\telse\n\t\t\tskb_checksum_none_assert(skb);\n\n\t\tskb->protocol = eth_type_trans(skb, tp->dev);\n\n\t\tif (len > (tp->dev->mtu + ETH_HLEN) &&\n\t\t    skb->protocol != htons(ETH_P_8021Q) &&\n\t\t    skb->protocol != htons(ETH_P_8021AD)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto drop_it_no_recycle;\n\t\t}\n\n\t\tif (desc->type_flags & RXD_FLAG_VLAN &&\n\t\t    !(tp->rx_mode & RX_MODE_KEEP_VLAN_TAG))\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       desc->err_vlan & RXD_VLAN_MASK);\n\n\t\tnapi_gro_receive(&tnapi->napi, skb);\n\n\t\treceived++;\n\t\tbudget--;\n\nnext_pkt:\n\t\t(*post_ptr)++;\n\n\t\tif (unlikely(rx_std_posted >= tp->rx_std_max_post)) {\n\t\t\ttpr->rx_std_prod_idx = std_prod_idx &\n\t\t\t\t\t       tp->rx_std_ring_mask;\n\t\t\ttw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG,\n\t\t\t\t     tpr->rx_std_prod_idx);\n\t\t\twork_mask &= ~RXD_OPAQUE_RING_STD;\n\t\t\trx_std_posted = 0;\n\t\t}\nnext_pkt_nopost:\n\t\tsw_idx++;\n\t\tsw_idx &= tp->rx_ret_ring_mask;\n\n\t\t/* Refresh hw_idx to see if there is new work */\n\t\tif (sw_idx == hw_idx) {\n\t\t\thw_idx = *(tnapi->rx_rcb_prod_idx);\n\t\t\trmb();\n\t\t}\n\t}\n\n\t/* ACK the status ring. */\n\ttnapi->rx_rcb_ptr = sw_idx;\n\ttw32_rx_mbox(tnapi->consmbox, sw_idx);\n\n\t/* Refill RX ring(s). */\n\tif (!tg3_flag(tp, ENABLE_RSS)) {\n\t\t/* Sync BD data before updating mailbox */\n\t\twmb();\n\n\t\tif (work_mask & RXD_OPAQUE_RING_STD) {\n\t\t\ttpr->rx_std_prod_idx = std_prod_idx &\n\t\t\t\t\t       tp->rx_std_ring_mask;\n\t\t\ttw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG,\n\t\t\t\t     tpr->rx_std_prod_idx);\n\t\t}\n\t\tif (work_mask & RXD_OPAQUE_RING_JUMBO) {\n\t\t\ttpr->rx_jmb_prod_idx = jmb_prod_idx &\n\t\t\t\t\t       tp->rx_jmb_ring_mask;\n\t\t\ttw32_rx_mbox(TG3_RX_JMB_PROD_IDX_REG,\n\t\t\t\t     tpr->rx_jmb_prod_idx);\n\t\t}\n\t} else if (work_mask) {\n\t\t/* rx_std_buffers[] and rx_jmb_buffers[] entries must be\n\t\t * updated before the producer indices can be updated.\n\t\t */\n\t\tsmp_wmb();\n\n\t\ttpr->rx_std_prod_idx = std_prod_idx & tp->rx_std_ring_mask;\n\t\ttpr->rx_jmb_prod_idx = jmb_prod_idx & tp->rx_jmb_ring_mask;\n\n\t\tif (tnapi != &tp->napi[1]) {\n\t\t\ttp->rx_refill = true;\n\t\t\tnapi_schedule(&tp->napi[1].napi);\n\t\t}\n\t}\n\n\treturn received;\n}\n\nstatic void tg3_poll_link(struct tg3 *tp)\n{\n\t/* handle link change and other phy events */\n\tif (!(tg3_flag(tp, USE_LINKCHG_REG) || tg3_flag(tp, POLL_SERDES))) {\n\t\tstruct tg3_hw_status *sblk = tp->napi[0].hw_status;\n\n\t\tif (sblk->status & SD_STATUS_LINK_CHG) {\n\t\t\tsblk->status = SD_STATUS_UPDATED |\n\t\t\t\t       (sblk->status & ~SD_STATUS_LINK_CHG);\n\t\t\tspin_lock(&tp->lock);\n\t\t\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\t\t\ttw32_f(MAC_STATUS,\n\t\t\t\t     (MAC_STATUS_SYNC_CHANGED |\n\t\t\t\t      MAC_STATUS_CFG_CHANGED |\n\t\t\t\t      MAC_STATUS_MI_COMPLETION |\n\t\t\t\t      MAC_STATUS_LNKSTATE_CHANGED));\n\t\t\t\tudelay(40);\n\t\t\t} else\n\t\t\t\ttg3_setup_phy(tp, false);\n\t\t\tspin_unlock(&tp->lock);\n\t\t}\n\t}\n}\n\nstatic int tg3_rx_prodring_xfer(struct tg3 *tp,\n\t\t\t\tstruct tg3_rx_prodring_set *dpr,\n\t\t\t\tstruct tg3_rx_prodring_set *spr)\n{\n\tu32 si, di, cpycnt, src_prod_idx;\n\tint i, err = 0;\n\n\twhile (1) {\n\t\tsrc_prod_idx = spr->rx_std_prod_idx;\n\n\t\t/* Make sure updates to the rx_std_buffers[] entries and the\n\t\t * standard producer index are seen in the correct order.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tif (spr->rx_std_cons_idx == src_prod_idx)\n\t\t\tbreak;\n\n\t\tif (spr->rx_std_cons_idx < src_prod_idx)\n\t\t\tcpycnt = src_prod_idx - spr->rx_std_cons_idx;\n\t\telse\n\t\t\tcpycnt = tp->rx_std_ring_mask + 1 -\n\t\t\t\t spr->rx_std_cons_idx;\n\n\t\tcpycnt = min(cpycnt,\n\t\t\t     tp->rx_std_ring_mask + 1 - dpr->rx_std_prod_idx);\n\n\t\tsi = spr->rx_std_cons_idx;\n\t\tdi = dpr->rx_std_prod_idx;\n\n\t\tfor (i = di; i < di + cpycnt; i++) {\n\t\t\tif (dpr->rx_std_buffers[i].data) {\n\t\t\t\tcpycnt = i - di;\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cpycnt)\n\t\t\tbreak;\n\n\t\t/* Ensure that updates to the rx_std_buffers ring and the\n\t\t * shadowed hardware producer ring from tg3_recycle_skb() are\n\t\t * ordered correctly WRT the skb check above.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tmemcpy(&dpr->rx_std_buffers[di],\n\t\t       &spr->rx_std_buffers[si],\n\t\t       cpycnt * sizeof(struct ring_info));\n\n\t\tfor (i = 0; i < cpycnt; i++, di++, si++) {\n\t\t\tstruct tg3_rx_buffer_desc *sbd, *dbd;\n\t\t\tsbd = &spr->rx_std[si];\n\t\t\tdbd = &dpr->rx_std[di];\n\t\t\tdbd->addr_hi = sbd->addr_hi;\n\t\t\tdbd->addr_lo = sbd->addr_lo;\n\t\t}\n\n\t\tspr->rx_std_cons_idx = (spr->rx_std_cons_idx + cpycnt) &\n\t\t\t\t       tp->rx_std_ring_mask;\n\t\tdpr->rx_std_prod_idx = (dpr->rx_std_prod_idx + cpycnt) &\n\t\t\t\t       tp->rx_std_ring_mask;\n\t}\n\n\twhile (1) {\n\t\tsrc_prod_idx = spr->rx_jmb_prod_idx;\n\n\t\t/* Make sure updates to the rx_jmb_buffers[] entries and\n\t\t * the jumbo producer index are seen in the correct order.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tif (spr->rx_jmb_cons_idx == src_prod_idx)\n\t\t\tbreak;\n\n\t\tif (spr->rx_jmb_cons_idx < src_prod_idx)\n\t\t\tcpycnt = src_prod_idx - spr->rx_jmb_cons_idx;\n\t\telse\n\t\t\tcpycnt = tp->rx_jmb_ring_mask + 1 -\n\t\t\t\t spr->rx_jmb_cons_idx;\n\n\t\tcpycnt = min(cpycnt,\n\t\t\t     tp->rx_jmb_ring_mask + 1 - dpr->rx_jmb_prod_idx);\n\n\t\tsi = spr->rx_jmb_cons_idx;\n\t\tdi = dpr->rx_jmb_prod_idx;\n\n\t\tfor (i = di; i < di + cpycnt; i++) {\n\t\t\tif (dpr->rx_jmb_buffers[i].data) {\n\t\t\t\tcpycnt = i - di;\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!cpycnt)\n\t\t\tbreak;\n\n\t\t/* Ensure that updates to the rx_jmb_buffers ring and the\n\t\t * shadowed hardware producer ring from tg3_recycle_skb() are\n\t\t * ordered correctly WRT the skb check above.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tmemcpy(&dpr->rx_jmb_buffers[di],\n\t\t       &spr->rx_jmb_buffers[si],\n\t\t       cpycnt * sizeof(struct ring_info));\n\n\t\tfor (i = 0; i < cpycnt; i++, di++, si++) {\n\t\t\tstruct tg3_rx_buffer_desc *sbd, *dbd;\n\t\t\tsbd = &spr->rx_jmb[si].std;\n\t\t\tdbd = &dpr->rx_jmb[di].std;\n\t\t\tdbd->addr_hi = sbd->addr_hi;\n\t\t\tdbd->addr_lo = sbd->addr_lo;\n\t\t}\n\n\t\tspr->rx_jmb_cons_idx = (spr->rx_jmb_cons_idx + cpycnt) &\n\t\t\t\t       tp->rx_jmb_ring_mask;\n\t\tdpr->rx_jmb_prod_idx = (dpr->rx_jmb_prod_idx + cpycnt) &\n\t\t\t\t       tp->rx_jmb_ring_mask;\n\t}\n\n\treturn err;\n}\n\nstatic int tg3_poll_work(struct tg3_napi *tnapi, int work_done, int budget)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\n\t/* run TX completion thread */\n\tif (tnapi->hw_status->idx[0].tx_consumer != tnapi->tx_cons) {\n\t\ttg3_tx(tnapi);\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\treturn work_done;\n\t}\n\n\tif (!tnapi->rx_rcb_prod_idx)\n\t\treturn work_done;\n\n\t/* run RX thread, within the bounds set by NAPI.\n\t * All RX \"locking\" is done by ensuring outside\n\t * code synchronizes with tg3->napi.poll()\n\t */\n\tif (*(tnapi->rx_rcb_prod_idx) != tnapi->rx_rcb_ptr)\n\t\twork_done += tg3_rx(tnapi, budget - work_done);\n\n\tif (tg3_flag(tp, ENABLE_RSS) && tnapi == &tp->napi[1]) {\n\t\tstruct tg3_rx_prodring_set *dpr = &tp->napi[0].prodring;\n\t\tint i, err = 0;\n\t\tu32 std_prod_idx = dpr->rx_std_prod_idx;\n\t\tu32 jmb_prod_idx = dpr->rx_jmb_prod_idx;\n\n\t\ttp->rx_refill = false;\n\t\tfor (i = 1; i <= tp->rxq_cnt; i++)\n\t\t\terr |= tg3_rx_prodring_xfer(tp, dpr,\n\t\t\t\t\t\t    &tp->napi[i].prodring);\n\n\t\twmb();\n\n\t\tif (std_prod_idx != dpr->rx_std_prod_idx)\n\t\t\ttw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG,\n\t\t\t\t     dpr->rx_std_prod_idx);\n\n\t\tif (jmb_prod_idx != dpr->rx_jmb_prod_idx)\n\t\t\ttw32_rx_mbox(TG3_RX_JMB_PROD_IDX_REG,\n\t\t\t\t     dpr->rx_jmb_prod_idx);\n\n\t\tif (err)\n\t\t\ttw32_f(HOSTCC_MODE, tp->coal_now);\n\t}\n\n\treturn work_done;\n}\n\nstatic inline void tg3_reset_task_schedule(struct tg3 *tp)\n{\n\tif (!test_and_set_bit(TG3_FLAG_RESET_TASK_PENDING, tp->tg3_flags))\n\t\tschedule_work(&tp->reset_task);\n}\n\nstatic inline void tg3_reset_task_cancel(struct tg3 *tp)\n{\n\tif (test_and_clear_bit(TG3_FLAG_RESET_TASK_PENDING, tp->tg3_flags))\n\t\tcancel_work_sync(&tp->reset_task);\n\ttg3_flag_clear(tp, TX_RECOVERY_PENDING);\n}\n\nstatic int tg3_poll_msix(struct napi_struct *napi, int budget)\n{\n\tstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\n\tstruct tg3 *tp = tnapi->tp;\n\tint work_done = 0;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\twhile (1) {\n\t\twork_done = tg3_poll_work(tnapi, work_done, budget);\n\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\tgoto tx_recovery;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\t/* tp->last_tag is used in tg3_int_reenable() below\n\t\t * to tell the hw how much work has been processed,\n\t\t * so we must read it before checking for more work.\n\t\t */\n\t\ttnapi->last_tag = sblk->status_tag;\n\t\ttnapi->last_irq_tag = tnapi->last_tag;\n\t\trmb();\n\n\t\t/* check for RX/TX work to do */\n\t\tif (likely(sblk->idx[0].tx_consumer == tnapi->tx_cons &&\n\t\t\t   *(tnapi->rx_rcb_prod_idx) == tnapi->rx_rcb_ptr)) {\n\n\t\t\t/* This test here is not race free, but will reduce\n\t\t\t * the number of interrupts by looping again.\n\t\t\t */\n\t\t\tif (tnapi == &tp->napi[1] && tp->rx_refill)\n\t\t\t\tcontinue;\n\n\t\t\tnapi_complete_done(napi, work_done);\n\t\t\t/* Reenable interrupts. */\n\t\t\ttw32_mailbox(tnapi->int_mbox, tnapi->last_tag << 24);\n\n\t\t\t/* This test here is synchronized by napi_schedule()\n\t\t\t * and napi_complete() to close the race condition.\n\t\t\t */\n\t\t\tif (unlikely(tnapi == &tp->napi[1] && tp->rx_refill)) {\n\t\t\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t\t\t\t\t  HOSTCC_MODE_ENABLE |\n\t\t\t\t\t\t  tnapi->coal_now);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttg3_send_ape_heartbeat(tp, TG3_APE_HB_INTERVAL << 1);\n\treturn work_done;\n\ntx_recovery:\n\t/* work_done is guaranteed to be less than budget. */\n\tnapi_complete(napi);\n\ttg3_reset_task_schedule(tp);\n\treturn work_done;\n}\n\nstatic void tg3_process_error(struct tg3 *tp)\n{\n\tu32 val;\n\tbool real_error = false;\n\n\tif (tg3_flag(tp, ERROR_PROCESSED))\n\t\treturn;\n\n\t/* Check Flow Attention register */\n\tval = tr32(HOSTCC_FLOW_ATTN);\n\tif (val & ~HOSTCC_FLOW_ATTN_MBUF_LWM) {\n\t\tnetdev_err(tp->dev, \"FLOW Attention error.  Resetting chip.\\n\");\n\t\treal_error = true;\n\t}\n\n\tif (tr32(MSGINT_STATUS) & ~MSGINT_STATUS_MSI_REQ) {\n\t\tnetdev_err(tp->dev, \"MSI Status error.  Resetting chip.\\n\");\n\t\treal_error = true;\n\t}\n\n\tif (tr32(RDMAC_STATUS) || tr32(WDMAC_STATUS)) {\n\t\tnetdev_err(tp->dev, \"DMA Status error.  Resetting chip.\\n\");\n\t\treal_error = true;\n\t}\n\n\tif (!real_error)\n\t\treturn;\n\n\ttg3_dump_state(tp);\n\n\ttg3_flag_set(tp, ERROR_PROCESSED);\n\ttg3_reset_task_schedule(tp);\n}\n\nstatic int tg3_poll(struct napi_struct *napi, int budget)\n{\n\tstruct tg3_napi *tnapi = container_of(napi, struct tg3_napi, napi);\n\tstruct tg3 *tp = tnapi->tp;\n\tint work_done = 0;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\twhile (1) {\n\t\tif (sblk->status & SD_STATUS_ERROR)\n\t\t\ttg3_process_error(tp);\n\n\t\ttg3_poll_link(tp);\n\n\t\twork_done = tg3_poll_work(tnapi, work_done, budget);\n\n\t\tif (unlikely(tg3_flag(tp, TX_RECOVERY_PENDING)))\n\t\t\tgoto tx_recovery;\n\n\t\tif (unlikely(work_done >= budget))\n\t\t\tbreak;\n\n\t\tif (tg3_flag(tp, TAGGED_STATUS)) {\n\t\t\t/* tp->last_tag is used in tg3_int_reenable() below\n\t\t\t * to tell the hw how much work has been processed,\n\t\t\t * so we must read it before checking for more work.\n\t\t\t */\n\t\t\ttnapi->last_tag = sblk->status_tag;\n\t\t\ttnapi->last_irq_tag = tnapi->last_tag;\n\t\t\trmb();\n\t\t} else\n\t\t\tsblk->status &= ~SD_STATUS_UPDATED;\n\n\t\tif (likely(!tg3_has_work(tnapi))) {\n\t\t\tnapi_complete_done(napi, work_done);\n\t\t\ttg3_int_reenable(tnapi);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttg3_send_ape_heartbeat(tp, TG3_APE_HB_INTERVAL << 1);\n\treturn work_done;\n\ntx_recovery:\n\t/* work_done is guaranteed to be less than budget. */\n\tnapi_complete(napi);\n\ttg3_reset_task_schedule(tp);\n\treturn work_done;\n}\n\nstatic void tg3_napi_disable(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = tp->irq_cnt - 1; i >= 0; i--)\n\t\tnapi_disable(&tp->napi[i].napi);\n}\n\nstatic void tg3_napi_enable(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->irq_cnt; i++)\n\t\tnapi_enable(&tp->napi[i].napi);\n}\n\nstatic void tg3_napi_init(struct tg3 *tp)\n{\n\tint i;\n\n\tnetif_napi_add(tp->dev, &tp->napi[0].napi, tg3_poll, 64);\n\tfor (i = 1; i < tp->irq_cnt; i++)\n\t\tnetif_napi_add(tp->dev, &tp->napi[i].napi, tg3_poll_msix, 64);\n}\n\nstatic void tg3_napi_fini(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->irq_cnt; i++)\n\t\tnetif_napi_del(&tp->napi[i].napi);\n}\n\nstatic inline void tg3_netif_stop(struct tg3 *tp)\n{\n\tnetif_trans_update(tp->dev);\t/* prevent tx timeout */\n\ttg3_napi_disable(tp);\n\tnetif_carrier_off(tp->dev);\n\tnetif_tx_disable(tp->dev);\n}\n\n/* tp->lock must be held */\nstatic inline void tg3_netif_start(struct tg3 *tp)\n{\n\ttg3_ptp_resume(tp);\n\n\t/* NOTE: unconditional netif_tx_wake_all_queues is only\n\t * appropriate so long as all callers are assured to\n\t * have free tx slots (such as after tg3_init_hw)\n\t */\n\tnetif_tx_wake_all_queues(tp->dev);\n\n\tif (tp->link_up)\n\t\tnetif_carrier_on(tp->dev);\n\n\ttg3_napi_enable(tp);\n\ttp->napi[0].hw_status->status |= SD_STATUS_UPDATED;\n\ttg3_enable_ints(tp);\n}\n\nstatic void tg3_irq_quiesce(struct tg3 *tp)\n\t__releases(tp->lock)\n\t__acquires(tp->lock)\n{\n\tint i;\n\n\tBUG_ON(tp->irq_sync);\n\n\ttp->irq_sync = 1;\n\tsmp_mb();\n\n\tspin_unlock_bh(&tp->lock);\n\n\tfor (i = 0; i < tp->irq_cnt; i++)\n\t\tsynchronize_irq(tp->napi[i].irq_vec);\n\n\tspin_lock_bh(&tp->lock);\n}\n\n/* Fully shutdown all tg3 driver activity elsewhere in the system.\n * If irq_sync is non-zero, then the IRQ handler must be synchronized\n * with as well.  Most of the time, this is not necessary except when\n * shutting down the device.\n */\nstatic inline void tg3_full_lock(struct tg3 *tp, int irq_sync)\n{\n\tspin_lock_bh(&tp->lock);\n\tif (irq_sync)\n\t\ttg3_irq_quiesce(tp);\n}\n\nstatic inline void tg3_full_unlock(struct tg3 *tp)\n{\n\tspin_unlock_bh(&tp->lock);\n}\n\n/* One-shot MSI handler - Chip automatically disables interrupt\n * after sending MSI so driver doesn't have to do it.\n */\nstatic irqreturn_t tg3_msi_1shot(int irq, void *dev_id)\n{\n\tstruct tg3_napi *tnapi = dev_id;\n\tstruct tg3 *tp = tnapi->tp;\n\n\tprefetch(tnapi->hw_status);\n\tif (tnapi->rx_rcb)\n\t\tprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\n\n\tif (likely(!tg3_irq_sync(tp)))\n\t\tnapi_schedule(&tnapi->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n/* MSI ISR - No need to check for interrupt sharing and no need to\n * flush status block and interrupt mailbox. PCI ordering rules\n * guarantee that MSI will arrive after the status block.\n */\nstatic irqreturn_t tg3_msi(int irq, void *dev_id)\n{\n\tstruct tg3_napi *tnapi = dev_id;\n\tstruct tg3 *tp = tnapi->tp;\n\n\tprefetch(tnapi->hw_status);\n\tif (tnapi->rx_rcb)\n\t\tprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\n\t/*\n\t * Writing any value to intr-mbox-0 clears PCI INTA# and\n\t * chip-internal interrupt pending events.\n\t * Writing non-zero to intr-mbox-0 additional tells the\n\t * NIC to stop sending us irqs, engaging \"in-intr-handler\"\n\t * event coalescing.\n\t */\n\ttw32_mailbox(tnapi->int_mbox, 0x00000001);\n\tif (likely(!tg3_irq_sync(tp)))\n\t\tnapi_schedule(&tnapi->napi);\n\n\treturn IRQ_RETVAL(1);\n}\n\nstatic irqreturn_t tg3_interrupt(int irq, void *dev_id)\n{\n\tstruct tg3_napi *tnapi = dev_id;\n\tstruct tg3 *tp = tnapi->tp;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\tunsigned int handled = 1;\n\n\t/* In INTx mode, it is possible for the interrupt to arrive at\n\t * the CPU before the status block posted prior to the interrupt.\n\t * Reading the PCI State register will confirm whether the\n\t * interrupt is ours and will flush the status block.\n\t */\n\tif (unlikely(!(sblk->status & SD_STATUS_UPDATED))) {\n\t\tif (tg3_flag(tp, CHIP_RESETTING) ||\n\t\t    (tr32(TG3PCI_PCISTATE) & PCISTATE_INT_NOT_ACTIVE)) {\n\t\t\thandled = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Writing any value to intr-mbox-0 clears PCI INTA# and\n\t * chip-internal interrupt pending events.\n\t * Writing non-zero to intr-mbox-0 additional tells the\n\t * NIC to stop sending us irqs, engaging \"in-intr-handler\"\n\t * event coalescing.\n\t *\n\t * Flush the mailbox to de-assert the IRQ immediately to prevent\n\t * spurious interrupts.  The flush impacts performance but\n\t * excessive spurious interrupts can be worse in some cases.\n\t */\n\ttw32_mailbox_f(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);\n\tif (tg3_irq_sync(tp))\n\t\tgoto out;\n\tsblk->status &= ~SD_STATUS_UPDATED;\n\tif (likely(tg3_has_work(tnapi))) {\n\t\tprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\n\t\tnapi_schedule(&tnapi->napi);\n\t} else {\n\t\t/* No work, shared interrupt perhaps?  re-enable\n\t\t * interrupts, and flush that PCI write\n\t\t */\n\t\ttw32_mailbox_f(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW,\n\t\t\t       0x00000000);\n\t}\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic irqreturn_t tg3_interrupt_tagged(int irq, void *dev_id)\n{\n\tstruct tg3_napi *tnapi = dev_id;\n\tstruct tg3 *tp = tnapi->tp;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\tunsigned int handled = 1;\n\n\t/* In INTx mode, it is possible for the interrupt to arrive at\n\t * the CPU before the status block posted prior to the interrupt.\n\t * Reading the PCI State register will confirm whether the\n\t * interrupt is ours and will flush the status block.\n\t */\n\tif (unlikely(sblk->status_tag == tnapi->last_irq_tag)) {\n\t\tif (tg3_flag(tp, CHIP_RESETTING) ||\n\t\t    (tr32(TG3PCI_PCISTATE) & PCISTATE_INT_NOT_ACTIVE)) {\n\t\t\thandled = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * writing any value to intr-mbox-0 clears PCI INTA# and\n\t * chip-internal interrupt pending events.\n\t * writing non-zero to intr-mbox-0 additional tells the\n\t * NIC to stop sending us irqs, engaging \"in-intr-handler\"\n\t * event coalescing.\n\t *\n\t * Flush the mailbox to de-assert the IRQ immediately to prevent\n\t * spurious interrupts.  The flush impacts performance but\n\t * excessive spurious interrupts can be worse in some cases.\n\t */\n\ttw32_mailbox_f(MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW, 0x00000001);\n\n\t/*\n\t * In a shared interrupt configuration, sometimes other devices'\n\t * interrupts will scream.  We record the current status tag here\n\t * so that the above check can report that the screaming interrupts\n\t * are unhandled.  Eventually they will be silenced.\n\t */\n\ttnapi->last_irq_tag = sblk->status_tag;\n\n\tif (tg3_irq_sync(tp))\n\t\tgoto out;\n\n\tprefetch(&tnapi->rx_rcb[tnapi->rx_rcb_ptr]);\n\n\tnapi_schedule(&tnapi->napi);\n\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n/* ISR for interrupt test */\nstatic irqreturn_t tg3_test_isr(int irq, void *dev_id)\n{\n\tstruct tg3_napi *tnapi = dev_id;\n\tstruct tg3 *tp = tnapi->tp;\n\tstruct tg3_hw_status *sblk = tnapi->hw_status;\n\n\tif ((sblk->status & SD_STATUS_UPDATED) ||\n\t    !(tr32(TG3PCI_PCISTATE) & PCISTATE_INT_NOT_ACTIVE)) {\n\t\ttg3_disable_ints(tp);\n\t\treturn IRQ_RETVAL(1);\n\t}\n\treturn IRQ_RETVAL(0);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void tg3_poll_controller(struct net_device *dev)\n{\n\tint i;\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (tg3_irq_sync(tp))\n\t\treturn;\n\n\tfor (i = 0; i < tp->irq_cnt; i++)\n\t\ttg3_interrupt(tp->napi[i].irq_vec, &tp->napi[i]);\n}\n#endif\n\nstatic void tg3_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (netif_msg_tx_err(tp)) {\n\t\tnetdev_err(dev, \"transmit timed out, resetting\\n\");\n\t\ttg3_dump_state(tp);\n\t}\n\n\ttg3_reset_task_schedule(tp);\n}\n\n/* Test for DMA buffers crossing any 4GB boundaries: 4G, 8G, etc */\nstatic inline int tg3_4g_overflow_test(dma_addr_t mapping, int len)\n{\n\tu32 base = (u32) mapping & 0xffffffff;\n\n\treturn base + len + 8 < base;\n}\n\n/* Test for TSO DMA buffers that cross into regions which are within MSS bytes\n * of any 4GB boundaries: 4G, 8G, etc\n */\nstatic inline int tg3_4g_tso_overflow_test(struct tg3 *tp, dma_addr_t mapping,\n\t\t\t\t\t   u32 len, u32 mss)\n{\n\tif (tg3_asic_rev(tp) == ASIC_REV_5762 && mss) {\n\t\tu32 base = (u32) mapping & 0xffffffff;\n\n\t\treturn ((base + len + (mss & 0x3fff)) < base);\n\t}\n\treturn 0;\n}\n\n/* Test for DMA addresses > 40-bit */\nstatic inline int tg3_40bit_overflow_test(struct tg3 *tp, dma_addr_t mapping,\n\t\t\t\t\t  int len)\n{\n#if defined(CONFIG_HIGHMEM) && (BITS_PER_LONG == 64)\n\tif (tg3_flag(tp, 40BIT_DMA_BUG))\n\t\treturn ((u64) mapping + len) > DMA_BIT_MASK(40);\n\treturn 0;\n#else\n\treturn 0;\n#endif\n}\n\nstatic inline void tg3_tx_set_bd(struct tg3_tx_buffer_desc *txbd,\n\t\t\t\t dma_addr_t mapping, u32 len, u32 flags,\n\t\t\t\t u32 mss, u32 vlan)\n{\n\ttxbd->addr_hi = ((u64) mapping >> 32);\n\ttxbd->addr_lo = ((u64) mapping & 0xffffffff);\n\ttxbd->len_flags = (len << TXD_LEN_SHIFT) | (flags & 0x0000ffff);\n\ttxbd->vlan_tag = (mss << TXD_MSS_SHIFT) | (vlan << TXD_VLAN_TAG_SHIFT);\n}\n\nstatic bool tg3_tx_frag_set(struct tg3_napi *tnapi, u32 *entry, u32 *budget,\n\t\t\t    dma_addr_t map, u32 len, u32 flags,\n\t\t\t    u32 mss, u32 vlan)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\tbool hwbug = false;\n\n\tif (tg3_flag(tp, SHORT_DMA_BUG) && len <= 8)\n\t\thwbug = true;\n\n\tif (tg3_4g_overflow_test(map, len))\n\t\thwbug = true;\n\n\tif (tg3_4g_tso_overflow_test(tp, map, len, mss))\n\t\thwbug = true;\n\n\tif (tg3_40bit_overflow_test(tp, map, len))\n\t\thwbug = true;\n\n\tif (tp->dma_limit) {\n\t\tu32 prvidx = *entry;\n\t\tu32 tmp_flag = flags & ~TXD_FLAG_END;\n\t\twhile (len > tp->dma_limit && *budget) {\n\t\t\tu32 frag_len = tp->dma_limit;\n\t\t\tlen -= tp->dma_limit;\n\n\t\t\t/* Avoid the 8byte DMA problem */\n\t\t\tif (len <= 8) {\n\t\t\t\tlen += tp->dma_limit / 2;\n\t\t\t\tfrag_len = tp->dma_limit / 2;\n\t\t\t}\n\n\t\t\ttnapi->tx_buffers[*entry].fragmented = true;\n\n\t\t\ttg3_tx_set_bd(&tnapi->tx_ring[*entry], map,\n\t\t\t\t      frag_len, tmp_flag, mss, vlan);\n\t\t\t*budget -= 1;\n\t\t\tprvidx = *entry;\n\t\t\t*entry = NEXT_TX(*entry);\n\n\t\t\tmap += frag_len;\n\t\t}\n\n\t\tif (len) {\n\t\t\tif (*budget) {\n\t\t\t\ttg3_tx_set_bd(&tnapi->tx_ring[*entry], map,\n\t\t\t\t\t      len, flags, mss, vlan);\n\t\t\t\t*budget -= 1;\n\t\t\t\t*entry = NEXT_TX(*entry);\n\t\t\t} else {\n\t\t\t\thwbug = true;\n\t\t\t\ttnapi->tx_buffers[prvidx].fragmented = false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttg3_tx_set_bd(&tnapi->tx_ring[*entry], map,\n\t\t\t      len, flags, mss, vlan);\n\t\t*entry = NEXT_TX(*entry);\n\t}\n\n\treturn hwbug;\n}\n\nstatic void tg3_tx_skb_unmap(struct tg3_napi *tnapi, u32 entry, int last)\n{\n\tint i;\n\tstruct sk_buff *skb;\n\tstruct tg3_tx_ring_info *txb = &tnapi->tx_buffers[entry];\n\n\tskb = txb->skb;\n\ttxb->skb = NULL;\n\n\tpci_unmap_single(tnapi->tp->pdev,\n\t\t\t dma_unmap_addr(txb, mapping),\n\t\t\t skb_headlen(skb),\n\t\t\t PCI_DMA_TODEVICE);\n\n\twhile (txb->fragmented) {\n\t\ttxb->fragmented = false;\n\t\tentry = NEXT_TX(entry);\n\t\ttxb = &tnapi->tx_buffers[entry];\n\t}\n\n\tfor (i = 0; i <= last; i++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tentry = NEXT_TX(entry);\n\t\ttxb = &tnapi->tx_buffers[entry];\n\n\t\tpci_unmap_page(tnapi->tp->pdev,\n\t\t\t       dma_unmap_addr(txb, mapping),\n\t\t\t       skb_frag_size(frag), PCI_DMA_TODEVICE);\n\n\t\twhile (txb->fragmented) {\n\t\t\ttxb->fragmented = false;\n\t\t\tentry = NEXT_TX(entry);\n\t\t\ttxb = &tnapi->tx_buffers[entry];\n\t\t}\n\t}\n}\n\n/* Workaround 4GB and 40-bit hardware DMA bugs. */\nstatic int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi,\n\t\t\t\t       struct sk_buff **pskb,\n\t\t\t\t       u32 *entry, u32 *budget,\n\t\t\t\t       u32 base_flags, u32 mss, u32 vlan)\n{\n\tstruct tg3 *tp = tnapi->tp;\n\tstruct sk_buff *new_skb, *skb = *pskb;\n\tdma_addr_t new_addr = 0;\n\tint ret = 0;\n\n\tif (tg3_asic_rev(tp) != ASIC_REV_5701)\n\t\tnew_skb = skb_copy(skb, GFP_ATOMIC);\n\telse {\n\t\tint more_headroom = 4 - ((unsigned long)skb->data & 3);\n\n\t\tnew_skb = skb_copy_expand(skb,\n\t\t\t\t\t  skb_headroom(skb) + more_headroom,\n\t\t\t\t\t  skb_tailroom(skb), GFP_ATOMIC);\n\t}\n\n\tif (!new_skb) {\n\t\tret = -1;\n\t} else {\n\t\t/* New SKB is guaranteed to be linear. */\n\t\tnew_addr = pci_map_single(tp->pdev, new_skb->data, new_skb->len,\n\t\t\t\t\t  PCI_DMA_TODEVICE);\n\t\t/* Make sure the mapping succeeded */\n\t\tif (pci_dma_mapping_error(tp->pdev, new_addr)) {\n\t\t\tdev_kfree_skb_any(new_skb);\n\t\t\tret = -1;\n\t\t} else {\n\t\t\tu32 save_entry = *entry;\n\n\t\t\tbase_flags |= TXD_FLAG_END;\n\n\t\t\ttnapi->tx_buffers[*entry].skb = new_skb;\n\t\t\tdma_unmap_addr_set(&tnapi->tx_buffers[*entry],\n\t\t\t\t\t   mapping, new_addr);\n\n\t\t\tif (tg3_tx_frag_set(tnapi, entry, budget, new_addr,\n\t\t\t\t\t    new_skb->len, base_flags,\n\t\t\t\t\t    mss, vlan)) {\n\t\t\t\ttg3_tx_skb_unmap(tnapi, save_entry, -1);\n\t\t\t\tdev_kfree_skb_any(new_skb);\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_consume_skb_any(skb);\n\t*pskb = new_skb;\n\treturn ret;\n}\n\nstatic bool tg3_tso_bug_gso_check(struct tg3_napi *tnapi, struct sk_buff *skb)\n{\n\t/* Check if we will never have enough descriptors,\n\t * as gso_segs can be more than current ring size\n\t */\n\treturn skb_shinfo(skb)->gso_segs < tnapi->tx_pending / 3;\n}\n\nstatic netdev_tx_t tg3_start_xmit(struct sk_buff *, struct net_device *);\n\n/* Use GSO to workaround all TSO packets that meet HW bug conditions\n * indicated in tg3_tx_frag_set()\n */\nstatic int tg3_tso_bug(struct tg3 *tp, struct tg3_napi *tnapi,\n\t\t       struct netdev_queue *txq, struct sk_buff *skb)\n{\n\tu32 frag_cnt_est = skb_shinfo(skb)->gso_segs * 3;\n\tstruct sk_buff *segs, *seg, *next;\n\n\t/* Estimate the number of fragments in the worst case */\n\tif (unlikely(tg3_tx_avail(tnapi) <= frag_cnt_est)) {\n\t\tnetif_tx_stop_queue(txq);\n\n\t\t/* netif_tx_stop_queue() must be done before checking\n\t\t * checking tx index in tg3_tx_avail() below, because in\n\t\t * tg3_tx(), we update tx index before checking for\n\t\t * netif_tx_queue_stopped().\n\t\t */\n\t\tsmp_mb();\n\t\tif (tg3_tx_avail(tnapi) <= frag_cnt_est)\n\t\t\treturn NETDEV_TX_BUSY;\n\n\t\tnetif_tx_wake_queue(txq);\n\t}\n\n\tsegs = skb_gso_segment(skb, tp->dev->features &\n\t\t\t\t    ~(NETIF_F_TSO | NETIF_F_TSO6));\n\tif (IS_ERR(segs) || !segs)\n\t\tgoto tg3_tso_bug_end;\n\n\tskb_list_walk_safe(segs, seg, next) {\n\t\tskb_mark_not_on_list(seg);\n\t\ttg3_start_xmit(seg, tp->dev);\n\t}\n\ntg3_tso_bug_end:\n\tdev_consume_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n/* hard_start_xmit for all devices */\nstatic netdev_tx_t tg3_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tu32 len, entry, base_flags, mss, vlan = 0;\n\tu32 budget;\n\tint i = -1, would_hit_hwbug;\n\tdma_addr_t mapping;\n\tstruct tg3_napi *tnapi;\n\tstruct netdev_queue *txq;\n\tunsigned int last;\n\tstruct iphdr *iph = NULL;\n\tstruct tcphdr *tcph = NULL;\n\t__sum16 tcp_csum = 0, ip_csum = 0;\n\t__be16 ip_tot_len = 0;\n\n\ttxq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));\n\ttnapi = &tp->napi[skb_get_queue_mapping(skb)];\n\tif (tg3_flag(tp, ENABLE_TSS))\n\t\ttnapi++;\n\n\tbudget = tg3_tx_avail(tnapi);\n\n\t/* We are running in BH disabled context with netif_tx_lock\n\t * and TX reclaim runs via tp->napi.poll inside of a software\n\t * interrupt.  Furthermore, IRQ processing runs lockless so we have\n\t * no IRQ context deadlocks to worry about either.  Rejoice!\n\t */\n\tif (unlikely(budget <= (skb_shinfo(skb)->nr_frags + 1))) {\n\t\tif (!netif_tx_queue_stopped(txq)) {\n\t\t\tnetif_tx_stop_queue(txq);\n\n\t\t\t/* This is a hard error, log it. */\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"BUG! Tx Ring full when queue awake!\\n\");\n\t\t}\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tentry = tnapi->tx_prod;\n\tbase_flags = 0;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (mss) {\n\t\tu32 tcp_opt_len, hdr_len;\n\n\t\tif (skb_cow_head(skb, 0))\n\t\t\tgoto drop;\n\n\t\tiph = ip_hdr(skb);\n\t\ttcp_opt_len = tcp_optlen(skb);\n\n\t\thdr_len = skb_transport_offset(skb) + tcp_hdrlen(skb) - ETH_HLEN;\n\n\t\t/* HW/FW can not correctly segment packets that have been\n\t\t * vlan encapsulated.\n\t\t */\n\t\tif (skb->protocol == htons(ETH_P_8021Q) ||\n\t\t    skb->protocol == htons(ETH_P_8021AD)) {\n\t\t\tif (tg3_tso_bug_gso_check(tnapi, skb))\n\t\t\t\treturn tg3_tso_bug(tp, tnapi, txq, skb);\n\t\t\tgoto drop;\n\t\t}\n\n\t\tif (!skb_is_gso_v6(skb)) {\n\t\t\tif (unlikely((ETH_HLEN + hdr_len) > 80) &&\n\t\t\t    tg3_flag(tp, TSO_BUG)) {\n\t\t\t\tif (tg3_tso_bug_gso_check(tnapi, skb))\n\t\t\t\t\treturn tg3_tso_bug(tp, tnapi, txq, skb);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tip_csum = iph->check;\n\t\t\tip_tot_len = iph->tot_len;\n\t\t\tiph->check = 0;\n\t\t\tiph->tot_len = htons(mss + hdr_len);\n\t\t}\n\n\t\tbase_flags |= (TXD_FLAG_CPU_PRE_DMA |\n\t\t\t       TXD_FLAG_CPU_POST_DMA);\n\n\t\ttcph = tcp_hdr(skb);\n\t\ttcp_csum = tcph->check;\n\n\t\tif (tg3_flag(tp, HW_TSO_1) ||\n\t\t    tg3_flag(tp, HW_TSO_2) ||\n\t\t    tg3_flag(tp, HW_TSO_3)) {\n\t\t\ttcph->check = 0;\n\t\t\tbase_flags &= ~TXD_FLAG_TCPUDP_CSUM;\n\t\t} else {\n\t\t\ttcph->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr,\n\t\t\t\t\t\t\t 0, IPPROTO_TCP, 0);\n\t\t}\n\n\t\tif (tg3_flag(tp, HW_TSO_3)) {\n\t\t\tmss |= (hdr_len & 0xc) << 12;\n\t\t\tif (hdr_len & 0x10)\n\t\t\t\tbase_flags |= 0x00000010;\n\t\t\tbase_flags |= (hdr_len & 0x3e0) << 5;\n\t\t} else if (tg3_flag(tp, HW_TSO_2))\n\t\t\tmss |= hdr_len << 9;\n\t\telse if (tg3_flag(tp, HW_TSO_1) ||\n\t\t\t tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\t\tif (tcp_opt_len || iph->ihl > 5) {\n\t\t\t\tint tsflags;\n\n\t\t\t\ttsflags = (iph->ihl - 5) + (tcp_opt_len >> 2);\n\t\t\t\tmss |= (tsflags << 11);\n\t\t\t}\n\t\t} else {\n\t\t\tif (tcp_opt_len || iph->ihl > 5) {\n\t\t\t\tint tsflags;\n\n\t\t\t\ttsflags = (iph->ihl - 5) + (tcp_opt_len >> 2);\n\t\t\t\tbase_flags |= tsflags << 12;\n\t\t\t}\n\t\t}\n\t} else if (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t/* HW/FW can not correctly checksum packets that have been\n\t\t * vlan encapsulated.\n\t\t */\n\t\tif (skb->protocol == htons(ETH_P_8021Q) ||\n\t\t    skb->protocol == htons(ETH_P_8021AD)) {\n\t\t\tif (skb_checksum_help(skb))\n\t\t\t\tgoto drop;\n\t\t} else  {\n\t\t\tbase_flags |= TXD_FLAG_TCPUDP_CSUM;\n\t\t}\n\t}\n\n\tif (tg3_flag(tp, USE_JUMBO_BDFLAG) &&\n\t    !mss && skb->len > VLAN_ETH_FRAME_LEN)\n\t\tbase_flags |= TXD_FLAG_JMB_PKT;\n\n\tif (skb_vlan_tag_present(skb)) {\n\t\tbase_flags |= TXD_FLAG_VLAN;\n\t\tvlan = skb_vlan_tag_get(skb);\n\t}\n\n\tif ((unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) &&\n\t    tg3_flag(tp, TX_TSTAMP_EN)) {\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tbase_flags |= TXD_FLAG_HWTSTAMP;\n\t}\n\n\tlen = skb_headlen(skb);\n\n\tmapping = pci_map_single(tp->pdev, skb->data, len, PCI_DMA_TODEVICE);\n\tif (pci_dma_mapping_error(tp->pdev, mapping))\n\t\tgoto drop;\n\n\n\ttnapi->tx_buffers[entry].skb = skb;\n\tdma_unmap_addr_set(&tnapi->tx_buffers[entry], mapping, mapping);\n\n\twould_hit_hwbug = 0;\n\n\tif (tg3_flag(tp, 5701_DMA_BUG))\n\t\twould_hit_hwbug = 1;\n\n\tif (tg3_tx_frag_set(tnapi, &entry, &budget, mapping, len, base_flags |\n\t\t\t  ((skb_shinfo(skb)->nr_frags == 0) ? TXD_FLAG_END : 0),\n\t\t\t    mss, vlan)) {\n\t\twould_hit_hwbug = 1;\n\t} else if (skb_shinfo(skb)->nr_frags > 0) {\n\t\tu32 tmp_mss = mss;\n\n\t\tif (!tg3_flag(tp, HW_TSO_1) &&\n\t\t    !tg3_flag(tp, HW_TSO_2) &&\n\t\t    !tg3_flag(tp, HW_TSO_3))\n\t\t\ttmp_mss = 0;\n\n\t\t/* Now loop through additional data\n\t\t * fragments, and queue them.\n\t\t */\n\t\tlast = skb_shinfo(skb)->nr_frags - 1;\n\t\tfor (i = 0; i <= last; i++) {\n\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\t\tlen = skb_frag_size(frag);\n\t\t\tmapping = skb_frag_dma_map(&tp->pdev->dev, frag, 0,\n\t\t\t\t\t\t   len, DMA_TO_DEVICE);\n\n\t\t\ttnapi->tx_buffers[entry].skb = NULL;\n\t\t\tdma_unmap_addr_set(&tnapi->tx_buffers[entry], mapping,\n\t\t\t\t\t   mapping);\n\t\t\tif (dma_mapping_error(&tp->pdev->dev, mapping))\n\t\t\t\tgoto dma_error;\n\n\t\t\tif (!budget ||\n\t\t\t    tg3_tx_frag_set(tnapi, &entry, &budget, mapping,\n\t\t\t\t\t    len, base_flags |\n\t\t\t\t\t    ((i == last) ? TXD_FLAG_END : 0),\n\t\t\t\t\t    tmp_mss, vlan)) {\n\t\t\t\twould_hit_hwbug = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (would_hit_hwbug) {\n\t\ttg3_tx_skb_unmap(tnapi, tnapi->tx_prod, i);\n\n\t\tif (mss && tg3_tso_bug_gso_check(tnapi, skb)) {\n\t\t\t/* If it's a TSO packet, do GSO instead of\n\t\t\t * allocating and copying to a large linear SKB\n\t\t\t */\n\t\t\tif (ip_tot_len) {\n\t\t\t\tiph->check = ip_csum;\n\t\t\t\tiph->tot_len = ip_tot_len;\n\t\t\t}\n\t\t\ttcph->check = tcp_csum;\n\t\t\treturn tg3_tso_bug(tp, tnapi, txq, skb);\n\t\t}\n\n\t\t/* If the workaround fails due to memory/mapping\n\t\t * failure, silently drop this packet.\n\t\t */\n\t\tentry = tnapi->tx_prod;\n\t\tbudget = tg3_tx_avail(tnapi);\n\t\tif (tigon3_dma_hwbug_workaround(tnapi, &skb, &entry, &budget,\n\t\t\t\t\t\tbase_flags, mss, vlan))\n\t\t\tgoto drop_nofree;\n\t}\n\n\tskb_tx_timestamp(skb);\n\tnetdev_tx_sent_queue(txq, skb->len);\n\n\t/* Sync BD data before updating mailbox */\n\twmb();\n\n\ttnapi->tx_prod = entry;\n\tif (unlikely(tg3_tx_avail(tnapi) <= (MAX_SKB_FRAGS + 1))) {\n\t\tnetif_tx_stop_queue(txq);\n\n\t\t/* netif_tx_stop_queue() must be done before checking\n\t\t * checking tx index in tg3_tx_avail() below, because in\n\t\t * tg3_tx(), we update tx index before checking for\n\t\t * netif_tx_queue_stopped().\n\t\t */\n\t\tsmp_mb();\n\t\tif (tg3_tx_avail(tnapi) > TG3_TX_WAKEUP_THRESH(tnapi))\n\t\t\tnetif_tx_wake_queue(txq);\n\t}\n\n\tif (!netdev_xmit_more() || netif_xmit_stopped(txq)) {\n\t\t/* Packets are ready, update Tx producer idx on card. */\n\t\ttw32_tx_mbox(tnapi->prodmbox, entry);\n\t}\n\n\treturn NETDEV_TX_OK;\n\ndma_error:\n\ttg3_tx_skb_unmap(tnapi, tnapi->tx_prod, --i);\n\ttnapi->tx_buffers[tnapi->tx_prod].skb = NULL;\ndrop:\n\tdev_kfree_skb_any(skb);\ndrop_nofree:\n\ttp->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic void tg3_mac_loopback(struct tg3 *tp, bool enable)\n{\n\tif (enable) {\n\t\ttp->mac_mode &= ~(MAC_MODE_HALF_DUPLEX |\n\t\t\t\t  MAC_MODE_PORT_MODE_MASK);\n\n\t\ttp->mac_mode |= MAC_MODE_PORT_INT_LPBACK;\n\n\t\tif (!tg3_flag(tp, 5705_PLUS))\n\t\t\ttp->mac_mode |= MAC_MODE_LINK_POLARITY;\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)\n\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_MII;\n\t\telse\n\t\t\ttp->mac_mode |= MAC_MODE_PORT_MODE_GMII;\n\t} else {\n\t\ttp->mac_mode &= ~MAC_MODE_PORT_INT_LPBACK;\n\n\t\tif (tg3_flag(tp, 5705_PLUS) ||\n\t\t    (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5700)\n\t\t\ttp->mac_mode &= ~MAC_MODE_LINK_POLARITY;\n\t}\n\n\ttw32(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n}\n\nstatic int tg3_phy_lpbk_set(struct tg3 *tp, u32 speed, bool extlpbk)\n{\n\tu32 val, bmcr, mac_mode, ptest = 0;\n\n\ttg3_phy_toggle_apd(tp, false);\n\ttg3_phy_toggle_automdix(tp, false);\n\n\tif (extlpbk && tg3_phy_set_extloopbk(tp))\n\t\treturn -EIO;\n\n\tbmcr = BMCR_FULLDPLX;\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tbreak;\n\tcase SPEED_100:\n\t\tbmcr |= BMCR_SPEED100;\n\t\tbreak;\n\tcase SPEED_1000:\n\tdefault:\n\t\tif (tp->phy_flags & TG3_PHYFLG_IS_FET) {\n\t\t\tspeed = SPEED_100;\n\t\t\tbmcr |= BMCR_SPEED100;\n\t\t} else {\n\t\t\tspeed = SPEED_1000;\n\t\t\tbmcr |= BMCR_SPEED1000;\n\t\t}\n\t}\n\n\tif (extlpbk) {\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_IS_FET)) {\n\t\t\ttg3_readphy(tp, MII_CTRL1000, &val);\n\t\t\tval |= CTL1000_AS_MASTER |\n\t\t\t       CTL1000_ENABLE_MASTER;\n\t\t\ttg3_writephy(tp, MII_CTRL1000, val);\n\t\t} else {\n\t\t\tptest = MII_TG3_FET_PTEST_TRIM_SEL |\n\t\t\t\tMII_TG3_FET_PTEST_TRIM_2;\n\t\t\ttg3_writephy(tp, MII_TG3_FET_PTEST, ptest);\n\t\t}\n\t} else\n\t\tbmcr |= BMCR_LOOPBACK;\n\n\ttg3_writephy(tp, MII_BMCR, bmcr);\n\n\t/* The write needs to be flushed for the FETs */\n\tif (tp->phy_flags & TG3_PHYFLG_IS_FET)\n\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\n\tudelay(40);\n\n\tif ((tp->phy_flags & TG3_PHYFLG_IS_FET) &&\n\t    tg3_asic_rev(tp) == ASIC_REV_5785) {\n\t\ttg3_writephy(tp, MII_TG3_FET_PTEST, ptest |\n\t\t\t     MII_TG3_FET_PTEST_FRC_TX_LINK |\n\t\t\t     MII_TG3_FET_PTEST_FRC_TX_LOCK);\n\n\t\t/* The write needs to be flushed for the AC131 */\n\t\ttg3_readphy(tp, MII_TG3_FET_PTEST, &val);\n\t}\n\n\t/* Reset to prevent losing 1st rx packet intermittently */\n\tif ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\n\t    tg3_flag(tp, 5780_CLASS)) {\n\t\ttw32_f(MAC_RX_MODE, RX_MODE_RESET);\n\t\tudelay(10);\n\t\ttw32_f(MAC_RX_MODE, tp->rx_mode);\n\t}\n\n\tmac_mode = tp->mac_mode &\n\t\t   ~(MAC_MODE_PORT_MODE_MASK | MAC_MODE_HALF_DUPLEX);\n\tif (speed == SPEED_1000)\n\t\tmac_mode |= MAC_MODE_PORT_MODE_GMII;\n\telse\n\t\tmac_mode |= MAC_MODE_PORT_MODE_MII;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700) {\n\t\tu32 masked_phy_id = tp->phy_id & TG3_PHY_ID_MASK;\n\n\t\tif (masked_phy_id == TG3_PHY_ID_BCM5401)\n\t\t\tmac_mode &= ~MAC_MODE_LINK_POLARITY;\n\t\telse if (masked_phy_id == TG3_PHY_ID_BCM5411)\n\t\t\tmac_mode |= MAC_MODE_LINK_POLARITY;\n\n\t\ttg3_writephy(tp, MII_TG3_EXT_CTRL,\n\t\t\t     MII_TG3_EXT_CTRL_LNK3_LED_MODE);\n\t}\n\n\ttw32(MAC_MODE, mac_mode);\n\tudelay(40);\n\n\treturn 0;\n}\n\nstatic void tg3_set_loopback(struct net_device *dev, netdev_features_t features)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (features & NETIF_F_LOOPBACK) {\n\t\tif (tp->mac_mode & MAC_MODE_PORT_INT_LPBACK)\n\t\t\treturn;\n\n\t\tspin_lock_bh(&tp->lock);\n\t\ttg3_mac_loopback(tp, true);\n\t\tnetif_carrier_on(tp->dev);\n\t\tspin_unlock_bh(&tp->lock);\n\t\tnetdev_info(dev, \"Internal MAC loopback mode enabled.\\n\");\n\t} else {\n\t\tif (!(tp->mac_mode & MAC_MODE_PORT_INT_LPBACK))\n\t\t\treturn;\n\n\t\tspin_lock_bh(&tp->lock);\n\t\ttg3_mac_loopback(tp, false);\n\t\t/* Force link status check */\n\t\ttg3_setup_phy(tp, true);\n\t\tspin_unlock_bh(&tp->lock);\n\t\tnetdev_info(dev, \"Internal MAC loopback mode disabled.\\n\");\n\t}\n}\n\nstatic netdev_features_t tg3_fix_features(struct net_device *dev,\n\tnetdev_features_t features)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (dev->mtu > ETH_DATA_LEN && tg3_flag(tp, 5780_CLASS))\n\t\tfeatures &= ~NETIF_F_ALL_TSO;\n\n\treturn features;\n}\n\nstatic int tg3_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tnetdev_features_t changed = dev->features ^ features;\n\n\tif ((changed & NETIF_F_LOOPBACK) && netif_running(dev))\n\t\ttg3_set_loopback(dev, features);\n\n\treturn 0;\n}\n\nstatic void tg3_rx_prodring_free(struct tg3 *tp,\n\t\t\t\t struct tg3_rx_prodring_set *tpr)\n{\n\tint i;\n\n\tif (tpr != &tp->napi[0].prodring) {\n\t\tfor (i = tpr->rx_std_cons_idx; i != tpr->rx_std_prod_idx;\n\t\t     i = (i + 1) & tp->rx_std_ring_mask)\n\t\t\ttg3_rx_data_free(tp, &tpr->rx_std_buffers[i],\n\t\t\t\t\ttp->rx_pkt_map_sz);\n\n\t\tif (tg3_flag(tp, JUMBO_CAPABLE)) {\n\t\t\tfor (i = tpr->rx_jmb_cons_idx;\n\t\t\t     i != tpr->rx_jmb_prod_idx;\n\t\t\t     i = (i + 1) & tp->rx_jmb_ring_mask) {\n\t\t\t\ttg3_rx_data_free(tp, &tpr->rx_jmb_buffers[i],\n\t\t\t\t\t\tTG3_RX_JMB_MAP_SZ);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (i = 0; i <= tp->rx_std_ring_mask; i++)\n\t\ttg3_rx_data_free(tp, &tpr->rx_std_buffers[i],\n\t\t\t\ttp->rx_pkt_map_sz);\n\n\tif (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS)) {\n\t\tfor (i = 0; i <= tp->rx_jmb_ring_mask; i++)\n\t\t\ttg3_rx_data_free(tp, &tpr->rx_jmb_buffers[i],\n\t\t\t\t\tTG3_RX_JMB_MAP_SZ);\n\t}\n}\n\n/* Initialize rx rings for packet processing.\n *\n * The chip has been shut down and the driver detached from\n * the networking, so no interrupts or new tx packets will\n * end up in the driver.  tp->{tx,}lock are held and thus\n * we may not sleep.\n */\nstatic int tg3_rx_prodring_alloc(struct tg3 *tp,\n\t\t\t\t struct tg3_rx_prodring_set *tpr)\n{\n\tu32 i, rx_pkt_dma_sz;\n\n\ttpr->rx_std_cons_idx = 0;\n\ttpr->rx_std_prod_idx = 0;\n\ttpr->rx_jmb_cons_idx = 0;\n\ttpr->rx_jmb_prod_idx = 0;\n\n\tif (tpr != &tp->napi[0].prodring) {\n\t\tmemset(&tpr->rx_std_buffers[0], 0,\n\t\t       TG3_RX_STD_BUFF_RING_SIZE(tp));\n\t\tif (tpr->rx_jmb_buffers)\n\t\t\tmemset(&tpr->rx_jmb_buffers[0], 0,\n\t\t\t       TG3_RX_JMB_BUFF_RING_SIZE(tp));\n\t\tgoto done;\n\t}\n\n\t/* Zero out all descriptors. */\n\tmemset(tpr->rx_std, 0, TG3_RX_STD_RING_BYTES(tp));\n\n\trx_pkt_dma_sz = TG3_RX_STD_DMA_SZ;\n\tif (tg3_flag(tp, 5780_CLASS) &&\n\t    tp->dev->mtu > ETH_DATA_LEN)\n\t\trx_pkt_dma_sz = TG3_RX_JMB_DMA_SZ;\n\ttp->rx_pkt_map_sz = TG3_RX_DMA_TO_MAP_SZ(rx_pkt_dma_sz);\n\n\t/* Initialize invariants of the rings, we only set this\n\t * stuff once.  This works because the card does not\n\t * write into the rx buffer posting rings.\n\t */\n\tfor (i = 0; i <= tp->rx_std_ring_mask; i++) {\n\t\tstruct tg3_rx_buffer_desc *rxd;\n\n\t\trxd = &tpr->rx_std[i];\n\t\trxd->idx_len = rx_pkt_dma_sz << RXD_LEN_SHIFT;\n\t\trxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT);\n\t\trxd->opaque = (RXD_OPAQUE_RING_STD |\n\t\t\t       (i << RXD_OPAQUE_INDEX_SHIFT));\n\t}\n\n\t/* Now allocate fresh SKBs for each rx ring. */\n\tfor (i = 0; i < tp->rx_pending; i++) {\n\t\tunsigned int frag_size;\n\n\t\tif (tg3_alloc_rx_data(tp, tpr, RXD_OPAQUE_RING_STD, i,\n\t\t\t\t      &frag_size) < 0) {\n\t\t\tnetdev_warn(tp->dev,\n\t\t\t\t    \"Using a smaller RX standard ring. Only \"\n\t\t\t\t    \"%d out of %d buffers were allocated \"\n\t\t\t\t    \"successfully\\n\", i, tp->rx_pending);\n\t\t\tif (i == 0)\n\t\t\t\tgoto initfail;\n\t\t\ttp->rx_pending = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tg3_flag(tp, JUMBO_CAPABLE) || tg3_flag(tp, 5780_CLASS))\n\t\tgoto done;\n\n\tmemset(tpr->rx_jmb, 0, TG3_RX_JMB_RING_BYTES(tp));\n\n\tif (!tg3_flag(tp, JUMBO_RING_ENABLE))\n\t\tgoto done;\n\n\tfor (i = 0; i <= tp->rx_jmb_ring_mask; i++) {\n\t\tstruct tg3_rx_buffer_desc *rxd;\n\n\t\trxd = &tpr->rx_jmb[i].std;\n\t\trxd->idx_len = TG3_RX_JMB_DMA_SZ << RXD_LEN_SHIFT;\n\t\trxd->type_flags = (RXD_FLAG_END << RXD_FLAGS_SHIFT) |\n\t\t\t\t  RXD_FLAG_JUMBO;\n\t\trxd->opaque = (RXD_OPAQUE_RING_JUMBO |\n\t\t       (i << RXD_OPAQUE_INDEX_SHIFT));\n\t}\n\n\tfor (i = 0; i < tp->rx_jumbo_pending; i++) {\n\t\tunsigned int frag_size;\n\n\t\tif (tg3_alloc_rx_data(tp, tpr, RXD_OPAQUE_RING_JUMBO, i,\n\t\t\t\t      &frag_size) < 0) {\n\t\t\tnetdev_warn(tp->dev,\n\t\t\t\t    \"Using a smaller RX jumbo ring. Only %d \"\n\t\t\t\t    \"out of %d buffers were allocated \"\n\t\t\t\t    \"successfully\\n\", i, tp->rx_jumbo_pending);\n\t\t\tif (i == 0)\n\t\t\t\tgoto initfail;\n\t\t\ttp->rx_jumbo_pending = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn 0;\n\ninitfail:\n\ttg3_rx_prodring_free(tp, tpr);\n\treturn -ENOMEM;\n}\n\nstatic void tg3_rx_prodring_fini(struct tg3 *tp,\n\t\t\t\t struct tg3_rx_prodring_set *tpr)\n{\n\tkfree(tpr->rx_std_buffers);\n\ttpr->rx_std_buffers = NULL;\n\tkfree(tpr->rx_jmb_buffers);\n\ttpr->rx_jmb_buffers = NULL;\n\tif (tpr->rx_std) {\n\t\tdma_free_coherent(&tp->pdev->dev, TG3_RX_STD_RING_BYTES(tp),\n\t\t\t\t  tpr->rx_std, tpr->rx_std_mapping);\n\t\ttpr->rx_std = NULL;\n\t}\n\tif (tpr->rx_jmb) {\n\t\tdma_free_coherent(&tp->pdev->dev, TG3_RX_JMB_RING_BYTES(tp),\n\t\t\t\t  tpr->rx_jmb, tpr->rx_jmb_mapping);\n\t\ttpr->rx_jmb = NULL;\n\t}\n}\n\nstatic int tg3_rx_prodring_init(struct tg3 *tp,\n\t\t\t\tstruct tg3_rx_prodring_set *tpr)\n{\n\ttpr->rx_std_buffers = kzalloc(TG3_RX_STD_BUFF_RING_SIZE(tp),\n\t\t\t\t      GFP_KERNEL);\n\tif (!tpr->rx_std_buffers)\n\t\treturn -ENOMEM;\n\n\ttpr->rx_std = dma_alloc_coherent(&tp->pdev->dev,\n\t\t\t\t\t TG3_RX_STD_RING_BYTES(tp),\n\t\t\t\t\t &tpr->rx_std_mapping,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!tpr->rx_std)\n\t\tgoto err_out;\n\n\tif (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS)) {\n\t\ttpr->rx_jmb_buffers = kzalloc(TG3_RX_JMB_BUFF_RING_SIZE(tp),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!tpr->rx_jmb_buffers)\n\t\t\tgoto err_out;\n\n\t\ttpr->rx_jmb = dma_alloc_coherent(&tp->pdev->dev,\n\t\t\t\t\t\t TG3_RX_JMB_RING_BYTES(tp),\n\t\t\t\t\t\t &tpr->rx_jmb_mapping,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!tpr->rx_jmb)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\ttg3_rx_prodring_fini(tp, tpr);\n\treturn -ENOMEM;\n}\n\n/* Free up pending packets in all rx/tx rings.\n *\n * The chip has been shut down and the driver detached from\n * the networking, so no interrupts or new tx packets will\n * end up in the driver.  tp->{tx,}lock is not held and we are not\n * in an interrupt context and thus may sleep.\n */\nstatic void tg3_free_rings(struct tg3 *tp)\n{\n\tint i, j;\n\n\tfor (j = 0; j < tp->irq_cnt; j++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[j];\n\n\t\ttg3_rx_prodring_free(tp, &tnapi->prodring);\n\n\t\tif (!tnapi->tx_buffers)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < TG3_TX_RING_SIZE; i++) {\n\t\t\tstruct sk_buff *skb = tnapi->tx_buffers[i].skb;\n\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\n\t\t\ttg3_tx_skb_unmap(tnapi, i,\n\t\t\t\t\t skb_shinfo(skb)->nr_frags - 1);\n\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t\tnetdev_tx_reset_queue(netdev_get_tx_queue(tp->dev, j));\n\t}\n}\n\n/* Initialize tx/rx rings for packet processing.\n *\n * The chip has been shut down and the driver detached from\n * the networking, so no interrupts or new tx packets will\n * end up in the driver.  tp->{tx,}lock are held and thus\n * we may not sleep.\n */\nstatic int tg3_init_rings(struct tg3 *tp)\n{\n\tint i;\n\n\t/* Free up all the SKBs. */\n\ttg3_free_rings(tp);\n\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\ttnapi->last_tag = 0;\n\t\ttnapi->last_irq_tag = 0;\n\t\ttnapi->hw_status->status = 0;\n\t\ttnapi->hw_status->status_tag = 0;\n\t\tmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\n\n\t\ttnapi->tx_prod = 0;\n\t\ttnapi->tx_cons = 0;\n\t\tif (tnapi->tx_ring)\n\t\t\tmemset(tnapi->tx_ring, 0, TG3_TX_RING_BYTES);\n\n\t\ttnapi->rx_rcb_ptr = 0;\n\t\tif (tnapi->rx_rcb)\n\t\t\tmemset(tnapi->rx_rcb, 0, TG3_RX_RCB_RING_BYTES(tp));\n\n\t\tif (tnapi->prodring.rx_std &&\n\t\t    tg3_rx_prodring_alloc(tp, &tnapi->prodring)) {\n\t\t\ttg3_free_rings(tp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tg3_mem_tx_release(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->irq_max; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\tif (tnapi->tx_ring) {\n\t\t\tdma_free_coherent(&tp->pdev->dev, TG3_TX_RING_BYTES,\n\t\t\t\ttnapi->tx_ring, tnapi->tx_desc_mapping);\n\t\t\ttnapi->tx_ring = NULL;\n\t\t}\n\n\t\tkfree(tnapi->tx_buffers);\n\t\ttnapi->tx_buffers = NULL;\n\t}\n}\n\nstatic int tg3_mem_tx_acquire(struct tg3 *tp)\n{\n\tint i;\n\tstruct tg3_napi *tnapi = &tp->napi[0];\n\n\t/* If multivector TSS is enabled, vector 0 does not handle\n\t * tx interrupts.  Don't allocate any resources for it.\n\t */\n\tif (tg3_flag(tp, ENABLE_TSS))\n\t\ttnapi++;\n\n\tfor (i = 0; i < tp->txq_cnt; i++, tnapi++) {\n\t\ttnapi->tx_buffers = kcalloc(TG3_TX_RING_SIZE,\n\t\t\t\t\t    sizeof(struct tg3_tx_ring_info),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!tnapi->tx_buffers)\n\t\t\tgoto err_out;\n\n\t\ttnapi->tx_ring = dma_alloc_coherent(&tp->pdev->dev,\n\t\t\t\t\t\t    TG3_TX_RING_BYTES,\n\t\t\t\t\t\t    &tnapi->tx_desc_mapping,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!tnapi->tx_ring)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\ttg3_mem_tx_release(tp);\n\treturn -ENOMEM;\n}\n\nstatic void tg3_mem_rx_release(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->irq_max; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\ttg3_rx_prodring_fini(tp, &tnapi->prodring);\n\n\t\tif (!tnapi->rx_rcb)\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(&tp->pdev->dev,\n\t\t\t\t  TG3_RX_RCB_RING_BYTES(tp),\n\t\t\t\t  tnapi->rx_rcb,\n\t\t\t\t  tnapi->rx_rcb_mapping);\n\t\ttnapi->rx_rcb = NULL;\n\t}\n}\n\nstatic int tg3_mem_rx_acquire(struct tg3 *tp)\n{\n\tunsigned int i, limit;\n\n\tlimit = tp->rxq_cnt;\n\n\t/* If RSS is enabled, we need a (dummy) producer ring\n\t * set on vector zero.  This is the true hw prodring.\n\t */\n\tif (tg3_flag(tp, ENABLE_RSS))\n\t\tlimit++;\n\n\tfor (i = 0; i < limit; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\tif (tg3_rx_prodring_init(tp, &tnapi->prodring))\n\t\t\tgoto err_out;\n\n\t\t/* If multivector RSS is enabled, vector 0\n\t\t * does not handle rx or tx interrupts.\n\t\t * Don't allocate any resources for it.\n\t\t */\n\t\tif (!i && tg3_flag(tp, ENABLE_RSS))\n\t\t\tcontinue;\n\n\t\ttnapi->rx_rcb = dma_alloc_coherent(&tp->pdev->dev,\n\t\t\t\t\t\t   TG3_RX_RCB_RING_BYTES(tp),\n\t\t\t\t\t\t   &tnapi->rx_rcb_mapping,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!tnapi->rx_rcb)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\ttg3_mem_rx_release(tp);\n\treturn -ENOMEM;\n}\n\n/*\n * Must not be invoked with interrupt sources disabled and\n * the hardware shutdown down.\n */\nstatic void tg3_free_consistent(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\tif (tnapi->hw_status) {\n\t\t\tdma_free_coherent(&tp->pdev->dev, TG3_HW_STATUS_SIZE,\n\t\t\t\t\t  tnapi->hw_status,\n\t\t\t\t\t  tnapi->status_mapping);\n\t\t\ttnapi->hw_status = NULL;\n\t\t}\n\t}\n\n\ttg3_mem_rx_release(tp);\n\ttg3_mem_tx_release(tp);\n\n\t/* tp->hw_stats can be referenced safely:\n\t *     1. under rtnl_lock\n\t *     2. or under tp->lock if TG3_FLAG_INIT_COMPLETE is set.\n\t */\n\tif (tp->hw_stats) {\n\t\tdma_free_coherent(&tp->pdev->dev, sizeof(struct tg3_hw_stats),\n\t\t\t\t  tp->hw_stats, tp->stats_mapping);\n\t\ttp->hw_stats = NULL;\n\t}\n}\n\n/*\n * Must not be invoked with interrupt sources disabled and\n * the hardware shutdown down.  Can sleep.\n */\nstatic int tg3_alloc_consistent(struct tg3 *tp)\n{\n\tint i;\n\n\ttp->hw_stats = dma_alloc_coherent(&tp->pdev->dev,\n\t\t\t\t\t  sizeof(struct tg3_hw_stats),\n\t\t\t\t\t  &tp->stats_mapping, GFP_KERNEL);\n\tif (!tp->hw_stats)\n\t\tgoto err_out;\n\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\t\tstruct tg3_hw_status *sblk;\n\n\t\ttnapi->hw_status = dma_alloc_coherent(&tp->pdev->dev,\n\t\t\t\t\t\t      TG3_HW_STATUS_SIZE,\n\t\t\t\t\t\t      &tnapi->status_mapping,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!tnapi->hw_status)\n\t\t\tgoto err_out;\n\n\t\tsblk = tnapi->hw_status;\n\n\t\tif (tg3_flag(tp, ENABLE_RSS)) {\n\t\t\tu16 *prodptr = NULL;\n\n\t\t\t/*\n\t\t\t * When RSS is enabled, the status block format changes\n\t\t\t * slightly.  The \"rx_jumbo_consumer\", \"reserved\",\n\t\t\t * and \"rx_mini_consumer\" members get mapped to the\n\t\t\t * other three rx return ring producer indexes.\n\t\t\t */\n\t\t\tswitch (i) {\n\t\t\tcase 1:\n\t\t\t\tprodptr = &sblk->idx[0].rx_producer;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tprodptr = &sblk->rx_jumbo_consumer;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tprodptr = &sblk->reserved;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tprodptr = &sblk->rx_mini_consumer;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttnapi->rx_rcb_prod_idx = prodptr;\n\t\t} else {\n\t\t\ttnapi->rx_rcb_prod_idx = &sblk->idx[0].rx_producer;\n\t\t}\n\t}\n\n\tif (tg3_mem_tx_acquire(tp) || tg3_mem_rx_acquire(tp))\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\ttg3_free_consistent(tp);\n\treturn -ENOMEM;\n}\n\n#define MAX_WAIT_CNT 1000\n\n/* To stop a block, clear the enable bit and poll till it\n * clears.  tp->lock is held.\n */\nstatic int tg3_stop_block(struct tg3 *tp, unsigned long ofs, u32 enable_bit, bool silent)\n{\n\tunsigned int i;\n\tu32 val;\n\n\tif (tg3_flag(tp, 5705_PLUS)) {\n\t\tswitch (ofs) {\n\t\tcase RCVLSC_MODE:\n\t\tcase DMAC_MODE:\n\t\tcase MBFREE_MODE:\n\t\tcase BUFMGR_MODE:\n\t\tcase MEMARB_MODE:\n\t\t\t/* We can't enable/disable these bits of the\n\t\t\t * 5705/5750, just say success.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tval = tr32(ofs);\n\tval &= ~enable_bit;\n\ttw32_f(ofs, val);\n\n\tfor (i = 0; i < MAX_WAIT_CNT; i++) {\n\t\tif (pci_channel_offline(tp->pdev)) {\n\t\t\tdev_err(&tp->pdev->dev,\n\t\t\t\t\"tg3_stop_block device offline, \"\n\t\t\t\t\"ofs=%lx enable_bit=%x\\n\",\n\t\t\t\tofs, enable_bit);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tudelay(100);\n\t\tval = tr32(ofs);\n\t\tif ((val & enable_bit) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i == MAX_WAIT_CNT && !silent) {\n\t\tdev_err(&tp->pdev->dev,\n\t\t\t\"tg3_stop_block timed out, ofs=%lx enable_bit=%x\\n\",\n\t\t\tofs, enable_bit);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/* tp->lock is held. */\nstatic int tg3_abort_hw(struct tg3 *tp, bool silent)\n{\n\tint i, err;\n\n\ttg3_disable_ints(tp);\n\n\tif (pci_channel_offline(tp->pdev)) {\n\t\ttp->rx_mode &= ~(RX_MODE_ENABLE | TX_MODE_ENABLE);\n\t\ttp->mac_mode &= ~MAC_MODE_TDE_ENABLE;\n\t\terr = -ENODEV;\n\t\tgoto err_no_dev;\n\t}\n\n\ttp->rx_mode &= ~RX_MODE_ENABLE;\n\ttw32_f(MAC_RX_MODE, tp->rx_mode);\n\tudelay(10);\n\n\terr  = tg3_stop_block(tp, RCVBDI_MODE, RCVBDI_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, RCVLPC_MODE, RCVLPC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, RCVLSC_MODE, RCVLSC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, RCVDBDI_MODE, RCVDBDI_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, RCVDCC_MODE, RCVDCC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, RCVCC_MODE, RCVCC_MODE_ENABLE, silent);\n\n\terr |= tg3_stop_block(tp, SNDBDS_MODE, SNDBDS_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, SNDBDI_MODE, SNDBDI_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, SNDDATAI_MODE, SNDDATAI_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, RDMAC_MODE, RDMAC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, SNDDATAC_MODE, SNDDATAC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, DMAC_MODE, DMAC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, SNDBDC_MODE, SNDBDC_MODE_ENABLE, silent);\n\n\ttp->mac_mode &= ~MAC_MODE_TDE_ENABLE;\n\ttw32_f(MAC_MODE, tp->mac_mode);\n\tudelay(40);\n\n\ttp->tx_mode &= ~TX_MODE_ENABLE;\n\ttw32_f(MAC_TX_MODE, tp->tx_mode);\n\n\tfor (i = 0; i < MAX_WAIT_CNT; i++) {\n\t\tudelay(100);\n\t\tif (!(tr32(MAC_TX_MODE) & TX_MODE_ENABLE))\n\t\t\tbreak;\n\t}\n\tif (i >= MAX_WAIT_CNT) {\n\t\tdev_err(&tp->pdev->dev,\n\t\t\t\"%s timed out, TX_MODE_ENABLE will not clear \"\n\t\t\t\"MAC_TX_MODE=%08x\\n\", __func__, tr32(MAC_TX_MODE));\n\t\terr |= -ENODEV;\n\t}\n\n\terr |= tg3_stop_block(tp, HOSTCC_MODE, HOSTCC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, WDMAC_MODE, WDMAC_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, MBFREE_MODE, MBFREE_MODE_ENABLE, silent);\n\n\ttw32(FTQ_RESET, 0xffffffff);\n\ttw32(FTQ_RESET, 0x00000000);\n\n\terr |= tg3_stop_block(tp, BUFMGR_MODE, BUFMGR_MODE_ENABLE, silent);\n\terr |= tg3_stop_block(tp, MEMARB_MODE, MEMARB_MODE_ENABLE, silent);\n\nerr_no_dev:\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\t\tif (tnapi->hw_status)\n\t\t\tmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\n\t}\n\n\treturn err;\n}\n\n/* Save PCI command register before chip reset */\nstatic void tg3_save_pci_state(struct tg3 *tp)\n{\n\tpci_read_config_word(tp->pdev, PCI_COMMAND, &tp->pci_cmd);\n}\n\n/* Restore PCI state after chip reset */\nstatic void tg3_restore_pci_state(struct tg3 *tp)\n{\n\tu32 val;\n\n\t/* Re-enable indirect register accesses. */\n\tpci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\n\t\t\t       tp->misc_host_ctrl);\n\n\t/* Set MAX PCI retry to zero. */\n\tval = (PCISTATE_ROM_ENABLE | PCISTATE_ROM_RETRY_ENABLE);\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0 &&\n\t    tg3_flag(tp, PCIX_MODE))\n\t\tval |= PCISTATE_RETRY_SAME_DMA;\n\t/* Allow reads and writes to the APE register and memory space. */\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\tval |= PCISTATE_ALLOW_APE_CTLSPC_WR |\n\t\t       PCISTATE_ALLOW_APE_SHMEM_WR |\n\t\t       PCISTATE_ALLOW_APE_PSPACE_WR;\n\tpci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);\n\n\tpci_write_config_word(tp->pdev, PCI_COMMAND, tp->pci_cmd);\n\n\tif (!tg3_flag(tp, PCI_EXPRESS)) {\n\t\tpci_write_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t\t      tp->pci_cacheline_sz);\n\t\tpci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER,\n\t\t\t\t      tp->pci_lat_timer);\n\t}\n\n\t/* Make sure PCI-X relaxed ordering bit is clear. */\n\tif (tg3_flag(tp, PCIX_MODE)) {\n\t\tu16 pcix_cmd;\n\n\t\tpci_read_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t     &pcix_cmd);\n\t\tpcix_cmd &= ~PCI_X_CMD_ERO;\n\t\tpci_write_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t      pcix_cmd);\n\t}\n\n\tif (tg3_flag(tp, 5780_CLASS)) {\n\n\t\t/* Chip reset on 5780 will reset MSI enable bit,\n\t\t * so need to restore it.\n\t\t */\n\t\tif (tg3_flag(tp, USING_MSI)) {\n\t\t\tu16 ctrl;\n\n\t\t\tpci_read_config_word(tp->pdev,\n\t\t\t\t\t     tp->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t\t     &ctrl);\n\t\t\tpci_write_config_word(tp->pdev,\n\t\t\t\t\t      tp->msi_cap + PCI_MSI_FLAGS,\n\t\t\t\t\t      ctrl | PCI_MSI_FLAGS_ENABLE);\n\t\t\tval = tr32(MSGINT_MODE);\n\t\t\ttw32(MSGINT_MODE, val | MSGINT_MODE_ENABLE);\n\t\t}\n\t}\n}\n\nstatic void tg3_override_clk(struct tg3 *tp)\n{\n\tu32 val;\n\n\tswitch (tg3_asic_rev(tp)) {\n\tcase ASIC_REV_5717:\n\t\tval = tr32(TG3_CPMU_CLCK_ORIDE_ENABLE);\n\t\ttw32(TG3_CPMU_CLCK_ORIDE_ENABLE, val |\n\t\t     TG3_CPMU_MAC_ORIDE_ENABLE);\n\t\tbreak;\n\n\tcase ASIC_REV_5719:\n\tcase ASIC_REV_5720:\n\t\ttw32(TG3_CPMU_CLCK_ORIDE, CPMU_CLCK_ORIDE_MAC_ORIDE_EN);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic void tg3_restore_clk(struct tg3 *tp)\n{\n\tu32 val;\n\n\tswitch (tg3_asic_rev(tp)) {\n\tcase ASIC_REV_5717:\n\t\tval = tr32(TG3_CPMU_CLCK_ORIDE_ENABLE);\n\t\ttw32(TG3_CPMU_CLCK_ORIDE_ENABLE,\n\t\t     val & ~TG3_CPMU_MAC_ORIDE_ENABLE);\n\t\tbreak;\n\n\tcase ASIC_REV_5719:\n\tcase ASIC_REV_5720:\n\t\tval = tr32(TG3_CPMU_CLCK_ORIDE);\n\t\ttw32(TG3_CPMU_CLCK_ORIDE, val & ~CPMU_CLCK_ORIDE_MAC_ORIDE_EN);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n}\n\n/* tp->lock is held. */\nstatic int tg3_chip_reset(struct tg3 *tp)\n\t__releases(tp->lock)\n\t__acquires(tp->lock)\n{\n\tu32 val;\n\tvoid (*write_op)(struct tg3 *, u32, u32);\n\tint i, err;\n\n\tif (!pci_device_is_present(tp->pdev))\n\t\treturn -ENODEV;\n\n\ttg3_nvram_lock(tp);\n\n\ttg3_ape_lock(tp, TG3_APE_LOCK_GRC);\n\n\t/* No matching tg3_nvram_unlock() after this because\n\t * chip reset below will undo the nvram lock.\n\t */\n\ttp->nvram_lock_cnt = 0;\n\n\t/* GRC_MISC_CFG core clock reset will clear the memory\n\t * enable bit in PCI register 4 and the MSI enable bit\n\t * on some chips, so we save relevant registers here.\n\t */\n\ttg3_save_pci_state(tp);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5752 ||\n\t    tg3_flag(tp, 5755_PLUS))\n\t\ttw32(GRC_FASTBOOT_PC, 0);\n\n\t/*\n\t * We must avoid the readl() that normally takes place.\n\t * It locks machines, causes machine checks, and other\n\t * fun things.  So, temporarily disable the 5701\n\t * hardware workaround, while we do the reset.\n\t */\n\twrite_op = tp->write32;\n\tif (write_op == tg3_write_flush_reg32)\n\t\ttp->write32 = tg3_write32;\n\n\t/* Prevent the irq handler from reading or writing PCI registers\n\t * during chip reset when the memory enable bit in the PCI command\n\t * register may be cleared.  The chip does not generate interrupt\n\t * at this time, but the irq handler may still be called due to irq\n\t * sharing or irqpoll.\n\t */\n\ttg3_flag_set(tp, CHIP_RESETTING);\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\t\tif (tnapi->hw_status) {\n\t\t\ttnapi->hw_status->status = 0;\n\t\t\ttnapi->hw_status->status_tag = 0;\n\t\t}\n\t\ttnapi->last_tag = 0;\n\t\ttnapi->last_irq_tag = 0;\n\t}\n\tsmp_mb();\n\n\ttg3_full_unlock(tp);\n\n\tfor (i = 0; i < tp->irq_cnt; i++)\n\t\tsynchronize_irq(tp->napi[i].irq_vec);\n\n\ttg3_full_lock(tp, 0);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tval = tr32(TG3_PCIE_LNKCTL) & ~TG3_PCIE_LNKCTL_L1_PLL_PD_EN;\n\t\ttw32(TG3_PCIE_LNKCTL, val | TG3_PCIE_LNKCTL_L1_PLL_PD_DIS);\n\t}\n\n\t/* do the reset */\n\tval = GRC_MISC_CFG_CORECLK_RESET;\n\n\tif (tg3_flag(tp, PCI_EXPRESS)) {\n\t\t/* Force PCIe 1.0a mode */\n\t\tif (tg3_asic_rev(tp) != ASIC_REV_5785 &&\n\t\t    !tg3_flag(tp, 57765_PLUS) &&\n\t\t    tr32(TG3_PCIE_PHY_TSTCTL) ==\n\t\t    (TG3_PCIE_PHY_TSTCTL_PCIE10 | TG3_PCIE_PHY_TSTCTL_PSCRAM))\n\t\t\ttw32(TG3_PCIE_PHY_TSTCTL, TG3_PCIE_PHY_TSTCTL_PSCRAM);\n\n\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0) {\n\t\t\ttw32(GRC_MISC_CFG, (1 << 29));\n\t\t\tval |= (1 << 29);\n\t\t}\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\ttw32(VCPU_STATUS, tr32(VCPU_STATUS) | VCPU_STATUS_DRV_RESET);\n\t\ttw32(GRC_VCPU_EXT_CTRL,\n\t\t     tr32(GRC_VCPU_EXT_CTRL) & ~GRC_VCPU_EXT_CTRL_HALT_CPU);\n\t}\n\n\t/* Set the clock to the highest frequency to avoid timeouts. With link\n\t * aware mode, the clock speed could be slow and bootcode does not\n\t * complete within the expected time. Override the clock to allow the\n\t * bootcode to finish sooner and then restore it.\n\t */\n\ttg3_override_clk(tp);\n\n\t/* Manage gphy power for all CPMU absent PCIe devices. */\n\tif (tg3_flag(tp, 5705_PLUS) && !tg3_flag(tp, CPMU_PRESENT))\n\t\tval |= GRC_MISC_CFG_KEEP_GPHY_POWER;\n\n\ttw32(GRC_MISC_CFG, val);\n\n\t/* restore 5701 hardware bug workaround write method */\n\ttp->write32 = write_op;\n\n\t/* Unfortunately, we have to delay before the PCI read back.\n\t * Some 575X chips even will not respond to a PCI cfg access\n\t * when the reset command is given to the chip.\n\t *\n\t * How do these hardware designers expect things to work\n\t * properly if the PCI write is posted for a long period\n\t * of time?  It is always necessary to have some method by\n\t * which a register read back can occur to push the write\n\t * out which does the reset.\n\t *\n\t * For most tg3 variants the trick below was working.\n\t * Ho hum...\n\t */\n\tudelay(120);\n\n\t/* Flush PCI posted writes.  The normal MMIO registers\n\t * are inaccessible at this time so this is the only\n\t * way to make this reliably (actually, this is no longer\n\t * the case, see above).  I tried to use indirect\n\t * register read/write but this upset some 5701 variants.\n\t */\n\tpci_read_config_dword(tp->pdev, PCI_COMMAND, &val);\n\n\tudelay(120);\n\n\tif (tg3_flag(tp, PCI_EXPRESS) && pci_is_pcie(tp->pdev)) {\n\t\tu16 val16;\n\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5750_A0) {\n\t\t\tint j;\n\t\t\tu32 cfg_val;\n\n\t\t\t/* Wait for link training to complete.  */\n\t\t\tfor (j = 0; j < 5000; j++)\n\t\t\t\tudelay(100);\n\n\t\t\tpci_read_config_dword(tp->pdev, 0xc4, &cfg_val);\n\t\t\tpci_write_config_dword(tp->pdev, 0xc4,\n\t\t\t\t\t       cfg_val | (1 << 15));\n\t\t}\n\n\t\t/* Clear the \"no snoop\" and \"relaxed ordering\" bits. */\n\t\tval16 = PCI_EXP_DEVCTL_RELAX_EN | PCI_EXP_DEVCTL_NOSNOOP_EN;\n\t\t/*\n\t\t * Older PCIe devices only support the 128 byte\n\t\t * MPS setting.  Enforce the restriction.\n\t\t */\n\t\tif (!tg3_flag(tp, CPMU_PRESENT))\n\t\t\tval16 |= PCI_EXP_DEVCTL_PAYLOAD;\n\t\tpcie_capability_clear_word(tp->pdev, PCI_EXP_DEVCTL, val16);\n\n\t\t/* Clear error status */\n\t\tpcie_capability_write_word(tp->pdev, PCI_EXP_DEVSTA,\n\t\t\t\t      PCI_EXP_DEVSTA_CED |\n\t\t\t\t      PCI_EXP_DEVSTA_NFED |\n\t\t\t\t      PCI_EXP_DEVSTA_FED |\n\t\t\t\t      PCI_EXP_DEVSTA_URD);\n\t}\n\n\ttg3_restore_pci_state(tp);\n\n\ttg3_flag_clear(tp, CHIP_RESETTING);\n\ttg3_flag_clear(tp, ERROR_PROCESSED);\n\n\tval = 0;\n\tif (tg3_flag(tp, 5780_CLASS))\n\t\tval = tr32(MEMARB_MODE);\n\ttw32(MEMARB_MODE, val | MEMARB_MODE_ENABLE);\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5750_A3) {\n\t\ttg3_stop_fw(tp);\n\t\ttw32(0x5000, 0x400);\n\t}\n\n\tif (tg3_flag(tp, IS_SSB_CORE)) {\n\t\t/*\n\t\t * BCM4785: In order to avoid repercussions from using\n\t\t * potentially defective internal ROM, stop the Rx RISC CPU,\n\t\t * which is not required.\n\t\t */\n\t\ttg3_stop_fw(tp);\n\t\ttg3_halt_cpu(tp, RX_CPU_BASE);\n\t}\n\n\terr = tg3_poll_fw(tp);\n\tif (err)\n\t\treturn err;\n\n\ttw32(GRC_MODE, tp->grc_mode);\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A0) {\n\t\tval = tr32(0xc4);\n\n\t\ttw32(0xc4, val | (1 << 15));\n\t}\n\n\tif ((tp->nic_sram_data_cfg & NIC_SRAM_DATA_CFG_MINI_PCI) != 0 &&\n\t    tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\ttp->pci_clock_ctrl |= CLOCK_CTRL_CLKRUN_OENABLE;\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A0)\n\t\t\ttp->pci_clock_ctrl |= CLOCK_CTRL_FORCE_CLKRUN;\n\t\ttw32(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);\n\t}\n\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\n\t\ttp->mac_mode = MAC_MODE_PORT_MODE_TBI;\n\t\tval = tp->mac_mode;\n\t} else if (tp->phy_flags & TG3_PHYFLG_MII_SERDES) {\n\t\ttp->mac_mode = MAC_MODE_PORT_MODE_GMII;\n\t\tval = tp->mac_mode;\n\t} else\n\t\tval = 0;\n\n\ttw32_f(MAC_MODE, val);\n\tudelay(40);\n\n\ttg3_ape_unlock(tp, TG3_APE_LOCK_GRC);\n\n\ttg3_mdio_start(tp);\n\n\tif (tg3_flag(tp, PCI_EXPRESS) &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0 &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5785 &&\n\t    !tg3_flag(tp, 57765_PLUS)) {\n\t\tval = tr32(0x7c00);\n\n\t\ttw32(0x7c00, val | (1 << 25));\n\t}\n\n\ttg3_restore_clk(tp);\n\n\t/* Increase the core clock speed to fix tx timeout issue for 5762\n\t * with 100Mbps link speed.\n\t */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5762) {\n\t\tval = tr32(TG3_CPMU_CLCK_ORIDE_ENABLE);\n\t\ttw32(TG3_CPMU_CLCK_ORIDE_ENABLE, val |\n\t\t     TG3_CPMU_MAC_ORIDE_ENABLE);\n\t}\n\n\t/* Reprobe ASF enable state.  */\n\ttg3_flag_clear(tp, ENABLE_ASF);\n\ttp->phy_flags &= ~(TG3_PHYFLG_1G_ON_VAUX_OK |\n\t\t\t   TG3_PHYFLG_KEEP_LINK_ON_PWRDN);\n\n\ttg3_flag_clear(tp, ASF_NEW_HANDSHAKE);\n\ttg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);\n\tif (val == NIC_SRAM_DATA_SIG_MAGIC) {\n\t\tu32 nic_cfg;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);\n\t\tif (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE) {\n\t\t\ttg3_flag_set(tp, ENABLE_ASF);\n\t\t\ttp->last_event_jiffies = jiffies;\n\t\t\tif (tg3_flag(tp, 5750_PLUS))\n\t\t\t\ttg3_flag_set(tp, ASF_NEW_HANDSHAKE);\n\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_3, &nic_cfg);\n\t\t\tif (nic_cfg & NIC_SRAM_1G_ON_VAUX_OK)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_1G_ON_VAUX_OK;\n\t\t\tif (nic_cfg & NIC_SRAM_LNK_FLAP_AVOID)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_KEEP_LINK_ON_PWRDN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tg3_get_nstats(struct tg3 *, struct rtnl_link_stats64 *);\nstatic void tg3_get_estats(struct tg3 *, struct tg3_ethtool_stats *);\nstatic void __tg3_set_rx_mode(struct net_device *);\n\n/* tp->lock is held. */\nstatic int tg3_halt(struct tg3 *tp, int kind, bool silent)\n{\n\tint err;\n\n\ttg3_stop_fw(tp);\n\n\ttg3_write_sig_pre_reset(tp, kind);\n\n\ttg3_abort_hw(tp, silent);\n\terr = tg3_chip_reset(tp);\n\n\t__tg3_set_mac_addr(tp, false);\n\n\ttg3_write_sig_legacy(tp, kind);\n\ttg3_write_sig_post_reset(tp, kind);\n\n\tif (tp->hw_stats) {\n\t\t/* Save the stats across chip resets... */\n\t\ttg3_get_nstats(tp, &tp->net_stats_prev);\n\t\ttg3_get_estats(tp, &tp->estats_prev);\n\n\t\t/* And make sure the next sample is new data */\n\t\tmemset(tp->hw_stats, 0, sizeof(struct tg3_hw_stats));\n\t}\n\n\treturn err;\n}\n\nstatic int tg3_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tint err = 0;\n\tbool skip_mac_1 = false;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\tif (tg3_flag(tp, ENABLE_ASF)) {\n\t\tu32 addr0_high, addr0_low, addr1_high, addr1_low;\n\n\t\taddr0_high = tr32(MAC_ADDR_0_HIGH);\n\t\taddr0_low = tr32(MAC_ADDR_0_LOW);\n\t\taddr1_high = tr32(MAC_ADDR_1_HIGH);\n\t\taddr1_low = tr32(MAC_ADDR_1_LOW);\n\n\t\t/* Skip MAC addr 1 if ASF is using it. */\n\t\tif ((addr0_high != addr1_high || addr0_low != addr1_low) &&\n\t\t    !(addr1_high == 0 && addr1_low == 0))\n\t\t\tskip_mac_1 = true;\n\t}\n\tspin_lock_bh(&tp->lock);\n\t__tg3_set_mac_addr(tp, skip_mac_1);\n\t__tg3_set_rx_mode(dev);\n\tspin_unlock_bh(&tp->lock);\n\n\treturn err;\n}\n\n/* tp->lock is held. */\nstatic void tg3_set_bdinfo(struct tg3 *tp, u32 bdinfo_addr,\n\t\t\t   dma_addr_t mapping, u32 maxlen_flags,\n\t\t\t   u32 nic_addr)\n{\n\ttg3_write_mem(tp,\n\t\t      (bdinfo_addr + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH),\n\t\t      ((u64) mapping >> 32));\n\ttg3_write_mem(tp,\n\t\t      (bdinfo_addr + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW),\n\t\t      ((u64) mapping & 0xffffffff));\n\ttg3_write_mem(tp,\n\t\t      (bdinfo_addr + TG3_BDINFO_MAXLEN_FLAGS),\n\t\t       maxlen_flags);\n\n\tif (!tg3_flag(tp, 5705_PLUS))\n\t\ttg3_write_mem(tp,\n\t\t\t      (bdinfo_addr + TG3_BDINFO_NIC_ADDR),\n\t\t\t      nic_addr);\n}\n\n\nstatic void tg3_coal_tx_init(struct tg3 *tp, struct ethtool_coalesce *ec)\n{\n\tint i = 0;\n\n\tif (!tg3_flag(tp, ENABLE_TSS)) {\n\t\ttw32(HOSTCC_TXCOL_TICKS, ec->tx_coalesce_usecs);\n\t\ttw32(HOSTCC_TXMAX_FRAMES, ec->tx_max_coalesced_frames);\n\t\ttw32(HOSTCC_TXCOAL_MAXF_INT, ec->tx_max_coalesced_frames_irq);\n\t} else {\n\t\ttw32(HOSTCC_TXCOL_TICKS, 0);\n\t\ttw32(HOSTCC_TXMAX_FRAMES, 0);\n\t\ttw32(HOSTCC_TXCOAL_MAXF_INT, 0);\n\n\t\tfor (; i < tp->txq_cnt; i++) {\n\t\t\tu32 reg;\n\n\t\t\treg = HOSTCC_TXCOL_TICKS_VEC1 + i * 0x18;\n\t\t\ttw32(reg, ec->tx_coalesce_usecs);\n\t\t\treg = HOSTCC_TXMAX_FRAMES_VEC1 + i * 0x18;\n\t\t\ttw32(reg, ec->tx_max_coalesced_frames);\n\t\t\treg = HOSTCC_TXCOAL_MAXF_INT_VEC1 + i * 0x18;\n\t\t\ttw32(reg, ec->tx_max_coalesced_frames_irq);\n\t\t}\n\t}\n\n\tfor (; i < tp->irq_max - 1; i++) {\n\t\ttw32(HOSTCC_TXCOL_TICKS_VEC1 + i * 0x18, 0);\n\t\ttw32(HOSTCC_TXMAX_FRAMES_VEC1 + i * 0x18, 0);\n\t\ttw32(HOSTCC_TXCOAL_MAXF_INT_VEC1 + i * 0x18, 0);\n\t}\n}\n\nstatic void tg3_coal_rx_init(struct tg3 *tp, struct ethtool_coalesce *ec)\n{\n\tint i = 0;\n\tu32 limit = tp->rxq_cnt;\n\n\tif (!tg3_flag(tp, ENABLE_RSS)) {\n\t\ttw32(HOSTCC_RXCOL_TICKS, ec->rx_coalesce_usecs);\n\t\ttw32(HOSTCC_RXMAX_FRAMES, ec->rx_max_coalesced_frames);\n\t\ttw32(HOSTCC_RXCOAL_MAXF_INT, ec->rx_max_coalesced_frames_irq);\n\t\tlimit--;\n\t} else {\n\t\ttw32(HOSTCC_RXCOL_TICKS, 0);\n\t\ttw32(HOSTCC_RXMAX_FRAMES, 0);\n\t\ttw32(HOSTCC_RXCOAL_MAXF_INT, 0);\n\t}\n\n\tfor (; i < limit; i++) {\n\t\tu32 reg;\n\n\t\treg = HOSTCC_RXCOL_TICKS_VEC1 + i * 0x18;\n\t\ttw32(reg, ec->rx_coalesce_usecs);\n\t\treg = HOSTCC_RXMAX_FRAMES_VEC1 + i * 0x18;\n\t\ttw32(reg, ec->rx_max_coalesced_frames);\n\t\treg = HOSTCC_RXCOAL_MAXF_INT_VEC1 + i * 0x18;\n\t\ttw32(reg, ec->rx_max_coalesced_frames_irq);\n\t}\n\n\tfor (; i < tp->irq_max - 1; i++) {\n\t\ttw32(HOSTCC_RXCOL_TICKS_VEC1 + i * 0x18, 0);\n\t\ttw32(HOSTCC_RXMAX_FRAMES_VEC1 + i * 0x18, 0);\n\t\ttw32(HOSTCC_RXCOAL_MAXF_INT_VEC1 + i * 0x18, 0);\n\t}\n}\n\nstatic void __tg3_set_coalesce(struct tg3 *tp, struct ethtool_coalesce *ec)\n{\n\ttg3_coal_tx_init(tp, ec);\n\ttg3_coal_rx_init(tp, ec);\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\tu32 val = ec->stats_block_coalesce_usecs;\n\n\t\ttw32(HOSTCC_RXCOAL_TICK_INT, ec->rx_coalesce_usecs_irq);\n\t\ttw32(HOSTCC_TXCOAL_TICK_INT, ec->tx_coalesce_usecs_irq);\n\n\t\tif (!tp->link_up)\n\t\t\tval = 0;\n\n\t\ttw32(HOSTCC_STAT_COAL_TICKS, val);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_tx_rcbs_disable(struct tg3 *tp)\n{\n\tu32 txrcb, limit;\n\n\t/* Disable all transmit rings but the first. */\n\tif (!tg3_flag(tp, 5705_PLUS))\n\t\tlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE * 16;\n\telse if (tg3_flag(tp, 5717_PLUS))\n\t\tlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE * 4;\n\telse if (tg3_flag(tp, 57765_CLASS) ||\n\t\t tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\tlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE * 2;\n\telse\n\t\tlimit = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE;\n\n\tfor (txrcb = NIC_SRAM_SEND_RCB + TG3_BDINFO_SIZE;\n\t     txrcb < limit; txrcb += TG3_BDINFO_SIZE)\n\t\ttg3_write_mem(tp, txrcb + TG3_BDINFO_MAXLEN_FLAGS,\n\t\t\t      BDINFO_FLAGS_DISABLED);\n}\n\n/* tp->lock is held. */\nstatic void tg3_tx_rcbs_init(struct tg3 *tp)\n{\n\tint i = 0;\n\tu32 txrcb = NIC_SRAM_SEND_RCB;\n\n\tif (tg3_flag(tp, ENABLE_TSS))\n\t\ti++;\n\n\tfor (; i < tp->irq_max; i++, txrcb += TG3_BDINFO_SIZE) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\tif (!tnapi->tx_ring)\n\t\t\tcontinue;\n\n\t\ttg3_set_bdinfo(tp, txrcb, tnapi->tx_desc_mapping,\n\t\t\t       (TG3_TX_RING_SIZE << BDINFO_FLAGS_MAXLEN_SHIFT),\n\t\t\t       NIC_SRAM_TX_BUFFER_DESC);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_rx_ret_rcbs_disable(struct tg3 *tp)\n{\n\tu32 rxrcb, limit;\n\n\t/* Disable all receive return rings but the first. */\n\tif (tg3_flag(tp, 5717_PLUS))\n\t\tlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE * 17;\n\telse if (!tg3_flag(tp, 5705_PLUS))\n\t\tlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE * 16;\n\telse if (tg3_asic_rev(tp) == ASIC_REV_5755 ||\n\t\t tg3_asic_rev(tp) == ASIC_REV_5762 ||\n\t\t tg3_flag(tp, 57765_CLASS))\n\t\tlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE * 4;\n\telse\n\t\tlimit = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE;\n\n\tfor (rxrcb = NIC_SRAM_RCV_RET_RCB + TG3_BDINFO_SIZE;\n\t     rxrcb < limit; rxrcb += TG3_BDINFO_SIZE)\n\t\ttg3_write_mem(tp, rxrcb + TG3_BDINFO_MAXLEN_FLAGS,\n\t\t\t      BDINFO_FLAGS_DISABLED);\n}\n\n/* tp->lock is held. */\nstatic void tg3_rx_ret_rcbs_init(struct tg3 *tp)\n{\n\tint i = 0;\n\tu32 rxrcb = NIC_SRAM_RCV_RET_RCB;\n\n\tif (tg3_flag(tp, ENABLE_RSS))\n\t\ti++;\n\n\tfor (; i < tp->irq_max; i++, rxrcb += TG3_BDINFO_SIZE) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\tif (!tnapi->rx_rcb)\n\t\t\tcontinue;\n\n\t\ttg3_set_bdinfo(tp, rxrcb, tnapi->rx_rcb_mapping,\n\t\t\t       (tp->rx_ret_ring_mask + 1) <<\n\t\t\t\tBDINFO_FLAGS_MAXLEN_SHIFT, 0);\n\t}\n}\n\n/* tp->lock is held. */\nstatic void tg3_rings_reset(struct tg3 *tp)\n{\n\tint i;\n\tu32 stblk;\n\tstruct tg3_napi *tnapi = &tp->napi[0];\n\n\ttg3_tx_rcbs_disable(tp);\n\n\ttg3_rx_ret_rcbs_disable(tp);\n\n\t/* Disable interrupts */\n\ttw32_mailbox_f(tp->napi[0].int_mbox, 1);\n\ttp->napi[0].chk_msi_cnt = 0;\n\ttp->napi[0].last_rx_cons = 0;\n\ttp->napi[0].last_tx_cons = 0;\n\n\t/* Zero mailbox registers. */\n\tif (tg3_flag(tp, SUPPORT_MSIX)) {\n\t\tfor (i = 1; i < tp->irq_max; i++) {\n\t\t\ttp->napi[i].tx_prod = 0;\n\t\t\ttp->napi[i].tx_cons = 0;\n\t\t\tif (tg3_flag(tp, ENABLE_TSS))\n\t\t\t\ttw32_mailbox(tp->napi[i].prodmbox, 0);\n\t\t\ttw32_rx_mbox(tp->napi[i].consmbox, 0);\n\t\t\ttw32_mailbox_f(tp->napi[i].int_mbox, 1);\n\t\t\ttp->napi[i].chk_msi_cnt = 0;\n\t\t\ttp->napi[i].last_rx_cons = 0;\n\t\t\ttp->napi[i].last_tx_cons = 0;\n\t\t}\n\t\tif (!tg3_flag(tp, ENABLE_TSS))\n\t\t\ttw32_mailbox(tp->napi[0].prodmbox, 0);\n\t} else {\n\t\ttp->napi[0].tx_prod = 0;\n\t\ttp->napi[0].tx_cons = 0;\n\t\ttw32_mailbox(tp->napi[0].prodmbox, 0);\n\t\ttw32_rx_mbox(tp->napi[0].consmbox, 0);\n\t}\n\n\t/* Make sure the NIC-based send BD rings are disabled. */\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\tu32 mbox = MAILBOX_SNDNIC_PROD_IDX_0 + TG3_64BIT_REG_LOW;\n\t\tfor (i = 0; i < 16; i++)\n\t\t\ttw32_tx_mbox(mbox + i * 8, 0);\n\t}\n\n\t/* Clear status block in ram. */\n\tmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\n\n\t/* Set status block DMA address */\n\ttw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,\n\t     ((u64) tnapi->status_mapping >> 32));\n\ttw32(HOSTCC_STATUS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,\n\t     ((u64) tnapi->status_mapping & 0xffffffff));\n\n\tstblk = HOSTCC_STATBLCK_RING1;\n\n\tfor (i = 1, tnapi++; i < tp->irq_cnt; i++, tnapi++) {\n\t\tu64 mapping = (u64)tnapi->status_mapping;\n\t\ttw32(stblk + TG3_64BIT_REG_HIGH, mapping >> 32);\n\t\ttw32(stblk + TG3_64BIT_REG_LOW, mapping & 0xffffffff);\n\t\tstblk += 8;\n\n\t\t/* Clear status block in ram. */\n\t\tmemset(tnapi->hw_status, 0, TG3_HW_STATUS_SIZE);\n\t}\n\n\ttg3_tx_rcbs_init(tp);\n\ttg3_rx_ret_rcbs_init(tp);\n}\n\nstatic void tg3_setup_rxbd_thresholds(struct tg3 *tp)\n{\n\tu32 val, bdcache_maxcnt, host_rep_thresh, nic_rep_thresh;\n\n\tif (!tg3_flag(tp, 5750_PLUS) ||\n\t    tg3_flag(tp, 5780_CLASS) ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5750 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5752 ||\n\t    tg3_flag(tp, 57765_PLUS))\n\t\tbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5700;\n\telse if (tg3_asic_rev(tp) == ASIC_REV_5755 ||\n\t\t tg3_asic_rev(tp) == ASIC_REV_5787)\n\t\tbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5755;\n\telse\n\t\tbdcache_maxcnt = TG3_SRAM_RX_STD_BDCACHE_SIZE_5906;\n\n\tnic_rep_thresh = min(bdcache_maxcnt / 2, tp->rx_std_max_post);\n\thost_rep_thresh = max_t(u32, tp->rx_pending / 8, 1);\n\n\tval = min(nic_rep_thresh, host_rep_thresh);\n\ttw32(RCVBDI_STD_THRESH, val);\n\n\tif (tg3_flag(tp, 57765_PLUS))\n\t\ttw32(STD_REPLENISH_LWM, bdcache_maxcnt);\n\n\tif (!tg3_flag(tp, JUMBO_CAPABLE) || tg3_flag(tp, 5780_CLASS))\n\t\treturn;\n\n\tbdcache_maxcnt = TG3_SRAM_RX_JMB_BDCACHE_SIZE_5700;\n\n\thost_rep_thresh = max_t(u32, tp->rx_jumbo_pending / 8, 1);\n\n\tval = min(bdcache_maxcnt / 2, host_rep_thresh);\n\ttw32(RCVBDI_JUMBO_THRESH, val);\n\n\tif (tg3_flag(tp, 57765_PLUS))\n\t\ttw32(JMB_REPLENISH_LWM, bdcache_maxcnt);\n}\n\nstatic inline u32 calc_crc(unsigned char *buf, int len)\n{\n\tu32 reg;\n\tu32 tmp;\n\tint j, k;\n\n\treg = 0xffffffff;\n\n\tfor (j = 0; j < len; j++) {\n\t\treg ^= buf[j];\n\n\t\tfor (k = 0; k < 8; k++) {\n\t\t\ttmp = reg & 0x01;\n\n\t\t\treg >>= 1;\n\n\t\t\tif (tmp)\n\t\t\t\treg ^= CRC32_POLY_LE;\n\t\t}\n\t}\n\n\treturn ~reg;\n}\n\nstatic void tg3_set_multi(struct tg3 *tp, unsigned int accept_all)\n{\n\t/* accept or reject all multicast frames */\n\ttw32(MAC_HASH_REG_0, accept_all ? 0xffffffff : 0);\n\ttw32(MAC_HASH_REG_1, accept_all ? 0xffffffff : 0);\n\ttw32(MAC_HASH_REG_2, accept_all ? 0xffffffff : 0);\n\ttw32(MAC_HASH_REG_3, accept_all ? 0xffffffff : 0);\n}\n\nstatic void __tg3_set_rx_mode(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tu32 rx_mode;\n\n\trx_mode = tp->rx_mode & ~(RX_MODE_PROMISC |\n\t\t\t\t  RX_MODE_KEEP_VLAN_TAG);\n\n#if !defined(CONFIG_VLAN_8021Q) && !defined(CONFIG_VLAN_8021Q_MODULE)\n\t/* When ASF is in use, we always keep the RX_MODE_KEEP_VLAN_TAG\n\t * flag clear.\n\t */\n\tif (!tg3_flag(tp, ENABLE_ASF))\n\t\trx_mode |= RX_MODE_KEEP_VLAN_TAG;\n#endif\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t/* Promiscuous mode. */\n\t\trx_mode |= RX_MODE_PROMISC;\n\t} else if (dev->flags & IFF_ALLMULTI) {\n\t\t/* Accept all multicast. */\n\t\ttg3_set_multi(tp, 1);\n\t} else if (netdev_mc_empty(dev)) {\n\t\t/* Reject all multicast. */\n\t\ttg3_set_multi(tp, 0);\n\t} else {\n\t\t/* Accept one or more multicast(s). */\n\t\tstruct netdev_hw_addr *ha;\n\t\tu32 mc_filter[4] = { 0, };\n\t\tu32 regidx;\n\t\tu32 bit;\n\t\tu32 crc;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tcrc = calc_crc(ha->addr, ETH_ALEN);\n\t\t\tbit = ~crc & 0x7f;\n\t\t\tregidx = (bit & 0x60) >> 5;\n\t\t\tbit &= 0x1f;\n\t\t\tmc_filter[regidx] |= (1 << bit);\n\t\t}\n\n\t\ttw32(MAC_HASH_REG_0, mc_filter[0]);\n\t\ttw32(MAC_HASH_REG_1, mc_filter[1]);\n\t\ttw32(MAC_HASH_REG_2, mc_filter[2]);\n\t\ttw32(MAC_HASH_REG_3, mc_filter[3]);\n\t}\n\n\tif (netdev_uc_count(dev) > TG3_MAX_UCAST_ADDR(tp)) {\n\t\trx_mode |= RX_MODE_PROMISC;\n\t} else if (!(dev->flags & IFF_PROMISC)) {\n\t\t/* Add all entries into to the mac addr filter list */\n\t\tint i = 0;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\t__tg3_set_one_mac_addr(tp, ha->addr,\n\t\t\t\t\t       i + TG3_UCAST_ADDR_IDX(tp));\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (rx_mode != tp->rx_mode) {\n\t\ttp->rx_mode = rx_mode;\n\t\ttw32_f(MAC_RX_MODE, rx_mode);\n\t\tudelay(10);\n\t}\n}\n\nstatic void tg3_rss_init_dflt_indir_tbl(struct tg3 *tp, u32 qcnt)\n{\n\tint i;\n\n\tfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\n\t\ttp->rss_ind_tbl[i] = ethtool_rxfh_indir_default(i, qcnt);\n}\n\nstatic void tg3_rss_check_indir_tbl(struct tg3 *tp)\n{\n\tint i;\n\n\tif (!tg3_flag(tp, SUPPORT_MSIX))\n\t\treturn;\n\n\tif (tp->rxq_cnt == 1) {\n\t\tmemset(&tp->rss_ind_tbl[0], 0, sizeof(tp->rss_ind_tbl));\n\t\treturn;\n\t}\n\n\t/* Validate table against current IRQ count */\n\tfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++) {\n\t\tif (tp->rss_ind_tbl[i] >= tp->rxq_cnt)\n\t\t\tbreak;\n\t}\n\n\tif (i != TG3_RSS_INDIR_TBL_SIZE)\n\t\ttg3_rss_init_dflt_indir_tbl(tp, tp->rxq_cnt);\n}\n\nstatic void tg3_rss_write_indir_tbl(struct tg3 *tp)\n{\n\tint i = 0;\n\tu32 reg = MAC_RSS_INDIR_TBL_0;\n\n\twhile (i < TG3_RSS_INDIR_TBL_SIZE) {\n\t\tu32 val = tp->rss_ind_tbl[i];\n\t\ti++;\n\t\tfor (; i % 8; i++) {\n\t\t\tval <<= 4;\n\t\t\tval |= tp->rss_ind_tbl[i];\n\t\t}\n\t\ttw32(reg, val);\n\t\treg += 4;\n\t}\n}\n\nstatic inline u32 tg3_lso_rd_dma_workaround_bit(struct tg3 *tp)\n{\n\tif (tg3_asic_rev(tp) == ASIC_REV_5719)\n\t\treturn TG3_LSO_RD_DMA_TX_LENGTH_WA_5719;\n\telse\n\t\treturn TG3_LSO_RD_DMA_TX_LENGTH_WA_5720;\n}\n\n/* tp->lock is held. */\nstatic int tg3_reset_hw(struct tg3 *tp, bool reset_phy)\n{\n\tu32 val, rdmac_mode;\n\tint i, err, limit;\n\tstruct tg3_rx_prodring_set *tpr = &tp->napi[0].prodring;\n\n\ttg3_disable_ints(tp);\n\n\ttg3_stop_fw(tp);\n\n\ttg3_write_sig_pre_reset(tp, RESET_KIND_INIT);\n\n\tif (tg3_flag(tp, INIT_COMPLETE))\n\t\ttg3_abort_hw(tp, 1);\n\n\tif ((tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN) &&\n\t    !(tp->phy_flags & TG3_PHYFLG_USER_CONFIGURED)) {\n\t\ttg3_phy_pull_config(tp);\n\t\ttg3_eee_pull_config(tp, NULL);\n\t\ttp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\n\t}\n\n\t/* Enable MAC control of LPI */\n\tif (tp->phy_flags & TG3_PHYFLG_EEE_CAP)\n\t\ttg3_setup_eee(tp);\n\n\tif (reset_phy)\n\t\ttg3_phy_reset(tp);\n\n\terr = tg3_chip_reset(tp);\n\tif (err)\n\t\treturn err;\n\n\ttg3_write_sig_legacy(tp, RESET_KIND_INIT);\n\n\tif (tg3_chip_rev(tp) == CHIPREV_5784_AX) {\n\t\tval = tr32(TG3_CPMU_CTRL);\n\t\tval &= ~(CPMU_CTRL_LINK_AWARE_MODE | CPMU_CTRL_LINK_IDLE_MODE);\n\t\ttw32(TG3_CPMU_CTRL, val);\n\n\t\tval = tr32(TG3_CPMU_LSPD_10MB_CLK);\n\t\tval &= ~CPMU_LSPD_10MB_MACCLK_MASK;\n\t\tval |= CPMU_LSPD_10MB_MACCLK_6_25;\n\t\ttw32(TG3_CPMU_LSPD_10MB_CLK, val);\n\n\t\tval = tr32(TG3_CPMU_LNK_AWARE_PWRMD);\n\t\tval &= ~CPMU_LNK_AWARE_MACCLK_MASK;\n\t\tval |= CPMU_LNK_AWARE_MACCLK_6_25;\n\t\ttw32(TG3_CPMU_LNK_AWARE_PWRMD, val);\n\n\t\tval = tr32(TG3_CPMU_HST_ACC);\n\t\tval &= ~CPMU_HST_ACC_MACCLK_MASK;\n\t\tval |= CPMU_HST_ACC_MACCLK_6_25;\n\t\ttw32(TG3_CPMU_HST_ACC, val);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tval = tr32(PCIE_PWR_MGMT_THRESH) & ~PCIE_PWR_MGMT_L1_THRESH_MSK;\n\t\tval |= PCIE_PWR_MGMT_EXT_ASPM_TMR_EN |\n\t\t       PCIE_PWR_MGMT_L1_THRESH_4MS;\n\t\ttw32(PCIE_PWR_MGMT_THRESH, val);\n\n\t\tval = tr32(TG3_PCIE_EIDLE_DELAY) & ~TG3_PCIE_EIDLE_DELAY_MASK;\n\t\ttw32(TG3_PCIE_EIDLE_DELAY, val | TG3_PCIE_EIDLE_DELAY_13_CLKS);\n\n\t\ttw32(TG3_CORR_ERR_STAT, TG3_CORR_ERR_STAT_CLEAR);\n\n\t\tval = tr32(TG3_PCIE_LNKCTL) & ~TG3_PCIE_LNKCTL_L1_PLL_PD_EN;\n\t\ttw32(TG3_PCIE_LNKCTL, val | TG3_PCIE_LNKCTL_L1_PLL_PD_DIS);\n\t}\n\n\tif (tg3_flag(tp, L1PLLPD_EN)) {\n\t\tu32 grc_mode = tr32(GRC_MODE);\n\n\t\t/* Access the lower 1K of PL PCIE block registers. */\n\t\tval = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;\n\t\ttw32(GRC_MODE, val | GRC_MODE_PCIE_PL_SEL);\n\n\t\tval = tr32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL1);\n\t\ttw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL1,\n\t\t     val | TG3_PCIE_PL_LO_PHYCTL1_L1PLLPD_EN);\n\n\t\ttw32(GRC_MODE, grc_mode);\n\t}\n\n\tif (tg3_flag(tp, 57765_CLASS)) {\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0) {\n\t\t\tu32 grc_mode = tr32(GRC_MODE);\n\n\t\t\t/* Access the lower 1K of PL PCIE block registers. */\n\t\t\tval = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;\n\t\t\ttw32(GRC_MODE, val | GRC_MODE_PCIE_PL_SEL);\n\n\t\t\tval = tr32(TG3_PCIE_TLDLPL_PORT +\n\t\t\t\t   TG3_PCIE_PL_LO_PHYCTL5);\n\t\t\ttw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL5,\n\t\t\t     val | TG3_PCIE_PL_LO_PHYCTL5_DIS_L2CLKREQ);\n\n\t\t\ttw32(GRC_MODE, grc_mode);\n\t\t}\n\n\t\tif (tg3_chip_rev(tp) != CHIPREV_57765_AX) {\n\t\t\tu32 grc_mode;\n\n\t\t\t/* Fix transmit hangs */\n\t\t\tval = tr32(TG3_CPMU_PADRNG_CTL);\n\t\t\tval |= TG3_CPMU_PADRNG_CTL_RDIV2;\n\t\t\ttw32(TG3_CPMU_PADRNG_CTL, val);\n\n\t\t\tgrc_mode = tr32(GRC_MODE);\n\n\t\t\t/* Access the lower 1K of DL PCIE block registers. */\n\t\t\tval = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;\n\t\t\ttw32(GRC_MODE, val | GRC_MODE_PCIE_DL_SEL);\n\n\t\t\tval = tr32(TG3_PCIE_TLDLPL_PORT +\n\t\t\t\t   TG3_PCIE_DL_LO_FTSMAX);\n\t\t\tval &= ~TG3_PCIE_DL_LO_FTSMAX_MSK;\n\t\t\ttw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_DL_LO_FTSMAX,\n\t\t\t     val | TG3_PCIE_DL_LO_FTSMAX_VAL);\n\n\t\t\ttw32(GRC_MODE, grc_mode);\n\t\t}\n\n\t\tval = tr32(TG3_CPMU_LSPD_10MB_CLK);\n\t\tval &= ~CPMU_LSPD_10MB_MACCLK_MASK;\n\t\tval |= CPMU_LSPD_10MB_MACCLK_6_25;\n\t\ttw32(TG3_CPMU_LSPD_10MB_CLK, val);\n\t}\n\n\t/* This works around an issue with Athlon chipsets on\n\t * B3 tigon3 silicon.  This bit has no effect on any\n\t * other revision.  But do not set this on PCI Express\n\t * chips and don't even touch the clocks if the CPMU is present.\n\t */\n\tif (!tg3_flag(tp, CPMU_PRESENT)) {\n\t\tif (!tg3_flag(tp, PCI_EXPRESS))\n\t\t\ttp->pci_clock_ctrl |= CLOCK_CTRL_DELAY_PCI_GRANT;\n\t\ttw32_f(TG3PCI_CLOCK_CTRL, tp->pci_clock_ctrl);\n\t}\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0 &&\n\t    tg3_flag(tp, PCIX_MODE)) {\n\t\tval = tr32(TG3PCI_PCISTATE);\n\t\tval |= PCISTATE_RETRY_SAME_DMA;\n\t\ttw32(TG3PCI_PCISTATE, val);\n\t}\n\n\tif (tg3_flag(tp, ENABLE_APE)) {\n\t\t/* Allow reads and writes to the\n\t\t * APE register and memory space.\n\t\t */\n\t\tval = tr32(TG3PCI_PCISTATE);\n\t\tval |= PCISTATE_ALLOW_APE_CTLSPC_WR |\n\t\t       PCISTATE_ALLOW_APE_SHMEM_WR |\n\t\t       PCISTATE_ALLOW_APE_PSPACE_WR;\n\t\ttw32(TG3PCI_PCISTATE, val);\n\t}\n\n\tif (tg3_chip_rev(tp) == CHIPREV_5704_BX) {\n\t\t/* Enable some hw fixes.  */\n\t\tval = tr32(TG3PCI_MSI_DATA);\n\t\tval |= (1 << 26) | (1 << 28) | (1 << 29);\n\t\ttw32(TG3PCI_MSI_DATA, val);\n\t}\n\n\t/* Descriptor ring init may make accesses to the\n\t * NIC SRAM area to setup the TX descriptors, so we\n\t * can only do this after the hardware has been\n\t * successfully reset.\n\t */\n\terr = tg3_init_rings(tp);\n\tif (err)\n\t\treturn err;\n\n\tif (tg3_flag(tp, 57765_PLUS)) {\n\t\tval = tr32(TG3PCI_DMA_RW_CTRL) &\n\t\t      ~DMA_RWCTRL_DIS_CACHE_ALIGNMENT;\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_57765_A0)\n\t\t\tval &= ~DMA_RWCTRL_CRDRDR_RDMA_MRRS_MSK;\n\t\tif (!tg3_flag(tp, 57765_CLASS) &&\n\t\t    tg3_asic_rev(tp) != ASIC_REV_5717 &&\n\t\t    tg3_asic_rev(tp) != ASIC_REV_5762)\n\t\t\tval |= DMA_RWCTRL_TAGGED_STAT_WA;\n\t\ttw32(TG3PCI_DMA_RW_CTRL, val | tp->dma_rwctrl);\n\t} else if (tg3_asic_rev(tp) != ASIC_REV_5784 &&\n\t\t   tg3_asic_rev(tp) != ASIC_REV_5761) {\n\t\t/* This value is determined during the probe time DMA\n\t\t * engine test, tg3_test_dma.\n\t\t */\n\t\ttw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\n\t}\n\n\ttp->grc_mode &= ~(GRC_MODE_HOST_SENDBDS |\n\t\t\t  GRC_MODE_4X_NIC_SEND_RINGS |\n\t\t\t  GRC_MODE_NO_TX_PHDR_CSUM |\n\t\t\t  GRC_MODE_NO_RX_PHDR_CSUM);\n\ttp->grc_mode |= GRC_MODE_HOST_SENDBDS;\n\n\t/* Pseudo-header checksum is done by hardware logic and not\n\t * the offload processers, so make the chip do the pseudo-\n\t * header checksums on receive.  For transmit it is more\n\t * convenient to do the pseudo-header checksum in software\n\t * as Linux does that on transmit for us in all cases.\n\t */\n\ttp->grc_mode |= GRC_MODE_NO_TX_PHDR_CSUM;\n\n\tval = GRC_MODE_IRQ_ON_MAC_ATTN | GRC_MODE_HOST_STACKUP;\n\tif (tp->rxptpctl)\n\t\ttw32(TG3_RX_PTP_CTL,\n\t\t     tp->rxptpctl | TG3_RX_PTP_CTL_HWTS_INTERLOCK);\n\n\tif (tg3_flag(tp, PTP_CAPABLE))\n\t\tval |= GRC_MODE_TIME_SYNC_ENABLE;\n\n\ttw32(GRC_MODE, tp->grc_mode | val);\n\n\t/* On one of the AMD platform, MRRS is restricted to 4000 because of\n\t * south bridge limitation. As a workaround, Driver is setting MRRS\n\t * to 2048 instead of default 4096.\n\t */\n\tif (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&\n\t    tp->pdev->subsystem_device == TG3PCI_SUBDEVICE_ID_DELL_5762) {\n\t\tval = tr32(TG3PCI_DEV_STATUS_CTRL) & ~MAX_READ_REQ_MASK;\n\t\ttw32(TG3PCI_DEV_STATUS_CTRL, val | MAX_READ_REQ_SIZE_2048);\n\t}\n\n\t/* Setup the timer prescalar register.  Clock is always 66Mhz. */\n\tval = tr32(GRC_MISC_CFG);\n\tval &= ~0xff;\n\tval |= (65 << GRC_MISC_CFG_PRESCALAR_SHIFT);\n\ttw32(GRC_MISC_CFG, val);\n\n\t/* Initialize MBUF/DESC pool. */\n\tif (tg3_flag(tp, 5750_PLUS)) {\n\t\t/* Do nothing.  */\n\t} else if (tg3_asic_rev(tp) != ASIC_REV_5705) {\n\t\ttw32(BUFMGR_MB_POOL_ADDR, NIC_SRAM_MBUF_POOL_BASE);\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5704)\n\t\t\ttw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE64);\n\t\telse\n\t\t\ttw32(BUFMGR_MB_POOL_SIZE, NIC_SRAM_MBUF_POOL_SIZE96);\n\t\ttw32(BUFMGR_DMA_DESC_POOL_ADDR, NIC_SRAM_DMA_DESC_POOL_BASE);\n\t\ttw32(BUFMGR_DMA_DESC_POOL_SIZE, NIC_SRAM_DMA_DESC_POOL_SIZE);\n\t} else if (tg3_flag(tp, TSO_CAPABLE)) {\n\t\tint fw_len;\n\n\t\tfw_len = tp->fw_len;\n\t\tfw_len = (fw_len + (0x80 - 1)) & ~(0x80 - 1);\n\t\ttw32(BUFMGR_MB_POOL_ADDR,\n\t\t     NIC_SRAM_MBUF_POOL_BASE5705 + fw_len);\n\t\ttw32(BUFMGR_MB_POOL_SIZE,\n\t\t     NIC_SRAM_MBUF_POOL_SIZE5705 - fw_len - 0xa00);\n\t}\n\n\tif (tp->dev->mtu <= ETH_DATA_LEN) {\n\t\ttw32(BUFMGR_MB_RDMA_LOW_WATER,\n\t\t     tp->bufmgr_config.mbuf_read_dma_low_water);\n\t\ttw32(BUFMGR_MB_MACRX_LOW_WATER,\n\t\t     tp->bufmgr_config.mbuf_mac_rx_low_water);\n\t\ttw32(BUFMGR_MB_HIGH_WATER,\n\t\t     tp->bufmgr_config.mbuf_high_water);\n\t} else {\n\t\ttw32(BUFMGR_MB_RDMA_LOW_WATER,\n\t\t     tp->bufmgr_config.mbuf_read_dma_low_water_jumbo);\n\t\ttw32(BUFMGR_MB_MACRX_LOW_WATER,\n\t\t     tp->bufmgr_config.mbuf_mac_rx_low_water_jumbo);\n\t\ttw32(BUFMGR_MB_HIGH_WATER,\n\t\t     tp->bufmgr_config.mbuf_high_water_jumbo);\n\t}\n\ttw32(BUFMGR_DMA_LOW_WATER,\n\t     tp->bufmgr_config.dma_low_water);\n\ttw32(BUFMGR_DMA_HIGH_WATER,\n\t     tp->bufmgr_config.dma_high_water);\n\n\tval = BUFMGR_MODE_ENABLE | BUFMGR_MODE_ATTN_ENABLE;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5719)\n\t\tval |= BUFMGR_MODE_NO_TX_UNDERRUN;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5720_A0)\n\t\tval |= BUFMGR_MODE_MBLOW_ATTN_ENAB;\n\ttw32(BUFMGR_MODE, val);\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (tr32(BUFMGR_MODE) & BUFMGR_MODE_ENABLE)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\tif (i >= 2000) {\n\t\tnetdev_err(tp->dev, \"%s cannot enable BUFMGR\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5906_A1)\n\t\ttw32(ISO_PKT_TX, (tr32(ISO_PKT_TX) & ~0x3) | 0x2);\n\n\ttg3_setup_rxbd_thresholds(tp);\n\n\t/* Initialize TG3_BDINFO's at:\n\t *  RCVDBDI_STD_BD:\tstandard eth size rx ring\n\t *  RCVDBDI_JUMBO_BD:\tjumbo frame rx ring\n\t *  RCVDBDI_MINI_BD:\tsmall frame rx ring (??? does not work)\n\t *\n\t * like so:\n\t *  TG3_BDINFO_HOST_ADDR:\thigh/low parts of DMA address of ring\n\t *  TG3_BDINFO_MAXLEN_FLAGS:\t(rx max buffer size << 16) |\n\t *                              ring attribute flags\n\t *  TG3_BDINFO_NIC_ADDR:\tlocation of descriptors in nic SRAM\n\t *\n\t * Standard receive ring @ NIC_SRAM_RX_BUFFER_DESC, 512 entries.\n\t * Jumbo receive ring @ NIC_SRAM_RX_JUMBO_BUFFER_DESC, 256 entries.\n\t *\n\t * The size of each ring is fixed in the firmware, but the location is\n\t * configurable.\n\t */\n\ttw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,\n\t     ((u64) tpr->rx_std_mapping >> 32));\n\ttw32(RCVDBDI_STD_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,\n\t     ((u64) tpr->rx_std_mapping & 0xffffffff));\n\tif (!tg3_flag(tp, 5717_PLUS))\n\t\ttw32(RCVDBDI_STD_BD + TG3_BDINFO_NIC_ADDR,\n\t\t     NIC_SRAM_RX_BUFFER_DESC);\n\n\t/* Disable the mini ring */\n\tif (!tg3_flag(tp, 5705_PLUS))\n\t\ttw32(RCVDBDI_MINI_BD + TG3_BDINFO_MAXLEN_FLAGS,\n\t\t     BDINFO_FLAGS_DISABLED);\n\n\t/* Program the jumbo buffer descriptor ring control\n\t * blocks on those devices that have them.\n\t */\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\n\t    (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS))) {\n\n\t\tif (tg3_flag(tp, JUMBO_RING_ENABLE)) {\n\t\t\ttw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_HIGH,\n\t\t\t     ((u64) tpr->rx_jmb_mapping >> 32));\n\t\t\ttw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_HOST_ADDR + TG3_64BIT_REG_LOW,\n\t\t\t     ((u64) tpr->rx_jmb_mapping & 0xffffffff));\n\t\t\tval = TG3_RX_JMB_RING_SIZE(tp) <<\n\t\t\t      BDINFO_FLAGS_MAXLEN_SHIFT;\n\t\t\ttw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,\n\t\t\t     val | BDINFO_FLAGS_USE_EXT_RECV);\n\t\t\tif (!tg3_flag(tp, USE_JUMBO_BDFLAG) ||\n\t\t\t    tg3_flag(tp, 57765_CLASS) ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\t\t\ttw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_NIC_ADDR,\n\t\t\t\t     NIC_SRAM_RX_JUMBO_BUFFER_DESC);\n\t\t} else {\n\t\t\ttw32(RCVDBDI_JUMBO_BD + TG3_BDINFO_MAXLEN_FLAGS,\n\t\t\t     BDINFO_FLAGS_DISABLED);\n\t\t}\n\n\t\tif (tg3_flag(tp, 57765_PLUS)) {\n\t\t\tval = TG3_RX_STD_RING_SIZE(tp);\n\t\t\tval <<= BDINFO_FLAGS_MAXLEN_SHIFT;\n\t\t\tval |= (TG3_RX_STD_DMA_SZ << 2);\n\t\t} else\n\t\t\tval = TG3_RX_STD_DMA_SZ << BDINFO_FLAGS_MAXLEN_SHIFT;\n\t} else\n\t\tval = TG3_RX_STD_MAX_SIZE_5700 << BDINFO_FLAGS_MAXLEN_SHIFT;\n\n\ttw32(RCVDBDI_STD_BD + TG3_BDINFO_MAXLEN_FLAGS, val);\n\n\ttpr->rx_std_prod_idx = tp->rx_pending;\n\ttw32_rx_mbox(TG3_RX_STD_PROD_IDX_REG, tpr->rx_std_prod_idx);\n\n\ttpr->rx_jmb_prod_idx =\n\t\ttg3_flag(tp, JUMBO_RING_ENABLE) ? tp->rx_jumbo_pending : 0;\n\ttw32_rx_mbox(TG3_RX_JMB_PROD_IDX_REG, tpr->rx_jmb_prod_idx);\n\n\ttg3_rings_reset(tp);\n\n\t/* Initialize MAC address and backoff seed. */\n\t__tg3_set_mac_addr(tp, false);\n\n\t/* MTU + ethernet header + FCS + optional VLAN tag */\n\ttw32(MAC_RX_MTU_SIZE,\n\t     tp->dev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\n\t/* The slot time is changed by tg3_setup_phy if we\n\t * run at gigabit with half duplex.\n\t */\n\tval = (2 << TX_LENGTHS_IPG_CRS_SHIFT) |\n\t      (6 << TX_LENGTHS_IPG_SHIFT) |\n\t      (32 << TX_LENGTHS_SLOT_TIME_SHIFT);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\tval |= tr32(MAC_TX_LENGTHS) &\n\t\t       (TX_LENGTHS_JMB_FRM_LEN_MSK |\n\t\t\tTX_LENGTHS_CNT_DWN_VAL_MSK);\n\n\ttw32(MAC_TX_LENGTHS, val);\n\n\t/* Receive rules. */\n\ttw32(MAC_RCV_RULE_CFG, RCV_RULE_CFG_DEFAULT_CLASS);\n\ttw32(RCVLPC_CONFIG, 0x0181);\n\n\t/* Calculate RDMAC_MODE setting early, we need it to determine\n\t * the RCVLPC_STATE_ENABLE mask.\n\t */\n\trdmac_mode = (RDMAC_MODE_ENABLE | RDMAC_MODE_TGTABORT_ENAB |\n\t\t      RDMAC_MODE_MSTABORT_ENAB | RDMAC_MODE_PARITYERR_ENAB |\n\t\t      RDMAC_MODE_ADDROFLOW_ENAB | RDMAC_MODE_FIFOOFLOW_ENAB |\n\t\t      RDMAC_MODE_FIFOURUN_ENAB | RDMAC_MODE_FIFOOREAD_ENAB |\n\t\t      RDMAC_MODE_LNGREAD_ENAB);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717)\n\t\trdmac_mode |= RDMAC_MODE_MULT_DMA_RD_DIS;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5784 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5785 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57780)\n\t\trdmac_mode |= RDMAC_MODE_BD_SBD_CRPT_ENAB |\n\t\t\t      RDMAC_MODE_MBUF_RBD_CRPT_ENAB |\n\t\t\t      RDMAC_MODE_MBUF_SBD_CRPT_ENAB;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5705 &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) {\n\t\tif (tg3_flag(tp, TSO_CAPABLE) &&\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\t\trdmac_mode |= RDMAC_MODE_FIFO_SIZE_128;\n\t\t} else if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&\n\t\t\t   !tg3_flag(tp, IS_5788)) {\n\t\t\trdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;\n\t\t}\n\t}\n\n\tif (tg3_flag(tp, PCI_EXPRESS))\n\t\trdmac_mode |= RDMAC_MODE_FIFO_LONG_BURST;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\ttp->dma_limit = 0;\n\t\tif (tp->dev->mtu <= ETH_DATA_LEN) {\n\t\t\trdmac_mode |= RDMAC_MODE_JMB_2K_MMRR;\n\t\t\ttp->dma_limit = TG3_TX_BD_DMA_MAX_2K;\n\t\t}\n\t}\n\n\tif (tg3_flag(tp, HW_TSO_1) ||\n\t    tg3_flag(tp, HW_TSO_2) ||\n\t    tg3_flag(tp, HW_TSO_3))\n\t\trdmac_mode |= RDMAC_MODE_IPV4_LSO_EN;\n\n\tif (tg3_flag(tp, 57765_PLUS) ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5785 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57780)\n\t\trdmac_mode |= RDMAC_MODE_IPV6_LSO_EN;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\trdmac_mode |= tr32(RDMAC_MODE) & RDMAC_MODE_H2BNC_VLAN_DET;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5761 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5784 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5785 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57780 ||\n\t    tg3_flag(tp, 57765_PLUS)) {\n\t\tu32 tgtreg;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\t\ttgtreg = TG3_RDMA_RSRVCTRL_REG2;\n\t\telse\n\t\t\ttgtreg = TG3_RDMA_RSRVCTRL_REG;\n\n\t\tval = tr32(tgtreg);\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5762) {\n\t\t\tval &= ~(TG3_RDMA_RSRVCTRL_TXMRGN_MASK |\n\t\t\t\t TG3_RDMA_RSRVCTRL_FIFO_LWM_MASK |\n\t\t\t\t TG3_RDMA_RSRVCTRL_FIFO_HWM_MASK);\n\t\t\tval |= TG3_RDMA_RSRVCTRL_TXMRGN_320B |\n\t\t\t       TG3_RDMA_RSRVCTRL_FIFO_LWM_1_5K |\n\t\t\t       TG3_RDMA_RSRVCTRL_FIFO_HWM_1_5K;\n\t\t}\n\t\ttw32(tgtreg, val | TG3_RDMA_RSRVCTRL_FIFO_OFLW_FIX);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762) {\n\t\tu32 tgtreg;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\t\ttgtreg = TG3_LSO_RD_DMA_CRPTEN_CTRL2;\n\t\telse\n\t\t\ttgtreg = TG3_LSO_RD_DMA_CRPTEN_CTRL;\n\n\t\tval = tr32(tgtreg);\n\t\ttw32(tgtreg, val |\n\t\t     TG3_LSO_RD_DMA_CRPTEN_CTRL_BLEN_BD_4K |\n\t\t     TG3_LSO_RD_DMA_CRPTEN_CTRL_BLEN_LSO_4K);\n\t}\n\n\t/* Receive/send statistics. */\n\tif (tg3_flag(tp, 5750_PLUS)) {\n\t\tval = tr32(RCVLPC_STATS_ENABLE);\n\t\tval &= ~RCVLPC_STATSENAB_DACK_FIX;\n\t\ttw32(RCVLPC_STATS_ENABLE, val);\n\t} else if ((rdmac_mode & RDMAC_MODE_FIFO_SIZE_128) &&\n\t\t   tg3_flag(tp, TSO_CAPABLE)) {\n\t\tval = tr32(RCVLPC_STATS_ENABLE);\n\t\tval &= ~RCVLPC_STATSENAB_LNGBRST_RFIX;\n\t\ttw32(RCVLPC_STATS_ENABLE, val);\n\t} else {\n\t\ttw32(RCVLPC_STATS_ENABLE, 0xffffff);\n\t}\n\ttw32(RCVLPC_STATSCTRL, RCVLPC_STATSCTRL_ENABLE);\n\ttw32(SNDDATAI_STATSENAB, 0xffffff);\n\ttw32(SNDDATAI_STATSCTRL,\n\t     (SNDDATAI_SCTRL_ENABLE |\n\t      SNDDATAI_SCTRL_FASTUPD));\n\n\t/* Setup host coalescing engine. */\n\ttw32(HOSTCC_MODE, 0);\n\tfor (i = 0; i < 2000; i++) {\n\t\tif (!(tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\t__tg3_set_coalesce(tp, &tp->coal);\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\t/* Status/statistics block address.  See tg3_timer,\n\t\t * the tg3_periodic_fetch_stats call there, and\n\t\t * tg3_get_stats to see how this works for 5705/5750 chips.\n\t\t */\n\t\ttw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_HIGH,\n\t\t     ((u64) tp->stats_mapping >> 32));\n\t\ttw32(HOSTCC_STATS_BLK_HOST_ADDR + TG3_64BIT_REG_LOW,\n\t\t     ((u64) tp->stats_mapping & 0xffffffff));\n\t\ttw32(HOSTCC_STATS_BLK_NIC_ADDR, NIC_SRAM_STATS_BLK);\n\n\t\ttw32(HOSTCC_STATUS_BLK_NIC_ADDR, NIC_SRAM_STATUS_BLK);\n\n\t\t/* Clear statistics and status block memory areas */\n\t\tfor (i = NIC_SRAM_STATS_BLK;\n\t\t     i < NIC_SRAM_STATUS_BLK + TG3_HW_STATUS_SIZE;\n\t\t     i += sizeof(u32)) {\n\t\t\ttg3_write_mem(tp, i, 0);\n\t\t\tudelay(40);\n\t\t}\n\t}\n\n\ttw32(HOSTCC_MODE, HOSTCC_MODE_ENABLE | tp->coalesce_mode);\n\n\ttw32(RCVCC_MODE, RCVCC_MODE_ENABLE | RCVCC_MODE_ATTN_ENABLE);\n\ttw32(RCVLPC_MODE, RCVLPC_MODE_ENABLE);\n\tif (!tg3_flag(tp, 5705_PLUS))\n\t\ttw32(RCVLSC_MODE, RCVLSC_MODE_ENABLE | RCVLSC_MODE_ATTN_ENABLE);\n\n\tif (tp->phy_flags & TG3_PHYFLG_MII_SERDES) {\n\t\ttp->phy_flags &= ~TG3_PHYFLG_PARALLEL_DETECT;\n\t\t/* reset to prevent losing 1st rx packet intermittently */\n\t\ttw32_f(MAC_RX_MODE, RX_MODE_RESET);\n\t\tudelay(10);\n\t}\n\n\ttp->mac_mode |= MAC_MODE_TXSTAT_ENABLE | MAC_MODE_RXSTAT_ENABLE |\n\t\t\tMAC_MODE_TDE_ENABLE | MAC_MODE_RDE_ENABLE |\n\t\t\tMAC_MODE_FHDE_ENABLE;\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\ttp->mac_mode |= MAC_MODE_APE_TX_EN | MAC_MODE_APE_RX_EN;\n\tif (!tg3_flag(tp, 5705_PLUS) &&\n\t    !(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5700)\n\t\ttp->mac_mode |= MAC_MODE_LINK_POLARITY;\n\ttw32_f(MAC_MODE, tp->mac_mode | MAC_MODE_RXSTAT_CLEAR | MAC_MODE_TXSTAT_CLEAR);\n\tudelay(40);\n\n\t/* tp->grc_local_ctrl is partially set up during tg3_get_invariants().\n\t * If TG3_FLAG_IS_NIC is zero, we should read the\n\t * register to preserve the GPIO settings for LOMs. The GPIOs,\n\t * whether used as inputs or outputs, are set by boot code after\n\t * reset.\n\t */\n\tif (!tg3_flag(tp, IS_NIC)) {\n\t\tu32 gpio_mask;\n\n\t\tgpio_mask = GRC_LCLCTRL_GPIO_OE0 | GRC_LCLCTRL_GPIO_OE1 |\n\t\t\t    GRC_LCLCTRL_GPIO_OE2 | GRC_LCLCTRL_GPIO_OUTPUT0 |\n\t\t\t    GRC_LCLCTRL_GPIO_OUTPUT1 | GRC_LCLCTRL_GPIO_OUTPUT2;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5752)\n\t\t\tgpio_mask |= GRC_LCLCTRL_GPIO_OE3 |\n\t\t\t\t     GRC_LCLCTRL_GPIO_OUTPUT3;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5755)\n\t\t\tgpio_mask |= GRC_LCLCTRL_GPIO_UART_SEL;\n\n\t\ttp->grc_local_ctrl &= ~gpio_mask;\n\t\ttp->grc_local_ctrl |= tr32(GRC_LOCAL_CTRL) & gpio_mask;\n\n\t\t/* GPIO1 must be driven high for eeprom write protect */\n\t\tif (tg3_flag(tp, EEPROM_WRITE_PROT))\n\t\t\ttp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |\n\t\t\t\t\t       GRC_LCLCTRL_GPIO_OUTPUT1);\n\t}\n\ttw32_f(GRC_LOCAL_CTRL, tp->grc_local_ctrl);\n\tudelay(100);\n\n\tif (tg3_flag(tp, USING_MSIX)) {\n\t\tval = tr32(MSGINT_MODE);\n\t\tval |= MSGINT_MODE_ENABLE;\n\t\tif (tp->irq_cnt > 1)\n\t\t\tval |= MSGINT_MODE_MULTIVEC_EN;\n\t\tif (!tg3_flag(tp, 1SHOT_MSI))\n\t\t\tval |= MSGINT_MODE_ONE_SHOT_DISABLE;\n\t\ttw32(MSGINT_MODE, val);\n\t}\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\ttw32_f(DMAC_MODE, DMAC_MODE_ENABLE);\n\t\tudelay(40);\n\t}\n\n\tval = (WDMAC_MODE_ENABLE | WDMAC_MODE_TGTABORT_ENAB |\n\t       WDMAC_MODE_MSTABORT_ENAB | WDMAC_MODE_PARITYERR_ENAB |\n\t       WDMAC_MODE_ADDROFLOW_ENAB | WDMAC_MODE_FIFOOFLOW_ENAB |\n\t       WDMAC_MODE_FIFOURUN_ENAB | WDMAC_MODE_FIFOOREAD_ENAB |\n\t       WDMAC_MODE_LNGREAD_ENAB);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5705 &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) {\n\t\tif (tg3_flag(tp, TSO_CAPABLE) &&\n\t\t    (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A1 ||\n\t\t     tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A2)) {\n\t\t\t/* nothing */\n\t\t} else if (!(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH) &&\n\t\t\t   !tg3_flag(tp, IS_5788)) {\n\t\t\tval |= WDMAC_MODE_RX_ACCEL;\n\t\t}\n\t}\n\n\t/* Enable host coalescing bug fix */\n\tif (tg3_flag(tp, 5755_PLUS))\n\t\tval |= WDMAC_MODE_STATUS_TAG_FIX;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\tval |= WDMAC_MODE_BURST_ALL_DATA;\n\n\ttw32_f(WDMAC_MODE, val);\n\tudelay(40);\n\n\tif (tg3_flag(tp, PCIX_MODE)) {\n\t\tu16 pcix_cmd;\n\n\t\tpci_read_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t     &pcix_cmd);\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5703) {\n\t\t\tpcix_cmd &= ~PCI_X_CMD_MAX_READ;\n\t\t\tpcix_cmd |= PCI_X_CMD_READ_2K;\n\t\t} else if (tg3_asic_rev(tp) == ASIC_REV_5704) {\n\t\t\tpcix_cmd &= ~(PCI_X_CMD_MAX_SPLIT | PCI_X_CMD_MAX_READ);\n\t\t\tpcix_cmd |= PCI_X_CMD_READ_2K;\n\t\t}\n\t\tpci_write_config_word(tp->pdev, tp->pcix_cap + PCI_X_CMD,\n\t\t\t\t      pcix_cmd);\n\t}\n\n\ttw32_f(RDMAC_MODE, rdmac_mode);\n\tudelay(40);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720) {\n\t\tfor (i = 0; i < TG3_NUM_RDMA_CHANNELS; i++) {\n\t\t\tif (tr32(TG3_RDMA_LENGTH + (i << 2)) > TG3_MAX_MTU(tp))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < TG3_NUM_RDMA_CHANNELS) {\n\t\t\tval = tr32(TG3_LSO_RD_DMA_CRPTEN_CTRL);\n\t\t\tval |= tg3_lso_rd_dma_workaround_bit(tp);\n\t\t\ttw32(TG3_LSO_RD_DMA_CRPTEN_CTRL, val);\n\t\t\ttg3_flag_set(tp, 5719_5720_RDMA_BUG);\n\t\t}\n\t}\n\n\ttw32(RCVDCC_MODE, RCVDCC_MODE_ENABLE | RCVDCC_MODE_ATTN_ENABLE);\n\tif (!tg3_flag(tp, 5705_PLUS))\n\t\ttw32(MBFREE_MODE, MBFREE_MODE_ENABLE);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5761)\n\t\ttw32(SNDDATAC_MODE,\n\t\t     SNDDATAC_MODE_ENABLE | SNDDATAC_MODE_CDELAY);\n\telse\n\t\ttw32(SNDDATAC_MODE, SNDDATAC_MODE_ENABLE);\n\n\ttw32(SNDBDC_MODE, SNDBDC_MODE_ENABLE | SNDBDC_MODE_ATTN_ENABLE);\n\ttw32(RCVBDI_MODE, RCVBDI_MODE_ENABLE | RCVBDI_MODE_RCB_ATTN_ENAB);\n\tval = RCVDBDI_MODE_ENABLE | RCVDBDI_MODE_INV_RING_SZ;\n\tif (tg3_flag(tp, LRG_PROD_RING_CAP))\n\t\tval |= RCVDBDI_MODE_LRG_RING_SZ;\n\ttw32(RCVDBDI_MODE, val);\n\ttw32(SNDDATAI_MODE, SNDDATAI_MODE_ENABLE);\n\tif (tg3_flag(tp, HW_TSO_1) ||\n\t    tg3_flag(tp, HW_TSO_2) ||\n\t    tg3_flag(tp, HW_TSO_3))\n\t\ttw32(SNDDATAI_MODE, SNDDATAI_MODE_ENABLE | 0x8);\n\tval = SNDBDI_MODE_ENABLE | SNDBDI_MODE_ATTN_ENABLE;\n\tif (tg3_flag(tp, ENABLE_TSS))\n\t\tval |= SNDBDI_MODE_MULTI_TXQ_EN;\n\ttw32(SNDBDI_MODE, val);\n\ttw32(SNDBDS_MODE, SNDBDS_MODE_ENABLE | SNDBDS_MODE_ATTN_ENABLE);\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0) {\n\t\terr = tg3_load_5701_a0_firmware_fix(tp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\t/* Ignore any errors for the firmware download. If download\n\t\t * fails, the device will operate with EEE disabled\n\t\t */\n\t\ttg3_load_57766_firmware(tp);\n\t}\n\n\tif (tg3_flag(tp, TSO_CAPABLE)) {\n\t\terr = tg3_load_tso_firmware(tp);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\ttp->tx_mode = TX_MODE_ENABLE;\n\n\tif (tg3_flag(tp, 5755_PLUS) ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\ttp->tx_mode |= TX_MODE_MBUF_LOCKUP_FIX;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762) {\n\t\tval = TX_MODE_JMB_FRM_LEN | TX_MODE_CNT_DN_MODE;\n\t\ttp->tx_mode &= ~val;\n\t\ttp->tx_mode |= tr32(MAC_TX_MODE) & val;\n\t}\n\n\ttw32_f(MAC_TX_MODE, tp->tx_mode);\n\tudelay(100);\n\n\tif (tg3_flag(tp, ENABLE_RSS)) {\n\t\tu32 rss_key[10];\n\n\t\ttg3_rss_write_indir_tbl(tp);\n\n\t\tnetdev_rss_key_fill(rss_key, 10 * sizeof(u32));\n\n\t\tfor (i = 0; i < 10 ; i++)\n\t\t\ttw32(MAC_RSS_HASH_KEY_0 + i*4, rss_key[i]);\n\t}\n\n\ttp->rx_mode = RX_MODE_ENABLE;\n\tif (tg3_flag(tp, 5755_PLUS))\n\t\ttp->rx_mode |= RX_MODE_IPV6_CSUM_ENABLE;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\ttp->rx_mode |= RX_MODE_IPV4_FRAG_FIX;\n\n\tif (tg3_flag(tp, ENABLE_RSS))\n\t\ttp->rx_mode |= RX_MODE_RSS_ENABLE |\n\t\t\t       RX_MODE_RSS_ITBL_HASH_BITS_7 |\n\t\t\t       RX_MODE_RSS_IPV6_HASH_EN |\n\t\t\t       RX_MODE_RSS_TCP_IPV6_HASH_EN |\n\t\t\t       RX_MODE_RSS_IPV4_HASH_EN |\n\t\t\t       RX_MODE_RSS_TCP_IPV4_HASH_EN;\n\n\ttw32_f(MAC_RX_MODE, tp->rx_mode);\n\tudelay(10);\n\n\ttw32(MAC_LED_CTRL, tp->led_ctrl);\n\n\ttw32(MAC_MI_STAT, MAC_MI_STAT_LNKSTAT_ATTN_ENAB);\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\n\t\ttw32_f(MAC_RX_MODE, RX_MODE_RESET);\n\t\tudelay(10);\n\t}\n\ttw32_f(MAC_RX_MODE, tp->rx_mode);\n\tudelay(10);\n\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\n\t\tif ((tg3_asic_rev(tp) == ASIC_REV_5704) &&\n\t\t    !(tp->phy_flags & TG3_PHYFLG_SERDES_PREEMPHASIS)) {\n\t\t\t/* Set drive transmission level to 1.2V  */\n\t\t\t/* only if the signal pre-emphasis bit is not set  */\n\t\t\tval = tr32(MAC_SERDES_CFG);\n\t\t\tval &= 0xfffff000;\n\t\t\tval |= 0x880;\n\t\t\ttw32(MAC_SERDES_CFG, val);\n\t\t}\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5703_A1)\n\t\t\ttw32(MAC_SERDES_CFG, 0x616000);\n\t}\n\n\t/* Prevent chip from dropping frames when flow control\n\t * is enabled.\n\t */\n\tif (tg3_flag(tp, 57765_CLASS))\n\t\tval = 1;\n\telse\n\t\tval = 2;\n\ttw32_f(MAC_LOW_WMARK_MAX_RX_FRAME, val);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5704 &&\n\t    (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)) {\n\t\t/* Use hardware link auto-negotiation */\n\t\ttg3_flag_set(tp, HW_AUTONEG);\n\t}\n\n\tif ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\n\t    tg3_asic_rev(tp) == ASIC_REV_5714) {\n\t\tu32 tmp;\n\n\t\ttmp = tr32(SERDES_RX_CTRL);\n\t\ttw32(SERDES_RX_CTRL, tmp | SERDES_RX_SIG_DETECT);\n\t\ttp->grc_local_ctrl &= ~GRC_LCLCTRL_USE_EXT_SIG_DETECT;\n\t\ttp->grc_local_ctrl |= GRC_LCLCTRL_USE_SIG_DETECT;\n\t\ttw32(GRC_LOCAL_CTRL, tp->grc_local_ctrl);\n\t}\n\n\tif (!tg3_flag(tp, USE_PHYLIB)) {\n\t\tif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_IS_LOW_POWER;\n\n\t\terr = tg3_setup_phy(tp, false);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\n\t\t    !(tp->phy_flags & TG3_PHYFLG_IS_FET)) {\n\t\t\tu32 tmp;\n\n\t\t\t/* Clear CRC stats. */\n\t\t\tif (!tg3_readphy(tp, MII_TG3_TEST1, &tmp)) {\n\t\t\t\ttg3_writephy(tp, MII_TG3_TEST1,\n\t\t\t\t\t     tmp | MII_TG3_TEST1_CRC_EN);\n\t\t\t\ttg3_readphy(tp, MII_TG3_RXR_COUNTERS, &tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\t__tg3_set_rx_mode(tp->dev);\n\n\t/* Initialize receive rules. */\n\ttw32(MAC_RCV_RULE_0,  0xc2000000 & RCV_RULE_DISABLE_MASK);\n\ttw32(MAC_RCV_VALUE_0, 0xffffffff & RCV_RULE_DISABLE_MASK);\n\ttw32(MAC_RCV_RULE_1,  0x86000004 & RCV_RULE_DISABLE_MASK);\n\ttw32(MAC_RCV_VALUE_1, 0xffffffff & RCV_RULE_DISABLE_MASK);\n\n\tif (tg3_flag(tp, 5705_PLUS) && !tg3_flag(tp, 5780_CLASS))\n\t\tlimit = 8;\n\telse\n\t\tlimit = 16;\n\tif (tg3_flag(tp, ENABLE_ASF))\n\t\tlimit -= 4;\n\tswitch (limit) {\n\tcase 16:\n\t\ttw32(MAC_RCV_RULE_15,  0); tw32(MAC_RCV_VALUE_15,  0);\n\t\tfallthrough;\n\tcase 15:\n\t\ttw32(MAC_RCV_RULE_14,  0); tw32(MAC_RCV_VALUE_14,  0);\n\t\tfallthrough;\n\tcase 14:\n\t\ttw32(MAC_RCV_RULE_13,  0); tw32(MAC_RCV_VALUE_13,  0);\n\t\tfallthrough;\n\tcase 13:\n\t\ttw32(MAC_RCV_RULE_12,  0); tw32(MAC_RCV_VALUE_12,  0);\n\t\tfallthrough;\n\tcase 12:\n\t\ttw32(MAC_RCV_RULE_11,  0); tw32(MAC_RCV_VALUE_11,  0);\n\t\tfallthrough;\n\tcase 11:\n\t\ttw32(MAC_RCV_RULE_10,  0); tw32(MAC_RCV_VALUE_10,  0);\n\t\tfallthrough;\n\tcase 10:\n\t\ttw32(MAC_RCV_RULE_9,  0); tw32(MAC_RCV_VALUE_9,  0);\n\t\tfallthrough;\n\tcase 9:\n\t\ttw32(MAC_RCV_RULE_8,  0); tw32(MAC_RCV_VALUE_8,  0);\n\t\tfallthrough;\n\tcase 8:\n\t\ttw32(MAC_RCV_RULE_7,  0); tw32(MAC_RCV_VALUE_7,  0);\n\t\tfallthrough;\n\tcase 7:\n\t\ttw32(MAC_RCV_RULE_6,  0); tw32(MAC_RCV_VALUE_6,  0);\n\t\tfallthrough;\n\tcase 6:\n\t\ttw32(MAC_RCV_RULE_5,  0); tw32(MAC_RCV_VALUE_5,  0);\n\t\tfallthrough;\n\tcase 5:\n\t\ttw32(MAC_RCV_RULE_4,  0); tw32(MAC_RCV_VALUE_4,  0);\n\t\tfallthrough;\n\tcase 4:\n\t\t/* tw32(MAC_RCV_RULE_3,  0); tw32(MAC_RCV_VALUE_3,  0); */\n\tcase 3:\n\t\t/* tw32(MAC_RCV_RULE_2,  0); tw32(MAC_RCV_VALUE_2,  0); */\n\tcase 2:\n\tcase 1:\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\t/* Write our heartbeat update interval to APE. */\n\t\ttg3_ape_write32(tp, TG3_APE_HOST_HEARTBEAT_INT_MS,\n\t\t\t\tAPE_HOST_HEARTBEAT_INT_5SEC);\n\n\ttg3_write_sig_post_reset(tp, RESET_KIND_INIT);\n\n\treturn 0;\n}\n\n/* Called at device open time to get the chip ready for\n * packet processing.  Invoked with tp->lock held.\n */\nstatic int tg3_init_hw(struct tg3 *tp, bool reset_phy)\n{\n\t/* Chip may have been just powered on. If so, the boot code may still\n\t * be running initialization. Wait for it to finish to avoid races in\n\t * accessing the hardware.\n\t */\n\ttg3_enable_register_access(tp);\n\ttg3_poll_fw(tp);\n\n\ttg3_switch_clocks(tp);\n\n\ttw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\n\treturn tg3_reset_hw(tp, reset_phy);\n}\n\n#ifdef CONFIG_TIGON3_HWMON\nstatic void tg3_sd_scan_scratchpad(struct tg3 *tp, struct tg3_ocir *ocir)\n{\n\tu32 off, len = TG3_OCIR_LEN;\n\tint i;\n\n\tfor (i = 0, off = 0; i < TG3_SD_NUM_RECS; i++, ocir++, off += len) {\n\t\ttg3_ape_scratchpad_read(tp, (u32 *) ocir, off, len);\n\n\t\tif (ocir->signature != TG3_OCIR_SIG_MAGIC ||\n\t\t    !(ocir->version_flags & TG3_OCIR_FLAG_ACTIVE))\n\t\t\tmemset(ocir, 0, len);\n\t}\n}\n\n/* sysfs attributes for hwmon */\nstatic ssize_t tg3_show_temp(struct device *dev,\n\t\t\t     struct device_attribute *devattr, char *buf)\n{\n\tstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\n\tstruct tg3 *tp = dev_get_drvdata(dev);\n\tu32 temperature;\n\n\tspin_lock_bh(&tp->lock);\n\ttg3_ape_scratchpad_read(tp, &temperature, attr->index,\n\t\t\t\tsizeof(temperature));\n\tspin_unlock_bh(&tp->lock);\n\treturn sprintf(buf, \"%u\\n\", temperature * 1000);\n}\n\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, tg3_show_temp, NULL,\n\t\t\t  TG3_TEMP_SENSOR_OFFSET);\nstatic SENSOR_DEVICE_ATTR(temp1_crit, 0444, tg3_show_temp, NULL,\n\t\t\t  TG3_TEMP_CAUTION_OFFSET);\nstatic SENSOR_DEVICE_ATTR(temp1_max, 0444, tg3_show_temp, NULL,\n\t\t\t  TG3_TEMP_MAX_OFFSET);\n\nstatic struct attribute *tg3_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_max.dev_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(tg3);\n\nstatic void tg3_hwmon_close(struct tg3 *tp)\n{\n\tif (tp->hwmon_dev) {\n\t\thwmon_device_unregister(tp->hwmon_dev);\n\t\ttp->hwmon_dev = NULL;\n\t}\n}\n\nstatic void tg3_hwmon_open(struct tg3 *tp)\n{\n\tint i;\n\tu32 size = 0;\n\tstruct pci_dev *pdev = tp->pdev;\n\tstruct tg3_ocir ocirs[TG3_SD_NUM_RECS];\n\n\ttg3_sd_scan_scratchpad(tp, ocirs);\n\n\tfor (i = 0; i < TG3_SD_NUM_RECS; i++) {\n\t\tif (!ocirs[i].src_data_length)\n\t\t\tcontinue;\n\n\t\tsize += ocirs[i].src_hdr_length;\n\t\tsize += ocirs[i].src_data_length;\n\t}\n\n\tif (!size)\n\t\treturn;\n\n\ttp->hwmon_dev = hwmon_device_register_with_groups(&pdev->dev, \"tg3\",\n\t\t\t\t\t\t\t  tp, tg3_groups);\n\tif (IS_ERR(tp->hwmon_dev)) {\n\t\ttp->hwmon_dev = NULL;\n\t\tdev_err(&pdev->dev, \"Cannot register hwmon device, aborting\\n\");\n\t}\n}\n#else\nstatic inline void tg3_hwmon_close(struct tg3 *tp) { }\nstatic inline void tg3_hwmon_open(struct tg3 *tp) { }\n#endif /* CONFIG_TIGON3_HWMON */\n\n\n#define TG3_STAT_ADD32(PSTAT, REG) \\\ndo {\tu32 __val = tr32(REG); \\\n\t(PSTAT)->low += __val; \\\n\tif ((PSTAT)->low < __val) \\\n\t\t(PSTAT)->high += 1; \\\n} while (0)\n\nstatic void tg3_periodic_fetch_stats(struct tg3 *tp)\n{\n\tstruct tg3_hw_stats *sp = tp->hw_stats;\n\n\tif (!tp->link_up)\n\t\treturn;\n\n\tTG3_STAT_ADD32(&sp->tx_octets, MAC_TX_STATS_OCTETS);\n\tTG3_STAT_ADD32(&sp->tx_collisions, MAC_TX_STATS_COLLISIONS);\n\tTG3_STAT_ADD32(&sp->tx_xon_sent, MAC_TX_STATS_XON_SENT);\n\tTG3_STAT_ADD32(&sp->tx_xoff_sent, MAC_TX_STATS_XOFF_SENT);\n\tTG3_STAT_ADD32(&sp->tx_mac_errors, MAC_TX_STATS_MAC_ERRORS);\n\tTG3_STAT_ADD32(&sp->tx_single_collisions, MAC_TX_STATS_SINGLE_COLLISIONS);\n\tTG3_STAT_ADD32(&sp->tx_mult_collisions, MAC_TX_STATS_MULT_COLLISIONS);\n\tTG3_STAT_ADD32(&sp->tx_deferred, MAC_TX_STATS_DEFERRED);\n\tTG3_STAT_ADD32(&sp->tx_excessive_collisions, MAC_TX_STATS_EXCESSIVE_COL);\n\tTG3_STAT_ADD32(&sp->tx_late_collisions, MAC_TX_STATS_LATE_COL);\n\tTG3_STAT_ADD32(&sp->tx_ucast_packets, MAC_TX_STATS_UCAST);\n\tTG3_STAT_ADD32(&sp->tx_mcast_packets, MAC_TX_STATS_MCAST);\n\tTG3_STAT_ADD32(&sp->tx_bcast_packets, MAC_TX_STATS_BCAST);\n\tif (unlikely(tg3_flag(tp, 5719_5720_RDMA_BUG) &&\n\t\t     (sp->tx_ucast_packets.low + sp->tx_mcast_packets.low +\n\t\t      sp->tx_bcast_packets.low) > TG3_NUM_RDMA_CHANNELS)) {\n\t\tu32 val;\n\n\t\tval = tr32(TG3_LSO_RD_DMA_CRPTEN_CTRL);\n\t\tval &= ~tg3_lso_rd_dma_workaround_bit(tp);\n\t\ttw32(TG3_LSO_RD_DMA_CRPTEN_CTRL, val);\n\t\ttg3_flag_clear(tp, 5719_5720_RDMA_BUG);\n\t}\n\n\tTG3_STAT_ADD32(&sp->rx_octets, MAC_RX_STATS_OCTETS);\n\tTG3_STAT_ADD32(&sp->rx_fragments, MAC_RX_STATS_FRAGMENTS);\n\tTG3_STAT_ADD32(&sp->rx_ucast_packets, MAC_RX_STATS_UCAST);\n\tTG3_STAT_ADD32(&sp->rx_mcast_packets, MAC_RX_STATS_MCAST);\n\tTG3_STAT_ADD32(&sp->rx_bcast_packets, MAC_RX_STATS_BCAST);\n\tTG3_STAT_ADD32(&sp->rx_fcs_errors, MAC_RX_STATS_FCS_ERRORS);\n\tTG3_STAT_ADD32(&sp->rx_align_errors, MAC_RX_STATS_ALIGN_ERRORS);\n\tTG3_STAT_ADD32(&sp->rx_xon_pause_rcvd, MAC_RX_STATS_XON_PAUSE_RECVD);\n\tTG3_STAT_ADD32(&sp->rx_xoff_pause_rcvd, MAC_RX_STATS_XOFF_PAUSE_RECVD);\n\tTG3_STAT_ADD32(&sp->rx_mac_ctrl_rcvd, MAC_RX_STATS_MAC_CTRL_RECVD);\n\tTG3_STAT_ADD32(&sp->rx_xoff_entered, MAC_RX_STATS_XOFF_ENTERED);\n\tTG3_STAT_ADD32(&sp->rx_frame_too_long_errors, MAC_RX_STATS_FRAME_TOO_LONG);\n\tTG3_STAT_ADD32(&sp->rx_jabbers, MAC_RX_STATS_JABBERS);\n\tTG3_STAT_ADD32(&sp->rx_undersize_packets, MAC_RX_STATS_UNDERSIZE);\n\n\tTG3_STAT_ADD32(&sp->rxbds_empty, RCVLPC_NO_RCV_BD_CNT);\n\tif (tg3_asic_rev(tp) != ASIC_REV_5717 &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5762 &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5719_A0 &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5720_A0) {\n\t\tTG3_STAT_ADD32(&sp->rx_discards, RCVLPC_IN_DISCARDS_CNT);\n\t} else {\n\t\tu32 val = tr32(HOSTCC_FLOW_ATTN);\n\t\tval = (val & HOSTCC_FLOW_ATTN_MBUF_LWM) ? 1 : 0;\n\t\tif (val) {\n\t\t\ttw32(HOSTCC_FLOW_ATTN, HOSTCC_FLOW_ATTN_MBUF_LWM);\n\t\t\tsp->rx_discards.low += val;\n\t\t\tif (sp->rx_discards.low < val)\n\t\t\t\tsp->rx_discards.high += 1;\n\t\t}\n\t\tsp->mbuf_lwm_thresh_hit = sp->rx_discards;\n\t}\n\tTG3_STAT_ADD32(&sp->rx_errors, RCVLPC_IN_ERRORS_CNT);\n}\n\nstatic void tg3_chk_missed_msi(struct tg3 *tp)\n{\n\tu32 i;\n\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\tif (tg3_has_work(tnapi)) {\n\t\t\tif (tnapi->last_rx_cons == tnapi->rx_rcb_ptr &&\n\t\t\t    tnapi->last_tx_cons == tnapi->tx_cons) {\n\t\t\t\tif (tnapi->chk_msi_cnt < 1) {\n\t\t\t\t\ttnapi->chk_msi_cnt++;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttg3_msi(0, tnapi);\n\t\t\t}\n\t\t}\n\t\ttnapi->chk_msi_cnt = 0;\n\t\ttnapi->last_rx_cons = tnapi->rx_rcb_ptr;\n\t\ttnapi->last_tx_cons = tnapi->tx_cons;\n\t}\n}\n\nstatic void tg3_timer(struct timer_list *t)\n{\n\tstruct tg3 *tp = from_timer(tp, t, timer);\n\n\tspin_lock(&tp->lock);\n\n\tif (tp->irq_sync || tg3_flag(tp, RESET_TASK_PENDING)) {\n\t\tspin_unlock(&tp->lock);\n\t\tgoto restart_timer;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_flag(tp, 57765_CLASS))\n\t\ttg3_chk_missed_msi(tp);\n\n\tif (tg3_flag(tp, FLUSH_POSTED_WRITES)) {\n\t\t/* BCM4785: Flush posted writes from GbE to host memory. */\n\t\ttr32(HOSTCC_MODE);\n\t}\n\n\tif (!tg3_flag(tp, TAGGED_STATUS)) {\n\t\t/* All of this garbage is because when using non-tagged\n\t\t * IRQ status the mailbox/status_block protocol the chip\n\t\t * uses with the cpu is race prone.\n\t\t */\n\t\tif (tp->napi[0].hw_status->status & SD_STATUS_UPDATED) {\n\t\t\ttw32(GRC_LOCAL_CTRL,\n\t\t\t     tp->grc_local_ctrl | GRC_LCLCTRL_SETINT);\n\t\t} else {\n\t\t\ttw32(HOSTCC_MODE, tp->coalesce_mode |\n\t\t\t     HOSTCC_MODE_ENABLE | HOSTCC_MODE_NOW);\n\t\t}\n\n\t\tif (!(tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {\n\t\t\tspin_unlock(&tp->lock);\n\t\t\ttg3_reset_task_schedule(tp);\n\t\t\tgoto restart_timer;\n\t\t}\n\t}\n\n\t/* This part only runs once per second. */\n\tif (!--tp->timer_counter) {\n\t\tif (tg3_flag(tp, 5705_PLUS))\n\t\t\ttg3_periodic_fetch_stats(tp);\n\n\t\tif (tp->setlpicnt && !--tp->setlpicnt)\n\t\t\ttg3_phy_eee_enable(tp);\n\n\t\tif (tg3_flag(tp, USE_LINKCHG_REG)) {\n\t\t\tu32 mac_stat;\n\t\t\tint phy_event;\n\n\t\t\tmac_stat = tr32(MAC_STATUS);\n\n\t\t\tphy_event = 0;\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_USE_MI_INTERRUPT) {\n\t\t\t\tif (mac_stat & MAC_STATUS_MI_INTERRUPT)\n\t\t\t\t\tphy_event = 1;\n\t\t\t} else if (mac_stat & MAC_STATUS_LNKSTATE_CHANGED)\n\t\t\t\tphy_event = 1;\n\n\t\t\tif (phy_event)\n\t\t\t\ttg3_setup_phy(tp, false);\n\t\t} else if (tg3_flag(tp, POLL_SERDES)) {\n\t\t\tu32 mac_stat = tr32(MAC_STATUS);\n\t\t\tint need_setup = 0;\n\n\t\t\tif (tp->link_up &&\n\t\t\t    (mac_stat & MAC_STATUS_LNKSTATE_CHANGED)) {\n\t\t\t\tneed_setup = 1;\n\t\t\t}\n\t\t\tif (!tp->link_up &&\n\t\t\t    (mac_stat & (MAC_STATUS_PCS_SYNCED |\n\t\t\t\t\t MAC_STATUS_SIGNAL_DET))) {\n\t\t\t\tneed_setup = 1;\n\t\t\t}\n\t\t\tif (need_setup) {\n\t\t\t\tif (!tp->serdes_counter) {\n\t\t\t\t\ttw32_f(MAC_MODE,\n\t\t\t\t\t     (tp->mac_mode &\n\t\t\t\t\t      ~MAC_MODE_PORT_MODE_MASK));\n\t\t\t\t\tudelay(40);\n\t\t\t\t\ttw32_f(MAC_MODE, tp->mac_mode);\n\t\t\t\t\tudelay(40);\n\t\t\t\t}\n\t\t\t\ttg3_setup_phy(tp, false);\n\t\t\t}\n\t\t} else if ((tp->phy_flags & TG3_PHYFLG_MII_SERDES) &&\n\t\t\t   tg3_flag(tp, 5780_CLASS)) {\n\t\t\ttg3_serdes_parallel_detect(tp);\n\t\t} else if (tg3_flag(tp, POLL_CPMU_LINK)) {\n\t\t\tu32 cpmu = tr32(TG3_CPMU_STATUS);\n\t\t\tbool link_up = !((cpmu & TG3_CPMU_STATUS_LINK_MASK) ==\n\t\t\t\t\t TG3_CPMU_STATUS_LINK_MASK);\n\n\t\t\tif (link_up != tp->link_up)\n\t\t\t\ttg3_setup_phy(tp, false);\n\t\t}\n\n\t\ttp->timer_counter = tp->timer_multiplier;\n\t}\n\n\t/* Heartbeat is only sent once every 2 seconds.\n\t *\n\t * The heartbeat is to tell the ASF firmware that the host\n\t * driver is still alive.  In the event that the OS crashes,\n\t * ASF needs to reset the hardware to free up the FIFO space\n\t * that may be filled with rx packets destined for the host.\n\t * If the FIFO is full, ASF will no longer function properly.\n\t *\n\t * Unintended resets have been reported on real time kernels\n\t * where the timer doesn't run on time.  Netpoll will also have\n\t * same problem.\n\t *\n\t * The new FWCMD_NICDRV_ALIVE3 command tells the ASF firmware\n\t * to check the ring condition when the heartbeat is expiring\n\t * before doing the reset.  This will prevent most unintended\n\t * resets.\n\t */\n\tif (!--tp->asf_counter) {\n\t\tif (tg3_flag(tp, ENABLE_ASF) && !tg3_flag(tp, ENABLE_APE)) {\n\t\t\ttg3_wait_for_event_ack(tp);\n\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_MBOX,\n\t\t\t\t      FWCMD_NICDRV_ALIVE3);\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_LEN_MBOX, 4);\n\t\t\ttg3_write_mem(tp, NIC_SRAM_FW_CMD_DATA_MBOX,\n\t\t\t\t      TG3_FW_UPDATE_TIMEOUT_SEC);\n\n\t\t\ttg3_generate_fw_event(tp);\n\t\t}\n\t\ttp->asf_counter = tp->asf_multiplier;\n\t}\n\n\t/* Update the APE heartbeat every 5 seconds.*/\n\ttg3_send_ape_heartbeat(tp, TG3_APE_HB_INTERVAL);\n\n\tspin_unlock(&tp->lock);\n\nrestart_timer:\n\ttp->timer.expires = jiffies + tp->timer_offset;\n\tadd_timer(&tp->timer);\n}\n\nstatic void tg3_timer_init(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, TAGGED_STATUS) &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5717 &&\n\t    !tg3_flag(tp, 57765_CLASS))\n\t\ttp->timer_offset = HZ;\n\telse\n\t\ttp->timer_offset = HZ / 10;\n\n\tBUG_ON(tp->timer_offset > HZ);\n\n\ttp->timer_multiplier = (HZ / tp->timer_offset);\n\ttp->asf_multiplier = (HZ / tp->timer_offset) *\n\t\t\t     TG3_FW_UPDATE_FREQ_SEC;\n\n\ttimer_setup(&tp->timer, tg3_timer, 0);\n}\n\nstatic void tg3_timer_start(struct tg3 *tp)\n{\n\ttp->asf_counter   = tp->asf_multiplier;\n\ttp->timer_counter = tp->timer_multiplier;\n\n\ttp->timer.expires = jiffies + tp->timer_offset;\n\tadd_timer(&tp->timer);\n}\n\nstatic void tg3_timer_stop(struct tg3 *tp)\n{\n\tdel_timer_sync(&tp->timer);\n}\n\n/* Restart hardware after configuration changes, self-test, etc.\n * Invoked with tp->lock held.\n */\nstatic int tg3_restart_hw(struct tg3 *tp, bool reset_phy)\n\t__releases(tp->lock)\n\t__acquires(tp->lock)\n{\n\tint err;\n\n\terr = tg3_init_hw(tp, reset_phy);\n\tif (err) {\n\t\tnetdev_err(tp->dev,\n\t\t\t   \"Failed to re-initialize device, aborting\\n\");\n\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\ttg3_full_unlock(tp);\n\t\ttg3_timer_stop(tp);\n\t\ttp->irq_sync = 0;\n\t\ttg3_napi_enable(tp);\n\t\tdev_close(tp->dev);\n\t\ttg3_full_lock(tp, 0);\n\t}\n\treturn err;\n}\n\nstatic void tg3_reset_task(struct work_struct *work)\n{\n\tstruct tg3 *tp = container_of(work, struct tg3, reset_task);\n\tint err;\n\n\trtnl_lock();\n\ttg3_full_lock(tp, 0);\n\n\tif (!netif_running(tp->dev)) {\n\t\ttg3_flag_clear(tp, RESET_TASK_PENDING);\n\t\ttg3_full_unlock(tp);\n\t\trtnl_unlock();\n\t\treturn;\n\t}\n\n\ttg3_full_unlock(tp);\n\n\ttg3_phy_stop(tp);\n\n\ttg3_netif_stop(tp);\n\n\ttg3_full_lock(tp, 1);\n\n\tif (tg3_flag(tp, TX_RECOVERY_PENDING)) {\n\t\ttp->write32_tx_mbox = tg3_write32_tx_mbox;\n\t\ttp->write32_rx_mbox = tg3_write_flush_reg32;\n\t\ttg3_flag_set(tp, MBOX_WRITE_REORDER);\n\t\ttg3_flag_clear(tp, TX_RECOVERY_PENDING);\n\t}\n\n\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 0);\n\terr = tg3_init_hw(tp, true);\n\tif (err) {\n\t\ttg3_full_unlock(tp);\n\t\ttp->irq_sync = 0;\n\t\ttg3_napi_enable(tp);\n\t\t/* Clear this flag so that tg3_reset_task_cancel() will not\n\t\t * call cancel_work_sync() and wait forever.\n\t\t */\n\t\ttg3_flag_clear(tp, RESET_TASK_PENDING);\n\t\tdev_close(tp->dev);\n\t\tgoto out;\n\t}\n\n\ttg3_netif_start(tp);\n\n\ttg3_full_unlock(tp);\n\n\tif (!err)\n\t\ttg3_phy_start(tp);\n\n\ttg3_flag_clear(tp, RESET_TASK_PENDING);\nout:\n\trtnl_unlock();\n}\n\nstatic int tg3_request_irq(struct tg3 *tp, int irq_num)\n{\n\tirq_handler_t fn;\n\tunsigned long flags;\n\tchar *name;\n\tstruct tg3_napi *tnapi = &tp->napi[irq_num];\n\n\tif (tp->irq_cnt == 1)\n\t\tname = tp->dev->name;\n\telse {\n\t\tname = &tnapi->irq_lbl[0];\n\t\tif (tnapi->tx_buffers && tnapi->rx_rcb)\n\t\t\tsnprintf(name, IFNAMSIZ,\n\t\t\t\t \"%s-txrx-%d\", tp->dev->name, irq_num);\n\t\telse if (tnapi->tx_buffers)\n\t\t\tsnprintf(name, IFNAMSIZ,\n\t\t\t\t \"%s-tx-%d\", tp->dev->name, irq_num);\n\t\telse if (tnapi->rx_rcb)\n\t\t\tsnprintf(name, IFNAMSIZ,\n\t\t\t\t \"%s-rx-%d\", tp->dev->name, irq_num);\n\t\telse\n\t\t\tsnprintf(name, IFNAMSIZ,\n\t\t\t\t \"%s-%d\", tp->dev->name, irq_num);\n\t\tname[IFNAMSIZ-1] = 0;\n\t}\n\n\tif (tg3_flag(tp, USING_MSI) || tg3_flag(tp, USING_MSIX)) {\n\t\tfn = tg3_msi;\n\t\tif (tg3_flag(tp, 1SHOT_MSI))\n\t\t\tfn = tg3_msi_1shot;\n\t\tflags = 0;\n\t} else {\n\t\tfn = tg3_interrupt;\n\t\tif (tg3_flag(tp, TAGGED_STATUS))\n\t\t\tfn = tg3_interrupt_tagged;\n\t\tflags = IRQF_SHARED;\n\t}\n\n\treturn request_irq(tnapi->irq_vec, fn, flags, name, tnapi);\n}\n\nstatic int tg3_test_interrupt(struct tg3 *tp)\n{\n\tstruct tg3_napi *tnapi = &tp->napi[0];\n\tstruct net_device *dev = tp->dev;\n\tint err, i, intr_ok = 0;\n\tu32 val;\n\n\tif (!netif_running(dev))\n\t\treturn -ENODEV;\n\n\ttg3_disable_ints(tp);\n\n\tfree_irq(tnapi->irq_vec, tnapi);\n\n\t/*\n\t * Turn off MSI one shot mode.  Otherwise this test has no\n\t * observable way to know whether the interrupt was delivered.\n\t */\n\tif (tg3_flag(tp, 57765_PLUS)) {\n\t\tval = tr32(MSGINT_MODE) | MSGINT_MODE_ONE_SHOT_DISABLE;\n\t\ttw32(MSGINT_MODE, val);\n\t}\n\n\terr = request_irq(tnapi->irq_vec, tg3_test_isr,\n\t\t\t  IRQF_SHARED, dev->name, tnapi);\n\tif (err)\n\t\treturn err;\n\n\ttnapi->hw_status->status &= ~SD_STATUS_UPDATED;\n\ttg3_enable_ints(tp);\n\n\ttw32_f(HOSTCC_MODE, tp->coalesce_mode | HOSTCC_MODE_ENABLE |\n\t       tnapi->coal_now);\n\n\tfor (i = 0; i < 5; i++) {\n\t\tu32 int_mbox, misc_host_ctrl;\n\n\t\tint_mbox = tr32_mailbox(tnapi->int_mbox);\n\t\tmisc_host_ctrl = tr32(TG3PCI_MISC_HOST_CTRL);\n\n\t\tif ((int_mbox != 0) ||\n\t\t    (misc_host_ctrl & MISC_HOST_CTRL_MASK_PCI_INT)) {\n\t\t\tintr_ok = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tg3_flag(tp, 57765_PLUS) &&\n\t\t    tnapi->hw_status->status_tag != tnapi->last_tag)\n\t\t\ttw32_mailbox_f(tnapi->int_mbox, tnapi->last_tag << 24);\n\n\t\tmsleep(10);\n\t}\n\n\ttg3_disable_ints(tp);\n\n\tfree_irq(tnapi->irq_vec, tnapi);\n\n\terr = tg3_request_irq(tp, 0);\n\n\tif (err)\n\t\treturn err;\n\n\tif (intr_ok) {\n\t\t/* Reenable MSI one shot mode. */\n\t\tif (tg3_flag(tp, 57765_PLUS) && tg3_flag(tp, 1SHOT_MSI)) {\n\t\t\tval = tr32(MSGINT_MODE) & ~MSGINT_MODE_ONE_SHOT_DISABLE;\n\t\t\ttw32(MSGINT_MODE, val);\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n/* Returns 0 if MSI test succeeds or MSI test fails and INTx mode is\n * successfully restored\n */\nstatic int tg3_test_msi(struct tg3 *tp)\n{\n\tint err;\n\tu16 pci_cmd;\n\n\tif (!tg3_flag(tp, USING_MSI))\n\t\treturn 0;\n\n\t/* Turn off SERR reporting in case MSI terminates with Master\n\t * Abort.\n\t */\n\tpci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\n\tpci_write_config_word(tp->pdev, PCI_COMMAND,\n\t\t\t      pci_cmd & ~PCI_COMMAND_SERR);\n\n\terr = tg3_test_interrupt(tp);\n\n\tpci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\n\n\tif (!err)\n\t\treturn 0;\n\n\t/* other failures */\n\tif (err != -EIO)\n\t\treturn err;\n\n\t/* MSI test failed, go back to INTx mode */\n\tnetdev_warn(tp->dev, \"No interrupt was generated using MSI. Switching \"\n\t\t    \"to INTx mode. Please report this failure to the PCI \"\n\t\t    \"maintainer and include system chipset information\\n\");\n\n\tfree_irq(tp->napi[0].irq_vec, &tp->napi[0]);\n\n\tpci_disable_msi(tp->pdev);\n\n\ttg3_flag_clear(tp, USING_MSI);\n\ttp->napi[0].irq_vec = tp->pdev->irq;\n\n\terr = tg3_request_irq(tp, 0);\n\tif (err)\n\t\treturn err;\n\n\t/* Need to reset the chip because the MSI cycle may have terminated\n\t * with Master Abort.\n\t */\n\ttg3_full_lock(tp, 1);\n\n\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\terr = tg3_init_hw(tp, true);\n\n\ttg3_full_unlock(tp);\n\n\tif (err)\n\t\tfree_irq(tp->napi[0].irq_vec, &tp->napi[0]);\n\n\treturn err;\n}\n\nstatic int tg3_request_firmware(struct tg3 *tp)\n{\n\tconst struct tg3_firmware_hdr *fw_hdr;\n\n\tif (request_firmware(&tp->fw, tp->fw_needed, &tp->pdev->dev)) {\n\t\tnetdev_err(tp->dev, \"Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t   tp->fw_needed);\n\t\treturn -ENOENT;\n\t}\n\n\tfw_hdr = (struct tg3_firmware_hdr *)tp->fw->data;\n\n\t/* Firmware blob starts with version numbers, followed by\n\t * start address and _full_ length including BSS sections\n\t * (which must be longer than the actual data, of course\n\t */\n\n\ttp->fw_len = be32_to_cpu(fw_hdr->len);\t/* includes bss */\n\tif (tp->fw_len < (tp->fw->size - TG3_FW_HDR_LEN)) {\n\t\tnetdev_err(tp->dev, \"bogus length %d in \\\"%s\\\"\\n\",\n\t\t\t   tp->fw_len, tp->fw_needed);\n\t\trelease_firmware(tp->fw);\n\t\ttp->fw = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\t/* We no longer need firmware; we have it. */\n\ttp->fw_needed = NULL;\n\treturn 0;\n}\n\nstatic u32 tg3_irq_count(struct tg3 *tp)\n{\n\tu32 irq_cnt = max(tp->rxq_cnt, tp->txq_cnt);\n\n\tif (irq_cnt > 1) {\n\t\t/* We want as many rx rings enabled as there are cpus.\n\t\t * In multiqueue MSI-X mode, the first MSI-X vector\n\t\t * only deals with link interrupts, etc, so we add\n\t\t * one to the number of vectors we are requesting.\n\t\t */\n\t\tirq_cnt = min_t(unsigned, irq_cnt + 1, tp->irq_max);\n\t}\n\n\treturn irq_cnt;\n}\n\nstatic bool tg3_enable_msix(struct tg3 *tp)\n{\n\tint i, rc;\n\tstruct msix_entry msix_ent[TG3_IRQ_MAX_VECS];\n\n\ttp->txq_cnt = tp->txq_req;\n\ttp->rxq_cnt = tp->rxq_req;\n\tif (!tp->rxq_cnt)\n\t\ttp->rxq_cnt = netif_get_num_default_rss_queues();\n\tif (tp->rxq_cnt > tp->rxq_max)\n\t\ttp->rxq_cnt = tp->rxq_max;\n\n\t/* Disable multiple TX rings by default.  Simple round-robin hardware\n\t * scheduling of the TX rings can cause starvation of rings with\n\t * small packets when other rings have TSO or jumbo packets.\n\t */\n\tif (!tp->txq_req)\n\t\ttp->txq_cnt = 1;\n\n\ttp->irq_cnt = tg3_irq_count(tp);\n\n\tfor (i = 0; i < tp->irq_max; i++) {\n\t\tmsix_ent[i].entry  = i;\n\t\tmsix_ent[i].vector = 0;\n\t}\n\n\trc = pci_enable_msix_range(tp->pdev, msix_ent, 1, tp->irq_cnt);\n\tif (rc < 0) {\n\t\treturn false;\n\t} else if (rc < tp->irq_cnt) {\n\t\tnetdev_notice(tp->dev, \"Requested %d MSI-X vectors, received %d\\n\",\n\t\t\t      tp->irq_cnt, rc);\n\t\ttp->irq_cnt = rc;\n\t\ttp->rxq_cnt = max(rc - 1, 1);\n\t\tif (tp->txq_cnt)\n\t\t\ttp->txq_cnt = min(tp->rxq_cnt, tp->txq_max);\n\t}\n\n\tfor (i = 0; i < tp->irq_max; i++)\n\t\ttp->napi[i].irq_vec = msix_ent[i].vector;\n\n\tif (netif_set_real_num_rx_queues(tp->dev, tp->rxq_cnt)) {\n\t\tpci_disable_msix(tp->pdev);\n\t\treturn false;\n\t}\n\n\tif (tp->irq_cnt == 1)\n\t\treturn true;\n\n\ttg3_flag_set(tp, ENABLE_RSS);\n\n\tif (tp->txq_cnt > 1)\n\t\ttg3_flag_set(tp, ENABLE_TSS);\n\n\tnetif_set_real_num_tx_queues(tp->dev, tp->txq_cnt);\n\n\treturn true;\n}\n\nstatic void tg3_ints_init(struct tg3 *tp)\n{\n\tif ((tg3_flag(tp, SUPPORT_MSI) || tg3_flag(tp, SUPPORT_MSIX)) &&\n\t    !tg3_flag(tp, TAGGED_STATUS)) {\n\t\t/* All MSI supporting chips should support tagged\n\t\t * status.  Assert that this is the case.\n\t\t */\n\t\tnetdev_warn(tp->dev,\n\t\t\t    \"MSI without TAGGED_STATUS? Not using MSI\\n\");\n\t\tgoto defcfg;\n\t}\n\n\tif (tg3_flag(tp, SUPPORT_MSIX) && tg3_enable_msix(tp))\n\t\ttg3_flag_set(tp, USING_MSIX);\n\telse if (tg3_flag(tp, SUPPORT_MSI) && pci_enable_msi(tp->pdev) == 0)\n\t\ttg3_flag_set(tp, USING_MSI);\n\n\tif (tg3_flag(tp, USING_MSI) || tg3_flag(tp, USING_MSIX)) {\n\t\tu32 msi_mode = tr32(MSGINT_MODE);\n\t\tif (tg3_flag(tp, USING_MSIX) && tp->irq_cnt > 1)\n\t\t\tmsi_mode |= MSGINT_MODE_MULTIVEC_EN;\n\t\tif (!tg3_flag(tp, 1SHOT_MSI))\n\t\t\tmsi_mode |= MSGINT_MODE_ONE_SHOT_DISABLE;\n\t\ttw32(MSGINT_MODE, msi_mode | MSGINT_MODE_ENABLE);\n\t}\ndefcfg:\n\tif (!tg3_flag(tp, USING_MSIX)) {\n\t\ttp->irq_cnt = 1;\n\t\ttp->napi[0].irq_vec = tp->pdev->irq;\n\t}\n\n\tif (tp->irq_cnt == 1) {\n\t\ttp->txq_cnt = 1;\n\t\ttp->rxq_cnt = 1;\n\t\tnetif_set_real_num_tx_queues(tp->dev, 1);\n\t\tnetif_set_real_num_rx_queues(tp->dev, 1);\n\t}\n}\n\nstatic void tg3_ints_fini(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, USING_MSIX))\n\t\tpci_disable_msix(tp->pdev);\n\telse if (tg3_flag(tp, USING_MSI))\n\t\tpci_disable_msi(tp->pdev);\n\ttg3_flag_clear(tp, USING_MSI);\n\ttg3_flag_clear(tp, USING_MSIX);\n\ttg3_flag_clear(tp, ENABLE_RSS);\n\ttg3_flag_clear(tp, ENABLE_TSS);\n}\n\nstatic int tg3_start(struct tg3 *tp, bool reset_phy, bool test_irq,\n\t\t     bool init)\n{\n\tstruct net_device *dev = tp->dev;\n\tint i, err;\n\n\t/*\n\t * Setup interrupts first so we know how\n\t * many NAPI resources to allocate\n\t */\n\ttg3_ints_init(tp);\n\n\ttg3_rss_check_indir_tbl(tp);\n\n\t/* The placement of this call is tied\n\t * to the setup and use of Host TX descriptors.\n\t */\n\terr = tg3_alloc_consistent(tp);\n\tif (err)\n\t\tgoto out_ints_fini;\n\n\ttg3_napi_init(tp);\n\n\ttg3_napi_enable(tp);\n\n\tfor (i = 0; i < tp->irq_cnt; i++) {\n\t\terr = tg3_request_irq(tp, i);\n\t\tif (err) {\n\t\t\tfor (i--; i >= 0; i--) {\n\t\t\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\t\t\tfree_irq(tnapi->irq_vec, tnapi);\n\t\t\t}\n\t\t\tgoto out_napi_fini;\n\t\t}\n\t}\n\n\ttg3_full_lock(tp, 0);\n\n\tif (init)\n\t\ttg3_ape_driver_state_change(tp, RESET_KIND_INIT);\n\n\terr = tg3_init_hw(tp, reset_phy);\n\tif (err) {\n\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\ttg3_free_rings(tp);\n\t}\n\n\ttg3_full_unlock(tp);\n\n\tif (err)\n\t\tgoto out_free_irq;\n\n\tif (test_irq && tg3_flag(tp, USING_MSI)) {\n\t\terr = tg3_test_msi(tp);\n\n\t\tif (err) {\n\t\t\ttg3_full_lock(tp, 0);\n\t\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\t\ttg3_free_rings(tp);\n\t\t\ttg3_full_unlock(tp);\n\n\t\t\tgoto out_napi_fini;\n\t\t}\n\n\t\tif (!tg3_flag(tp, 57765_PLUS) && tg3_flag(tp, USING_MSI)) {\n\t\t\tu32 val = tr32(PCIE_TRANSACTION_CFG);\n\n\t\t\ttw32(PCIE_TRANSACTION_CFG,\n\t\t\t     val | PCIE_TRANS_CFG_1SHOT_MSI);\n\t\t}\n\t}\n\n\ttg3_phy_start(tp);\n\n\ttg3_hwmon_open(tp);\n\n\ttg3_full_lock(tp, 0);\n\n\ttg3_timer_start(tp);\n\ttg3_flag_set(tp, INIT_COMPLETE);\n\ttg3_enable_ints(tp);\n\n\ttg3_ptp_resume(tp);\n\n\ttg3_full_unlock(tp);\n\n\tnetif_tx_start_all_queues(dev);\n\n\t/*\n\t * Reset loopback feature if it was turned on while the device was down\n\t * make sure that it's installed properly now.\n\t */\n\tif (dev->features & NETIF_F_LOOPBACK)\n\t\ttg3_set_loopback(dev, dev->features);\n\n\treturn 0;\n\nout_free_irq:\n\tfor (i = tp->irq_cnt - 1; i >= 0; i--) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\t\tfree_irq(tnapi->irq_vec, tnapi);\n\t}\n\nout_napi_fini:\n\ttg3_napi_disable(tp);\n\ttg3_napi_fini(tp);\n\ttg3_free_consistent(tp);\n\nout_ints_fini:\n\ttg3_ints_fini(tp);\n\n\treturn err;\n}\n\nstatic void tg3_stop(struct tg3 *tp)\n{\n\tint i;\n\n\ttg3_reset_task_cancel(tp);\n\ttg3_netif_stop(tp);\n\n\ttg3_timer_stop(tp);\n\n\ttg3_hwmon_close(tp);\n\n\ttg3_phy_stop(tp);\n\n\ttg3_full_lock(tp, 1);\n\n\ttg3_disable_ints(tp);\n\n\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\ttg3_free_rings(tp);\n\ttg3_flag_clear(tp, INIT_COMPLETE);\n\n\ttg3_full_unlock(tp);\n\n\tfor (i = tp->irq_cnt - 1; i >= 0; i--) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\t\tfree_irq(tnapi->irq_vec, tnapi);\n\t}\n\n\ttg3_ints_fini(tp);\n\n\ttg3_napi_fini(tp);\n\n\ttg3_free_consistent(tp);\n}\n\nstatic int tg3_open(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err;\n\n\tif (tp->pcierr_recovery) {\n\t\tnetdev_err(dev, \"Failed to open device. PCI error recovery \"\n\t\t\t   \"in progress\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (tp->fw_needed) {\n\t\terr = tg3_request_firmware(tp);\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\t\tif (err) {\n\t\t\t\tnetdev_warn(tp->dev, \"EEE capability disabled\\n\");\n\t\t\t\ttp->phy_flags &= ~TG3_PHYFLG_EEE_CAP;\n\t\t\t} else if (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP)) {\n\t\t\t\tnetdev_warn(tp->dev, \"EEE capability restored\\n\");\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_EEE_CAP;\n\t\t\t}\n\t\t} else if (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0) {\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (err) {\n\t\t\tnetdev_warn(tp->dev, \"TSO capability disabled\\n\");\n\t\t\ttg3_flag_clear(tp, TSO_CAPABLE);\n\t\t} else if (!tg3_flag(tp, TSO_CAPABLE)) {\n\t\t\tnetdev_notice(tp->dev, \"TSO capability restored\\n\");\n\t\t\ttg3_flag_set(tp, TSO_CAPABLE);\n\t\t}\n\t}\n\n\ttg3_carrier_off(tp);\n\n\terr = tg3_power_up(tp);\n\tif (err)\n\t\treturn err;\n\n\ttg3_full_lock(tp, 0);\n\n\ttg3_disable_ints(tp);\n\ttg3_flag_clear(tp, INIT_COMPLETE);\n\n\ttg3_full_unlock(tp);\n\n\terr = tg3_start(tp,\n\t\t\t!(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN),\n\t\t\ttrue, true);\n\tif (err) {\n\t\ttg3_frob_aux_power(tp, false);\n\t\tpci_set_power_state(tp->pdev, PCI_D3hot);\n\t}\n\n\treturn err;\n}\n\nstatic int tg3_close(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (tp->pcierr_recovery) {\n\t\tnetdev_err(dev, \"Failed to close device. PCI error recovery \"\n\t\t\t   \"in progress\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\ttg3_stop(tp);\n\n\tif (pci_device_is_present(tp->pdev)) {\n\t\ttg3_power_down_prepare(tp);\n\n\t\ttg3_carrier_off(tp);\n\t}\n\treturn 0;\n}\n\nstatic inline u64 get_stat64(tg3_stat64_t *val)\n{\n       return ((u64)val->high << 32) | ((u64)val->low);\n}\n\nstatic u64 tg3_calc_crc_errors(struct tg3 *tp)\n{\n\tstruct tg3_hw_stats *hw_stats = tp->hw_stats;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\n\t    (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5701)) {\n\t\tu32 val;\n\n\t\tif (!tg3_readphy(tp, MII_TG3_TEST1, &val)) {\n\t\t\ttg3_writephy(tp, MII_TG3_TEST1,\n\t\t\t\t     val | MII_TG3_TEST1_CRC_EN);\n\t\t\ttg3_readphy(tp, MII_TG3_RXR_COUNTERS, &val);\n\t\t} else\n\t\t\tval = 0;\n\n\t\ttp->phy_crc_errors += val;\n\n\t\treturn tp->phy_crc_errors;\n\t}\n\n\treturn get_stat64(&hw_stats->rx_fcs_errors);\n}\n\n#define ESTAT_ADD(member) \\\n\testats->member =\told_estats->member + \\\n\t\t\t\tget_stat64(&hw_stats->member)\n\nstatic void tg3_get_estats(struct tg3 *tp, struct tg3_ethtool_stats *estats)\n{\n\tstruct tg3_ethtool_stats *old_estats = &tp->estats_prev;\n\tstruct tg3_hw_stats *hw_stats = tp->hw_stats;\n\n\tESTAT_ADD(rx_octets);\n\tESTAT_ADD(rx_fragments);\n\tESTAT_ADD(rx_ucast_packets);\n\tESTAT_ADD(rx_mcast_packets);\n\tESTAT_ADD(rx_bcast_packets);\n\tESTAT_ADD(rx_fcs_errors);\n\tESTAT_ADD(rx_align_errors);\n\tESTAT_ADD(rx_xon_pause_rcvd);\n\tESTAT_ADD(rx_xoff_pause_rcvd);\n\tESTAT_ADD(rx_mac_ctrl_rcvd);\n\tESTAT_ADD(rx_xoff_entered);\n\tESTAT_ADD(rx_frame_too_long_errors);\n\tESTAT_ADD(rx_jabbers);\n\tESTAT_ADD(rx_undersize_packets);\n\tESTAT_ADD(rx_in_length_errors);\n\tESTAT_ADD(rx_out_length_errors);\n\tESTAT_ADD(rx_64_or_less_octet_packets);\n\tESTAT_ADD(rx_65_to_127_octet_packets);\n\tESTAT_ADD(rx_128_to_255_octet_packets);\n\tESTAT_ADD(rx_256_to_511_octet_packets);\n\tESTAT_ADD(rx_512_to_1023_octet_packets);\n\tESTAT_ADD(rx_1024_to_1522_octet_packets);\n\tESTAT_ADD(rx_1523_to_2047_octet_packets);\n\tESTAT_ADD(rx_2048_to_4095_octet_packets);\n\tESTAT_ADD(rx_4096_to_8191_octet_packets);\n\tESTAT_ADD(rx_8192_to_9022_octet_packets);\n\n\tESTAT_ADD(tx_octets);\n\tESTAT_ADD(tx_collisions);\n\tESTAT_ADD(tx_xon_sent);\n\tESTAT_ADD(tx_xoff_sent);\n\tESTAT_ADD(tx_flow_control);\n\tESTAT_ADD(tx_mac_errors);\n\tESTAT_ADD(tx_single_collisions);\n\tESTAT_ADD(tx_mult_collisions);\n\tESTAT_ADD(tx_deferred);\n\tESTAT_ADD(tx_excessive_collisions);\n\tESTAT_ADD(tx_late_collisions);\n\tESTAT_ADD(tx_collide_2times);\n\tESTAT_ADD(tx_collide_3times);\n\tESTAT_ADD(tx_collide_4times);\n\tESTAT_ADD(tx_collide_5times);\n\tESTAT_ADD(tx_collide_6times);\n\tESTAT_ADD(tx_collide_7times);\n\tESTAT_ADD(tx_collide_8times);\n\tESTAT_ADD(tx_collide_9times);\n\tESTAT_ADD(tx_collide_10times);\n\tESTAT_ADD(tx_collide_11times);\n\tESTAT_ADD(tx_collide_12times);\n\tESTAT_ADD(tx_collide_13times);\n\tESTAT_ADD(tx_collide_14times);\n\tESTAT_ADD(tx_collide_15times);\n\tESTAT_ADD(tx_ucast_packets);\n\tESTAT_ADD(tx_mcast_packets);\n\tESTAT_ADD(tx_bcast_packets);\n\tESTAT_ADD(tx_carrier_sense_errors);\n\tESTAT_ADD(tx_discards);\n\tESTAT_ADD(tx_errors);\n\n\tESTAT_ADD(dma_writeq_full);\n\tESTAT_ADD(dma_write_prioq_full);\n\tESTAT_ADD(rxbds_empty);\n\tESTAT_ADD(rx_discards);\n\tESTAT_ADD(rx_errors);\n\tESTAT_ADD(rx_threshold_hit);\n\n\tESTAT_ADD(dma_readq_full);\n\tESTAT_ADD(dma_read_prioq_full);\n\tESTAT_ADD(tx_comp_queue_full);\n\n\tESTAT_ADD(ring_set_send_prod_index);\n\tESTAT_ADD(ring_status_update);\n\tESTAT_ADD(nic_irqs);\n\tESTAT_ADD(nic_avoided_irqs);\n\tESTAT_ADD(nic_tx_threshold_hit);\n\n\tESTAT_ADD(mbuf_lwm_thresh_hit);\n}\n\nstatic void tg3_get_nstats(struct tg3 *tp, struct rtnl_link_stats64 *stats)\n{\n\tstruct rtnl_link_stats64 *old_stats = &tp->net_stats_prev;\n\tstruct tg3_hw_stats *hw_stats = tp->hw_stats;\n\n\tstats->rx_packets = old_stats->rx_packets +\n\t\tget_stat64(&hw_stats->rx_ucast_packets) +\n\t\tget_stat64(&hw_stats->rx_mcast_packets) +\n\t\tget_stat64(&hw_stats->rx_bcast_packets);\n\n\tstats->tx_packets = old_stats->tx_packets +\n\t\tget_stat64(&hw_stats->tx_ucast_packets) +\n\t\tget_stat64(&hw_stats->tx_mcast_packets) +\n\t\tget_stat64(&hw_stats->tx_bcast_packets);\n\n\tstats->rx_bytes = old_stats->rx_bytes +\n\t\tget_stat64(&hw_stats->rx_octets);\n\tstats->tx_bytes = old_stats->tx_bytes +\n\t\tget_stat64(&hw_stats->tx_octets);\n\n\tstats->rx_errors = old_stats->rx_errors +\n\t\tget_stat64(&hw_stats->rx_errors);\n\tstats->tx_errors = old_stats->tx_errors +\n\t\tget_stat64(&hw_stats->tx_errors) +\n\t\tget_stat64(&hw_stats->tx_mac_errors) +\n\t\tget_stat64(&hw_stats->tx_carrier_sense_errors) +\n\t\tget_stat64(&hw_stats->tx_discards);\n\n\tstats->multicast = old_stats->multicast +\n\t\tget_stat64(&hw_stats->rx_mcast_packets);\n\tstats->collisions = old_stats->collisions +\n\t\tget_stat64(&hw_stats->tx_collisions);\n\n\tstats->rx_length_errors = old_stats->rx_length_errors +\n\t\tget_stat64(&hw_stats->rx_frame_too_long_errors) +\n\t\tget_stat64(&hw_stats->rx_undersize_packets);\n\n\tstats->rx_frame_errors = old_stats->rx_frame_errors +\n\t\tget_stat64(&hw_stats->rx_align_errors);\n\tstats->tx_aborted_errors = old_stats->tx_aborted_errors +\n\t\tget_stat64(&hw_stats->tx_discards);\n\tstats->tx_carrier_errors = old_stats->tx_carrier_errors +\n\t\tget_stat64(&hw_stats->tx_carrier_sense_errors);\n\n\tstats->rx_crc_errors = old_stats->rx_crc_errors +\n\t\ttg3_calc_crc_errors(tp);\n\n\tstats->rx_missed_errors = old_stats->rx_missed_errors +\n\t\tget_stat64(&hw_stats->rx_discards);\n\n\tstats->rx_dropped = tp->rx_dropped;\n\tstats->tx_dropped = tp->tx_dropped;\n}\n\nstatic int tg3_get_regs_len(struct net_device *dev)\n{\n\treturn TG3_REG_BLK_SIZE;\n}\n\nstatic void tg3_get_regs(struct net_device *dev,\n\t\tstruct ethtool_regs *regs, void *_p)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tregs->version = 0;\n\n\tmemset(_p, 0, TG3_REG_BLK_SIZE);\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\n\t\treturn;\n\n\ttg3_full_lock(tp, 0);\n\n\ttg3_dump_legacy_regs(tp, (u32 *)_p);\n\n\ttg3_full_unlock(tp);\n}\n\nstatic int tg3_get_eeprom_len(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\treturn tp->nvram_size;\n}\n\nstatic int tg3_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint ret, cpmu_restore = 0;\n\tu8  *pd;\n\tu32 i, offset, len, b_offset, b_count, cpmu_val = 0;\n\t__be32 val;\n\n\tif (tg3_flag(tp, NO_NVRAM))\n\t\treturn -EINVAL;\n\n\toffset = eeprom->offset;\n\tlen = eeprom->len;\n\teeprom->len = 0;\n\n\teeprom->magic = TG3_EEPROM_MAGIC;\n\n\t/* Override clock, link aware and link idle modes */\n\tif (tg3_flag(tp, CPMU_PRESENT)) {\n\t\tcpmu_val = tr32(TG3_CPMU_CTRL);\n\t\tif (cpmu_val & (CPMU_CTRL_LINK_AWARE_MODE |\n\t\t\t\tCPMU_CTRL_LINK_IDLE_MODE)) {\n\t\t\ttw32(TG3_CPMU_CTRL, cpmu_val &\n\t\t\t\t\t    ~(CPMU_CTRL_LINK_AWARE_MODE |\n\t\t\t\t\t     CPMU_CTRL_LINK_IDLE_MODE));\n\t\t\tcpmu_restore = 1;\n\t\t}\n\t}\n\ttg3_override_clk(tp);\n\n\tif (offset & 3) {\n\t\t/* adjustments to start on required 4 byte boundary */\n\t\tb_offset = offset & 3;\n\t\tb_count = 4 - b_offset;\n\t\tif (b_count > len) {\n\t\t\t/* i.e. offset=1 len=2 */\n\t\t\tb_count = len;\n\t\t}\n\t\tret = tg3_nvram_read_be32(tp, offset-b_offset, &val);\n\t\tif (ret)\n\t\t\tgoto eeprom_done;\n\t\tmemcpy(data, ((char *)&val) + b_offset, b_count);\n\t\tlen -= b_count;\n\t\toffset += b_count;\n\t\teeprom->len += b_count;\n\t}\n\n\t/* read bytes up to the last 4 byte boundary */\n\tpd = &data[eeprom->len];\n\tfor (i = 0; i < (len - (len & 3)); i += 4) {\n\t\tret = tg3_nvram_read_be32(tp, offset + i, &val);\n\t\tif (ret) {\n\t\t\tif (i)\n\t\t\t\ti -= 4;\n\t\t\teeprom->len += i;\n\t\t\tgoto eeprom_done;\n\t\t}\n\t\tmemcpy(pd + i, &val, 4);\n\t\tif (need_resched()) {\n\t\t\tif (signal_pending(current)) {\n\t\t\t\teeprom->len += i;\n\t\t\t\tret = -EINTR;\n\t\t\t\tgoto eeprom_done;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t}\n\t}\n\teeprom->len += i;\n\n\tif (len & 3) {\n\t\t/* read last bytes not ending on 4 byte boundary */\n\t\tpd = &data[eeprom->len];\n\t\tb_count = len & 3;\n\t\tb_offset = offset + len - b_count;\n\t\tret = tg3_nvram_read_be32(tp, b_offset, &val);\n\t\tif (ret)\n\t\t\tgoto eeprom_done;\n\t\tmemcpy(pd, &val, b_count);\n\t\teeprom->len += b_count;\n\t}\n\tret = 0;\n\neeprom_done:\n\t/* Restore clock, link aware and link idle modes */\n\ttg3_restore_clk(tp);\n\tif (cpmu_restore)\n\t\ttw32(TG3_CPMU_CTRL, cpmu_val);\n\n\treturn ret;\n}\n\nstatic int tg3_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint ret;\n\tu32 offset, len, b_offset, odd_len;\n\tu8 *buf;\n\t__be32 start = 0, end;\n\n\tif (tg3_flag(tp, NO_NVRAM) ||\n\t    eeprom->magic != TG3_EEPROM_MAGIC)\n\t\treturn -EINVAL;\n\n\toffset = eeprom->offset;\n\tlen = eeprom->len;\n\n\tif ((b_offset = (offset & 3))) {\n\t\t/* adjustments to start on required 4 byte boundary */\n\t\tret = tg3_nvram_read_be32(tp, offset-b_offset, &start);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tlen += b_offset;\n\t\toffset &= ~3;\n\t\tif (len < 4)\n\t\t\tlen = 4;\n\t}\n\n\todd_len = 0;\n\tif (len & 3) {\n\t\t/* adjustments to end on required 4 byte boundary */\n\t\todd_len = 1;\n\t\tlen = (len + 3) & ~3;\n\t\tret = tg3_nvram_read_be32(tp, offset+len-4, &end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tbuf = data;\n\tif (b_offset || odd_len) {\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tif (b_offset)\n\t\t\tmemcpy(buf, &start, 4);\n\t\tif (odd_len)\n\t\t\tmemcpy(buf+len-4, &end, 4);\n\t\tmemcpy(buf + b_offset, data, eeprom->len);\n\t}\n\n\tret = tg3_nvram_write_block(tp, offset, len, buf);\n\n\tif (buf != data)\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int tg3_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tu32 supported, advertising;\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tstruct phy_device *phydev;\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\n\t\t\treturn -EAGAIN;\n\t\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\t\tphy_ethtool_ksettings_get(phydev, cmd);\n\n\t\treturn 0;\n\t}\n\n\tsupported = (SUPPORTED_Autoneg);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY))\n\t\tsupported |= (SUPPORTED_1000baseT_Half |\n\t\t\t      SUPPORTED_1000baseT_Full);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\n\t\tsupported |= (SUPPORTED_100baseT_Half |\n\t\t\t      SUPPORTED_100baseT_Full |\n\t\t\t      SUPPORTED_10baseT_Half |\n\t\t\t      SUPPORTED_10baseT_Full |\n\t\t\t      SUPPORTED_TP);\n\t\tcmd->base.port = PORT_TP;\n\t} else {\n\t\tsupported |= SUPPORTED_FIBRE;\n\t\tcmd->base.port = PORT_FIBRE;\n\t}\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\n\tadvertising = tp->link_config.advertising;\n\tif (tg3_flag(tp, PAUSE_AUTONEG)) {\n\t\tif (tp->link_config.flowctrl & FLOW_CTRL_RX) {\n\t\t\tif (tp->link_config.flowctrl & FLOW_CTRL_TX) {\n\t\t\t\tadvertising |= ADVERTISED_Pause;\n\t\t\t} else {\n\t\t\t\tadvertising |= ADVERTISED_Pause |\n\t\t\t\t\tADVERTISED_Asym_Pause;\n\t\t\t}\n\t\t} else if (tp->link_config.flowctrl & FLOW_CTRL_TX) {\n\t\t\tadvertising |= ADVERTISED_Asym_Pause;\n\t\t}\n\t}\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\tif (netif_running(dev) && tp->link_up) {\n\t\tcmd->base.speed = tp->link_config.active_speed;\n\t\tcmd->base.duplex = tp->link_config.active_duplex;\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\tcmd->link_modes.lp_advertising,\n\t\t\ttp->link_config.rmt_adv);\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES)) {\n\t\t\tif (tp->phy_flags & TG3_PHYFLG_MDIX_STATE)\n\t\t\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_X;\n\t\t\telse\n\t\t\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI;\n\t\t}\n\t} else {\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tcmd->base.eth_tp_mdix = ETH_TP_MDI_INVALID;\n\t}\n\tcmd->base.phy_address = tp->phy_addr;\n\tcmd->base.autoneg = tp->link_config.autoneg;\n\treturn 0;\n}\n\nstatic int tg3_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tu32 speed = cmd->base.speed;\n\tu32 advertising;\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tstruct phy_device *phydev;\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\n\t\t\treturn -EAGAIN;\n\t\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\t\treturn phy_ethtool_ksettings_set(phydev, cmd);\n\t}\n\n\tif (cmd->base.autoneg != AUTONEG_ENABLE &&\n\t    cmd->base.autoneg != AUTONEG_DISABLE)\n\t\treturn -EINVAL;\n\n\tif (cmd->base.autoneg == AUTONEG_DISABLE &&\n\t    cmd->base.duplex != DUPLEX_FULL &&\n\t    cmd->base.duplex != DUPLEX_HALF)\n\t\treturn -EINVAL;\n\n\tethtool_convert_link_mode_to_legacy_u32(&advertising,\n\t\t\t\t\t\tcmd->link_modes.advertising);\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\tu32 mask = ADVERTISED_Autoneg |\n\t\t\t   ADVERTISED_Pause |\n\t\t\t   ADVERTISED_Asym_Pause;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY))\n\t\t\tmask |= ADVERTISED_1000baseT_Half |\n\t\t\t\tADVERTISED_1000baseT_Full;\n\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\n\t\t\tmask |= ADVERTISED_100baseT_Half |\n\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\tADVERTISED_10baseT_Half |\n\t\t\t\tADVERTISED_10baseT_Full |\n\t\t\t\tADVERTISED_TP;\n\t\telse\n\t\t\tmask |= ADVERTISED_FIBRE;\n\n\t\tif (advertising & ~mask)\n\t\t\treturn -EINVAL;\n\n\t\tmask &= (ADVERTISED_1000baseT_Half |\n\t\t\t ADVERTISED_1000baseT_Full |\n\t\t\t ADVERTISED_100baseT_Half |\n\t\t\t ADVERTISED_100baseT_Full |\n\t\t\t ADVERTISED_10baseT_Half |\n\t\t\t ADVERTISED_10baseT_Full);\n\n\t\tadvertising &= mask;\n\t} else {\n\t\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES) {\n\t\t\tif (speed != SPEED_1000)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (cmd->base.duplex != DUPLEX_FULL)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (speed != SPEED_100 &&\n\t\t\t    speed != SPEED_10)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttg3_full_lock(tp, 0);\n\n\ttp->link_config.autoneg = cmd->base.autoneg;\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\ttp->link_config.advertising = (advertising |\n\t\t\t\t\t      ADVERTISED_Autoneg);\n\t\ttp->link_config.speed = SPEED_UNKNOWN;\n\t\ttp->link_config.duplex = DUPLEX_UNKNOWN;\n\t} else {\n\t\ttp->link_config.advertising = 0;\n\t\ttp->link_config.speed = speed;\n\t\ttp->link_config.duplex = cmd->base.duplex;\n\t}\n\n\ttp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\n\n\ttg3_warn_mgmt_link_flap(tp);\n\n\tif (netif_running(dev))\n\t\ttg3_setup_phy(tp, true);\n\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n\nstatic void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\n\tstrlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));\n\tstrlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));\n}\n\nstatic void tg3_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (tg3_flag(tp, WOL_CAP) && device_can_wakeup(&tp->pdev->dev))\n\t\twol->supported = WAKE_MAGIC;\n\telse\n\t\twol->supported = 0;\n\twol->wolopts = 0;\n\tif (tg3_flag(tp, WOL_ENABLE) && device_can_wakeup(&tp->pdev->dev))\n\t\twol->wolopts = WAKE_MAGIC;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int tg3_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tstruct device *dp = &tp->pdev->dev;\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EINVAL;\n\tif ((wol->wolopts & WAKE_MAGIC) &&\n\t    !(tg3_flag(tp, WOL_CAP) && device_can_wakeup(dp)))\n\t\treturn -EINVAL;\n\n\tdevice_set_wakeup_enable(dp, wol->wolopts & WAKE_MAGIC);\n\n\tif (device_may_wakeup(dp))\n\t\ttg3_flag_set(tp, WOL_ENABLE);\n\telse\n\t\ttg3_flag_clear(tp, WOL_ENABLE);\n\n\treturn 0;\n}\n\nstatic u32 tg3_get_msglevel(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\treturn tp->msg_enable;\n}\n\nstatic void tg3_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\ttp->msg_enable = value;\n}\n\nstatic int tg3_nway_reset(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint r;\n\n\tif (!netif_running(dev))\n\t\treturn -EAGAIN;\n\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\n\t\treturn -EINVAL;\n\n\ttg3_warn_mgmt_link_flap(tp);\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\n\t\t\treturn -EAGAIN;\n\t\tr = phy_start_aneg(mdiobus_get_phy(tp->mdio_bus, tp->phy_addr));\n\t} else {\n\t\tu32 bmcr;\n\n\t\tspin_lock_bh(&tp->lock);\n\t\tr = -EINVAL;\n\t\ttg3_readphy(tp, MII_BMCR, &bmcr);\n\t\tif (!tg3_readphy(tp, MII_BMCR, &bmcr) &&\n\t\t    ((bmcr & BMCR_ANENABLE) ||\n\t\t     (tp->phy_flags & TG3_PHYFLG_PARALLEL_DETECT))) {\n\t\t\ttg3_writephy(tp, MII_BMCR, bmcr | BMCR_ANRESTART |\n\t\t\t\t\t\t   BMCR_ANENABLE);\n\t\t\tr = 0;\n\t\t}\n\t\tspin_unlock_bh(&tp->lock);\n\t}\n\n\treturn r;\n}\n\nstatic void tg3_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tering->rx_max_pending = tp->rx_std_ring_mask;\n\tif (tg3_flag(tp, JUMBO_RING_ENABLE))\n\t\tering->rx_jumbo_max_pending = tp->rx_jmb_ring_mask;\n\telse\n\t\tering->rx_jumbo_max_pending = 0;\n\n\tering->tx_max_pending = TG3_TX_RING_SIZE - 1;\n\n\tering->rx_pending = tp->rx_pending;\n\tif (tg3_flag(tp, JUMBO_RING_ENABLE))\n\t\tering->rx_jumbo_pending = tp->rx_jumbo_pending;\n\telse\n\t\tering->rx_jumbo_pending = 0;\n\n\tering->tx_pending = tp->napi[0].tx_pending;\n}\n\nstatic int tg3_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint i, irq_sync = 0, err = 0;\n\tbool reset_phy = false;\n\n\tif ((ering->rx_pending > tp->rx_std_ring_mask) ||\n\t    (ering->rx_jumbo_pending > tp->rx_jmb_ring_mask) ||\n\t    (ering->tx_pending > TG3_TX_RING_SIZE - 1) ||\n\t    (ering->tx_pending <= MAX_SKB_FRAGS) ||\n\t    (tg3_flag(tp, TSO_BUG) &&\n\t     (ering->tx_pending <= (MAX_SKB_FRAGS * 3))))\n\t\treturn -EINVAL;\n\n\tif (netif_running(dev)) {\n\t\ttg3_phy_stop(tp);\n\t\ttg3_netif_stop(tp);\n\t\tirq_sync = 1;\n\t}\n\n\ttg3_full_lock(tp, irq_sync);\n\n\ttp->rx_pending = ering->rx_pending;\n\n\tif (tg3_flag(tp, MAX_RXPEND_64) &&\n\t    tp->rx_pending > 63)\n\t\ttp->rx_pending = 63;\n\n\tif (tg3_flag(tp, JUMBO_RING_ENABLE))\n\t\ttp->rx_jumbo_pending = ering->rx_jumbo_pending;\n\n\tfor (i = 0; i < tp->irq_max; i++)\n\t\ttp->napi[i].tx_pending = ering->tx_pending;\n\n\tif (netif_running(dev)) {\n\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\t/* Reset PHY to avoid PHY lock up */\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\t\treset_phy = true;\n\n\t\terr = tg3_restart_hw(tp, reset_phy);\n\t\tif (!err)\n\t\t\ttg3_netif_start(tp);\n\t}\n\n\ttg3_full_unlock(tp);\n\n\tif (irq_sync && !err)\n\t\ttg3_phy_start(tp);\n\n\treturn err;\n}\n\nstatic void tg3_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tepause->autoneg = !!tg3_flag(tp, PAUSE_AUTONEG);\n\n\tif (tp->link_config.flowctrl & FLOW_CTRL_RX)\n\t\tepause->rx_pause = 1;\n\telse\n\t\tepause->rx_pause = 0;\n\n\tif (tp->link_config.flowctrl & FLOW_CTRL_TX)\n\t\tepause->tx_pause = 1;\n\telse\n\t\tepause->tx_pause = 0;\n}\n\nstatic int tg3_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err = 0;\n\tbool reset_phy = false;\n\n\tif (tp->link_config.autoneg == AUTONEG_ENABLE)\n\t\ttg3_warn_mgmt_link_flap(tp);\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tstruct phy_device *phydev;\n\n\t\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\n\t\tif (!phy_validate_pause(phydev, epause))\n\t\t\treturn -EINVAL;\n\n\t\ttp->link_config.flowctrl = 0;\n\t\tphy_set_asym_pause(phydev, epause->rx_pause, epause->tx_pause);\n\t\tif (epause->rx_pause) {\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_RX;\n\n\t\t\tif (epause->tx_pause) {\n\t\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\t\t}\n\t\t} else if (epause->tx_pause) {\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\t}\n\n\t\tif (epause->autoneg)\n\t\t\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\t\telse\n\t\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_IS_CONNECTED) {\n\t\t\tif (phydev->autoneg) {\n\t\t\t\t/* phy_set_asym_pause() will\n\t\t\t\t * renegotiate the link to inform our\n\t\t\t\t * link partner of our flow control\n\t\t\t\t * settings, even if the flow control\n\t\t\t\t * is forced.  Let tg3_adjust_link()\n\t\t\t\t * do the final flow control setup.\n\t\t\t\t */\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (!epause->autoneg)\n\t\t\t\ttg3_setup_flow_control(tp, 0, 0);\n\t\t}\n\t} else {\n\t\tint irq_sync = 0;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_netif_stop(tp);\n\t\t\tirq_sync = 1;\n\t\t}\n\n\t\ttg3_full_lock(tp, irq_sync);\n\n\t\tif (epause->autoneg)\n\t\t\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\t\telse\n\t\t\ttg3_flag_clear(tp, PAUSE_AUTONEG);\n\t\tif (epause->rx_pause)\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_RX;\n\t\telse\n\t\t\ttp->link_config.flowctrl &= ~FLOW_CTRL_RX;\n\t\tif (epause->tx_pause)\n\t\t\ttp->link_config.flowctrl |= FLOW_CTRL_TX;\n\t\telse\n\t\t\ttp->link_config.flowctrl &= ~FLOW_CTRL_TX;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\t\t/* Reset PHY to avoid PHY lock up */\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\t\t\treset_phy = true;\n\n\t\t\terr = tg3_restart_hw(tp, reset_phy);\n\t\t\tif (!err)\n\t\t\t\ttg3_netif_start(tp);\n\t\t}\n\n\t\ttg3_full_unlock(tp);\n\t}\n\n\ttp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\n\n\treturn err;\n}\n\nstatic int tg3_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_TEST:\n\t\treturn TG3_NUM_TEST;\n\tcase ETH_SS_STATS:\n\t\treturn TG3_NUM_STATS;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int tg3_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,\n\t\t\t u32 *rules __always_unused)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (!tg3_flag(tp, SUPPORT_MSIX))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (info->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tif (netif_running(tp->dev))\n\t\t\tinfo->data = tp->rxq_cnt;\n\t\telse {\n\t\t\tinfo->data = num_online_cpus();\n\t\t\tif (info->data > TG3_RSS_MAX_NUM_QS)\n\t\t\t\tinfo->data = TG3_RSS_MAX_NUM_QS;\n\t\t}\n\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic u32 tg3_get_rxfh_indir_size(struct net_device *dev)\n{\n\tu32 size = 0;\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (tg3_flag(tp, SUPPORT_MSIX))\n\t\tsize = TG3_RSS_INDIR_TBL_SIZE;\n\n\treturn size;\n}\n\nstatic int tg3_get_rxfh(struct net_device *dev, u32 *indir, u8 *key, u8 *hfunc)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint i;\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\tif (!indir)\n\t\treturn 0;\n\n\tfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\n\t\tindir[i] = tp->rss_ind_tbl[i];\n\n\treturn 0;\n}\n\nstatic int tg3_set_rxfh(struct net_device *dev, const u32 *indir, const u8 *key,\n\t\t\tconst u8 hfunc)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tsize_t i;\n\n\t/* We require at least one supported parameter to be changed and no\n\t * change in any of the unsupported parameters\n\t */\n\tif (key ||\n\t    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!indir)\n\t\treturn 0;\n\n\tfor (i = 0; i < TG3_RSS_INDIR_TBL_SIZE; i++)\n\t\ttp->rss_ind_tbl[i] = indir[i];\n\n\tif (!netif_running(dev) || !tg3_flag(tp, ENABLE_RSS))\n\t\treturn 0;\n\n\t/* It is legal to write the indirection\n\t * table while the device is running.\n\t */\n\ttg3_full_lock(tp, 0);\n\ttg3_rss_write_indir_tbl(tp);\n\ttg3_full_unlock(tp);\n\n\treturn 0;\n}\n\nstatic void tg3_get_channels(struct net_device *dev,\n\t\t\t     struct ethtool_channels *channel)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tu32 deflt_qs = netif_get_num_default_rss_queues();\n\n\tchannel->max_rx = tp->rxq_max;\n\tchannel->max_tx = tp->txq_max;\n\n\tif (netif_running(dev)) {\n\t\tchannel->rx_count = tp->rxq_cnt;\n\t\tchannel->tx_count = tp->txq_cnt;\n\t} else {\n\t\tif (tp->rxq_req)\n\t\t\tchannel->rx_count = tp->rxq_req;\n\t\telse\n\t\t\tchannel->rx_count = min(deflt_qs, tp->rxq_max);\n\n\t\tif (tp->txq_req)\n\t\t\tchannel->tx_count = tp->txq_req;\n\t\telse\n\t\t\tchannel->tx_count = min(deflt_qs, tp->txq_max);\n\t}\n}\n\nstatic int tg3_set_channels(struct net_device *dev,\n\t\t\t    struct ethtool_channels *channel)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (!tg3_flag(tp, SUPPORT_MSIX))\n\t\treturn -EOPNOTSUPP;\n\n\tif (channel->rx_count > tp->rxq_max ||\n\t    channel->tx_count > tp->txq_max)\n\t\treturn -EINVAL;\n\n\ttp->rxq_req = channel->rx_count;\n\ttp->txq_req = channel->tx_count;\n\n\tif (!netif_running(dev))\n\t\treturn 0;\n\n\ttg3_stop(tp);\n\n\ttg3_carrier_off(tp);\n\n\ttg3_start(tp, true, false, false);\n\n\treturn 0;\n}\n\nstatic void tg3_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tmemcpy(buf, &ethtool_test_keys, sizeof(ethtool_test_keys));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\t/* we need a WARN() */\n\t\tbreak;\n\t}\n}\n\nstatic int tg3_set_phys_id(struct net_device *dev,\n\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\treturn 1;\t/* cycle on/off once per second */\n\n\tcase ETHTOOL_ID_ON:\n\t\ttw32(MAC_LED_CTRL, LED_CTRL_LNKLED_OVERRIDE |\n\t\t     LED_CTRL_1000MBPS_ON |\n\t\t     LED_CTRL_100MBPS_ON |\n\t\t     LED_CTRL_10MBPS_ON |\n\t\t     LED_CTRL_TRAFFIC_OVERRIDE |\n\t\t     LED_CTRL_TRAFFIC_BLINK |\n\t\t     LED_CTRL_TRAFFIC_LED);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\ttw32(MAC_LED_CTRL, LED_CTRL_LNKLED_OVERRIDE |\n\t\t     LED_CTRL_TRAFFIC_OVERRIDE);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\ttw32(MAC_LED_CTRL, tp->led_ctrl);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void tg3_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t   struct ethtool_stats *estats, u64 *tmp_stats)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (tp->hw_stats)\n\t\ttg3_get_estats(tp, (struct tg3_ethtool_stats *)tmp_stats);\n\telse\n\t\tmemset(tmp_stats, 0, sizeof(struct tg3_ethtool_stats));\n}\n\nstatic __be32 *tg3_vpd_readblock(struct tg3 *tp, u32 *vpdlen)\n{\n\tint i;\n\t__be32 *buf;\n\tu32 offset = 0, len = 0;\n\tu32 magic, val;\n\n\tif (tg3_flag(tp, NO_NVRAM) || tg3_nvram_read(tp, 0, &magic))\n\t\treturn NULL;\n\n\tif (magic == TG3_EEPROM_MAGIC) {\n\t\tfor (offset = TG3_NVM_DIR_START;\n\t\t     offset < TG3_NVM_DIR_END;\n\t\t     offset += TG3_NVM_DIRENT_SIZE) {\n\t\t\tif (tg3_nvram_read(tp, offset, &val))\n\t\t\t\treturn NULL;\n\n\t\t\tif ((val >> TG3_NVM_DIRTYPE_SHIFT) ==\n\t\t\t    TG3_NVM_DIRTYPE_EXTVPD)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (offset != TG3_NVM_DIR_END) {\n\t\t\tlen = (val & TG3_NVM_DIRTYPE_LENMSK) * 4;\n\t\t\tif (tg3_nvram_read(tp, offset + 4, &offset))\n\t\t\t\treturn NULL;\n\n\t\t\toffset = tg3_nvram_logical_addr(tp, offset);\n\t\t}\n\n\t\tif (!offset || !len) {\n\t\t\toffset = TG3_NVM_VPD_OFF;\n\t\t\tlen = TG3_NVM_VPD_LEN;\n\t\t}\n\t} else {\n\t\tlen = TG3_NVM_PCI_VPD_MAX_LEN;\n\t}\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn NULL;\n\n\tif (magic == TG3_EEPROM_MAGIC) {\n\t\tfor (i = 0; i < len; i += 4) {\n\t\t\t/* The data is in little-endian format in NVRAM.\n\t\t\t * Use the big-endian read routines to preserve\n\t\t\t * the byte order as it exists in NVRAM.\n\t\t\t */\n\t\t\tif (tg3_nvram_read_be32(tp, offset + i, &buf[i/4]))\n\t\t\t\tgoto error;\n\t\t}\n\t\t*vpdlen = len;\n\t} else {\n\t\tssize_t cnt;\n\n\t\tcnt = pci_read_vpd(tp->pdev, 0, len, (u8 *)buf);\n\t\tif (cnt < 0)\n\t\t\tgoto error;\n\t\t*vpdlen = cnt;\n\t}\n\n\treturn buf;\n\nerror:\n\tkfree(buf);\n\treturn NULL;\n}\n\n#define NVRAM_TEST_SIZE 0x100\n#define NVRAM_SELFBOOT_FORMAT1_0_SIZE\t0x14\n#define NVRAM_SELFBOOT_FORMAT1_2_SIZE\t0x18\n#define NVRAM_SELFBOOT_FORMAT1_3_SIZE\t0x1c\n#define NVRAM_SELFBOOT_FORMAT1_4_SIZE\t0x20\n#define NVRAM_SELFBOOT_FORMAT1_5_SIZE\t0x24\n#define NVRAM_SELFBOOT_FORMAT1_6_SIZE\t0x50\n#define NVRAM_SELFBOOT_HW_SIZE 0x20\n#define NVRAM_SELFBOOT_DATA_SIZE 0x1c\n\nstatic int tg3_test_nvram(struct tg3 *tp)\n{\n\tu32 csum, magic, len;\n\t__be32 *buf;\n\tint i, j, k, err = 0, size;\n\n\tif (tg3_flag(tp, NO_NVRAM))\n\t\treturn 0;\n\n\tif (tg3_nvram_read(tp, 0, &magic) != 0)\n\t\treturn -EIO;\n\n\tif (magic == TG3_EEPROM_MAGIC)\n\t\tsize = NVRAM_TEST_SIZE;\n\telse if ((magic & TG3_EEPROM_MAGIC_FW_MSK) == TG3_EEPROM_MAGIC_FW) {\n\t\tif ((magic & TG3_EEPROM_SB_FORMAT_MASK) ==\n\t\t    TG3_EEPROM_SB_FORMAT_1) {\n\t\t\tswitch (magic & TG3_EEPROM_SB_REVISION_MASK) {\n\t\t\tcase TG3_EEPROM_SB_REVISION_0:\n\t\t\t\tsize = NVRAM_SELFBOOT_FORMAT1_0_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase TG3_EEPROM_SB_REVISION_2:\n\t\t\t\tsize = NVRAM_SELFBOOT_FORMAT1_2_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase TG3_EEPROM_SB_REVISION_3:\n\t\t\t\tsize = NVRAM_SELFBOOT_FORMAT1_3_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase TG3_EEPROM_SB_REVISION_4:\n\t\t\t\tsize = NVRAM_SELFBOOT_FORMAT1_4_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase TG3_EEPROM_SB_REVISION_5:\n\t\t\t\tsize = NVRAM_SELFBOOT_FORMAT1_5_SIZE;\n\t\t\t\tbreak;\n\t\t\tcase TG3_EEPROM_SB_REVISION_6:\n\t\t\t\tsize = NVRAM_SELFBOOT_FORMAT1_6_SIZE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else\n\t\t\treturn 0;\n\t} else if ((magic & TG3_EEPROM_MAGIC_HW_MSK) == TG3_EEPROM_MAGIC_HW)\n\t\tsize = NVRAM_SELFBOOT_HW_SIZE;\n\telse\n\t\treturn -EIO;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\terr = -EIO;\n\tfor (i = 0, j = 0; i < size; i += 4, j++) {\n\t\terr = tg3_nvram_read_be32(tp, i, &buf[j]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (i < size)\n\t\tgoto out;\n\n\t/* Selfboot format */\n\tmagic = be32_to_cpu(buf[0]);\n\tif ((magic & TG3_EEPROM_MAGIC_FW_MSK) ==\n\t    TG3_EEPROM_MAGIC_FW) {\n\t\tu8 *buf8 = (u8 *) buf, csum8 = 0;\n\n\t\tif ((magic & TG3_EEPROM_SB_REVISION_MASK) ==\n\t\t    TG3_EEPROM_SB_REVISION_2) {\n\t\t\t/* For rev 2, the csum doesn't include the MBA. */\n\t\t\tfor (i = 0; i < TG3_EEPROM_SB_F1R2_MBA_OFF; i++)\n\t\t\t\tcsum8 += buf8[i];\n\t\t\tfor (i = TG3_EEPROM_SB_F1R2_MBA_OFF + 4; i < size; i++)\n\t\t\t\tcsum8 += buf8[i];\n\t\t} else {\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\tcsum8 += buf8[i];\n\t\t}\n\n\t\tif (csum8 == 0) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif ((magic & TG3_EEPROM_MAGIC_HW_MSK) ==\n\t    TG3_EEPROM_MAGIC_HW) {\n\t\tu8 data[NVRAM_SELFBOOT_DATA_SIZE];\n\t\tu8 parity[NVRAM_SELFBOOT_DATA_SIZE];\n\t\tu8 *buf8 = (u8 *) buf;\n\n\t\t/* Separate the parity bits and the data bytes.  */\n\t\tfor (i = 0, j = 0, k = 0; i < NVRAM_SELFBOOT_HW_SIZE; i++) {\n\t\t\tif ((i == 0) || (i == 8)) {\n\t\t\t\tint l;\n\t\t\t\tu8 msk;\n\n\t\t\t\tfor (l = 0, msk = 0x80; l < 7; l++, msk >>= 1)\n\t\t\t\t\tparity[k++] = buf8[i] & msk;\n\t\t\t\ti++;\n\t\t\t} else if (i == 16) {\n\t\t\t\tint l;\n\t\t\t\tu8 msk;\n\n\t\t\t\tfor (l = 0, msk = 0x20; l < 6; l++, msk >>= 1)\n\t\t\t\t\tparity[k++] = buf8[i] & msk;\n\t\t\t\ti++;\n\n\t\t\t\tfor (l = 0, msk = 0x80; l < 8; l++, msk >>= 1)\n\t\t\t\t\tparity[k++] = buf8[i] & msk;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tdata[j++] = buf8[i];\n\t\t}\n\n\t\terr = -EIO;\n\t\tfor (i = 0; i < NVRAM_SELFBOOT_DATA_SIZE; i++) {\n\t\t\tu8 hw8 = hweight8(data[i]);\n\n\t\t\tif ((hw8 & 0x1) && parity[i])\n\t\t\t\tgoto out;\n\t\t\telse if (!(hw8 & 0x1) && !parity[i])\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = -EIO;\n\n\t/* Bootstrap checksum at offset 0x10 */\n\tcsum = calc_crc((unsigned char *) buf, 0x10);\n\tif (csum != le32_to_cpu(buf[0x10/4]))\n\t\tgoto out;\n\n\t/* Manufacturing block starts at offset 0x74, checksum at 0xfc */\n\tcsum = calc_crc((unsigned char *) &buf[0x74/4], 0x88);\n\tif (csum != le32_to_cpu(buf[0xfc/4]))\n\t\tgoto out;\n\n\tkfree(buf);\n\n\tbuf = tg3_vpd_readblock(tp, &len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ti = pci_vpd_find_tag((u8 *)buf, 0, len, PCI_VPD_LRDT_RO_DATA);\n\tif (i > 0) {\n\t\tj = pci_vpd_lrdt_size(&((u8 *)buf)[i]);\n\t\tif (j < 0)\n\t\t\tgoto out;\n\n\t\tif (i + PCI_VPD_LRDT_TAG_SIZE + j > len)\n\t\t\tgoto out;\n\n\t\ti += PCI_VPD_LRDT_TAG_SIZE;\n\t\tj = pci_vpd_find_info_keyword((u8 *)buf, i, j,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_CHKSUM);\n\t\tif (j > 0) {\n\t\t\tu8 csum8 = 0;\n\n\t\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\n\t\t\tfor (i = 0; i <= j; i++)\n\t\t\t\tcsum8 += ((u8 *)buf)[i];\n\n\t\t\tif (csum8)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\n\nout:\n\tkfree(buf);\n\treturn err;\n}\n\n#define TG3_SERDES_TIMEOUT_SEC\t2\n#define TG3_COPPER_TIMEOUT_SEC\t6\n\nstatic int tg3_test_link(struct tg3 *tp)\n{\n\tint i, max;\n\n\tif (!netif_running(tp->dev))\n\t\treturn -ENODEV;\n\n\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\n\t\tmax = TG3_SERDES_TIMEOUT_SEC;\n\telse\n\t\tmax = TG3_COPPER_TIMEOUT_SEC;\n\n\tfor (i = 0; i < max; i++) {\n\t\tif (tp->link_up)\n\t\t\treturn 0;\n\n\t\tif (msleep_interruptible(1000))\n\t\t\tbreak;\n\t}\n\n\treturn -EIO;\n}\n\n/* Only test the commonly used registers */\nstatic int tg3_test_registers(struct tg3 *tp)\n{\n\tint i, is_5705, is_5750;\n\tu32 offset, read_mask, write_mask, val, save_val, read_val;\n\tstatic struct {\n\t\tu16 offset;\n\t\tu16 flags;\n#define TG3_FL_5705\t0x1\n#define TG3_FL_NOT_5705\t0x2\n#define TG3_FL_NOT_5788\t0x4\n#define TG3_FL_NOT_5750\t0x8\n\t\tu32 read_mask;\n\t\tu32 write_mask;\n\t} reg_tbl[] = {\n\t\t/* MAC Control Registers */\n\t\t{ MAC_MODE, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0x00ef6f8c },\n\t\t{ MAC_MODE, TG3_FL_5705,\n\t\t\t0x00000000, 0x01ef6b8c },\n\t\t{ MAC_STATUS, TG3_FL_NOT_5705,\n\t\t\t0x03800107, 0x00000000 },\n\t\t{ MAC_STATUS, TG3_FL_5705,\n\t\t\t0x03800100, 0x00000000 },\n\t\t{ MAC_ADDR_0_HIGH, 0x0000,\n\t\t\t0x00000000, 0x0000ffff },\n\t\t{ MAC_ADDR_0_LOW, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ MAC_RX_MTU_SIZE, 0x0000,\n\t\t\t0x00000000, 0x0000ffff },\n\t\t{ MAC_TX_MODE, 0x0000,\n\t\t\t0x00000000, 0x00000070 },\n\t\t{ MAC_TX_LENGTHS, 0x0000,\n\t\t\t0x00000000, 0x00003fff },\n\t\t{ MAC_RX_MODE, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0x000007fc },\n\t\t{ MAC_RX_MODE, TG3_FL_5705,\n\t\t\t0x00000000, 0x000007dc },\n\t\t{ MAC_HASH_REG_0, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ MAC_HASH_REG_1, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ MAC_HASH_REG_2, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ MAC_HASH_REG_3, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\n\t\t/* Receive Data and Receive BD Initiator Control Registers. */\n\t\t{ RCVDBDI_JUMBO_BD+0, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ RCVDBDI_JUMBO_BD+4, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ RCVDBDI_JUMBO_BD+8, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0x00000003 },\n\t\t{ RCVDBDI_JUMBO_BD+0xc, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ RCVDBDI_STD_BD+0, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ RCVDBDI_STD_BD+4, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ RCVDBDI_STD_BD+8, 0x0000,\n\t\t\t0x00000000, 0xffff0002 },\n\t\t{ RCVDBDI_STD_BD+0xc, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\n\t\t/* Receive BD Initiator Control Registers. */\n\t\t{ RCVBDI_STD_THRESH, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ RCVBDI_STD_THRESH, TG3_FL_5705,\n\t\t\t0x00000000, 0x000003ff },\n\t\t{ RCVBDI_JUMBO_THRESH, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\n\t\t/* Host Coalescing Control Registers. */\n\t\t{ HOSTCC_MODE, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0x00000004 },\n\t\t{ HOSTCC_MODE, TG3_FL_5705,\n\t\t\t0x00000000, 0x000000f6 },\n\t\t{ HOSTCC_RXCOL_TICKS, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_RXCOL_TICKS, TG3_FL_5705,\n\t\t\t0x00000000, 0x000003ff },\n\t\t{ HOSTCC_TXCOL_TICKS, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_TXCOL_TICKS, TG3_FL_5705,\n\t\t\t0x00000000, 0x000003ff },\n\t\t{ HOSTCC_RXMAX_FRAMES, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_RXMAX_FRAMES, TG3_FL_5705 | TG3_FL_NOT_5788,\n\t\t\t0x00000000, 0x000000ff },\n\t\t{ HOSTCC_TXMAX_FRAMES, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_TXMAX_FRAMES, TG3_FL_5705 | TG3_FL_NOT_5788,\n\t\t\t0x00000000, 0x000000ff },\n\t\t{ HOSTCC_RXCOAL_TICK_INT, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_TXCOAL_TICK_INT, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_RXCOAL_MAXF_INT, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_RXCOAL_MAXF_INT, TG3_FL_5705 | TG3_FL_NOT_5788,\n\t\t\t0x00000000, 0x000000ff },\n\t\t{ HOSTCC_TXCOAL_MAXF_INT, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_TXCOAL_MAXF_INT, TG3_FL_5705 | TG3_FL_NOT_5788,\n\t\t\t0x00000000, 0x000000ff },\n\t\t{ HOSTCC_STAT_COAL_TICKS, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_STATS_BLK_HOST_ADDR, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_STATS_BLK_HOST_ADDR+4, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_STATUS_BLK_HOST_ADDR, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_STATUS_BLK_HOST_ADDR+4, 0x0000,\n\t\t\t0x00000000, 0xffffffff },\n\t\t{ HOSTCC_STATS_BLK_NIC_ADDR, 0x0000,\n\t\t\t0xffffffff, 0x00000000 },\n\t\t{ HOSTCC_STATUS_BLK_NIC_ADDR, 0x0000,\n\t\t\t0xffffffff, 0x00000000 },\n\n\t\t/* Buffer Manager Control Registers. */\n\t\t{ BUFMGR_MB_POOL_ADDR, TG3_FL_NOT_5750,\n\t\t\t0x00000000, 0x007fff80 },\n\t\t{ BUFMGR_MB_POOL_SIZE, TG3_FL_NOT_5750,\n\t\t\t0x00000000, 0x007fffff },\n\t\t{ BUFMGR_MB_RDMA_LOW_WATER, 0x0000,\n\t\t\t0x00000000, 0x0000003f },\n\t\t{ BUFMGR_MB_MACRX_LOW_WATER, 0x0000,\n\t\t\t0x00000000, 0x000001ff },\n\t\t{ BUFMGR_MB_HIGH_WATER, 0x0000,\n\t\t\t0x00000000, 0x000001ff },\n\t\t{ BUFMGR_DMA_DESC_POOL_ADDR, TG3_FL_NOT_5705,\n\t\t\t0xffffffff, 0x00000000 },\n\t\t{ BUFMGR_DMA_DESC_POOL_SIZE, TG3_FL_NOT_5705,\n\t\t\t0xffffffff, 0x00000000 },\n\n\t\t/* Mailbox Registers */\n\t\t{ GRCMBOX_RCVSTD_PROD_IDX+4, 0x0000,\n\t\t\t0x00000000, 0x000001ff },\n\t\t{ GRCMBOX_RCVJUMBO_PROD_IDX+4, TG3_FL_NOT_5705,\n\t\t\t0x00000000, 0x000001ff },\n\t\t{ GRCMBOX_RCVRET_CON_IDX_0+4, 0x0000,\n\t\t\t0x00000000, 0x000007ff },\n\t\t{ GRCMBOX_SNDHOST_PROD_IDX_0+4, 0x0000,\n\t\t\t0x00000000, 0x000001ff },\n\n\t\t{ 0xffff, 0x0000, 0x00000000, 0x00000000 },\n\t};\n\n\tis_5705 = is_5750 = 0;\n\tif (tg3_flag(tp, 5705_PLUS)) {\n\t\tis_5705 = 1;\n\t\tif (tg3_flag(tp, 5750_PLUS))\n\t\t\tis_5750 = 1;\n\t}\n\n\tfor (i = 0; reg_tbl[i].offset != 0xffff; i++) {\n\t\tif (is_5705 && (reg_tbl[i].flags & TG3_FL_NOT_5705))\n\t\t\tcontinue;\n\n\t\tif (!is_5705 && (reg_tbl[i].flags & TG3_FL_5705))\n\t\t\tcontinue;\n\n\t\tif (tg3_flag(tp, IS_5788) &&\n\t\t    (reg_tbl[i].flags & TG3_FL_NOT_5788))\n\t\t\tcontinue;\n\n\t\tif (is_5750 && (reg_tbl[i].flags & TG3_FL_NOT_5750))\n\t\t\tcontinue;\n\n\t\toffset = (u32) reg_tbl[i].offset;\n\t\tread_mask = reg_tbl[i].read_mask;\n\t\twrite_mask = reg_tbl[i].write_mask;\n\n\t\t/* Save the original register content */\n\t\tsave_val = tr32(offset);\n\n\t\t/* Determine the read-only value. */\n\t\tread_val = save_val & read_mask;\n\n\t\t/* Write zero to the register, then make sure the read-only bits\n\t\t * are not changed and the read/write bits are all zeros.\n\t\t */\n\t\ttw32(offset, 0);\n\n\t\tval = tr32(offset);\n\n\t\t/* Test the read-only and read/write bits. */\n\t\tif (((val & read_mask) != read_val) || (val & write_mask))\n\t\t\tgoto out;\n\n\t\t/* Write ones to all the bits defined by RdMask and WrMask, then\n\t\t * make sure the read-only bits are not changed and the\n\t\t * read/write bits are all ones.\n\t\t */\n\t\ttw32(offset, read_mask | write_mask);\n\n\t\tval = tr32(offset);\n\n\t\t/* Test the read-only bits. */\n\t\tif ((val & read_mask) != read_val)\n\t\t\tgoto out;\n\n\t\t/* Test the read/write bits. */\n\t\tif ((val & write_mask) != write_mask)\n\t\t\tgoto out;\n\n\t\ttw32(offset, save_val);\n\t}\n\n\treturn 0;\n\nout:\n\tif (netif_msg_hw(tp))\n\t\tnetdev_err(tp->dev,\n\t\t\t   \"Register test failed at offset %x\\n\", offset);\n\ttw32(offset, save_val);\n\treturn -EIO;\n}\n\nstatic int tg3_do_mem_test(struct tg3 *tp, u32 offset, u32 len)\n{\n\tstatic const u32 test_pattern[] = { 0x00000000, 0xffffffff, 0xaa55a55a };\n\tint i;\n\tu32 j;\n\n\tfor (i = 0; i < ARRAY_SIZE(test_pattern); i++) {\n\t\tfor (j = 0; j < len; j += 4) {\n\t\t\tu32 val;\n\n\t\t\ttg3_write_mem(tp, offset + j, test_pattern[i]);\n\t\t\ttg3_read_mem(tp, offset + j, &val);\n\t\t\tif (val != test_pattern[i])\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int tg3_test_memory(struct tg3 *tp)\n{\n\tstatic struct mem_entry {\n\t\tu32 offset;\n\t\tu32 len;\n\t} mem_tbl_570x[] = {\n\t\t{ 0x00000000, 0x00b50},\n\t\t{ 0x00002000, 0x1c000},\n\t\t{ 0xffffffff, 0x00000}\n\t}, mem_tbl_5705[] = {\n\t\t{ 0x00000100, 0x0000c},\n\t\t{ 0x00000200, 0x00008},\n\t\t{ 0x00004000, 0x00800},\n\t\t{ 0x00006000, 0x01000},\n\t\t{ 0x00008000, 0x02000},\n\t\t{ 0x00010000, 0x0e000},\n\t\t{ 0xffffffff, 0x00000}\n\t}, mem_tbl_5755[] = {\n\t\t{ 0x00000200, 0x00008},\n\t\t{ 0x00004000, 0x00800},\n\t\t{ 0x00006000, 0x00800},\n\t\t{ 0x00008000, 0x02000},\n\t\t{ 0x00010000, 0x0c000},\n\t\t{ 0xffffffff, 0x00000}\n\t}, mem_tbl_5906[] = {\n\t\t{ 0x00000200, 0x00008},\n\t\t{ 0x00004000, 0x00400},\n\t\t{ 0x00006000, 0x00400},\n\t\t{ 0x00008000, 0x01000},\n\t\t{ 0x00010000, 0x01000},\n\t\t{ 0xffffffff, 0x00000}\n\t}, mem_tbl_5717[] = {\n\t\t{ 0x00000200, 0x00008},\n\t\t{ 0x00010000, 0x0a000},\n\t\t{ 0x00020000, 0x13c00},\n\t\t{ 0xffffffff, 0x00000}\n\t}, mem_tbl_57765[] = {\n\t\t{ 0x00000200, 0x00008},\n\t\t{ 0x00004000, 0x00800},\n\t\t{ 0x00006000, 0x09800},\n\t\t{ 0x00010000, 0x0a000},\n\t\t{ 0xffffffff, 0x00000}\n\t};\n\tstruct mem_entry *mem_tbl;\n\tint err = 0;\n\tint i;\n\n\tif (tg3_flag(tp, 5717_PLUS))\n\t\tmem_tbl = mem_tbl_5717;\n\telse if (tg3_flag(tp, 57765_CLASS) ||\n\t\t tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\tmem_tbl = mem_tbl_57765;\n\telse if (tg3_flag(tp, 5755_PLUS))\n\t\tmem_tbl = mem_tbl_5755;\n\telse if (tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\tmem_tbl = mem_tbl_5906;\n\telse if (tg3_flag(tp, 5705_PLUS))\n\t\tmem_tbl = mem_tbl_5705;\n\telse\n\t\tmem_tbl = mem_tbl_570x;\n\n\tfor (i = 0; mem_tbl[i].offset != 0xffffffff; i++) {\n\t\terr = tg3_do_mem_test(tp, mem_tbl[i].offset, mem_tbl[i].len);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n#define TG3_TSO_MSS\t\t500\n\n#define TG3_TSO_IP_HDR_LEN\t20\n#define TG3_TSO_TCP_HDR_LEN\t20\n#define TG3_TSO_TCP_OPT_LEN\t12\n\nstatic const u8 tg3_tso_header[] = {\n0x08, 0x00,\n0x45, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x40, 0x00,\n0x40, 0x06, 0x00, 0x00,\n0x0a, 0x00, 0x00, 0x01,\n0x0a, 0x00, 0x00, 0x02,\n0x0d, 0x00, 0xe0, 0x00,\n0x00, 0x00, 0x01, 0x00,\n0x00, 0x00, 0x02, 0x00,\n0x80, 0x10, 0x10, 0x00,\n0x14, 0x09, 0x00, 0x00,\n0x01, 0x01, 0x08, 0x0a,\n0x11, 0x11, 0x11, 0x11,\n0x11, 0x11, 0x11, 0x11,\n};\n\nstatic int tg3_run_loopback(struct tg3 *tp, u32 pktsz, bool tso_loopback)\n{\n\tu32 rx_start_idx, rx_idx, tx_idx, opaque_key;\n\tu32 base_flags = 0, mss = 0, desc_idx, coal_now, data_off, val;\n\tu32 budget;\n\tstruct sk_buff *skb;\n\tu8 *tx_data, *rx_data;\n\tdma_addr_t map;\n\tint num_pkts, tx_len, rx_len, i, err;\n\tstruct tg3_rx_buffer_desc *desc;\n\tstruct tg3_napi *tnapi, *rnapi;\n\tstruct tg3_rx_prodring_set *tpr = &tp->napi[0].prodring;\n\n\ttnapi = &tp->napi[0];\n\trnapi = &tp->napi[0];\n\tif (tp->irq_cnt > 1) {\n\t\tif (tg3_flag(tp, ENABLE_RSS))\n\t\t\trnapi = &tp->napi[1];\n\t\tif (tg3_flag(tp, ENABLE_TSS))\n\t\t\ttnapi = &tp->napi[1];\n\t}\n\tcoal_now = tnapi->coal_now | rnapi->coal_now;\n\n\terr = -EIO;\n\n\ttx_len = pktsz;\n\tskb = netdev_alloc_skb(tp->dev, tx_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\ttx_data = skb_put(skb, tx_len);\n\tmemcpy(tx_data, tp->dev->dev_addr, ETH_ALEN);\n\tmemset(tx_data + ETH_ALEN, 0x0, 8);\n\n\ttw32(MAC_RX_MTU_SIZE, tx_len + ETH_FCS_LEN);\n\n\tif (tso_loopback) {\n\t\tstruct iphdr *iph = (struct iphdr *)&tx_data[ETH_HLEN];\n\n\t\tu32 hdr_len = TG3_TSO_IP_HDR_LEN + TG3_TSO_TCP_HDR_LEN +\n\t\t\t      TG3_TSO_TCP_OPT_LEN;\n\n\t\tmemcpy(tx_data + ETH_ALEN * 2, tg3_tso_header,\n\t\t       sizeof(tg3_tso_header));\n\t\tmss = TG3_TSO_MSS;\n\n\t\tval = tx_len - ETH_ALEN * 2 - sizeof(tg3_tso_header);\n\t\tnum_pkts = DIV_ROUND_UP(val, TG3_TSO_MSS);\n\n\t\t/* Set the total length field in the IP header */\n\t\tiph->tot_len = htons((u16)(mss + hdr_len));\n\n\t\tbase_flags = (TXD_FLAG_CPU_PRE_DMA |\n\t\t\t      TXD_FLAG_CPU_POST_DMA);\n\n\t\tif (tg3_flag(tp, HW_TSO_1) ||\n\t\t    tg3_flag(tp, HW_TSO_2) ||\n\t\t    tg3_flag(tp, HW_TSO_3)) {\n\t\t\tstruct tcphdr *th;\n\t\t\tval = ETH_HLEN + TG3_TSO_IP_HDR_LEN;\n\t\t\tth = (struct tcphdr *)&tx_data[val];\n\t\t\tth->check = 0;\n\t\t} else\n\t\t\tbase_flags |= TXD_FLAG_TCPUDP_CSUM;\n\n\t\tif (tg3_flag(tp, HW_TSO_3)) {\n\t\t\tmss |= (hdr_len & 0xc) << 12;\n\t\t\tif (hdr_len & 0x10)\n\t\t\t\tbase_flags |= 0x00000010;\n\t\t\tbase_flags |= (hdr_len & 0x3e0) << 5;\n\t\t} else if (tg3_flag(tp, HW_TSO_2))\n\t\t\tmss |= hdr_len << 9;\n\t\telse if (tg3_flag(tp, HW_TSO_1) ||\n\t\t\t tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\t\tmss |= (TG3_TSO_TCP_OPT_LEN << 9);\n\t\t} else {\n\t\t\tbase_flags |= (TG3_TSO_TCP_OPT_LEN << 10);\n\t\t}\n\n\t\tdata_off = ETH_ALEN * 2 + sizeof(tg3_tso_header);\n\t} else {\n\t\tnum_pkts = 1;\n\t\tdata_off = ETH_HLEN;\n\n\t\tif (tg3_flag(tp, USE_JUMBO_BDFLAG) &&\n\t\t    tx_len > VLAN_ETH_FRAME_LEN)\n\t\t\tbase_flags |= TXD_FLAG_JMB_PKT;\n\t}\n\n\tfor (i = data_off; i < tx_len; i++)\n\t\ttx_data[i] = (u8) (i & 0xff);\n\n\tmap = pci_map_single(tp->pdev, skb->data, tx_len, PCI_DMA_TODEVICE);\n\tif (pci_dma_mapping_error(tp->pdev, map)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tval = tnapi->tx_prod;\n\ttnapi->tx_buffers[val].skb = skb;\n\tdma_unmap_addr_set(&tnapi->tx_buffers[val], mapping, map);\n\n\ttw32_f(HOSTCC_MODE, tp->coalesce_mode | HOSTCC_MODE_ENABLE |\n\t       rnapi->coal_now);\n\n\tudelay(10);\n\n\trx_start_idx = rnapi->hw_status->idx[0].rx_producer;\n\n\tbudget = tg3_tx_avail(tnapi);\n\tif (tg3_tx_frag_set(tnapi, &val, &budget, map, tx_len,\n\t\t\t    base_flags | TXD_FLAG_END, mss, 0)) {\n\t\ttnapi->tx_buffers[val].skb = NULL;\n\t\tdev_kfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\ttnapi->tx_prod++;\n\n\t/* Sync BD data before updating mailbox */\n\twmb();\n\n\ttw32_tx_mbox(tnapi->prodmbox, tnapi->tx_prod);\n\ttr32_mailbox(tnapi->prodmbox);\n\n\tudelay(10);\n\n\t/* 350 usec to allow enough time on some 10/100 Mbps devices.  */\n\tfor (i = 0; i < 35; i++) {\n\t\ttw32_f(HOSTCC_MODE, tp->coalesce_mode | HOSTCC_MODE_ENABLE |\n\t\t       coal_now);\n\n\t\tudelay(10);\n\n\t\ttx_idx = tnapi->hw_status->idx[0].tx_consumer;\n\t\trx_idx = rnapi->hw_status->idx[0].rx_producer;\n\t\tif ((tx_idx == tnapi->tx_prod) &&\n\t\t    (rx_idx == (rx_start_idx + num_pkts)))\n\t\t\tbreak;\n\t}\n\n\ttg3_tx_skb_unmap(tnapi, tnapi->tx_prod - 1, -1);\n\tdev_kfree_skb(skb);\n\n\tif (tx_idx != tnapi->tx_prod)\n\t\tgoto out;\n\n\tif (rx_idx != rx_start_idx + num_pkts)\n\t\tgoto out;\n\n\tval = data_off;\n\twhile (rx_idx != rx_start_idx) {\n\t\tdesc = &rnapi->rx_rcb[rx_start_idx++];\n\t\tdesc_idx = desc->opaque & RXD_OPAQUE_INDEX_MASK;\n\t\topaque_key = desc->opaque & RXD_OPAQUE_RING_MASK;\n\n\t\tif ((desc->err_vlan & RXD_ERR_MASK) != 0 &&\n\t\t    (desc->err_vlan != RXD_ERR_ODD_NIBBLE_RCVD_MII))\n\t\t\tgoto out;\n\n\t\trx_len = ((desc->idx_len & RXD_LEN_MASK) >> RXD_LEN_SHIFT)\n\t\t\t - ETH_FCS_LEN;\n\n\t\tif (!tso_loopback) {\n\t\t\tif (rx_len != tx_len)\n\t\t\t\tgoto out;\n\n\t\t\tif (pktsz <= TG3_RX_STD_DMA_SZ - ETH_FCS_LEN) {\n\t\t\t\tif (opaque_key != RXD_OPAQUE_RING_STD)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (opaque_key != RXD_OPAQUE_RING_JUMBO)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if ((desc->type_flags & RXD_FLAG_TCPUDP_CSUM) &&\n\t\t\t   (desc->ip_tcp_csum & RXD_TCPCSUM_MASK)\n\t\t\t    >> RXD_TCPCSUM_SHIFT != 0xffff) {\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (opaque_key == RXD_OPAQUE_RING_STD) {\n\t\t\trx_data = tpr->rx_std_buffers[desc_idx].data;\n\t\t\tmap = dma_unmap_addr(&tpr->rx_std_buffers[desc_idx],\n\t\t\t\t\t     mapping);\n\t\t} else if (opaque_key == RXD_OPAQUE_RING_JUMBO) {\n\t\t\trx_data = tpr->rx_jmb_buffers[desc_idx].data;\n\t\t\tmap = dma_unmap_addr(&tpr->rx_jmb_buffers[desc_idx],\n\t\t\t\t\t     mapping);\n\t\t} else\n\t\t\tgoto out;\n\n\t\tpci_dma_sync_single_for_cpu(tp->pdev, map, rx_len,\n\t\t\t\t\t    PCI_DMA_FROMDEVICE);\n\n\t\trx_data += TG3_RX_OFFSET(tp);\n\t\tfor (i = data_off; i < rx_len; i++, val++) {\n\t\t\tif (*(rx_data + i) != (u8) (val & 0xff))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\terr = 0;\n\n\t/* tg3_free_rings will unmap and free the rx_data */\nout:\n\treturn err;\n}\n\n#define TG3_STD_LOOPBACK_FAILED\t\t1\n#define TG3_JMB_LOOPBACK_FAILED\t\t2\n#define TG3_TSO_LOOPBACK_FAILED\t\t4\n#define TG3_LOOPBACK_FAILED \\\n\t(TG3_STD_LOOPBACK_FAILED | \\\n\t TG3_JMB_LOOPBACK_FAILED | \\\n\t TG3_TSO_LOOPBACK_FAILED)\n\nstatic int tg3_test_loopback(struct tg3 *tp, u64 *data, bool do_extlpbk)\n{\n\tint err = -EIO;\n\tu32 eee_cap;\n\tu32 jmb_pkt_sz = 9000;\n\n\tif (tp->dma_limit)\n\t\tjmb_pkt_sz = tp->dma_limit - ETH_HLEN;\n\n\teee_cap = tp->phy_flags & TG3_PHYFLG_EEE_CAP;\n\ttp->phy_flags &= ~TG3_PHYFLG_EEE_CAP;\n\n\tif (!netif_running(tp->dev)) {\n\t\tdata[TG3_MAC_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\n\t\tdata[TG3_PHY_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\n\t\tif (do_extlpbk)\n\t\t\tdata[TG3_EXT_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\n\t\tgoto done;\n\t}\n\n\terr = tg3_reset_hw(tp, true);\n\tif (err) {\n\t\tdata[TG3_MAC_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\n\t\tdata[TG3_PHY_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\n\t\tif (do_extlpbk)\n\t\t\tdata[TG3_EXT_LOOPB_TEST] = TG3_LOOPBACK_FAILED;\n\t\tgoto done;\n\t}\n\n\tif (tg3_flag(tp, ENABLE_RSS)) {\n\t\tint i;\n\n\t\t/* Reroute all rx packets to the 1st queue */\n\t\tfor (i = MAC_RSS_INDIR_TBL_0;\n\t\t     i < MAC_RSS_INDIR_TBL_0 + TG3_RSS_INDIR_TBL_SIZE; i += 4)\n\t\t\ttw32(i, 0x0);\n\t}\n\n\t/* HW errata - mac loopback fails in some cases on 5780.\n\t * Normal traffic and PHY loopback are not affected by\n\t * errata.  Also, the MAC loopback test is deprecated for\n\t * all newer ASIC revisions.\n\t */\n\tif (tg3_asic_rev(tp) != ASIC_REV_5780 &&\n\t    !tg3_flag(tp, CPMU_PRESENT)) {\n\t\ttg3_mac_loopback(tp, true);\n\n\t\tif (tg3_run_loopback(tp, ETH_FRAME_LEN, false))\n\t\t\tdata[TG3_MAC_LOOPB_TEST] |= TG3_STD_LOOPBACK_FAILED;\n\n\t\tif (tg3_flag(tp, JUMBO_RING_ENABLE) &&\n\t\t    tg3_run_loopback(tp, jmb_pkt_sz + ETH_HLEN, false))\n\t\t\tdata[TG3_MAC_LOOPB_TEST] |= TG3_JMB_LOOPBACK_FAILED;\n\n\t\ttg3_mac_loopback(tp, false);\n\t}\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_PHY_SERDES) &&\n\t    !tg3_flag(tp, USE_PHYLIB)) {\n\t\tint i;\n\n\t\ttg3_phy_lpbk_set(tp, 0, false);\n\n\t\t/* Wait for link */\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tif (tr32(MAC_TX_STATUS) & TX_STATUS_LINK_UP)\n\t\t\t\tbreak;\n\t\t\tmdelay(1);\n\t\t}\n\n\t\tif (tg3_run_loopback(tp, ETH_FRAME_LEN, false))\n\t\t\tdata[TG3_PHY_LOOPB_TEST] |= TG3_STD_LOOPBACK_FAILED;\n\t\tif (tg3_flag(tp, TSO_CAPABLE) &&\n\t\t    tg3_run_loopback(tp, ETH_FRAME_LEN, true))\n\t\t\tdata[TG3_PHY_LOOPB_TEST] |= TG3_TSO_LOOPBACK_FAILED;\n\t\tif (tg3_flag(tp, JUMBO_RING_ENABLE) &&\n\t\t    tg3_run_loopback(tp, jmb_pkt_sz + ETH_HLEN, false))\n\t\t\tdata[TG3_PHY_LOOPB_TEST] |= TG3_JMB_LOOPBACK_FAILED;\n\n\t\tif (do_extlpbk) {\n\t\t\ttg3_phy_lpbk_set(tp, 0, true);\n\n\t\t\t/* All link indications report up, but the hardware\n\t\t\t * isn't really ready for about 20 msec.  Double it\n\t\t\t * to be sure.\n\t\t\t */\n\t\t\tmdelay(40);\n\n\t\t\tif (tg3_run_loopback(tp, ETH_FRAME_LEN, false))\n\t\t\t\tdata[TG3_EXT_LOOPB_TEST] |=\n\t\t\t\t\t\t\tTG3_STD_LOOPBACK_FAILED;\n\t\t\tif (tg3_flag(tp, TSO_CAPABLE) &&\n\t\t\t    tg3_run_loopback(tp, ETH_FRAME_LEN, true))\n\t\t\t\tdata[TG3_EXT_LOOPB_TEST] |=\n\t\t\t\t\t\t\tTG3_TSO_LOOPBACK_FAILED;\n\t\t\tif (tg3_flag(tp, JUMBO_RING_ENABLE) &&\n\t\t\t    tg3_run_loopback(tp, jmb_pkt_sz + ETH_HLEN, false))\n\t\t\t\tdata[TG3_EXT_LOOPB_TEST] |=\n\t\t\t\t\t\t\tTG3_JMB_LOOPBACK_FAILED;\n\t\t}\n\n\t\t/* Re-enable gphy autopowerdown. */\n\t\tif (tp->phy_flags & TG3_PHYFLG_ENABLE_APD)\n\t\t\ttg3_phy_toggle_apd(tp, true);\n\t}\n\n\terr = (data[TG3_MAC_LOOPB_TEST] | data[TG3_PHY_LOOPB_TEST] |\n\t       data[TG3_EXT_LOOPB_TEST]) ? -EIO : 0;\n\ndone:\n\ttp->phy_flags |= eee_cap;\n\n\treturn err;\n}\n\nstatic void tg3_self_test(struct net_device *dev, struct ethtool_test *etest,\n\t\t\t  u64 *data)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tbool doextlpbk = etest->flags & ETH_TEST_FL_EXTERNAL_LB;\n\n\tif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER) {\n\t\tif (tg3_power_up(tp)) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tmemset(data, 1, sizeof(u64) * TG3_NUM_TEST);\n\t\t\treturn;\n\t\t}\n\t\ttg3_ape_driver_state_change(tp, RESET_KIND_INIT);\n\t}\n\n\tmemset(data, 0, sizeof(u64) * TG3_NUM_TEST);\n\n\tif (tg3_test_nvram(tp) != 0) {\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[TG3_NVRAM_TEST] = 1;\n\t}\n\tif (!doextlpbk && tg3_test_link(tp)) {\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[TG3_LINK_TEST] = 1;\n\t}\n\tif (etest->flags & ETH_TEST_FL_OFFLINE) {\n\t\tint err, err2 = 0, irq_sync = 0;\n\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_phy_stop(tp);\n\t\t\ttg3_netif_stop(tp);\n\t\t\tirq_sync = 1;\n\t\t}\n\n\t\ttg3_full_lock(tp, irq_sync);\n\t\ttg3_halt(tp, RESET_KIND_SUSPEND, 1);\n\t\terr = tg3_nvram_lock(tp);\n\t\ttg3_halt_cpu(tp, RX_CPU_BASE);\n\t\tif (!tg3_flag(tp, 5705_PLUS))\n\t\t\ttg3_halt_cpu(tp, TX_CPU_BASE);\n\t\tif (!err)\n\t\t\ttg3_nvram_unlock(tp);\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_MII_SERDES)\n\t\t\ttg3_phy_reset(tp);\n\n\t\tif (tg3_test_registers(tp) != 0) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tdata[TG3_REGISTER_TEST] = 1;\n\t\t}\n\n\t\tif (tg3_test_memory(tp) != 0) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tdata[TG3_MEMORY_TEST] = 1;\n\t\t}\n\n\t\tif (doextlpbk)\n\t\t\tetest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\n\n\t\tif (tg3_test_loopback(tp, data, doextlpbk))\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\n\t\ttg3_full_unlock(tp);\n\n\t\tif (tg3_test_interrupt(tp) != 0) {\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tdata[TG3_INTERRUPT_TEST] = 1;\n\t\t}\n\n\t\ttg3_full_lock(tp, 0);\n\n\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\tif (netif_running(dev)) {\n\t\t\ttg3_flag_set(tp, INIT_COMPLETE);\n\t\t\terr2 = tg3_restart_hw(tp, true);\n\t\t\tif (!err2)\n\t\t\t\ttg3_netif_start(tp);\n\t\t}\n\n\t\ttg3_full_unlock(tp);\n\n\t\tif (irq_sync && !err2)\n\t\t\ttg3_phy_start(tp);\n\t}\n\tif (tp->phy_flags & TG3_PHYFLG_IS_LOW_POWER)\n\t\ttg3_power_down_prepare(tp);\n\n}\n\nstatic int tg3_hwtstamp_set(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tstruct hwtstamp_config stmpconf;\n\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&stmpconf, ifr->ifr_data, sizeof(stmpconf)))\n\t\treturn -EFAULT;\n\n\tif (stmpconf.flags)\n\t\treturn -EINVAL;\n\n\tif (stmpconf.tx_type != HWTSTAMP_TX_ON &&\n\t    stmpconf.tx_type != HWTSTAMP_TX_OFF)\n\t\treturn -ERANGE;\n\n\tswitch (stmpconf.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttp->rxptpctl = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V1_EN |\n\t\t\t       TG3_RX_PTP_CTL_ALL_V1_EVENTS;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V1_EN |\n\t\t\t       TG3_RX_PTP_CTL_SYNC_EVNT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V1_EN |\n\t\t\t       TG3_RX_PTP_CTL_DELAY_REQ;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_EN |\n\t\t\t       TG3_RX_PTP_CTL_ALL_V2_EVENTS;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN |\n\t\t\t       TG3_RX_PTP_CTL_ALL_V2_EVENTS;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN |\n\t\t\t       TG3_RX_PTP_CTL_ALL_V2_EVENTS;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_EN |\n\t\t\t       TG3_RX_PTP_CTL_SYNC_EVNT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN |\n\t\t\t       TG3_RX_PTP_CTL_SYNC_EVNT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN |\n\t\t\t       TG3_RX_PTP_CTL_SYNC_EVNT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_EN |\n\t\t\t       TG3_RX_PTP_CTL_DELAY_REQ;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN |\n\t\t\t       TG3_RX_PTP_CTL_DELAY_REQ;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\ttp->rxptpctl = TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN |\n\t\t\t       TG3_RX_PTP_CTL_DELAY_REQ;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tif (netif_running(dev) && tp->rxptpctl)\n\t\ttw32(TG3_RX_PTP_CTL,\n\t\t     tp->rxptpctl | TG3_RX_PTP_CTL_HWTS_INTERLOCK);\n\n\tif (stmpconf.tx_type == HWTSTAMP_TX_ON)\n\t\ttg3_flag_set(tp, TX_TSTAMP_EN);\n\telse\n\t\ttg3_flag_clear(tp, TX_TSTAMP_EN);\n\n\treturn copy_to_user(ifr->ifr_data, &stmpconf, sizeof(stmpconf)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic int tg3_hwtstamp_get(struct net_device *dev, struct ifreq *ifr)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tstruct hwtstamp_config stmpconf;\n\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tstmpconf.flags = 0;\n\tstmpconf.tx_type = (tg3_flag(tp, TX_TSTAMP_EN) ?\n\t\t\t    HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF);\n\n\tswitch (tp->rxptpctl) {\n\tcase 0:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_NONE;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V1_EN | TG3_RX_PTP_CTL_ALL_V1_EVENTS:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V1_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_SYNC;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V1_EN | TG3_RX_PTP_CTL_DELAY_REQ:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_EN | TG3_RX_PTP_CTL_ALL_V2_EVENTS:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN | TG3_RX_PTP_CTL_ALL_V2_EVENTS:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN | TG3_RX_PTP_CTL_ALL_V2_EVENTS:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_SYNC;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_SYNC;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN | TG3_RX_PTP_CTL_SYNC_EVNT:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_SYNC;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_EN | TG3_RX_PTP_CTL_DELAY_REQ:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_DELAY_REQ;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_L2_EN | TG3_RX_PTP_CTL_DELAY_REQ:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ;\n\t\tbreak;\n\tcase TG3_RX_PTP_CTL_RX_PTP_V2_L4_EN | TG3_RX_PTP_CTL_DELAY_REQ:\n\t\tstmpconf.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ERANGE;\n\t}\n\n\treturn copy_to_user(ifr->ifr_data, &stmpconf, sizeof(stmpconf)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic int tg3_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *data = if_mii(ifr);\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err;\n\n\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\tstruct phy_device *phydev;\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED))\n\t\t\treturn -EAGAIN;\n\t\tphydev = mdiobus_get_phy(tp->mdio_bus, tp->phy_addr);\n\t\treturn phy_mii_ioctl(phydev, ifr, cmd);\n\t}\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tdata->phy_id = tp->phy_addr;\n\n\t\tfallthrough;\n\tcase SIOCGMIIREG: {\n\t\tu32 mii_regval;\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\n\t\t\tbreak;\t\t\t/* We have no PHY */\n\n\t\tif (!netif_running(dev))\n\t\t\treturn -EAGAIN;\n\n\t\tspin_lock_bh(&tp->lock);\n\t\terr = __tg3_readphy(tp, data->phy_id & 0x1f,\n\t\t\t\t    data->reg_num & 0x1f, &mii_regval);\n\t\tspin_unlock_bh(&tp->lock);\n\n\t\tdata->val_out = mii_regval;\n\n\t\treturn err;\n\t}\n\n\tcase SIOCSMIIREG:\n\t\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\n\t\t\tbreak;\t\t\t/* We have no PHY */\n\n\t\tif (!netif_running(dev))\n\t\t\treturn -EAGAIN;\n\n\t\tspin_lock_bh(&tp->lock);\n\t\terr = __tg3_writephy(tp, data->phy_id & 0x1f,\n\t\t\t\t     data->reg_num & 0x1f, data->val_in);\n\t\tspin_unlock_bh(&tp->lock);\n\n\t\treturn err;\n\n\tcase SIOCSHWTSTAMP:\n\t\treturn tg3_hwtstamp_set(dev, ifr);\n\n\tcase SIOCGHWTSTAMP:\n\t\treturn tg3_hwtstamp_get(dev, ifr);\n\n\tdefault:\n\t\t/* do nothing */\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int tg3_get_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tmemcpy(ec, &tp->coal, sizeof(*ec));\n\treturn 0;\n}\n\nstatic int tg3_set_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tu32 max_rxcoal_tick_int = 0, max_txcoal_tick_int = 0;\n\tu32 max_stat_coal_ticks = 0, min_stat_coal_ticks = 0;\n\n\tif (!tg3_flag(tp, 5705_PLUS)) {\n\t\tmax_rxcoal_tick_int = MAX_RXCOAL_TICK_INT;\n\t\tmax_txcoal_tick_int = MAX_TXCOAL_TICK_INT;\n\t\tmax_stat_coal_ticks = MAX_STAT_COAL_TICKS;\n\t\tmin_stat_coal_ticks = MIN_STAT_COAL_TICKS;\n\t}\n\n\tif ((ec->rx_coalesce_usecs > MAX_RXCOL_TICKS) ||\n\t    (!ec->rx_coalesce_usecs) ||\n\t    (ec->tx_coalesce_usecs > MAX_TXCOL_TICKS) ||\n\t    (!ec->tx_coalesce_usecs) ||\n\t    (ec->rx_max_coalesced_frames > MAX_RXMAX_FRAMES) ||\n\t    (ec->tx_max_coalesced_frames > MAX_TXMAX_FRAMES) ||\n\t    (ec->rx_coalesce_usecs_irq > max_rxcoal_tick_int) ||\n\t    (ec->tx_coalesce_usecs_irq > max_txcoal_tick_int) ||\n\t    (ec->rx_max_coalesced_frames_irq > MAX_RXCOAL_MAXF_INT) ||\n\t    (ec->tx_max_coalesced_frames_irq > MAX_TXCOAL_MAXF_INT) ||\n\t    (ec->stats_block_coalesce_usecs > max_stat_coal_ticks) ||\n\t    (ec->stats_block_coalesce_usecs < min_stat_coal_ticks))\n\t\treturn -EINVAL;\n\n\t/* Only copy relevant parameters, ignore all others. */\n\ttp->coal.rx_coalesce_usecs = ec->rx_coalesce_usecs;\n\ttp->coal.tx_coalesce_usecs = ec->tx_coalesce_usecs;\n\ttp->coal.rx_max_coalesced_frames = ec->rx_max_coalesced_frames;\n\ttp->coal.tx_max_coalesced_frames = ec->tx_max_coalesced_frames;\n\ttp->coal.rx_coalesce_usecs_irq = ec->rx_coalesce_usecs_irq;\n\ttp->coal.tx_coalesce_usecs_irq = ec->tx_coalesce_usecs_irq;\n\ttp->coal.rx_max_coalesced_frames_irq = ec->rx_max_coalesced_frames_irq;\n\ttp->coal.tx_max_coalesced_frames_irq = ec->tx_max_coalesced_frames_irq;\n\ttp->coal.stats_block_coalesce_usecs = ec->stats_block_coalesce_usecs;\n\n\tif (netif_running(dev)) {\n\t\ttg3_full_lock(tp, 0);\n\t\t__tg3_set_coalesce(tp, &tp->coal);\n\t\ttg3_full_unlock(tp);\n\t}\n\treturn 0;\n}\n\nstatic int tg3_set_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP)) {\n\t\tnetdev_warn(tp->dev, \"Board does not support EEE!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (edata->advertised != tp->eee.advertised) {\n\t\tnetdev_warn(tp->dev,\n\t\t\t    \"Direct manipulation of EEE advertisement is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (edata->tx_lpi_timer > TG3_CPMU_DBTMR1_LNKIDLE_MAX) {\n\t\tnetdev_warn(tp->dev,\n\t\t\t    \"Maximal Tx Lpi timer supported is %#x(u)\\n\",\n\t\t\t    TG3_CPMU_DBTMR1_LNKIDLE_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\ttp->eee = *edata;\n\n\ttp->phy_flags |= TG3_PHYFLG_USER_CONFIGURED;\n\ttg3_warn_mgmt_link_flap(tp);\n\n\tif (netif_running(tp->dev)) {\n\t\ttg3_full_lock(tp, 0);\n\t\ttg3_setup_eee(tp);\n\t\ttg3_phy_reset(tp);\n\t\ttg3_full_unlock(tp);\n\t}\n\n\treturn 0;\n}\n\nstatic int tg3_get_eee(struct net_device *dev, struct ethtool_eee *edata)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_EEE_CAP)) {\n\t\tnetdev_warn(tp->dev,\n\t\t\t    \"Board does not support EEE!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t*edata = tp->eee;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops tg3_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES_IRQ |\n\t\t\t\t     ETHTOOL_COALESCE_STATS_BLOCK_USECS,\n\t.get_drvinfo\t\t= tg3_get_drvinfo,\n\t.get_regs_len\t\t= tg3_get_regs_len,\n\t.get_regs\t\t= tg3_get_regs,\n\t.get_wol\t\t= tg3_get_wol,\n\t.set_wol\t\t= tg3_set_wol,\n\t.get_msglevel\t\t= tg3_get_msglevel,\n\t.set_msglevel\t\t= tg3_set_msglevel,\n\t.nway_reset\t\t= tg3_nway_reset,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_eeprom_len\t\t= tg3_get_eeprom_len,\n\t.get_eeprom\t\t= tg3_get_eeprom,\n\t.set_eeprom\t\t= tg3_set_eeprom,\n\t.get_ringparam\t\t= tg3_get_ringparam,\n\t.set_ringparam\t\t= tg3_set_ringparam,\n\t.get_pauseparam\t\t= tg3_get_pauseparam,\n\t.set_pauseparam\t\t= tg3_set_pauseparam,\n\t.self_test\t\t= tg3_self_test,\n\t.get_strings\t\t= tg3_get_strings,\n\t.set_phys_id\t\t= tg3_set_phys_id,\n\t.get_ethtool_stats\t= tg3_get_ethtool_stats,\n\t.get_coalesce\t\t= tg3_get_coalesce,\n\t.set_coalesce\t\t= tg3_set_coalesce,\n\t.get_sset_count\t\t= tg3_get_sset_count,\n\t.get_rxnfc\t\t= tg3_get_rxnfc,\n\t.get_rxfh_indir_size    = tg3_get_rxfh_indir_size,\n\t.get_rxfh\t\t= tg3_get_rxfh,\n\t.set_rxfh\t\t= tg3_set_rxfh,\n\t.get_channels\t\t= tg3_get_channels,\n\t.set_channels\t\t= tg3_set_channels,\n\t.get_ts_info\t\t= tg3_get_ts_info,\n\t.get_eee\t\t= tg3_get_eee,\n\t.set_eee\t\t= tg3_set_eee,\n\t.get_link_ksettings\t= tg3_get_link_ksettings,\n\t.set_link_ksettings\t= tg3_set_link_ksettings,\n};\n\nstatic void tg3_get_stats64(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tspin_lock_bh(&tp->lock);\n\tif (!tp->hw_stats || !tg3_flag(tp, INIT_COMPLETE)) {\n\t\t*stats = tp->net_stats_prev;\n\t\tspin_unlock_bh(&tp->lock);\n\t\treturn;\n\t}\n\n\ttg3_get_nstats(tp, stats);\n\tspin_unlock_bh(&tp->lock);\n}\n\nstatic void tg3_set_rx_mode(struct net_device *dev)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\tif (!netif_running(dev))\n\t\treturn;\n\n\ttg3_full_lock(tp, 0);\n\t__tg3_set_rx_mode(dev);\n\ttg3_full_unlock(tp);\n}\n\nstatic inline void tg3_set_mtu(struct net_device *dev, struct tg3 *tp,\n\t\t\t       int new_mtu)\n{\n\tdev->mtu = new_mtu;\n\n\tif (new_mtu > ETH_DATA_LEN) {\n\t\tif (tg3_flag(tp, 5780_CLASS)) {\n\t\t\tnetdev_update_features(dev);\n\t\t\ttg3_flag_clear(tp, TSO_CAPABLE);\n\t\t} else {\n\t\t\ttg3_flag_set(tp, JUMBO_RING_ENABLE);\n\t\t}\n\t} else {\n\t\tif (tg3_flag(tp, 5780_CLASS)) {\n\t\t\ttg3_flag_set(tp, TSO_CAPABLE);\n\t\t\tnetdev_update_features(dev);\n\t\t}\n\t\ttg3_flag_clear(tp, JUMBO_RING_ENABLE);\n\t}\n}\n\nstatic int tg3_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err;\n\tbool reset_phy = false;\n\n\tif (!netif_running(dev)) {\n\t\t/* We'll just catch it later when the\n\t\t * device is up'd.\n\t\t */\n\t\ttg3_set_mtu(dev, tp, new_mtu);\n\t\treturn 0;\n\t}\n\n\ttg3_phy_stop(tp);\n\n\ttg3_netif_stop(tp);\n\n\ttg3_set_mtu(dev, tp, new_mtu);\n\n\ttg3_full_lock(tp, 1);\n\n\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\n\t/* Reset PHY, otherwise the read DMA engine will be in a mode that\n\t * breaks all requests to 256 bytes.\n\t */\n\tif (tg3_asic_rev(tp) == ASIC_REV_57766 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\treset_phy = true;\n\n\terr = tg3_restart_hw(tp, reset_phy);\n\n\tif (!err)\n\t\ttg3_netif_start(tp);\n\n\ttg3_full_unlock(tp);\n\n\tif (!err)\n\t\ttg3_phy_start(tp);\n\n\treturn err;\n}\n\nstatic const struct net_device_ops tg3_netdev_ops = {\n\t.ndo_open\t\t= tg3_open,\n\t.ndo_stop\t\t= tg3_close,\n\t.ndo_start_xmit\t\t= tg3_start_xmit,\n\t.ndo_get_stats64\t= tg3_get_stats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= tg3_set_rx_mode,\n\t.ndo_set_mac_address\t= tg3_set_mac_addr,\n\t.ndo_do_ioctl\t\t= tg3_ioctl,\n\t.ndo_tx_timeout\t\t= tg3_tx_timeout,\n\t.ndo_change_mtu\t\t= tg3_change_mtu,\n\t.ndo_fix_features\t= tg3_fix_features,\n\t.ndo_set_features\t= tg3_set_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= tg3_poll_controller,\n#endif\n};\n\nstatic void tg3_get_eeprom_size(struct tg3 *tp)\n{\n\tu32 cursize, val, magic;\n\n\ttp->nvram_size = EEPROM_CHIP_SIZE;\n\n\tif (tg3_nvram_read(tp, 0, &magic) != 0)\n\t\treturn;\n\n\tif ((magic != TG3_EEPROM_MAGIC) &&\n\t    ((magic & TG3_EEPROM_MAGIC_FW_MSK) != TG3_EEPROM_MAGIC_FW) &&\n\t    ((magic & TG3_EEPROM_MAGIC_HW_MSK) != TG3_EEPROM_MAGIC_HW))\n\t\treturn;\n\n\t/*\n\t * Size the chip by reading offsets at increasing powers of two.\n\t * When we encounter our validation signature, we know the addressing\n\t * has wrapped around, and thus have our chip size.\n\t */\n\tcursize = 0x10;\n\n\twhile (cursize < tp->nvram_size) {\n\t\tif (tg3_nvram_read(tp, cursize, &val) != 0)\n\t\t\treturn;\n\n\t\tif (val == magic)\n\t\t\tbreak;\n\n\t\tcursize <<= 1;\n\t}\n\n\ttp->nvram_size = cursize;\n}\n\nstatic void tg3_get_nvram_size(struct tg3 *tp)\n{\n\tu32 val;\n\n\tif (tg3_flag(tp, NO_NVRAM) || tg3_nvram_read(tp, 0, &val) != 0)\n\t\treturn;\n\n\t/* Selfboot format */\n\tif (val != TG3_EEPROM_MAGIC) {\n\t\ttg3_get_eeprom_size(tp);\n\t\treturn;\n\t}\n\n\tif (tg3_nvram_read(tp, 0xf0, &val) == 0) {\n\t\tif (val != 0) {\n\t\t\t/* This is confusing.  We want to operate on the\n\t\t\t * 16-bit value at offset 0xf2.  The tg3_nvram_read()\n\t\t\t * call will read from NVRAM and byteswap the data\n\t\t\t * according to the byteswapping settings for all\n\t\t\t * other register accesses.  This ensures the data we\n\t\t\t * want will always reside in the lower 16-bits.\n\t\t\t * However, the data in NVRAM is in LE format, which\n\t\t\t * means the data from the NVRAM read will always be\n\t\t\t * opposite the endianness of the CPU.  The 16-bit\n\t\t\t * byteswap then brings the data to CPU endianness.\n\t\t\t */\n\t\t\ttp->nvram_size = swab16((u16)(val & 0x0000ffff)) * 1024;\n\t\t\treturn;\n\t\t}\n\t}\n\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n}\n\nstatic void tg3_get_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\tif (nvcfg1 & NVRAM_CFG1_FLASHIF_ENAB) {\n\t\ttg3_flag_set(tp, FLASH);\n\t} else {\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5750 ||\n\t    tg3_flag(tp, 5780_CLASS)) {\n\t\tswitch (nvcfg1 & NVRAM_CFG1_VENDOR_MASK) {\n\t\tcase FLASH_VENDOR_ATMEL_FLASH_BUFFERED:\n\t\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\t\ttp->nvram_pagesize = ATMEL_AT45DB0X1B_PAGE_SIZE;\n\t\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\t\tbreak;\n\t\tcase FLASH_VENDOR_ATMEL_FLASH_UNBUFFERED:\n\t\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\t\ttp->nvram_pagesize = ATMEL_AT25F512_PAGE_SIZE;\n\t\t\tbreak;\n\t\tcase FLASH_VENDOR_ATMEL_EEPROM:\n\t\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\t\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\t\tbreak;\n\t\tcase FLASH_VENDOR_ST:\n\t\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\t\ttp->nvram_pagesize = ST_M45PEX0_PAGE_SIZE;\n\t\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\t\tbreak;\n\t\tcase FLASH_VENDOR_SAIFUN:\n\t\t\ttp->nvram_jedecnum = JEDEC_SAIFUN;\n\t\t\ttp->nvram_pagesize = SAIFUN_SA25F0XX_PAGE_SIZE;\n\t\t\tbreak;\n\t\tcase FLASH_VENDOR_SST_SMALL:\n\t\tcase FLASH_VENDOR_SST_LARGE:\n\t\t\ttp->nvram_jedecnum = JEDEC_SST;\n\t\t\ttp->nvram_pagesize = SST_25VF0X0_PAGE_SIZE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttp->nvram_pagesize = ATMEL_AT45DB0X1B_PAGE_SIZE;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t}\n}\n\nstatic void tg3_nvram_get_pagesize(struct tg3 *tp, u32 nvmcfg1)\n{\n\tswitch (nvmcfg1 & NVRAM_CFG1_5752PAGE_SIZE_MASK) {\n\tcase FLASH_5752PAGE_SIZE_256:\n\t\ttp->nvram_pagesize = 256;\n\t\tbreak;\n\tcase FLASH_5752PAGE_SIZE_512:\n\t\ttp->nvram_pagesize = 512;\n\t\tbreak;\n\tcase FLASH_5752PAGE_SIZE_1K:\n\t\ttp->nvram_pagesize = 1024;\n\t\tbreak;\n\tcase FLASH_5752PAGE_SIZE_2K:\n\t\ttp->nvram_pagesize = 2048;\n\t\tbreak;\n\tcase FLASH_5752PAGE_SIZE_4K:\n\t\ttp->nvram_pagesize = 4096;\n\t\tbreak;\n\tcase FLASH_5752PAGE_SIZE_264:\n\t\ttp->nvram_pagesize = 264;\n\t\tbreak;\n\tcase FLASH_5752PAGE_SIZE_528:\n\t\ttp->nvram_pagesize = 528;\n\t\tbreak;\n\t}\n}\n\nstatic void tg3_get_5752_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\t/* NVRAM protection for TPM */\n\tif (nvcfg1 & (1 << 27))\n\t\ttg3_flag_set(tp, PROTECTED_NVRAM);\n\n\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\tcase FLASH_5752VENDOR_ATMEL_EEPROM_64KHZ:\n\tcase FLASH_5752VENDOR_ATMEL_EEPROM_376KHZ:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ST_M45PE10:\n\tcase FLASH_5752VENDOR_ST_M45PE20:\n\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\tbreak;\n\t}\n\n\tif (tg3_flag(tp, FLASH)) {\n\t\ttg3_nvram_get_pagesize(tp, nvcfg1);\n\t} else {\n\t\t/* For eeprom, set pagesize to maximum eeprom size */\n\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t}\n}\n\nstatic void tg3_get_5755_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1, protect = 0;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\t/* NVRAM protection for TPM */\n\tif (nvcfg1 & (1 << 27)) {\n\t\ttg3_flag_set(tp, PROTECTED_NVRAM);\n\t\tprotect = 1;\n\t}\n\n\tnvcfg1 &= NVRAM_CFG1_5752VENDOR_MASK;\n\tswitch (nvcfg1) {\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_1:\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_2:\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_3:\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_5:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\ttp->nvram_pagesize = 264;\n\t\tif (nvcfg1 == FLASH_5755VENDOR_ATMEL_FLASH_1 ||\n\t\t    nvcfg1 == FLASH_5755VENDOR_ATMEL_FLASH_5)\n\t\t\ttp->nvram_size = (protect ? 0x3e200 :\n\t\t\t\t\t  TG3_NVRAM_SIZE_512KB);\n\t\telse if (nvcfg1 == FLASH_5755VENDOR_ATMEL_FLASH_2)\n\t\t\ttp->nvram_size = (protect ? 0x1f200 :\n\t\t\t\t\t  TG3_NVRAM_SIZE_256KB);\n\t\telse\n\t\t\ttp->nvram_size = (protect ? 0x1f200 :\n\t\t\t\t\t  TG3_NVRAM_SIZE_128KB);\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ST_M45PE10:\n\tcase FLASH_5752VENDOR_ST_M45PE20:\n\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\ttp->nvram_pagesize = 256;\n\t\tif (nvcfg1 == FLASH_5752VENDOR_ST_M45PE10)\n\t\t\ttp->nvram_size = (protect ?\n\t\t\t\t\t  TG3_NVRAM_SIZE_64KB :\n\t\t\t\t\t  TG3_NVRAM_SIZE_128KB);\n\t\telse if (nvcfg1 == FLASH_5752VENDOR_ST_M45PE20)\n\t\t\ttp->nvram_size = (protect ?\n\t\t\t\t\t  TG3_NVRAM_SIZE_64KB :\n\t\t\t\t\t  TG3_NVRAM_SIZE_256KB);\n\t\telse\n\t\t\ttp->nvram_size = (protect ?\n\t\t\t\t\t  TG3_NVRAM_SIZE_128KB :\n\t\t\t\t\t  TG3_NVRAM_SIZE_512KB);\n\t\tbreak;\n\t}\n}\n\nstatic void tg3_get_5787_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\tcase FLASH_5787VENDOR_ATMEL_EEPROM_64KHZ:\n\tcase FLASH_5787VENDOR_ATMEL_EEPROM_376KHZ:\n\tcase FLASH_5787VENDOR_MICRO_EEPROM_64KHZ:\n\tcase FLASH_5787VENDOR_MICRO_EEPROM_376KHZ:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_1:\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_2:\n\tcase FLASH_5755VENDOR_ATMEL_FLASH_3:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\ttp->nvram_pagesize = 264;\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ST_M45PE10:\n\tcase FLASH_5752VENDOR_ST_M45PE20:\n\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\ttp->nvram_pagesize = 256;\n\t\tbreak;\n\t}\n}\n\nstatic void tg3_get_5761_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1, protect = 0;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\t/* NVRAM protection for TPM */\n\tif (nvcfg1 & (1 << 27)) {\n\t\ttg3_flag_set(tp, PROTECTED_NVRAM);\n\t\tprotect = 1;\n\t}\n\n\tnvcfg1 &= NVRAM_CFG1_5752VENDOR_MASK;\n\tswitch (nvcfg1) {\n\tcase FLASH_5761VENDOR_ATMEL_ADB021D:\n\tcase FLASH_5761VENDOR_ATMEL_ADB041D:\n\tcase FLASH_5761VENDOR_ATMEL_ADB081D:\n\tcase FLASH_5761VENDOR_ATMEL_ADB161D:\n\tcase FLASH_5761VENDOR_ATMEL_MDB021D:\n\tcase FLASH_5761VENDOR_ATMEL_MDB041D:\n\tcase FLASH_5761VENDOR_ATMEL_MDB081D:\n\tcase FLASH_5761VENDOR_ATMEL_MDB161D:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\ttg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\n\t\ttp->nvram_pagesize = 256;\n\t\tbreak;\n\tcase FLASH_5761VENDOR_ST_A_M45PE20:\n\tcase FLASH_5761VENDOR_ST_A_M45PE40:\n\tcase FLASH_5761VENDOR_ST_A_M45PE80:\n\tcase FLASH_5761VENDOR_ST_A_M45PE16:\n\tcase FLASH_5761VENDOR_ST_M_M45PE20:\n\tcase FLASH_5761VENDOR_ST_M_M45PE40:\n\tcase FLASH_5761VENDOR_ST_M_M45PE80:\n\tcase FLASH_5761VENDOR_ST_M_M45PE16:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\t\ttp->nvram_pagesize = 256;\n\t\tbreak;\n\t}\n\n\tif (protect) {\n\t\ttp->nvram_size = tr32(NVRAM_ADDR_LOCKOUT);\n\t} else {\n\t\tswitch (nvcfg1) {\n\t\tcase FLASH_5761VENDOR_ATMEL_ADB161D:\n\t\tcase FLASH_5761VENDOR_ATMEL_MDB161D:\n\t\tcase FLASH_5761VENDOR_ST_A_M45PE16:\n\t\tcase FLASH_5761VENDOR_ST_M_M45PE16:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_2MB;\n\t\t\tbreak;\n\t\tcase FLASH_5761VENDOR_ATMEL_ADB081D:\n\t\tcase FLASH_5761VENDOR_ATMEL_MDB081D:\n\t\tcase FLASH_5761VENDOR_ST_A_M45PE80:\n\t\tcase FLASH_5761VENDOR_ST_M_M45PE80:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_1MB;\n\t\t\tbreak;\n\t\tcase FLASH_5761VENDOR_ATMEL_ADB041D:\n\t\tcase FLASH_5761VENDOR_ATMEL_MDB041D:\n\t\tcase FLASH_5761VENDOR_ST_A_M45PE40:\n\t\tcase FLASH_5761VENDOR_ST_M_M45PE40:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\tcase FLASH_5761VENDOR_ATMEL_ADB021D:\n\t\tcase FLASH_5761VENDOR_ATMEL_MDB021D:\n\t\tcase FLASH_5761VENDOR_ST_A_M45PE20:\n\t\tcase FLASH_5761VENDOR_ST_M_M45PE20:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void tg3_get_5906_nvram_info(struct tg3 *tp)\n{\n\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n}\n\nstatic void tg3_get_57780_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\tcase FLASH_5787VENDOR_ATMEL_EEPROM_376KHZ:\n\tcase FLASH_5787VENDOR_MICRO_EEPROM_376KHZ:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t\treturn;\n\tcase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB011D:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB011B:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB021D:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB021B:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB041D:\n\tcase FLASH_57780VENDOR_ATMEL_AT45DB041B:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\t\tcase FLASH_5752VENDOR_ATMEL_FLASH_BUFFERED:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB011D:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB011B:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB021D:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB021B:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB041D:\n\t\tcase FLASH_57780VENDOR_ATMEL_AT45DB041B:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_5752VENDOR_ST_M45PE10:\n\tcase FLASH_5752VENDOR_ST_M45PE20:\n\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\t\tcase FLASH_5752VENDOR_ST_M45PE10:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\tcase FLASH_5752VENDOR_ST_M45PE20:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tcase FLASH_5752VENDOR_ST_M45PE40:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ttg3_flag_set(tp, NO_NVRAM);\n\t\treturn;\n\t}\n\n\ttg3_nvram_get_pagesize(tp, nvcfg1);\n\tif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\n\t\ttg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\n}\n\n\nstatic void tg3_get_5717_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\n\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\tcase FLASH_5717VENDOR_ATMEL_EEPROM:\n\tcase FLASH_5717VENDOR_MICRO_EEPROM:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t\treturn;\n\tcase FLASH_5717VENDOR_ATMEL_MDB011D:\n\tcase FLASH_5717VENDOR_ATMEL_ADB011B:\n\tcase FLASH_5717VENDOR_ATMEL_ADB011D:\n\tcase FLASH_5717VENDOR_ATMEL_MDB021D:\n\tcase FLASH_5717VENDOR_ATMEL_ADB021B:\n\tcase FLASH_5717VENDOR_ATMEL_ADB021D:\n\tcase FLASH_5717VENDOR_ATMEL_45USPT:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\t\tcase FLASH_5717VENDOR_ATMEL_MDB021D:\n\t\t\t/* Detect size with tg3_nvram_get_size() */\n\t\t\tbreak;\n\t\tcase FLASH_5717VENDOR_ATMEL_ADB021B:\n\t\tcase FLASH_5717VENDOR_ATMEL_ADB021D:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_5717VENDOR_ST_M_M25PE10:\n\tcase FLASH_5717VENDOR_ST_A_M25PE10:\n\tcase FLASH_5717VENDOR_ST_M_M45PE10:\n\tcase FLASH_5717VENDOR_ST_A_M45PE10:\n\tcase FLASH_5717VENDOR_ST_M_M25PE20:\n\tcase FLASH_5717VENDOR_ST_A_M25PE20:\n\tcase FLASH_5717VENDOR_ST_M_M45PE20:\n\tcase FLASH_5717VENDOR_ST_A_M45PE20:\n\tcase FLASH_5717VENDOR_ST_25USPT:\n\tcase FLASH_5717VENDOR_ST_45USPT:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK) {\n\t\tcase FLASH_5717VENDOR_ST_M_M25PE20:\n\t\tcase FLASH_5717VENDOR_ST_M_M45PE20:\n\t\t\t/* Detect size with tg3_nvram_get_size() */\n\t\t\tbreak;\n\t\tcase FLASH_5717VENDOR_ST_A_M25PE20:\n\t\tcase FLASH_5717VENDOR_ST_A_M45PE20:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ttg3_flag_set(tp, NO_NVRAM);\n\t\treturn;\n\t}\n\n\ttg3_nvram_get_pagesize(tp, nvcfg1);\n\tif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\n\t\ttg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\n}\n\nstatic void tg3_get_5720_nvram_info(struct tg3 *tp)\n{\n\tu32 nvcfg1, nvmpinstrp, nv_status;\n\n\tnvcfg1 = tr32(NVRAM_CFG1);\n\tnvmpinstrp = nvcfg1 & NVRAM_CFG1_5752VENDOR_MASK;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5762) {\n\t\tif (!(nvcfg1 & NVRAM_CFG1_5762VENDOR_MASK)) {\n\t\t\ttg3_flag_set(tp, NO_NVRAM);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (nvmpinstrp) {\n\t\tcase FLASH_5762_MX25L_100:\n\t\tcase FLASH_5762_MX25L_200:\n\t\tcase FLASH_5762_MX25L_400:\n\t\tcase FLASH_5762_MX25L_800:\n\t\tcase FLASH_5762_MX25L_160_320:\n\t\t\ttp->nvram_pagesize = 4096;\n\t\t\ttp->nvram_jedecnum = JEDEC_MACRONIX;\n\t\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\t\ttg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\n\t\t\ttg3_flag_set(tp, FLASH);\n\t\t\tnv_status = tr32(NVRAM_AUTOSENSE_STATUS);\n\t\t\ttp->nvram_size =\n\t\t\t\t(1 << (nv_status >> AUTOSENSE_DEVID &\n\t\t\t\t\t\tAUTOSENSE_DEVID_MASK)\n\t\t\t\t\t<< AUTOSENSE_SIZE_IN_MB);\n\t\t\treturn;\n\n\t\tcase FLASH_5762_EEPROM_HD:\n\t\t\tnvmpinstrp = FLASH_5720_EEPROM_HD;\n\t\t\tbreak;\n\t\tcase FLASH_5762_EEPROM_LD:\n\t\t\tnvmpinstrp = FLASH_5720_EEPROM_LD;\n\t\t\tbreak;\n\t\tcase FLASH_5720VENDOR_M_ST_M45PE20:\n\t\t\t/* This pinstrap supports multiple sizes, so force it\n\t\t\t * to read the actual size from location 0xf0.\n\t\t\t */\n\t\t\tnvmpinstrp = FLASH_5720VENDOR_ST_45USPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (nvmpinstrp) {\n\tcase FLASH_5720_EEPROM_HD:\n\tcase FLASH_5720_EEPROM_LD:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\n\t\tnvcfg1 &= ~NVRAM_CFG1_COMPAT_BYPASS;\n\t\ttw32(NVRAM_CFG1, nvcfg1);\n\t\tif (nvmpinstrp == FLASH_5720_EEPROM_HD)\n\t\t\ttp->nvram_pagesize = ATMEL_AT24C512_CHIP_SIZE;\n\t\telse\n\t\t\ttp->nvram_pagesize = ATMEL_AT24C02_CHIP_SIZE;\n\t\treturn;\n\tcase FLASH_5720VENDOR_M_ATMEL_DB011D:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB011B:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB011D:\n\tcase FLASH_5720VENDOR_M_ATMEL_DB021D:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB021B:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB021D:\n\tcase FLASH_5720VENDOR_M_ATMEL_DB041D:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB041B:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB041D:\n\tcase FLASH_5720VENDOR_M_ATMEL_DB081D:\n\tcase FLASH_5720VENDOR_A_ATMEL_DB081D:\n\tcase FLASH_5720VENDOR_ATMEL_45USPT:\n\t\ttp->nvram_jedecnum = JEDEC_ATMEL;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvmpinstrp) {\n\t\tcase FLASH_5720VENDOR_M_ATMEL_DB021D:\n\t\tcase FLASH_5720VENDOR_A_ATMEL_DB021B:\n\t\tcase FLASH_5720VENDOR_A_ATMEL_DB021D:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tcase FLASH_5720VENDOR_M_ATMEL_DB041D:\n\t\tcase FLASH_5720VENDOR_A_ATMEL_DB041B:\n\t\tcase FLASH_5720VENDOR_A_ATMEL_DB041D:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\tcase FLASH_5720VENDOR_M_ATMEL_DB081D:\n\t\tcase FLASH_5720VENDOR_A_ATMEL_DB081D:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_1MB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (tg3_asic_rev(tp) != ASIC_REV_5762)\n\t\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase FLASH_5720VENDOR_M_ST_M25PE10:\n\tcase FLASH_5720VENDOR_M_ST_M45PE10:\n\tcase FLASH_5720VENDOR_A_ST_M25PE10:\n\tcase FLASH_5720VENDOR_A_ST_M45PE10:\n\tcase FLASH_5720VENDOR_M_ST_M25PE20:\n\tcase FLASH_5720VENDOR_M_ST_M45PE20:\n\tcase FLASH_5720VENDOR_A_ST_M25PE20:\n\tcase FLASH_5720VENDOR_A_ST_M45PE20:\n\tcase FLASH_5720VENDOR_M_ST_M25PE40:\n\tcase FLASH_5720VENDOR_M_ST_M45PE40:\n\tcase FLASH_5720VENDOR_A_ST_M25PE40:\n\tcase FLASH_5720VENDOR_A_ST_M45PE40:\n\tcase FLASH_5720VENDOR_M_ST_M25PE80:\n\tcase FLASH_5720VENDOR_M_ST_M45PE80:\n\tcase FLASH_5720VENDOR_A_ST_M25PE80:\n\tcase FLASH_5720VENDOR_A_ST_M45PE80:\n\tcase FLASH_5720VENDOR_ST_25USPT:\n\tcase FLASH_5720VENDOR_ST_45USPT:\n\t\ttp->nvram_jedecnum = JEDEC_ST;\n\t\ttg3_flag_set(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, FLASH);\n\n\t\tswitch (nvmpinstrp) {\n\t\tcase FLASH_5720VENDOR_M_ST_M25PE20:\n\t\tcase FLASH_5720VENDOR_M_ST_M45PE20:\n\t\tcase FLASH_5720VENDOR_A_ST_M25PE20:\n\t\tcase FLASH_5720VENDOR_A_ST_M45PE20:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_256KB;\n\t\t\tbreak;\n\t\tcase FLASH_5720VENDOR_M_ST_M25PE40:\n\t\tcase FLASH_5720VENDOR_M_ST_M45PE40:\n\t\tcase FLASH_5720VENDOR_A_ST_M25PE40:\n\t\tcase FLASH_5720VENDOR_A_ST_M45PE40:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_512KB;\n\t\t\tbreak;\n\t\tcase FLASH_5720VENDOR_M_ST_M25PE80:\n\t\tcase FLASH_5720VENDOR_M_ST_M45PE80:\n\t\tcase FLASH_5720VENDOR_A_ST_M25PE80:\n\t\tcase FLASH_5720VENDOR_A_ST_M45PE80:\n\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_1MB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (tg3_asic_rev(tp) != ASIC_REV_5762)\n\t\t\t\ttp->nvram_size = TG3_NVRAM_SIZE_128KB;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ttg3_flag_set(tp, NO_NVRAM);\n\t\treturn;\n\t}\n\n\ttg3_nvram_get_pagesize(tp, nvcfg1);\n\tif (tp->nvram_pagesize != 264 && tp->nvram_pagesize != 528)\n\t\ttg3_flag_set(tp, NO_NVRAM_ADDR_TRANS);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5762) {\n\t\tu32 val;\n\n\t\tif (tg3_nvram_read(tp, 0, &val))\n\t\t\treturn;\n\n\t\tif (val != TG3_EEPROM_MAGIC &&\n\t\t    (val & TG3_EEPROM_MAGIC_FW_MSK) != TG3_EEPROM_MAGIC_FW)\n\t\t\ttg3_flag_set(tp, NO_NVRAM);\n\t}\n}\n\n/* Chips other than 5700/5701 use the NVRAM for fetching info. */\nstatic void tg3_nvram_init(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, IS_SSB_CORE)) {\n\t\t/* No NVRAM and EEPROM on the SSB Broadcom GigE core. */\n\t\ttg3_flag_clear(tp, NVRAM);\n\t\ttg3_flag_clear(tp, NVRAM_BUFFERED);\n\t\ttg3_flag_set(tp, NO_NVRAM);\n\t\treturn;\n\t}\n\n\ttw32_f(GRC_EEPROM_ADDR,\n\t     (EEPROM_ADDR_FSM_RESET |\n\t      (EEPROM_DEFAULT_CLOCK_PERIOD <<\n\t       EEPROM_ADDR_CLKPERD_SHIFT)));\n\n\tmsleep(1);\n\n\t/* Enable seeprom accesses. */\n\ttw32_f(GRC_LOCAL_CTRL,\n\t     tr32(GRC_LOCAL_CTRL) | GRC_LCLCTRL_AUTO_SEEPROM);\n\tudelay(100);\n\n\tif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5701) {\n\t\ttg3_flag_set(tp, NVRAM);\n\n\t\tif (tg3_nvram_lock(tp)) {\n\t\t\tnetdev_warn(tp->dev,\n\t\t\t\t    \"Cannot get nvram lock, %s failed\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn;\n\t\t}\n\t\ttg3_enable_nvram_access(tp);\n\n\t\ttp->nvram_size = 0;\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5752)\n\t\t\ttg3_get_5752_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_5755)\n\t\t\ttg3_get_5755_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_5787 ||\n\t\t\t tg3_asic_rev(tp) == ASIC_REV_5784 ||\n\t\t\t tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\t\ttg3_get_5787_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_5761)\n\t\t\ttg3_get_5761_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\t\ttg3_get_5906_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_57780 ||\n\t\t\t tg3_flag(tp, 57765_CLASS))\n\t\t\ttg3_get_57780_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t\t\t tg3_asic_rev(tp) == ASIC_REV_5719)\n\t\t\ttg3_get_5717_nvram_info(tp);\n\t\telse if (tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t\t\t tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\t\ttg3_get_5720_nvram_info(tp);\n\t\telse\n\t\t\ttg3_get_nvram_info(tp);\n\n\t\tif (tp->nvram_size == 0)\n\t\t\ttg3_get_nvram_size(tp);\n\n\t\ttg3_disable_nvram_access(tp);\n\t\ttg3_nvram_unlock(tp);\n\n\t} else {\n\t\ttg3_flag_clear(tp, NVRAM);\n\t\ttg3_flag_clear(tp, NVRAM_BUFFERED);\n\n\t\ttg3_get_eeprom_size(tp);\n\t}\n}\n\nstruct subsys_tbl_ent {\n\tu16 subsys_vendor, subsys_devid;\n\tu32 phy_id;\n};\n\nstatic struct subsys_tbl_ent subsys_id_to_phy_id[] = {\n\t/* Broadcom boards. */\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95700A6, TG3_PHY_ID_BCM5401 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95701A5, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95700T6, TG3_PHY_ID_BCM8002 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95700A9, 0 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95701T1, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95701T8, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95701A7, 0 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95701A10, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95701A12, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95703AX1, TG3_PHY_ID_BCM5703 },\n\t{ TG3PCI_SUBVENDOR_ID_BROADCOM,\n\t  TG3PCI_SUBDEVICE_ID_BROADCOM_95703AX2, TG3_PHY_ID_BCM5703 },\n\n\t/* 3com boards. */\n\t{ TG3PCI_SUBVENDOR_ID_3COM,\n\t  TG3PCI_SUBDEVICE_ID_3COM_3C996T, TG3_PHY_ID_BCM5401 },\n\t{ TG3PCI_SUBVENDOR_ID_3COM,\n\t  TG3PCI_SUBDEVICE_ID_3COM_3C996BT, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_3COM,\n\t  TG3PCI_SUBDEVICE_ID_3COM_3C996SX, 0 },\n\t{ TG3PCI_SUBVENDOR_ID_3COM,\n\t  TG3PCI_SUBDEVICE_ID_3COM_3C1000T, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_3COM,\n\t  TG3PCI_SUBDEVICE_ID_3COM_3C940BR01, TG3_PHY_ID_BCM5701 },\n\n\t/* DELL boards. */\n\t{ TG3PCI_SUBVENDOR_ID_DELL,\n\t  TG3PCI_SUBDEVICE_ID_DELL_VIPER, TG3_PHY_ID_BCM5401 },\n\t{ TG3PCI_SUBVENDOR_ID_DELL,\n\t  TG3PCI_SUBDEVICE_ID_DELL_JAGUAR, TG3_PHY_ID_BCM5401 },\n\t{ TG3PCI_SUBVENDOR_ID_DELL,\n\t  TG3PCI_SUBDEVICE_ID_DELL_MERLOT, TG3_PHY_ID_BCM5411 },\n\t{ TG3PCI_SUBVENDOR_ID_DELL,\n\t  TG3PCI_SUBDEVICE_ID_DELL_SLIM_MERLOT, TG3_PHY_ID_BCM5411 },\n\n\t/* Compaq boards. */\n\t{ TG3PCI_SUBVENDOR_ID_COMPAQ,\n\t  TG3PCI_SUBDEVICE_ID_COMPAQ_BANSHEE, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_COMPAQ,\n\t  TG3PCI_SUBDEVICE_ID_COMPAQ_BANSHEE_2, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_COMPAQ,\n\t  TG3PCI_SUBDEVICE_ID_COMPAQ_CHANGELING, 0 },\n\t{ TG3PCI_SUBVENDOR_ID_COMPAQ,\n\t  TG3PCI_SUBDEVICE_ID_COMPAQ_NC7780, TG3_PHY_ID_BCM5701 },\n\t{ TG3PCI_SUBVENDOR_ID_COMPAQ,\n\t  TG3PCI_SUBDEVICE_ID_COMPAQ_NC7780_2, TG3_PHY_ID_BCM5701 },\n\n\t/* IBM boards. */\n\t{ TG3PCI_SUBVENDOR_ID_IBM,\n\t  TG3PCI_SUBDEVICE_ID_IBM_5703SAX2, 0 }\n};\n\nstatic struct subsys_tbl_ent *tg3_lookup_by_subsys(struct tg3 *tp)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(subsys_id_to_phy_id); i++) {\n\t\tif ((subsys_id_to_phy_id[i].subsys_vendor ==\n\t\t     tp->pdev->subsystem_vendor) &&\n\t\t    (subsys_id_to_phy_id[i].subsys_devid ==\n\t\t     tp->pdev->subsystem_device))\n\t\t\treturn &subsys_id_to_phy_id[i];\n\t}\n\treturn NULL;\n}\n\nstatic void tg3_get_eeprom_hw_cfg(struct tg3 *tp)\n{\n\tu32 val;\n\n\ttp->phy_id = TG3_PHY_ID_INVALID;\n\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\n\t/* Assume an onboard device and WOL capable by default.  */\n\ttg3_flag_set(tp, EEPROM_WRITE_PROT);\n\ttg3_flag_set(tp, WOL_CAP);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tif (!(tr32(PCIE_TRANSACTION_CFG) & PCIE_TRANS_CFG_LOM)) {\n\t\t\ttg3_flag_clear(tp, EEPROM_WRITE_PROT);\n\t\t\ttg3_flag_set(tp, IS_NIC);\n\t\t}\n\t\tval = tr32(VCPU_CFGSHDW);\n\t\tif (val & VCPU_CFGSHDW_ASPM_DBNC)\n\t\t\ttg3_flag_set(tp, ASPM_WORKAROUND);\n\t\tif ((val & VCPU_CFGSHDW_WOL_ENABLE) &&\n\t\t    (val & VCPU_CFGSHDW_WOL_MAGPKT)) {\n\t\t\ttg3_flag_set(tp, WOL_ENABLE);\n\t\t\tdevice_set_wakeup_enable(&tp->pdev->dev, true);\n\t\t}\n\t\tgoto done;\n\t}\n\n\ttg3_read_mem(tp, NIC_SRAM_DATA_SIG, &val);\n\tif (val == NIC_SRAM_DATA_SIG_MAGIC) {\n\t\tu32 nic_cfg, led_cfg;\n\t\tu32 cfg2 = 0, cfg4 = 0, cfg5 = 0;\n\t\tu32 nic_phy_id, ver, eeprom_phy_id;\n\t\tint eeprom_phy_serdes = 0;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG, &nic_cfg);\n\t\ttp->nic_sram_data_cfg = nic_cfg;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_VER, &ver);\n\t\tver >>= NIC_SRAM_DATA_VER_SHIFT;\n\t\tif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\n\t\t    tg3_asic_rev(tp) != ASIC_REV_5701 &&\n\t\t    tg3_asic_rev(tp) != ASIC_REV_5703 &&\n\t\t    (ver > 0) && (ver < 0x100))\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_2, &cfg2);\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5785)\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_4, &cfg4);\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_5, &cfg5);\n\n\t\tif ((nic_cfg & NIC_SRAM_DATA_CFG_PHY_TYPE_MASK) ==\n\t\t    NIC_SRAM_DATA_CFG_PHY_TYPE_FIBER)\n\t\t\teeprom_phy_serdes = 1;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_DATA_PHY_ID, &nic_phy_id);\n\t\tif (nic_phy_id != 0) {\n\t\t\tu32 id1 = nic_phy_id & NIC_SRAM_DATA_PHY_ID1_MASK;\n\t\t\tu32 id2 = nic_phy_id & NIC_SRAM_DATA_PHY_ID2_MASK;\n\n\t\t\teeprom_phy_id  = (id1 >> 16) << 10;\n\t\t\teeprom_phy_id |= (id2 & 0xfc00) << 16;\n\t\t\teeprom_phy_id |= (id2 & 0x03ff) <<  0;\n\t\t} else\n\t\t\teeprom_phy_id = 0;\n\n\t\ttp->phy_id = eeprom_phy_id;\n\t\tif (eeprom_phy_serdes) {\n\t\t\tif (!tg3_flag(tp, 5705_PLUS))\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\n\t\t\telse\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_MII_SERDES;\n\t\t}\n\n\t\tif (tg3_flag(tp, 5750_PLUS))\n\t\t\tled_cfg = cfg2 & (NIC_SRAM_DATA_CFG_LED_MODE_MASK |\n\t\t\t\t    SHASTA_EXT_LED_MODE_MASK);\n\t\telse\n\t\t\tled_cfg = nic_cfg & NIC_SRAM_DATA_CFG_LED_MODE_MASK;\n\n\t\tswitch (led_cfg) {\n\t\tdefault:\n\t\tcase NIC_SRAM_DATA_CFG_LED_MODE_PHY_1:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\t\t\tbreak;\n\n\t\tcase NIC_SRAM_DATA_CFG_LED_MODE_PHY_2:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_2;\n\t\t\tbreak;\n\n\t\tcase NIC_SRAM_DATA_CFG_LED_MODE_MAC:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_MAC;\n\n\t\t\t/* Default to PHY_1_MODE if 0 (MAC_MODE) is\n\t\t\t * read on some older 5700/5701 bootcode.\n\t\t\t */\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5701)\n\t\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\n\t\t\tbreak;\n\n\t\tcase SHASTA_EXT_LED_SHARED:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_SHARED;\n\t\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0 &&\n\t\t\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A1)\n\t\t\t\ttp->led_ctrl |= (LED_CTRL_MODE_PHY_1 |\n\t\t\t\t\t\t LED_CTRL_MODE_PHY_2);\n\n\t\t\tif (tg3_flag(tp, 5717_PLUS) ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\t\t\ttp->led_ctrl |= LED_CTRL_BLINK_RATE_OVERRIDE |\n\t\t\t\t\t\tLED_CTRL_BLINK_RATE_MASK;\n\n\t\t\tbreak;\n\n\t\tcase SHASTA_EXT_LED_MAC:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_SHASTA_MAC;\n\t\t\tbreak;\n\n\t\tcase SHASTA_EXT_LED_COMBO:\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_COMBO;\n\t\t\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5750_A0)\n\t\t\t\ttp->led_ctrl |= (LED_CTRL_MODE_PHY_1 |\n\t\t\t\t\t\t LED_CTRL_MODE_PHY_2);\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ((tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t\t     tg3_asic_rev(tp) == ASIC_REV_5701) &&\n\t\t    tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL)\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_2;\n\n\t\tif (tg3_chip_rev(tp) == CHIPREV_5784_AX)\n\t\t\ttp->led_ctrl = LED_CTRL_MODE_PHY_1;\n\n\t\tif (nic_cfg & NIC_SRAM_DATA_CFG_EEPROM_WP) {\n\t\t\ttg3_flag_set(tp, EEPROM_WRITE_PROT);\n\t\t\tif ((tp->pdev->subsystem_vendor ==\n\t\t\t     PCI_VENDOR_ID_ARIMA) &&\n\t\t\t    (tp->pdev->subsystem_device == 0x205a ||\n\t\t\t     tp->pdev->subsystem_device == 0x2063))\n\t\t\t\ttg3_flag_clear(tp, EEPROM_WRITE_PROT);\n\t\t} else {\n\t\t\ttg3_flag_clear(tp, EEPROM_WRITE_PROT);\n\t\t\ttg3_flag_set(tp, IS_NIC);\n\t\t}\n\n\t\tif (nic_cfg & NIC_SRAM_DATA_CFG_ASF_ENABLE) {\n\t\t\ttg3_flag_set(tp, ENABLE_ASF);\n\t\t\tif (tg3_flag(tp, 5750_PLUS))\n\t\t\t\ttg3_flag_set(tp, ASF_NEW_HANDSHAKE);\n\t\t}\n\n\t\tif ((nic_cfg & NIC_SRAM_DATA_CFG_APE_ENABLE) &&\n\t\t    tg3_flag(tp, 5750_PLUS))\n\t\t\ttg3_flag_set(tp, ENABLE_APE);\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_ANY_SERDES &&\n\t\t    !(nic_cfg & NIC_SRAM_DATA_CFG_FIBER_WOL))\n\t\t\ttg3_flag_clear(tp, WOL_CAP);\n\n\t\tif (tg3_flag(tp, WOL_CAP) &&\n\t\t    (nic_cfg & NIC_SRAM_DATA_CFG_WOL_ENABLE)) {\n\t\t\ttg3_flag_set(tp, WOL_ENABLE);\n\t\t\tdevice_set_wakeup_enable(&tp->pdev->dev, true);\n\t\t}\n\n\t\tif (cfg2 & (1 << 17))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_CAPACITIVE_COUPLING;\n\n\t\t/* serdes signal pre-emphasis in register 0x590 set by */\n\t\t/* bootcode if bit 18 is set */\n\t\tif (cfg2 & (1 << 18))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_SERDES_PREEMPHASIS;\n\n\t\tif ((tg3_flag(tp, 57765_PLUS) ||\n\t\t     (tg3_asic_rev(tp) == ASIC_REV_5784 &&\n\t\t      tg3_chip_rev(tp) != CHIPREV_5784_AX)) &&\n\t\t    (cfg2 & NIC_SRAM_DATA_CFG_2_APD_EN))\n\t\t\ttp->phy_flags |= TG3_PHYFLG_ENABLE_APD;\n\n\t\tif (tg3_flag(tp, PCI_EXPRESS)) {\n\t\t\tu32 cfg3;\n\n\t\t\ttg3_read_mem(tp, NIC_SRAM_DATA_CFG_3, &cfg3);\n\t\t\tif (tg3_asic_rev(tp) != ASIC_REV_5785 &&\n\t\t\t    !tg3_flag(tp, 57765_PLUS) &&\n\t\t\t    (cfg3 & NIC_SRAM_ASPM_DEBOUNCE))\n\t\t\t\ttg3_flag_set(tp, ASPM_WORKAROUND);\n\t\t\tif (cfg3 & NIC_SRAM_LNK_FLAP_AVOID)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_KEEP_LINK_ON_PWRDN;\n\t\t\tif (cfg3 & NIC_SRAM_1G_ON_VAUX_OK)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_1G_ON_VAUX_OK;\n\t\t}\n\n\t\tif (cfg4 & NIC_SRAM_RGMII_INBAND_DISABLE)\n\t\t\ttg3_flag_set(tp, RGMII_INBAND_DISABLE);\n\t\tif (cfg4 & NIC_SRAM_RGMII_EXT_IBND_RX_EN)\n\t\t\ttg3_flag_set(tp, RGMII_EXT_IBND_RX_EN);\n\t\tif (cfg4 & NIC_SRAM_RGMII_EXT_IBND_TX_EN)\n\t\t\ttg3_flag_set(tp, RGMII_EXT_IBND_TX_EN);\n\n\t\tif (cfg5 & NIC_SRAM_DISABLE_1G_HALF_ADV)\n\t\t\ttp->phy_flags |= TG3_PHYFLG_DISABLE_1G_HD_ADV;\n\t}\ndone:\n\tif (tg3_flag(tp, WOL_CAP))\n\t\tdevice_set_wakeup_enable(&tp->pdev->dev,\n\t\t\t\t\t tg3_flag(tp, WOL_ENABLE));\n\telse\n\t\tdevice_set_wakeup_capable(&tp->pdev->dev, false);\n}\n\nstatic int tg3_ape_otp_read(struct tg3 *tp, u32 offset, u32 *val)\n{\n\tint i, err;\n\tu32 val2, off = offset * 8;\n\n\terr = tg3_nvram_lock(tp);\n\tif (err)\n\t\treturn err;\n\n\ttg3_ape_write32(tp, TG3_APE_OTP_ADDR, off | APE_OTP_ADDR_CPU_ENABLE);\n\ttg3_ape_write32(tp, TG3_APE_OTP_CTRL, APE_OTP_CTRL_PROG_EN |\n\t\t\tAPE_OTP_CTRL_CMD_RD | APE_OTP_CTRL_START);\n\ttg3_ape_read32(tp, TG3_APE_OTP_CTRL);\n\tudelay(10);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tval2 = tg3_ape_read32(tp, TG3_APE_OTP_STATUS);\n\t\tif (val2 & APE_OTP_STATUS_CMD_DONE) {\n\t\t\t*val = tg3_ape_read32(tp, TG3_APE_OTP_RD_DATA);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\ttg3_ape_write32(tp, TG3_APE_OTP_CTRL, 0);\n\n\ttg3_nvram_unlock(tp);\n\tif (val2 & APE_OTP_STATUS_CMD_DONE)\n\t\treturn 0;\n\n\treturn -EBUSY;\n}\n\nstatic int tg3_issue_otp_command(struct tg3 *tp, u32 cmd)\n{\n\tint i;\n\tu32 val;\n\n\ttw32(OTP_CTRL, cmd | OTP_CTRL_OTP_CMD_START);\n\ttw32(OTP_CTRL, cmd);\n\n\t/* Wait for up to 1 ms for command to execute. */\n\tfor (i = 0; i < 100; i++) {\n\t\tval = tr32(OTP_STATUS);\n\t\tif (val & OTP_STATUS_CMD_DONE)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\treturn (val & OTP_STATUS_CMD_DONE) ? 0 : -EBUSY;\n}\n\n/* Read the gphy configuration from the OTP region of the chip.  The gphy\n * configuration is a 32-bit value that straddles the alignment boundary.\n * We do two 32-bit reads and then shift and merge the results.\n */\nstatic u32 tg3_read_otp_phycfg(struct tg3 *tp)\n{\n\tu32 bhalf_otp, thalf_otp;\n\n\ttw32(OTP_MODE, OTP_MODE_OTP_THRU_GRC);\n\n\tif (tg3_issue_otp_command(tp, OTP_CTRL_OTP_CMD_INIT))\n\t\treturn 0;\n\n\ttw32(OTP_ADDRESS, OTP_ADDRESS_MAGIC1);\n\n\tif (tg3_issue_otp_command(tp, OTP_CTRL_OTP_CMD_READ))\n\t\treturn 0;\n\n\tthalf_otp = tr32(OTP_READ_DATA);\n\n\ttw32(OTP_ADDRESS, OTP_ADDRESS_MAGIC2);\n\n\tif (tg3_issue_otp_command(tp, OTP_CTRL_OTP_CMD_READ))\n\t\treturn 0;\n\n\tbhalf_otp = tr32(OTP_READ_DATA);\n\n\treturn ((thalf_otp & 0x0000ffff) << 16) | (bhalf_otp >> 16);\n}\n\nstatic void tg3_phy_init_link_config(struct tg3 *tp)\n{\n\tu32 adv = ADVERTISED_Autoneg;\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_10_100_ONLY)) {\n\t\tif (!(tp->phy_flags & TG3_PHYFLG_DISABLE_1G_HD_ADV))\n\t\t\tadv |= ADVERTISED_1000baseT_Half;\n\t\tadv |= ADVERTISED_1000baseT_Full;\n\t}\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\n\t\tadv |= ADVERTISED_100baseT_Half |\n\t\t       ADVERTISED_100baseT_Full |\n\t\t       ADVERTISED_10baseT_Half |\n\t\t       ADVERTISED_10baseT_Full |\n\t\t       ADVERTISED_TP;\n\telse\n\t\tadv |= ADVERTISED_FIBRE;\n\n\ttp->link_config.advertising = adv;\n\ttp->link_config.speed = SPEED_UNKNOWN;\n\ttp->link_config.duplex = DUPLEX_UNKNOWN;\n\ttp->link_config.autoneg = AUTONEG_ENABLE;\n\ttp->link_config.active_speed = SPEED_UNKNOWN;\n\ttp->link_config.active_duplex = DUPLEX_UNKNOWN;\n\n\ttp->old_link = -1;\n}\n\nstatic int tg3_phy_probe(struct tg3 *tp)\n{\n\tu32 hw_phy_id_1, hw_phy_id_2;\n\tu32 hw_phy_id, hw_phy_id_masked;\n\tint err;\n\n\t/* flow control autonegotiation is default behavior */\n\ttg3_flag_set(tp, PAUSE_AUTONEG);\n\ttp->link_config.flowctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;\n\n\tif (tg3_flag(tp, ENABLE_APE)) {\n\t\tswitch (tp->pci_fn) {\n\t\tcase 0:\n\t\t\ttp->phy_ape_lock = TG3_APE_LOCK_PHY0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttp->phy_ape_lock = TG3_APE_LOCK_PHY1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttp->phy_ape_lock = TG3_APE_LOCK_PHY2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttp->phy_ape_lock = TG3_APE_LOCK_PHY3;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tg3_flag(tp, ENABLE_ASF) &&\n\t    !(tp->phy_flags & TG3_PHYFLG_ANY_SERDES) &&\n\t    !(tp->phy_flags & TG3_PHYFLG_10_100_ONLY))\n\t\ttp->phy_flags &= ~(TG3_PHYFLG_1G_ON_VAUX_OK |\n\t\t\t\t   TG3_PHYFLG_KEEP_LINK_ON_PWRDN);\n\n\tif (tg3_flag(tp, USE_PHYLIB))\n\t\treturn tg3_phy_init(tp);\n\n\t/* Reading the PHY ID register can conflict with ASF\n\t * firmware access to the PHY hardware.\n\t */\n\terr = 0;\n\tif (tg3_flag(tp, ENABLE_ASF) || tg3_flag(tp, ENABLE_APE)) {\n\t\thw_phy_id = hw_phy_id_masked = TG3_PHY_ID_INVALID;\n\t} else {\n\t\t/* Now read the physical PHY_ID from the chip and verify\n\t\t * that it is sane.  If it doesn't look good, we fall back\n\t\t * to either the hard-coded table based PHY_ID and failing\n\t\t * that the value found in the eeprom area.\n\t\t */\n\t\terr |= tg3_readphy(tp, MII_PHYSID1, &hw_phy_id_1);\n\t\terr |= tg3_readphy(tp, MII_PHYSID2, &hw_phy_id_2);\n\n\t\thw_phy_id  = (hw_phy_id_1 & 0xffff) << 10;\n\t\thw_phy_id |= (hw_phy_id_2 & 0xfc00) << 16;\n\t\thw_phy_id |= (hw_phy_id_2 & 0x03ff) <<  0;\n\n\t\thw_phy_id_masked = hw_phy_id & TG3_PHY_ID_MASK;\n\t}\n\n\tif (!err && TG3_KNOWN_PHY_ID(hw_phy_id_masked)) {\n\t\ttp->phy_id = hw_phy_id;\n\t\tif (hw_phy_id_masked == TG3_PHY_ID_BCM8002)\n\t\t\ttp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\n\t\telse\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_PHY_SERDES;\n\t} else {\n\t\tif (tp->phy_id != TG3_PHY_ID_INVALID) {\n\t\t\t/* Do nothing, phy ID already set up in\n\t\t\t * tg3_get_eeprom_hw_cfg().\n\t\t\t */\n\t\t} else {\n\t\t\tstruct subsys_tbl_ent *p;\n\n\t\t\t/* No eeprom signature?  Try the hardcoded\n\t\t\t * subsys device table.\n\t\t\t */\n\t\t\tp = tg3_lookup_by_subsys(tp);\n\t\t\tif (p) {\n\t\t\t\ttp->phy_id = p->phy_id;\n\t\t\t} else if (!tg3_flag(tp, IS_SSB_CORE)) {\n\t\t\t\t/* For now we saw the IDs 0xbc050cd0,\n\t\t\t\t * 0xbc050f80 and 0xbc050c30 on devices\n\t\t\t\t * connected to an BCM4785 and there are\n\t\t\t\t * probably more. Just assume that the phy is\n\t\t\t\t * supported when it is connected to a SSB core\n\t\t\t\t * for now.\n\t\t\t\t */\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tif (!tp->phy_id ||\n\t\t\t    tp->phy_id == TG3_PHY_ID_BCM8002)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_PHY_SERDES;\n\t\t}\n\t}\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_ANY_SERDES) &&\n\t    (tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_57766 ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5762 ||\n\t     (tg3_asic_rev(tp) == ASIC_REV_5717 &&\n\t      tg3_chip_rev_id(tp) != CHIPREV_ID_5717_A0) ||\n\t     (tg3_asic_rev(tp) == ASIC_REV_57765 &&\n\t      tg3_chip_rev_id(tp) != CHIPREV_ID_57765_A0))) {\n\t\ttp->phy_flags |= TG3_PHYFLG_EEE_CAP;\n\n\t\ttp->eee.supported = SUPPORTED_100baseT_Full |\n\t\t\t\t    SUPPORTED_1000baseT_Full;\n\t\ttp->eee.advertised = ADVERTISED_100baseT_Full |\n\t\t\t\t     ADVERTISED_1000baseT_Full;\n\t\ttp->eee.eee_enabled = 1;\n\t\ttp->eee.tx_lpi_enabled = 1;\n\t\ttp->eee.tx_lpi_timer = TG3_CPMU_DBTMR1_LNKIDLE_2047US;\n\t}\n\n\ttg3_phy_init_link_config(tp);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN) &&\n\t    !(tp->phy_flags & TG3_PHYFLG_ANY_SERDES) &&\n\t    !tg3_flag(tp, ENABLE_APE) &&\n\t    !tg3_flag(tp, ENABLE_ASF)) {\n\t\tu32 bmsr, dummy;\n\n\t\ttg3_readphy(tp, MII_BMSR, &bmsr);\n\t\tif (!tg3_readphy(tp, MII_BMSR, &bmsr) &&\n\t\t    (bmsr & BMSR_LSTATUS))\n\t\t\tgoto skip_phy_reset;\n\n\t\terr = tg3_phy_reset(tp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttg3_phy_set_wirespeed(tp);\n\n\t\tif (!tg3_phy_copper_an_config_ok(tp, &dummy)) {\n\t\t\ttg3_phy_autoneg_cfg(tp, tp->link_config.advertising,\n\t\t\t\t\t    tp->link_config.flowctrl);\n\n\t\t\ttg3_writephy(tp, MII_BMCR,\n\t\t\t\t     BMCR_ANENABLE | BMCR_ANRESTART);\n\t\t}\n\t}\n\nskip_phy_reset:\n\tif ((tp->phy_id & TG3_PHY_ID_MASK) == TG3_PHY_ID_BCM5401) {\n\t\terr = tg3_init_5401phy_dsp(tp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = tg3_init_5401phy_dsp(tp);\n\t}\n\n\treturn err;\n}\n\nstatic void tg3_read_vpd(struct tg3 *tp)\n{\n\tu8 *vpd_data;\n\tunsigned int block_end, rosize, len;\n\tu32 vpdlen;\n\tint j, i = 0;\n\n\tvpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);\n\tif (!vpd_data)\n\t\tgoto out_no_vpd;\n\n\ti = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\trosize = pci_vpd_lrdt_size(&vpd_data[i]);\n\tblock_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;\n\ti += PCI_VPD_LRDT_TAG_SIZE;\n\n\tif (block_end > vpdlen)\n\t\tgoto out_not_found;\n\n\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_MFR_ID);\n\tif (j > 0) {\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end || len != 4 ||\n\t\t    memcmp(&vpd_data[j], \"1028\", 4))\n\t\t\tgoto partno;\n\n\t\tj = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t\t      PCI_VPD_RO_KEYWORD_VENDOR0);\n\t\tif (j < 0)\n\t\t\tgoto partno;\n\n\t\tlen = pci_vpd_info_field_size(&vpd_data[j]);\n\n\t\tj += PCI_VPD_INFO_FLD_HDR_SIZE;\n\t\tif (j + len > block_end)\n\t\t\tgoto partno;\n\n\t\tif (len >= sizeof(tp->fw_ver))\n\t\t\tlen = sizeof(tp->fw_ver) - 1;\n\t\tmemset(tp->fw_ver, 0, sizeof(tp->fw_ver));\n\t\tsnprintf(tp->fw_ver, sizeof(tp->fw_ver), \"%.*s bc \", len,\n\t\t\t &vpd_data[j]);\n\t}\n\npartno:\n\ti = pci_vpd_find_info_keyword(vpd_data, i, rosize,\n\t\t\t\t      PCI_VPD_RO_KEYWORD_PARTNO);\n\tif (i < 0)\n\t\tgoto out_not_found;\n\n\tlen = pci_vpd_info_field_size(&vpd_data[i]);\n\n\ti += PCI_VPD_INFO_FLD_HDR_SIZE;\n\tif (len > TG3_BPN_SIZE ||\n\t    (len + i) > vpdlen)\n\t\tgoto out_not_found;\n\n\tmemcpy(tp->board_part_number, &vpd_data[i], len);\n\nout_not_found:\n\tkfree(vpd_data);\n\tif (tp->board_part_number[0])\n\t\treturn;\n\nout_no_vpd:\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5717\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)\n\t\t\tstrcpy(tp->board_part_number, \"BCM5718\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57780\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57760\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57790\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57788\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57761\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57765\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57781\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57785\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57791\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57795\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57762\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57766\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57782\");\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\tstrcpy(tp->board_part_number, \"BCM57786\");\n\t\telse\n\t\t\tgoto nomatch;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\tstrcpy(tp->board_part_number, \"BCM95906\");\n\t} else {\nnomatch:\n\t\tstrcpy(tp->board_part_number, \"none\");\n\t}\n}\n\nstatic int tg3_fw_img_is_valid(struct tg3 *tp, u32 offset)\n{\n\tu32 val;\n\n\tif (tg3_nvram_read(tp, offset, &val) ||\n\t    (val & 0xfc000000) != 0x0c000000 ||\n\t    tg3_nvram_read(tp, offset + 4, &val) ||\n\t    val != 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void tg3_read_bc_ver(struct tg3 *tp)\n{\n\tu32 val, offset, start, ver_offset;\n\tint i, dst_off;\n\tbool newver = false;\n\n\tif (tg3_nvram_read(tp, 0xc, &offset) ||\n\t    tg3_nvram_read(tp, 0x4, &start))\n\t\treturn;\n\n\toffset = tg3_nvram_logical_addr(tp, offset);\n\n\tif (tg3_nvram_read(tp, offset, &val))\n\t\treturn;\n\n\tif ((val & 0xfc000000) == 0x0c000000) {\n\t\tif (tg3_nvram_read(tp, offset + 4, &val))\n\t\t\treturn;\n\n\t\tif (val == 0)\n\t\t\tnewver = true;\n\t}\n\n\tdst_off = strlen(tp->fw_ver);\n\n\tif (newver) {\n\t\tif (TG3_VER_SIZE - dst_off < 16 ||\n\t\t    tg3_nvram_read(tp, offset + 8, &ver_offset))\n\t\t\treturn;\n\n\t\toffset = offset + ver_offset - start;\n\t\tfor (i = 0; i < 16; i += 4) {\n\t\t\t__be32 v;\n\t\t\tif (tg3_nvram_read_be32(tp, offset + i, &v))\n\t\t\t\treturn;\n\n\t\t\tmemcpy(tp->fw_ver + dst_off + i, &v, sizeof(v));\n\t\t}\n\t} else {\n\t\tu32 major, minor;\n\n\t\tif (tg3_nvram_read(tp, TG3_NVM_PTREV_BCVER, &ver_offset))\n\t\t\treturn;\n\n\t\tmajor = (ver_offset & TG3_NVM_BCVER_MAJMSK) >>\n\t\t\tTG3_NVM_BCVER_MAJSFT;\n\t\tminor = ver_offset & TG3_NVM_BCVER_MINMSK;\n\t\tsnprintf(&tp->fw_ver[dst_off], TG3_VER_SIZE - dst_off,\n\t\t\t \"v%d.%02d\", major, minor);\n\t}\n}\n\nstatic void tg3_read_hwsb_ver(struct tg3 *tp)\n{\n\tu32 val, major, minor;\n\n\t/* Use native endian representation */\n\tif (tg3_nvram_read(tp, TG3_NVM_HWSB_CFG1, &val))\n\t\treturn;\n\n\tmajor = (val & TG3_NVM_HWSB_CFG1_MAJMSK) >>\n\t\tTG3_NVM_HWSB_CFG1_MAJSFT;\n\tminor = (val & TG3_NVM_HWSB_CFG1_MINMSK) >>\n\t\tTG3_NVM_HWSB_CFG1_MINSFT;\n\n\tsnprintf(&tp->fw_ver[0], 32, \"sb v%d.%02d\", major, minor);\n}\n\nstatic void tg3_read_sb_ver(struct tg3 *tp, u32 val)\n{\n\tu32 offset, major, minor, build;\n\n\tstrncat(tp->fw_ver, \"sb\", TG3_VER_SIZE - strlen(tp->fw_ver) - 1);\n\n\tif ((val & TG3_EEPROM_SB_FORMAT_MASK) != TG3_EEPROM_SB_FORMAT_1)\n\t\treturn;\n\n\tswitch (val & TG3_EEPROM_SB_REVISION_MASK) {\n\tcase TG3_EEPROM_SB_REVISION_0:\n\t\toffset = TG3_EEPROM_SB_F1R0_EDH_OFF;\n\t\tbreak;\n\tcase TG3_EEPROM_SB_REVISION_2:\n\t\toffset = TG3_EEPROM_SB_F1R2_EDH_OFF;\n\t\tbreak;\n\tcase TG3_EEPROM_SB_REVISION_3:\n\t\toffset = TG3_EEPROM_SB_F1R3_EDH_OFF;\n\t\tbreak;\n\tcase TG3_EEPROM_SB_REVISION_4:\n\t\toffset = TG3_EEPROM_SB_F1R4_EDH_OFF;\n\t\tbreak;\n\tcase TG3_EEPROM_SB_REVISION_5:\n\t\toffset = TG3_EEPROM_SB_F1R5_EDH_OFF;\n\t\tbreak;\n\tcase TG3_EEPROM_SB_REVISION_6:\n\t\toffset = TG3_EEPROM_SB_F1R6_EDH_OFF;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (tg3_nvram_read(tp, offset, &val))\n\t\treturn;\n\n\tbuild = (val & TG3_EEPROM_SB_EDH_BLD_MASK) >>\n\t\tTG3_EEPROM_SB_EDH_BLD_SHFT;\n\tmajor = (val & TG3_EEPROM_SB_EDH_MAJ_MASK) >>\n\t\tTG3_EEPROM_SB_EDH_MAJ_SHFT;\n\tminor =  val & TG3_EEPROM_SB_EDH_MIN_MASK;\n\n\tif (minor > 99 || build > 26)\n\t\treturn;\n\n\toffset = strlen(tp->fw_ver);\n\tsnprintf(&tp->fw_ver[offset], TG3_VER_SIZE - offset,\n\t\t \" v%d.%02d\", major, minor);\n\n\tif (build > 0) {\n\t\toffset = strlen(tp->fw_ver);\n\t\tif (offset < TG3_VER_SIZE - 1)\n\t\t\ttp->fw_ver[offset] = 'a' + build - 1;\n\t}\n}\n\nstatic void tg3_read_mgmtfw_ver(struct tg3 *tp)\n{\n\tu32 val, offset, start;\n\tint i, vlen;\n\n\tfor (offset = TG3_NVM_DIR_START;\n\t     offset < TG3_NVM_DIR_END;\n\t     offset += TG3_NVM_DIRENT_SIZE) {\n\t\tif (tg3_nvram_read(tp, offset, &val))\n\t\t\treturn;\n\n\t\tif ((val >> TG3_NVM_DIRTYPE_SHIFT) == TG3_NVM_DIRTYPE_ASFINI)\n\t\t\tbreak;\n\t}\n\n\tif (offset == TG3_NVM_DIR_END)\n\t\treturn;\n\n\tif (!tg3_flag(tp, 5705_PLUS))\n\t\tstart = 0x08000000;\n\telse if (tg3_nvram_read(tp, offset - 4, &start))\n\t\treturn;\n\n\tif (tg3_nvram_read(tp, offset + 4, &offset) ||\n\t    !tg3_fw_img_is_valid(tp, offset) ||\n\t    tg3_nvram_read(tp, offset + 8, &val))\n\t\treturn;\n\n\toffset += val - start;\n\n\tvlen = strlen(tp->fw_ver);\n\n\ttp->fw_ver[vlen++] = ',';\n\ttp->fw_ver[vlen++] = ' ';\n\n\tfor (i = 0; i < 4; i++) {\n\t\t__be32 v;\n\t\tif (tg3_nvram_read_be32(tp, offset, &v))\n\t\t\treturn;\n\n\t\toffset += sizeof(v);\n\n\t\tif (vlen > TG3_VER_SIZE - sizeof(v)) {\n\t\t\tmemcpy(&tp->fw_ver[vlen], &v, TG3_VER_SIZE - vlen);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(&tp->fw_ver[vlen], &v, sizeof(v));\n\t\tvlen += sizeof(v);\n\t}\n}\n\nstatic void tg3_probe_ncsi(struct tg3 *tp)\n{\n\tu32 apedata;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_SEG_SIG);\n\tif (apedata != APE_SEG_SIG_MAGIC)\n\t\treturn;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_FW_STATUS);\n\tif (!(apedata & APE_FW_STATUS_READY))\n\t\treturn;\n\n\tif (tg3_ape_read32(tp, TG3_APE_FW_FEATURES) & TG3_APE_FW_FEATURE_NCSI)\n\t\ttg3_flag_set(tp, APE_HAS_NCSI);\n}\n\nstatic void tg3_read_dash_ver(struct tg3 *tp)\n{\n\tint vlen;\n\tu32 apedata;\n\tchar *fwtype;\n\n\tapedata = tg3_ape_read32(tp, TG3_APE_FW_VERSION);\n\n\tif (tg3_flag(tp, APE_HAS_NCSI))\n\t\tfwtype = \"NCSI\";\n\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725)\n\t\tfwtype = \"SMASH\";\n\telse\n\t\tfwtype = \"DASH\";\n\n\tvlen = strlen(tp->fw_ver);\n\n\tsnprintf(&tp->fw_ver[vlen], TG3_VER_SIZE - vlen, \" %s v%d.%d.%d.%d\",\n\t\t fwtype,\n\t\t (apedata & APE_FW_VERSION_MAJMSK) >> APE_FW_VERSION_MAJSFT,\n\t\t (apedata & APE_FW_VERSION_MINMSK) >> APE_FW_VERSION_MINSFT,\n\t\t (apedata & APE_FW_VERSION_REVMSK) >> APE_FW_VERSION_REVSFT,\n\t\t (apedata & APE_FW_VERSION_BLDMSK));\n}\n\nstatic void tg3_read_otp_ver(struct tg3 *tp)\n{\n\tu32 val, val2;\n\n\tif (tg3_asic_rev(tp) != ASIC_REV_5762)\n\t\treturn;\n\n\tif (!tg3_ape_otp_read(tp, OTP_ADDRESS_MAGIC0, &val) &&\n\t    !tg3_ape_otp_read(tp, OTP_ADDRESS_MAGIC0 + 4, &val2) &&\n\t    TG3_OTP_MAGIC0_VALID(val)) {\n\t\tu64 val64 = (u64) val << 32 | val2;\n\t\tu32 ver = 0;\n\t\tint i, vlen;\n\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tif ((val64 & 0xff) == 0)\n\t\t\t\tbreak;\n\t\t\tver = val64 & 0xff;\n\t\t\tval64 >>= 8;\n\t\t}\n\t\tvlen = strlen(tp->fw_ver);\n\t\tsnprintf(&tp->fw_ver[vlen], TG3_VER_SIZE - vlen, \" .%02d\", ver);\n\t}\n}\n\nstatic void tg3_read_fw_ver(struct tg3 *tp)\n{\n\tu32 val;\n\tbool vpd_vers = false;\n\n\tif (tp->fw_ver[0] != 0)\n\t\tvpd_vers = true;\n\n\tif (tg3_flag(tp, NO_NVRAM)) {\n\t\tstrcat(tp->fw_ver, \"sb\");\n\t\ttg3_read_otp_ver(tp);\n\t\treturn;\n\t}\n\n\tif (tg3_nvram_read(tp, 0, &val))\n\t\treturn;\n\n\tif (val == TG3_EEPROM_MAGIC)\n\t\ttg3_read_bc_ver(tp);\n\telse if ((val & TG3_EEPROM_MAGIC_FW_MSK) == TG3_EEPROM_MAGIC_FW)\n\t\ttg3_read_sb_ver(tp, val);\n\telse if ((val & TG3_EEPROM_MAGIC_HW_MSK) == TG3_EEPROM_MAGIC_HW)\n\t\ttg3_read_hwsb_ver(tp);\n\n\tif (tg3_flag(tp, ENABLE_ASF)) {\n\t\tif (tg3_flag(tp, ENABLE_APE)) {\n\t\t\ttg3_probe_ncsi(tp);\n\t\t\tif (!vpd_vers)\n\t\t\t\ttg3_read_dash_ver(tp);\n\t\t} else if (!vpd_vers) {\n\t\t\ttg3_read_mgmtfw_ver(tp);\n\t\t}\n\t}\n\n\ttp->fw_ver[TG3_VER_SIZE - 1] = 0;\n}\n\nstatic inline u32 tg3_rx_ret_ring_size(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, LRG_PROD_RING_CAP))\n\t\treturn TG3_RX_RET_MAX_SIZE_5717;\n\telse if (tg3_flag(tp, JUMBO_CAPABLE) && !tg3_flag(tp, 5780_CLASS))\n\t\treturn TG3_RX_RET_MAX_SIZE_5700;\n\telse\n\t\treturn TG3_RX_RET_MAX_SIZE_5705;\n}\n\nstatic const struct pci_device_id tg3_write_reorder_chipsets[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_FE_GATE_700C) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8131_BRIDGE) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8385_0) },\n\t{ },\n};\n\nstatic struct pci_dev *tg3_find_peer(struct tg3 *tp)\n{\n\tstruct pci_dev *peer;\n\tunsigned int func, devnr = tp->pdev->devfn & ~7;\n\n\tfor (func = 0; func < 8; func++) {\n\t\tpeer = pci_get_slot(tp->pdev->bus, devnr | func);\n\t\tif (peer && peer != tp->pdev)\n\t\t\tbreak;\n\t\tpci_dev_put(peer);\n\t}\n\t/* 5704 can be configured in single-port mode, set peer to\n\t * tp->pdev in that case.\n\t */\n\tif (!peer) {\n\t\tpeer = tp->pdev;\n\t\treturn peer;\n\t}\n\n\t/*\n\t * We don't need to keep the refcount elevated; there's no way\n\t * to remove one half of this device without removing the other\n\t */\n\tpci_dev_put(peer);\n\n\treturn peer;\n}\n\nstatic void tg3_detect_asic_rev(struct tg3 *tp, u32 misc_ctrl_reg)\n{\n\ttp->pci_chip_rev_id = misc_ctrl_reg >> MISC_HOST_CTRL_CHIPREV_SHIFT;\n\tif (tg3_asic_rev(tp) == ASIC_REV_USE_PROD_ID_REG) {\n\t\tu32 reg;\n\n\t\t/* All devices that use the alternate\n\t\t * ASIC REV location have a CPMU.\n\t\t */\n\t\ttg3_flag_set(tp, CPMU_PRESENT);\n\n\t\tif (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5719 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5720 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_57767 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_57764 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5762 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5727 ||\n\t\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_57787)\n\t\t\treg = TG3PCI_GEN2_PRODID_ASICREV;\n\t\telse if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782 ||\n\t\t\t tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)\n\t\t\treg = TG3PCI_GEN15_PRODID_ASICREV;\n\t\telse\n\t\t\treg = TG3PCI_PRODID_ASICREV;\n\n\t\tpci_read_config_dword(tp->pdev, reg, &tp->pci_chip_rev_id);\n\t}\n\n\t/* Wrong chip ID in 5752 A0. This code can be removed later\n\t * as A0 is not in production.\n\t */\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5752_A0_HW)\n\t\ttp->pci_chip_rev_id = CHIPREV_ID_5752_A0;\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5717_C0)\n\t\ttp->pci_chip_rev_id = CHIPREV_ID_5720_A0;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\ttg3_flag_set(tp, 5717_PLUS);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_57765 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57766)\n\t\ttg3_flag_set(tp, 57765_CLASS);\n\n\tif (tg3_flag(tp, 57765_CLASS) || tg3_flag(tp, 5717_PLUS) ||\n\t     tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\ttg3_flag_set(tp, 57765_PLUS);\n\n\t/* Intentionally exclude ASIC_REV_5906 */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5755 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5787 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5784 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5761 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5785 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57780 ||\n\t    tg3_flag(tp, 57765_PLUS))\n\t\ttg3_flag_set(tp, 5755_PLUS);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5780 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5714)\n\t\ttg3_flag_set(tp, 5780_CLASS);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5750 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5752 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5906 ||\n\t    tg3_flag(tp, 5755_PLUS) ||\n\t    tg3_flag(tp, 5780_CLASS))\n\t\ttg3_flag_set(tp, 5750_PLUS);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5705 ||\n\t    tg3_flag(tp, 5750_PLUS))\n\t\ttg3_flag_set(tp, 5705_PLUS);\n}\n\nstatic bool tg3_10_100_only_device(struct tg3 *tp,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\tu32 grc_misc_cfg = tr32(GRC_MISC_CFG) & GRC_MISC_CFG_BOARD_ID_MASK;\n\n\tif ((tg3_asic_rev(tp) == ASIC_REV_5703 &&\n\t     (grc_misc_cfg == 0x8000 || grc_misc_cfg == 0x4000)) ||\n\t    (tp->phy_flags & TG3_PHYFLG_IS_FET))\n\t\treturn true;\n\n\tif (ent->driver_data & TG3_DRV_DATA_FLAG_10_100_ONLY) {\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5705) {\n\t\t\tif (ent->driver_data & TG3_DRV_DATA_FLAG_5705_10_100)\n\t\t\t\treturn true;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int tg3_get_invariants(struct tg3 *tp, const struct pci_device_id *ent)\n{\n\tu32 misc_ctrl_reg;\n\tu32 pci_state_reg, grc_misc_cfg;\n\tu32 val;\n\tu16 pci_cmd;\n\tint err;\n\n\t/* Force memory write invalidate off.  If we leave it on,\n\t * then on 5700_BX chips we have to enable a workaround.\n\t * The workaround is to set the TG3PCI_DMA_RW_CTRL boundary\n\t * to match the cacheline size.  The Broadcom driver have this\n\t * workaround but turns MWI off all the times so never uses\n\t * it.  This seems to suggest that the workaround is insufficient.\n\t */\n\tpci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\n\tpci_cmd &= ~PCI_COMMAND_INVALIDATE;\n\tpci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\n\n\t/* Important! -- Make sure register accesses are byteswapped\n\t * correctly.  Also, for those chips that require it, make\n\t * sure that indirect register accesses are enabled before\n\t * the first operation.\n\t */\n\tpci_read_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\n\t\t\t      &misc_ctrl_reg);\n\ttp->misc_host_ctrl |= (misc_ctrl_reg &\n\t\t\t       MISC_HOST_CTRL_CHIPREV);\n\tpci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\n\t\t\t       tp->misc_host_ctrl);\n\n\ttg3_detect_asic_rev(tp, misc_ctrl_reg);\n\n\t/* If we have 5702/03 A1 or A2 on certain ICH chipsets,\n\t * we need to disable memory and use config. cycles\n\t * only to access all registers. The 5702/03 chips\n\t * can mistakenly decode the special cycles from the\n\t * ICH chipsets as memory write cycles, causing corruption\n\t * of register and memory space. Only certain ICH bridges\n\t * will drive special cycles with non-zero data during the\n\t * address phase which can fall within the 5703's address\n\t * range. This is not an ICH bug as the PCI spec allows\n\t * non-zero address during special cycles. However, only\n\t * these ICH bridges are known to drive non-zero addresses\n\t * during special cycles.\n\t *\n\t * Since special cycles do not cross PCI bridges, we only\n\t * enable this workaround if the 5703 is on the secondary\n\t * bus of these ICH bridges.\n\t */\n\tif ((tg3_chip_rev_id(tp) == CHIPREV_ID_5703_A1) ||\n\t    (tg3_chip_rev_id(tp) == CHIPREV_ID_5703_A2)) {\n\t\tstatic struct tg3_dev_id {\n\t\t\tu32\tvendor;\n\t\t\tu32\tdevice;\n\t\t\tu32\trev;\n\t\t} ich_chipsets[] = {\n\t\t\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801AA_8,\n\t\t\t  PCI_ANY_ID },\n\t\t\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801AB_8,\n\t\t\t  PCI_ANY_ID },\n\t\t\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_11,\n\t\t\t  0xa },\n\t\t\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801BA_6,\n\t\t\t  PCI_ANY_ID },\n\t\t\t{ },\n\t\t};\n\t\tstruct tg3_dev_id *pci_id = &ich_chipsets[0];\n\t\tstruct pci_dev *bridge = NULL;\n\n\t\twhile (pci_id->vendor != 0) {\n\t\t\tbridge = pci_get_device(pci_id->vendor, pci_id->device,\n\t\t\t\t\t\tbridge);\n\t\t\tif (!bridge) {\n\t\t\t\tpci_id++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (pci_id->rev != PCI_ANY_ID) {\n\t\t\t\tif (bridge->revision > pci_id->rev)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bridge->subordinate &&\n\t\t\t    (bridge->subordinate->number ==\n\t\t\t     tp->pdev->bus->number)) {\n\t\t\t\ttg3_flag_set(tp, ICH_WORKAROUND);\n\t\t\t\tpci_dev_put(bridge);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5701) {\n\t\tstatic struct tg3_dev_id {\n\t\t\tu32\tvendor;\n\t\t\tu32\tdevice;\n\t\t} bridge_chipsets[] = {\n\t\t\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PXH_0 },\n\t\t\t{ PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PXH_1 },\n\t\t\t{ },\n\t\t};\n\t\tstruct tg3_dev_id *pci_id = &bridge_chipsets[0];\n\t\tstruct pci_dev *bridge = NULL;\n\n\t\twhile (pci_id->vendor != 0) {\n\t\t\tbridge = pci_get_device(pci_id->vendor,\n\t\t\t\t\t\tpci_id->device,\n\t\t\t\t\t\tbridge);\n\t\t\tif (!bridge) {\n\t\t\t\tpci_id++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (bridge->subordinate &&\n\t\t\t    (bridge->subordinate->number <=\n\t\t\t     tp->pdev->bus->number) &&\n\t\t\t    (bridge->subordinate->busn_res.end >=\n\t\t\t     tp->pdev->bus->number)) {\n\t\t\t\ttg3_flag_set(tp, 5701_DMA_BUG);\n\t\t\t\tpci_dev_put(bridge);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* The EPB bridge inside 5714, 5715, and 5780 cannot support\n\t * DMA addresses > 40-bit. This bridge may have other additional\n\t * 57xx devices behind it in some 4-port NIC designs for example.\n\t * Any tg3 device found behind the bridge will also need the 40-bit\n\t * DMA workaround.\n\t */\n\tif (tg3_flag(tp, 5780_CLASS)) {\n\t\ttg3_flag_set(tp, 40BIT_DMA_BUG);\n\t\ttp->msi_cap = tp->pdev->msi_cap;\n\t} else {\n\t\tstruct pci_dev *bridge = NULL;\n\n\t\tdo {\n\t\t\tbridge = pci_get_device(PCI_VENDOR_ID_SERVERWORKS,\n\t\t\t\t\t\tPCI_DEVICE_ID_SERVERWORKS_EPB,\n\t\t\t\t\t\tbridge);\n\t\t\tif (bridge && bridge->subordinate &&\n\t\t\t    (bridge->subordinate->number <=\n\t\t\t     tp->pdev->bus->number) &&\n\t\t\t    (bridge->subordinate->busn_res.end >=\n\t\t\t     tp->pdev->bus->number)) {\n\t\t\t\ttg3_flag_set(tp, 40BIT_DMA_BUG);\n\t\t\t\tpci_dev_put(bridge);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (bridge);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5704 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5714)\n\t\ttp->pdev_peer = tg3_find_peer(tp);\n\n\t/* Determine TSO capabilities */\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0)\n\t\t; /* Do nothing. HW bug. */\n\telse if (tg3_flag(tp, 57765_PLUS))\n\t\ttg3_flag_set(tp, HW_TSO_3);\n\telse if (tg3_flag(tp, 5755_PLUS) ||\n\t\t tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\ttg3_flag_set(tp, HW_TSO_2);\n\telse if (tg3_flag(tp, 5750_PLUS)) {\n\t\ttg3_flag_set(tp, HW_TSO_1);\n\t\ttg3_flag_set(tp, TSO_BUG);\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5750 &&\n\t\t    tg3_chip_rev_id(tp) >= CHIPREV_ID_5750_C2)\n\t\t\ttg3_flag_clear(tp, TSO_BUG);\n\t} else if (tg3_asic_rev(tp) != ASIC_REV_5700 &&\n\t\t   tg3_asic_rev(tp) != ASIC_REV_5701 &&\n\t\t   tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) {\n\t\ttg3_flag_set(tp, FW_TSO);\n\t\ttg3_flag_set(tp, TSO_BUG);\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5705)\n\t\t\ttp->fw_needed = FIRMWARE_TG3TSO5;\n\t\telse\n\t\t\ttp->fw_needed = FIRMWARE_TG3TSO;\n\t}\n\n\t/* Selectively allow TSO based on operating conditions */\n\tif (tg3_flag(tp, HW_TSO_1) ||\n\t    tg3_flag(tp, HW_TSO_2) ||\n\t    tg3_flag(tp, HW_TSO_3) ||\n\t    tg3_flag(tp, FW_TSO)) {\n\t\t/* For firmware TSO, assume ASF is disabled.\n\t\t * We'll disable TSO later if we discover ASF\n\t\t * is enabled in tg3_get_eeprom_hw_cfg().\n\t\t */\n\t\ttg3_flag_set(tp, TSO_CAPABLE);\n\t} else {\n\t\ttg3_flag_clear(tp, TSO_CAPABLE);\n\t\ttg3_flag_clear(tp, TSO_BUG);\n\t\ttp->fw_needed = NULL;\n\t}\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0)\n\t\ttp->fw_needed = FIRMWARE_TG3;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_57766)\n\t\ttp->fw_needed = FIRMWARE_TG357766;\n\n\ttp->irq_max = 1;\n\n\tif (tg3_flag(tp, 5750_PLUS)) {\n\t\ttg3_flag_set(tp, SUPPORT_MSI);\n\t\tif (tg3_chip_rev(tp) == CHIPREV_5750_AX ||\n\t\t    tg3_chip_rev(tp) == CHIPREV_5750_BX ||\n\t\t    (tg3_asic_rev(tp) == ASIC_REV_5714 &&\n\t\t     tg3_chip_rev_id(tp) <= CHIPREV_ID_5714_A2 &&\n\t\t     tp->pdev_peer == tp->pdev))\n\t\t\ttg3_flag_clear(tp, SUPPORT_MSI);\n\n\t\tif (tg3_flag(tp, 5755_PLUS) ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\t\ttg3_flag_set(tp, 1SHOT_MSI);\n\t\t}\n\n\t\tif (tg3_flag(tp, 57765_PLUS)) {\n\t\t\ttg3_flag_set(tp, SUPPORT_MSIX);\n\t\t\ttp->irq_max = TG3_IRQ_MAX_VECS;\n\t\t}\n\t}\n\n\ttp->txq_max = 1;\n\ttp->rxq_max = 1;\n\tif (tp->irq_max > 1) {\n\t\ttp->rxq_max = TG3_RSS_MAX_NUM_QS;\n\t\ttg3_rss_init_dflt_indir_tbl(tp, TG3_RSS_MAX_NUM_QS);\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5720)\n\t\t\ttp->txq_max = tp->irq_max - 1;\n\t}\n\n\tif (tg3_flag(tp, 5755_PLUS) ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\ttg3_flag_set(tp, SHORT_DMA_BUG);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5719)\n\t\ttp->dma_limit = TG3_TX_BD_DMA_MAX_4K;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\ttg3_flag_set(tp, LRG_PROD_RING_CAP);\n\n\tif (tg3_flag(tp, 57765_PLUS) &&\n\t    tg3_chip_rev_id(tp) != CHIPREV_ID_5719_A0)\n\t\ttg3_flag_set(tp, USE_JUMBO_BDFLAG);\n\n\tif (!tg3_flag(tp, 5705_PLUS) ||\n\t    tg3_flag(tp, 5780_CLASS) ||\n\t    tg3_flag(tp, USE_JUMBO_BDFLAG))\n\t\ttg3_flag_set(tp, JUMBO_CAPABLE);\n\n\tpci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,\n\t\t\t      &pci_state_reg);\n\n\tif (pci_is_pcie(tp->pdev)) {\n\t\tu16 lnkctl;\n\n\t\ttg3_flag_set(tp, PCI_EXPRESS);\n\n\t\tpcie_capability_read_word(tp->pdev, PCI_EXP_LNKCTL, &lnkctl);\n\t\tif (lnkctl & PCI_EXP_LNKCTL_CLKREQ_EN) {\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\t\t\ttg3_flag_clear(tp, HW_TSO_2);\n\t\t\t\ttg3_flag_clear(tp, TSO_CAPABLE);\n\t\t\t}\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5784 ||\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5761 ||\n\t\t\t    tg3_chip_rev_id(tp) == CHIPREV_ID_57780_A0 ||\n\t\t\t    tg3_chip_rev_id(tp) == CHIPREV_ID_57780_A1)\n\t\t\t\ttg3_flag_set(tp, CLKREQ_BUG);\n\t\t} else if (tg3_chip_rev_id(tp) == CHIPREV_ID_5717_A0) {\n\t\t\ttg3_flag_set(tp, L1PLLPD_EN);\n\t\t}\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5785) {\n\t\t/* BCM5785 devices are effectively PCIe devices, and should\n\t\t * follow PCIe codepaths, but do not have a PCIe capabilities\n\t\t * section.\n\t\t */\n\t\ttg3_flag_set(tp, PCI_EXPRESS);\n\t} else if (!tg3_flag(tp, 5705_PLUS) ||\n\t\t   tg3_flag(tp, 5780_CLASS)) {\n\t\ttp->pcix_cap = pci_find_capability(tp->pdev, PCI_CAP_ID_PCIX);\n\t\tif (!tp->pcix_cap) {\n\t\t\tdev_err(&tp->pdev->dev,\n\t\t\t\t\"Cannot find PCI-X capability, aborting\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (!(pci_state_reg & PCISTATE_CONV_PCI_MODE))\n\t\t\ttg3_flag_set(tp, PCIX_MODE);\n\t}\n\n\t/* If we have an AMD 762 or VIA K8T800 chipset, write\n\t * reordering to the mailbox registers done by the host\n\t * controller can cause major troubles.  We read back from\n\t * every mailbox register write to force the writes to be\n\t * posted to the chip in order.\n\t */\n\tif (pci_dev_present(tg3_write_reorder_chipsets) &&\n\t    !tg3_flag(tp, PCI_EXPRESS))\n\t\ttg3_flag_set(tp, MBOX_WRITE_REORDER);\n\n\tpci_read_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE,\n\t\t\t     &tp->pci_cacheline_sz);\n\tpci_read_config_byte(tp->pdev, PCI_LATENCY_TIMER,\n\t\t\t     &tp->pci_lat_timer);\n\tif (tg3_asic_rev(tp) == ASIC_REV_5703 &&\n\t    tp->pci_lat_timer < 64) {\n\t\ttp->pci_lat_timer = 64;\n\t\tpci_write_config_byte(tp->pdev, PCI_LATENCY_TIMER,\n\t\t\t\t      tp->pci_lat_timer);\n\t}\n\n\t/* Important! -- It is critical that the PCI-X hw workaround\n\t * situation is decided before the first MMIO register access.\n\t */\n\tif (tg3_chip_rev(tp) == CHIPREV_5700_BX) {\n\t\t/* 5700 BX chips need to have their TX producer index\n\t\t * mailboxes written twice to workaround a bug.\n\t\t */\n\t\ttg3_flag_set(tp, TXD_MBOX_HWBUG);\n\n\t\t/* If we are in PCI-X mode, enable register write workaround.\n\t\t *\n\t\t * The workaround is to use indirect register accesses\n\t\t * for all chip writes not to mailbox registers.\n\t\t */\n\t\tif (tg3_flag(tp, PCIX_MODE)) {\n\t\t\tu32 pm_reg;\n\n\t\t\ttg3_flag_set(tp, PCIX_TARGET_HWBUG);\n\n\t\t\t/* The chip can have it's power management PCI config\n\t\t\t * space registers clobbered due to this bug.\n\t\t\t * So explicitly force the chip into D0 here.\n\t\t\t */\n\t\t\tpci_read_config_dword(tp->pdev,\n\t\t\t\t\t      tp->pdev->pm_cap + PCI_PM_CTRL,\n\t\t\t\t\t      &pm_reg);\n\t\t\tpm_reg &= ~PCI_PM_CTRL_STATE_MASK;\n\t\t\tpm_reg |= PCI_PM_CTRL_PME_ENABLE | 0 /* D0 */;\n\t\t\tpci_write_config_dword(tp->pdev,\n\t\t\t\t\t       tp->pdev->pm_cap + PCI_PM_CTRL,\n\t\t\t\t\t       pm_reg);\n\n\t\t\t/* Also, force SERR#/PERR# in PCI command. */\n\t\t\tpci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\n\t\t\tpci_cmd |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;\n\t\t\tpci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\n\t\t}\n\t}\n\n\tif ((pci_state_reg & PCISTATE_BUS_SPEED_HIGH) != 0)\n\t\ttg3_flag_set(tp, PCI_HIGH_SPEED);\n\tif ((pci_state_reg & PCISTATE_BUS_32BIT) != 0)\n\t\ttg3_flag_set(tp, PCI_32BIT);\n\n\t/* Chip-specific fixup from Broadcom driver */\n\tif ((tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0) &&\n\t    (!(pci_state_reg & PCISTATE_RETRY_SAME_DMA))) {\n\t\tpci_state_reg |= PCISTATE_RETRY_SAME_DMA;\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, pci_state_reg);\n\t}\n\n\t/* Default fast path register access methods */\n\ttp->read32 = tg3_read32;\n\ttp->write32 = tg3_write32;\n\ttp->read32_mbox = tg3_read32;\n\ttp->write32_mbox = tg3_write32;\n\ttp->write32_tx_mbox = tg3_write32;\n\ttp->write32_rx_mbox = tg3_write32;\n\n\t/* Various workaround register access methods */\n\tif (tg3_flag(tp, PCIX_TARGET_HWBUG))\n\t\ttp->write32 = tg3_write_indirect_reg32;\n\telse if (tg3_asic_rev(tp) == ASIC_REV_5701 ||\n\t\t (tg3_flag(tp, PCI_EXPRESS) &&\n\t\t  tg3_chip_rev_id(tp) == CHIPREV_ID_5750_A0)) {\n\t\t/*\n\t\t * Back to back register writes can cause problems on these\n\t\t * chips, the workaround is to read back all reg writes\n\t\t * except those to mailbox regs.\n\t\t *\n\t\t * See tg3_write_indirect_reg32().\n\t\t */\n\t\ttp->write32 = tg3_write_flush_reg32;\n\t}\n\n\tif (tg3_flag(tp, TXD_MBOX_HWBUG) || tg3_flag(tp, MBOX_WRITE_REORDER)) {\n\t\ttp->write32_tx_mbox = tg3_write32_tx_mbox;\n\t\tif (tg3_flag(tp, MBOX_WRITE_REORDER))\n\t\t\ttp->write32_rx_mbox = tg3_write_flush_reg32;\n\t}\n\n\tif (tg3_flag(tp, ICH_WORKAROUND)) {\n\t\ttp->read32 = tg3_read_indirect_reg32;\n\t\ttp->write32 = tg3_write_indirect_reg32;\n\t\ttp->read32_mbox = tg3_read_indirect_mbox;\n\t\ttp->write32_mbox = tg3_write_indirect_mbox;\n\t\ttp->write32_tx_mbox = tg3_write_indirect_mbox;\n\t\ttp->write32_rx_mbox = tg3_write_indirect_mbox;\n\n\t\tiounmap(tp->regs);\n\t\ttp->regs = NULL;\n\n\t\tpci_read_config_word(tp->pdev, PCI_COMMAND, &pci_cmd);\n\t\tpci_cmd &= ~PCI_COMMAND_MEMORY;\n\t\tpci_write_config_word(tp->pdev, PCI_COMMAND, pci_cmd);\n\t}\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\ttp->read32_mbox = tg3_read32_mbox_5906;\n\t\ttp->write32_mbox = tg3_write32_mbox_5906;\n\t\ttp->write32_tx_mbox = tg3_write32_mbox_5906;\n\t\ttp->write32_rx_mbox = tg3_write32_mbox_5906;\n\t}\n\n\tif (tp->write32 == tg3_write_indirect_reg32 ||\n\t    (tg3_flag(tp, PCIX_MODE) &&\n\t     (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t      tg3_asic_rev(tp) == ASIC_REV_5701)))\n\t\ttg3_flag_set(tp, SRAM_USE_CONFIG);\n\n\t/* The memory arbiter has to be enabled in order for SRAM accesses\n\t * to succeed.  Normally on powerup the tg3 chip firmware will make\n\t * sure it is enabled, but other entities such as system netboot\n\t * code might disable it.\n\t */\n\tval = tr32(MEMARB_MODE);\n\ttw32(MEMARB_MODE, val | MEMARB_MODE_ENABLE);\n\n\ttp->pci_fn = PCI_FUNC(tp->pdev->devfn) & 3;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5704 ||\n\t    tg3_flag(tp, 5780_CLASS)) {\n\t\tif (tg3_flag(tp, PCIX_MODE)) {\n\t\t\tpci_read_config_dword(tp->pdev,\n\t\t\t\t\t      tp->pcix_cap + PCI_X_STATUS,\n\t\t\t\t\t      &val);\n\t\t\ttp->pci_fn = val & 0x7;\n\t\t}\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t\t   tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t\t   tg3_asic_rev(tp) == ASIC_REV_5720) {\n\t\ttg3_read_mem(tp, NIC_SRAM_CPMU_STATUS, &val);\n\t\tif ((val & NIC_SRAM_CPMUSTAT_SIG_MSK) != NIC_SRAM_CPMUSTAT_SIG)\n\t\t\tval = tr32(TG3_CPMU_STATUS);\n\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5717)\n\t\t\ttp->pci_fn = (val & TG3_CPMU_STATUS_FMSK_5717) ? 1 : 0;\n\t\telse\n\t\t\ttp->pci_fn = (val & TG3_CPMU_STATUS_FMSK_5719) >>\n\t\t\t\t     TG3_CPMU_STATUS_FSHFT_5719;\n\t}\n\n\tif (tg3_flag(tp, FLUSH_POSTED_WRITES)) {\n\t\ttp->write32_tx_mbox = tg3_write_flush_reg32;\n\t\ttp->write32_rx_mbox = tg3_write_flush_reg32;\n\t}\n\n\t/* Get eeprom hw config before calling tg3_set_power_state().\n\t * In particular, the TG3_FLAG_IS_NIC flag must be\n\t * determined before calling tg3_set_power_state() so that\n\t * we know whether or not to switch out of Vaux power.\n\t * When the flag is set, it means that GPIO1 is used for eeprom\n\t * write protect and also implies that it is a LOM where GPIOs\n\t * are not used to switch power.\n\t */\n\ttg3_get_eeprom_hw_cfg(tp);\n\n\tif (tg3_flag(tp, FW_TSO) && tg3_flag(tp, ENABLE_ASF)) {\n\t\ttg3_flag_clear(tp, TSO_CAPABLE);\n\t\ttg3_flag_clear(tp, TSO_BUG);\n\t\ttp->fw_needed = NULL;\n\t}\n\n\tif (tg3_flag(tp, ENABLE_APE)) {\n\t\t/* Allow reads and writes to the\n\t\t * APE register and memory space.\n\t\t */\n\t\tpci_state_reg |= PCISTATE_ALLOW_APE_CTLSPC_WR |\n\t\t\t\t PCISTATE_ALLOW_APE_SHMEM_WR |\n\t\t\t\t PCISTATE_ALLOW_APE_PSPACE_WR;\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_PCISTATE,\n\t\t\t\t       pci_state_reg);\n\n\t\ttg3_ape_lock_init(tp);\n\t\ttp->ape_hb_interval =\n\t\t\tmsecs_to_jiffies(APE_HOST_HEARTBEAT_INT_5SEC);\n\t}\n\n\t/* Set up tp->grc_local_ctrl before calling\n\t * tg3_pwrsrc_switch_to_vmain().  GPIO1 driven high\n\t * will bring 5700's external PHY out of reset.\n\t * It is also used as eeprom write protect on LOMs.\n\t */\n\ttp->grc_local_ctrl = GRC_LCLCTRL_INT_ON_ATTN | GRC_LCLCTRL_AUTO_SEEPROM;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    tg3_flag(tp, EEPROM_WRITE_PROT))\n\t\ttp->grc_local_ctrl |= (GRC_LCLCTRL_GPIO_OE1 |\n\t\t\t\t       GRC_LCLCTRL_GPIO_OUTPUT1);\n\t/* Unused GPIO3 must be driven as output on 5752 because there\n\t * are no pull-up resistors on unused GPIO pins.\n\t */\n\telse if (tg3_asic_rev(tp) == ASIC_REV_5752)\n\t\ttp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_OE3;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5755 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57780 ||\n\t    tg3_flag(tp, 57765_CLASS))\n\t\ttp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_UART_SEL;\n\n\tif (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S) {\n\t\t/* Turn off the debug UART. */\n\t\ttp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_UART_SEL;\n\t\tif (tg3_flag(tp, IS_NIC))\n\t\t\t/* Keep VMain power. */\n\t\t\ttp->grc_local_ctrl |= GRC_LCLCTRL_GPIO_OE0 |\n\t\t\t\t\t      GRC_LCLCTRL_GPIO_OUTPUT0;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\ttp->grc_local_ctrl |=\n\t\t\ttr32(GRC_LOCAL_CTRL) & GRC_LCLCTRL_GPIO_UART_SEL;\n\n\t/* Switch out of Vaux if it is a NIC */\n\ttg3_pwrsrc_switch_to_vmain(tp);\n\n\t/* Derive initial jumbo mode from MTU assigned in\n\t * ether_setup() via the alloc_etherdev() call\n\t */\n\tif (tp->dev->mtu > ETH_DATA_LEN && !tg3_flag(tp, 5780_CLASS))\n\t\ttg3_flag_set(tp, JUMBO_RING_ENABLE);\n\n\t/* Determine WakeOnLan speed to use. */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B2) {\n\t\ttg3_flag_clear(tp, WOL_SPEED_100MB);\n\t} else {\n\t\ttg3_flag_set(tp, WOL_SPEED_100MB);\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\ttp->phy_flags |= TG3_PHYFLG_IS_FET;\n\n\t/* A few boards don't want Ethernet@WireSpeed phy feature */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    (tg3_asic_rev(tp) == ASIC_REV_5705 &&\n\t     (tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A0) &&\n\t     (tg3_chip_rev_id(tp) != CHIPREV_ID_5705_A1)) ||\n\t    (tp->phy_flags & TG3_PHYFLG_IS_FET) ||\n\t    (tp->phy_flags & TG3_PHYFLG_ANY_SERDES))\n\t\ttp->phy_flags |= TG3_PHYFLG_NO_ETH_WIRE_SPEED;\n\n\tif (tg3_chip_rev(tp) == CHIPREV_5703_AX ||\n\t    tg3_chip_rev(tp) == CHIPREV_5704_AX)\n\t\ttp->phy_flags |= TG3_PHYFLG_ADC_BUG;\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5704_A0)\n\t\ttp->phy_flags |= TG3_PHYFLG_5704_A0_BUG;\n\n\tif (tg3_flag(tp, 5705_PLUS) &&\n\t    !(tp->phy_flags & TG3_PHYFLG_IS_FET) &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5785 &&\n\t    tg3_asic_rev(tp) != ASIC_REV_57780 &&\n\t    !tg3_flag(tp, 57765_PLUS)) {\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5755 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5787 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5784 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5761) {\n\t\t\tif (tp->pdev->device != PCI_DEVICE_ID_TIGON3_5756 &&\n\t\t\t    tp->pdev->device != PCI_DEVICE_ID_TIGON3_5722)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_JITTER_BUG;\n\t\t\tif (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5755M)\n\t\t\t\ttp->phy_flags |= TG3_PHYFLG_ADJUST_TRIM;\n\t\t} else\n\t\t\ttp->phy_flags |= TG3_PHYFLG_BER_BUG;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5784 &&\n\t    tg3_chip_rev(tp) != CHIPREV_5784_AX) {\n\t\ttp->phy_otp = tg3_read_otp_phycfg(tp);\n\t\tif (tp->phy_otp == 0)\n\t\t\ttp->phy_otp = TG3_OTP_DEFAULT;\n\t}\n\n\tif (tg3_flag(tp, CPMU_PRESENT))\n\t\ttp->mi_mode = MAC_MI_MODE_500KHZ_CONST;\n\telse\n\t\ttp->mi_mode = MAC_MI_MODE_BASE;\n\n\ttp->coalesce_mode = 0;\n\tif (tg3_chip_rev(tp) != CHIPREV_5700_AX &&\n\t    tg3_chip_rev(tp) != CHIPREV_5700_BX)\n\t\ttp->coalesce_mode |= HOSTCC_MODE_32BYTE;\n\n\t/* Set these bits to enable statistics workaround. */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5717 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5719_A0 ||\n\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5720_A0) {\n\t\ttp->coalesce_mode |= HOSTCC_MODE_ATTN;\n\t\ttp->grc_mode |= GRC_MODE_IRQ_ON_FLOW_ATTN;\n\t}\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5785 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_57780)\n\t\ttg3_flag_set(tp, USE_PHYLIB);\n\n\terr = tg3_mdio_init(tp);\n\tif (err)\n\t\treturn err;\n\n\t/* Initialize data/descriptor byte/word swapping. */\n\tval = tr32(GRC_MODE);\n\tif (tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\tval &= (GRC_MODE_BYTE_SWAP_B2HRX_DATA |\n\t\t\tGRC_MODE_WORD_SWAP_B2HRX_DATA |\n\t\t\tGRC_MODE_B2HRX_ENABLE |\n\t\t\tGRC_MODE_HTX2B_ENABLE |\n\t\t\tGRC_MODE_HOST_STACKUP);\n\telse\n\t\tval &= GRC_MODE_HOST_STACKUP;\n\n\ttw32(GRC_MODE, val | tp->grc_mode);\n\n\ttg3_switch_clocks(tp);\n\n\t/* Clear this out for sanity. */\n\ttw32(TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\n\t/* Clear TG3PCI_REG_BASE_ADDR to prevent hangs. */\n\ttw32(TG3PCI_REG_BASE_ADDR, 0);\n\n\tpci_read_config_dword(tp->pdev, TG3PCI_PCISTATE,\n\t\t\t      &pci_state_reg);\n\tif ((pci_state_reg & PCISTATE_CONV_PCI_MODE) == 0 &&\n\t    !tg3_flag(tp, PCIX_TARGET_HWBUG)) {\n\t\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5701_A0 ||\n\t\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B0 ||\n\t\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B2 ||\n\t\t    tg3_chip_rev_id(tp) == CHIPREV_ID_5701_B5) {\n\t\t\tvoid __iomem *sram_base;\n\n\t\t\t/* Write some dummy words into the SRAM status block\n\t\t\t * area, see if it reads back correctly.  If the return\n\t\t\t * value is bad, force enable the PCIX workaround.\n\t\t\t */\n\t\t\tsram_base = tp->regs + NIC_SRAM_WIN_BASE + NIC_SRAM_STATS_BLK;\n\n\t\t\twritel(0x00000000, sram_base);\n\t\t\twritel(0x00000000, sram_base + 4);\n\t\t\twritel(0xffffffff, sram_base + 4);\n\t\t\tif (readl(sram_base) != 0x00000000)\n\t\t\t\ttg3_flag_set(tp, PCIX_TARGET_HWBUG);\n\t\t}\n\t}\n\n\tudelay(50);\n\ttg3_nvram_init(tp);\n\n\t/* If the device has an NVRAM, no need to load patch firmware */\n\tif (tg3_asic_rev(tp) == ASIC_REV_57766 &&\n\t    !tg3_flag(tp, NO_NVRAM))\n\t\ttp->fw_needed = NULL;\n\n\tgrc_misc_cfg = tr32(GRC_MISC_CFG);\n\tgrc_misc_cfg &= GRC_MISC_CFG_BOARD_ID_MASK;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5705 &&\n\t    (grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788 ||\n\t     grc_misc_cfg == GRC_MISC_CFG_BOARD_ID_5788M))\n\t\ttg3_flag_set(tp, IS_5788);\n\n\tif (!tg3_flag(tp, IS_5788) &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5700)\n\t\ttg3_flag_set(tp, TAGGED_STATUS);\n\tif (tg3_flag(tp, TAGGED_STATUS)) {\n\t\ttp->coalesce_mode |= (HOSTCC_MODE_CLRTICK_RXBD |\n\t\t\t\t      HOSTCC_MODE_CLRTICK_TXBD);\n\n\t\ttp->misc_host_ctrl |= MISC_HOST_CTRL_TAGGED_STATUS;\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MISC_HOST_CTRL,\n\t\t\t\t       tp->misc_host_ctrl);\n\t}\n\n\t/* Preserve the APE MAC_MODE bits */\n\tif (tg3_flag(tp, ENABLE_APE))\n\t\ttp->mac_mode = MAC_MODE_APE_TX_EN | MAC_MODE_APE_RX_EN;\n\telse\n\t\ttp->mac_mode = 0;\n\n\tif (tg3_10_100_only_device(tp, ent))\n\t\ttp->phy_flags |= TG3_PHYFLG_10_100_ONLY;\n\n\terr = tg3_phy_probe(tp);\n\tif (err) {\n\t\tdev_err(&tp->pdev->dev, \"phy probe failed, err %d\\n\", err);\n\t\t/* ... but do not return immediately ... */\n\t\ttg3_mdio_fini(tp);\n\t}\n\n\ttg3_read_vpd(tp);\n\ttg3_read_fw_ver(tp);\n\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES) {\n\t\ttp->phy_flags &= ~TG3_PHYFLG_USE_MI_INTERRUPT;\n\t} else {\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5700)\n\t\t\ttp->phy_flags |= TG3_PHYFLG_USE_MI_INTERRUPT;\n\t\telse\n\t\t\ttp->phy_flags &= ~TG3_PHYFLG_USE_MI_INTERRUPT;\n\t}\n\n\t/* 5700 {AX,BX} chips have a broken status block link\n\t * change bit implementation, so we must use the\n\t * status register in those cases.\n\t */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700)\n\t\ttg3_flag_set(tp, USE_LINKCHG_REG);\n\telse\n\t\ttg3_flag_clear(tp, USE_LINKCHG_REG);\n\n\t/* The led_ctrl is set during tg3_phy_probe, here we might\n\t * have to force the link status polling mechanism based\n\t * upon subsystem IDs.\n\t */\n\tif (tp->pdev->subsystem_vendor == PCI_VENDOR_ID_DELL &&\n\t    tg3_asic_rev(tp) == ASIC_REV_5701 &&\n\t    !(tp->phy_flags & TG3_PHYFLG_PHY_SERDES)) {\n\t\ttp->phy_flags |= TG3_PHYFLG_USE_MI_INTERRUPT;\n\t\ttg3_flag_set(tp, USE_LINKCHG_REG);\n\t}\n\n\t/* For all SERDES we poll the MAC status register. */\n\tif (tp->phy_flags & TG3_PHYFLG_PHY_SERDES)\n\t\ttg3_flag_set(tp, POLL_SERDES);\n\telse\n\t\ttg3_flag_clear(tp, POLL_SERDES);\n\n\tif (tg3_flag(tp, ENABLE_APE) && tg3_flag(tp, ENABLE_ASF))\n\t\ttg3_flag_set(tp, POLL_CPMU_LINK);\n\n\ttp->rx_offset = NET_SKB_PAD + NET_IP_ALIGN;\n\ttp->rx_copy_thresh = TG3_RX_COPY_THRESHOLD;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5701 &&\n\t    tg3_flag(tp, PCIX_MODE)) {\n\t\ttp->rx_offset = NET_SKB_PAD;\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\t\ttp->rx_copy_thresh = ~(u16)0;\n#endif\n\t}\n\n\ttp->rx_std_ring_mask = TG3_RX_STD_RING_SIZE(tp) - 1;\n\ttp->rx_jmb_ring_mask = TG3_RX_JMB_RING_SIZE(tp) - 1;\n\ttp->rx_ret_ring_mask = tg3_rx_ret_ring_size(tp) - 1;\n\n\ttp->rx_std_max_post = tp->rx_std_ring_mask + 1;\n\n\t/* Increment the rx prod index on the rx std ring by at most\n\t * 8 for these chips to workaround hw errata.\n\t */\n\tif (tg3_asic_rev(tp) == ASIC_REV_5750 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5752 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5755)\n\t\ttp->rx_std_max_post = 8;\n\n\tif (tg3_flag(tp, ASPM_WORKAROUND))\n\t\ttp->pwrmgmt_thresh = tr32(PCIE_PWR_MGMT_THRESH) &\n\t\t\t\t     PCIE_PWR_MGMT_L1_THRESH_MSK;\n\n\treturn err;\n}\n\nstatic int tg3_get_device_address(struct tg3 *tp)\n{\n\tstruct net_device *dev = tp->dev;\n\tu32 hi, lo, mac_offset;\n\tint addr_ok = 0;\n\tint err;\n\n\tif (!eth_platform_get_mac_address(&tp->pdev->dev, dev->dev_addr))\n\t\treturn 0;\n\n\tif (tg3_flag(tp, IS_SSB_CORE)) {\n\t\terr = ssb_gige_get_macaddr(tp->pdev, &dev->dev_addr[0]);\n\t\tif (!err && is_valid_ether_addr(&dev->dev_addr[0]))\n\t\t\treturn 0;\n\t}\n\n\tmac_offset = 0x7c;\n\tif (tg3_asic_rev(tp) == ASIC_REV_5704 ||\n\t    tg3_flag(tp, 5780_CLASS)) {\n\t\tif (tr32(TG3PCI_DUAL_MAC_CTRL) & DUAL_MAC_CTRL_ID)\n\t\t\tmac_offset = 0xcc;\n\t\tif (tg3_nvram_lock(tp))\n\t\t\ttw32_f(NVRAM_CMD, NVRAM_CMD_RESET);\n\t\telse\n\t\t\ttg3_nvram_unlock(tp);\n\t} else if (tg3_flag(tp, 5717_PLUS)) {\n\t\tif (tp->pci_fn & 1)\n\t\t\tmac_offset = 0xcc;\n\t\tif (tp->pci_fn > 1)\n\t\t\tmac_offset += 0x18c;\n\t} else if (tg3_asic_rev(tp) == ASIC_REV_5906)\n\t\tmac_offset = 0x10;\n\n\t/* First try to get it from MAC address mailbox. */\n\ttg3_read_mem(tp, NIC_SRAM_MAC_ADDR_HIGH_MBOX, &hi);\n\tif ((hi >> 16) == 0x484b) {\n\t\tdev->dev_addr[0] = (hi >>  8) & 0xff;\n\t\tdev->dev_addr[1] = (hi >>  0) & 0xff;\n\n\t\ttg3_read_mem(tp, NIC_SRAM_MAC_ADDR_LOW_MBOX, &lo);\n\t\tdev->dev_addr[2] = (lo >> 24) & 0xff;\n\t\tdev->dev_addr[3] = (lo >> 16) & 0xff;\n\t\tdev->dev_addr[4] = (lo >>  8) & 0xff;\n\t\tdev->dev_addr[5] = (lo >>  0) & 0xff;\n\n\t\t/* Some old bootcode may report a 0 MAC address in SRAM */\n\t\taddr_ok = is_valid_ether_addr(&dev->dev_addr[0]);\n\t}\n\tif (!addr_ok) {\n\t\t/* Next, try NVRAM. */\n\t\tif (!tg3_flag(tp, NO_NVRAM) &&\n\t\t    !tg3_nvram_read_be32(tp, mac_offset + 0, &hi) &&\n\t\t    !tg3_nvram_read_be32(tp, mac_offset + 4, &lo)) {\n\t\t\tmemcpy(&dev->dev_addr[0], ((char *)&hi) + 2, 2);\n\t\t\tmemcpy(&dev->dev_addr[2], (char *)&lo, sizeof(lo));\n\t\t}\n\t\t/* Finally just fetch it out of the MAC control regs. */\n\t\telse {\n\t\t\thi = tr32(MAC_ADDR_0_HIGH);\n\t\t\tlo = tr32(MAC_ADDR_0_LOW);\n\n\t\t\tdev->dev_addr[5] = lo & 0xff;\n\t\t\tdev->dev_addr[4] = (lo >> 8) & 0xff;\n\t\t\tdev->dev_addr[3] = (lo >> 16) & 0xff;\n\t\t\tdev->dev_addr[2] = (lo >> 24) & 0xff;\n\t\t\tdev->dev_addr[1] = hi & 0xff;\n\t\t\tdev->dev_addr[0] = (hi >> 8) & 0xff;\n\t\t}\n\t}\n\n\tif (!is_valid_ether_addr(&dev->dev_addr[0]))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n#define BOUNDARY_SINGLE_CACHELINE\t1\n#define BOUNDARY_MULTI_CACHELINE\t2\n\nstatic u32 tg3_calc_dma_bndry(struct tg3 *tp, u32 val)\n{\n\tint cacheline_size;\n\tu8 byte;\n\tint goal;\n\n\tpci_read_config_byte(tp->pdev, PCI_CACHE_LINE_SIZE, &byte);\n\tif (byte == 0)\n\t\tcacheline_size = 1024;\n\telse\n\t\tcacheline_size = (int) byte * 4;\n\n\t/* On 5703 and later chips, the boundary bits have no\n\t * effect.\n\t */\n\tif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5701 &&\n\t    !tg3_flag(tp, PCI_EXPRESS))\n\t\tgoto out;\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_IA64) || defined(CONFIG_PARISC)\n\tgoal = BOUNDARY_MULTI_CACHELINE;\n#else\n#if defined(CONFIG_SPARC64) || defined(CONFIG_ALPHA)\n\tgoal = BOUNDARY_SINGLE_CACHELINE;\n#else\n\tgoal = 0;\n#endif\n#endif\n\n\tif (tg3_flag(tp, 57765_PLUS)) {\n\t\tval = goal ? 0 : DMA_RWCTRL_DIS_CACHE_ALIGNMENT;\n\t\tgoto out;\n\t}\n\n\tif (!goal)\n\t\tgoto out;\n\n\t/* PCI controllers on most RISC systems tend to disconnect\n\t * when a device tries to burst across a cache-line boundary.\n\t * Therefore, letting tg3 do so just wastes PCI bandwidth.\n\t *\n\t * Unfortunately, for PCI-E there are only limited\n\t * write-side controls for this, and thus for reads\n\t * we will still get the disconnects.  We'll also waste\n\t * these PCI cycles for both read and write for chips\n\t * other than 5700 and 5701 which do not implement the\n\t * boundary bits.\n\t */\n\tif (tg3_flag(tp, PCIX_MODE) && !tg3_flag(tp, PCI_EXPRESS)) {\n\t\tswitch (cacheline_size) {\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\tcase 128:\n\t\t\tif (goal == BOUNDARY_SINGLE_CACHELINE) {\n\t\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_128_PCIX |\n\t\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_128_PCIX);\n\t\t\t} else {\n\t\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_384_PCIX |\n\t\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_384_PCIX);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 256:\n\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_256_PCIX |\n\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_256_PCIX);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_384_PCIX |\n\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_384_PCIX);\n\t\t\tbreak;\n\t\t}\n\t} else if (tg3_flag(tp, PCI_EXPRESS)) {\n\t\tswitch (cacheline_size) {\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tif (goal == BOUNDARY_SINGLE_CACHELINE) {\n\t\t\t\tval &= ~DMA_RWCTRL_WRITE_BNDRY_DISAB_PCIE;\n\t\t\t\tval |= DMA_RWCTRL_WRITE_BNDRY_64_PCIE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 128:\n\t\tdefault:\n\t\t\tval &= ~DMA_RWCTRL_WRITE_BNDRY_DISAB_PCIE;\n\t\t\tval |= DMA_RWCTRL_WRITE_BNDRY_128_PCIE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cacheline_size) {\n\t\tcase 16:\n\t\t\tif (goal == BOUNDARY_SINGLE_CACHELINE) {\n\t\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_16 |\n\t\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 32:\n\t\t\tif (goal == BOUNDARY_SINGLE_CACHELINE) {\n\t\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_32 |\n\t\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 64:\n\t\t\tif (goal == BOUNDARY_SINGLE_CACHELINE) {\n\t\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_64 |\n\t\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_64);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 128:\n\t\t\tif (goal == BOUNDARY_SINGLE_CACHELINE) {\n\t\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_128 |\n\t\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_128);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 256:\n\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_256 |\n\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_256);\n\t\t\tbreak;\n\t\tcase 512:\n\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_512 |\n\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_512);\n\t\t\tbreak;\n\t\tcase 1024:\n\t\tdefault:\n\t\t\tval |= (DMA_RWCTRL_READ_BNDRY_1024 |\n\t\t\t\tDMA_RWCTRL_WRITE_BNDRY_1024);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn val;\n}\n\nstatic int tg3_do_test_dma(struct tg3 *tp, u32 *buf, dma_addr_t buf_dma,\n\t\t\t   int size, bool to_device)\n{\n\tstruct tg3_internal_buffer_desc test_desc;\n\tu32 sram_dma_descs;\n\tint i, ret;\n\n\tsram_dma_descs = NIC_SRAM_DMA_DESC_POOL_BASE;\n\n\ttw32(FTQ_RCVBD_COMP_FIFO_ENQDEQ, 0);\n\ttw32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ, 0);\n\ttw32(RDMAC_STATUS, 0);\n\ttw32(WDMAC_STATUS, 0);\n\n\ttw32(BUFMGR_MODE, 0);\n\ttw32(FTQ_RESET, 0);\n\n\ttest_desc.addr_hi = ((u64) buf_dma) >> 32;\n\ttest_desc.addr_lo = buf_dma & 0xffffffff;\n\ttest_desc.nic_mbuf = 0x00002100;\n\ttest_desc.len = size;\n\n\t/*\n\t * HP ZX1 was seeing test failures for 5701 cards running at 33Mhz\n\t * the *second* time the tg3 driver was getting loaded after an\n\t * initial scan.\n\t *\n\t * Broadcom tells me:\n\t *   ...the DMA engine is connected to the GRC block and a DMA\n\t *   reset may affect the GRC block in some unpredictable way...\n\t *   The behavior of resets to individual blocks has not been tested.\n\t *\n\t * Broadcom noted the GRC reset will also reset all sub-components.\n\t */\n\tif (to_device) {\n\t\ttest_desc.cqid_sqid = (13 << 8) | 2;\n\n\t\ttw32_f(RDMAC_MODE, RDMAC_MODE_ENABLE);\n\t\tudelay(40);\n\t} else {\n\t\ttest_desc.cqid_sqid = (16 << 8) | 7;\n\n\t\ttw32_f(WDMAC_MODE, WDMAC_MODE_ENABLE);\n\t\tudelay(40);\n\t}\n\ttest_desc.flags = 0x00000005;\n\n\tfor (i = 0; i < (sizeof(test_desc) / sizeof(u32)); i++) {\n\t\tu32 val;\n\n\t\tval = *(((u32 *)&test_desc) + i);\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR,\n\t\t\t\t       sram_dma_descs + (i * sizeof(u32)));\n\t\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_DATA, val);\n\t}\n\tpci_write_config_dword(tp->pdev, TG3PCI_MEM_WIN_BASE_ADDR, 0);\n\n\tif (to_device)\n\t\ttw32(FTQ_DMA_HIGH_READ_FIFO_ENQDEQ, sram_dma_descs);\n\telse\n\t\ttw32(FTQ_DMA_HIGH_WRITE_FIFO_ENQDEQ, sram_dma_descs);\n\n\tret = -ENODEV;\n\tfor (i = 0; i < 40; i++) {\n\t\tu32 val;\n\n\t\tif (to_device)\n\t\t\tval = tr32(FTQ_RCVBD_COMP_FIFO_ENQDEQ);\n\t\telse\n\t\t\tval = tr32(FTQ_RCVDATA_COMP_FIFO_ENQDEQ);\n\t\tif ((val & 0xffff) == sram_dma_descs) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(100);\n\t}\n\n\treturn ret;\n}\n\n#define TEST_BUFFER_SIZE\t0x2000\n\nstatic const struct pci_device_id tg3_dma_wait_state_chipsets[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_APPLE, PCI_DEVICE_ID_APPLE_UNI_N_PCI15) },\n\t{ },\n};\n\nstatic int tg3_test_dma(struct tg3 *tp)\n{\n\tdma_addr_t buf_dma;\n\tu32 *buf, saved_dma_rwctrl;\n\tint ret = 0;\n\n\tbuf = dma_alloc_coherent(&tp->pdev->dev, TEST_BUFFER_SIZE,\n\t\t\t\t &buf_dma, GFP_KERNEL);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nofree;\n\t}\n\n\ttp->dma_rwctrl = ((0x7 << DMA_RWCTRL_PCI_WRITE_CMD_SHIFT) |\n\t\t\t  (0x6 << DMA_RWCTRL_PCI_READ_CMD_SHIFT));\n\n\ttp->dma_rwctrl = tg3_calc_dma_bndry(tp, tp->dma_rwctrl);\n\n\tif (tg3_flag(tp, 57765_PLUS))\n\t\tgoto out;\n\n\tif (tg3_flag(tp, PCI_EXPRESS)) {\n\t\t/* DMA read watermark not used on PCIE */\n\t\ttp->dma_rwctrl |= 0x00180000;\n\t} else if (!tg3_flag(tp, PCIX_MODE)) {\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5705 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5750)\n\t\t\ttp->dma_rwctrl |= 0x003f0000;\n\t\telse\n\t\t\ttp->dma_rwctrl |= 0x003f000f;\n\t} else {\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5704) {\n\t\t\tu32 ccval = (tr32(TG3PCI_CLOCK_CTRL) & 0x1f);\n\t\t\tu32 read_water = 0x7;\n\n\t\t\t/* If the 5704 is behind the EPB bridge, we can\n\t\t\t * do the less restrictive ONE_DMA workaround for\n\t\t\t * better performance.\n\t\t\t */\n\t\t\tif (tg3_flag(tp, 40BIT_DMA_BUG) &&\n\t\t\t    tg3_asic_rev(tp) == ASIC_REV_5704)\n\t\t\t\ttp->dma_rwctrl |= 0x8000;\n\t\t\telse if (ccval == 0x6 || ccval == 0x7)\n\t\t\t\ttp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;\n\n\t\t\tif (tg3_asic_rev(tp) == ASIC_REV_5703)\n\t\t\t\tread_water = 4;\n\t\t\t/* Set bit 23 to enable PCIX hw bug fix */\n\t\t\ttp->dma_rwctrl |=\n\t\t\t\t(read_water << DMA_RWCTRL_READ_WATER_SHIFT) |\n\t\t\t\t(0x3 << DMA_RWCTRL_WRITE_WATER_SHIFT) |\n\t\t\t\t(1 << 23);\n\t\t} else if (tg3_asic_rev(tp) == ASIC_REV_5780) {\n\t\t\t/* 5780 always in PCIX mode */\n\t\t\ttp->dma_rwctrl |= 0x00144000;\n\t\t} else if (tg3_asic_rev(tp) == ASIC_REV_5714) {\n\t\t\t/* 5714 always in PCIX mode */\n\t\t\ttp->dma_rwctrl |= 0x00148000;\n\t\t} else {\n\t\t\ttp->dma_rwctrl |= 0x001b000f;\n\t\t}\n\t}\n\tif (tg3_flag(tp, ONE_DMA_AT_ONCE))\n\t\ttp->dma_rwctrl |= DMA_RWCTRL_ONE_DMA;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5703 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5704)\n\t\ttp->dma_rwctrl &= 0xfffffff0;\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5700 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5701) {\n\t\t/* Remove this if it causes problems for some boards. */\n\t\ttp->dma_rwctrl |= DMA_RWCTRL_USE_MEM_READ_MULT;\n\n\t\t/* On 5700/5701 chips, we need to set this bit.\n\t\t * Otherwise the chip will issue cacheline transactions\n\t\t * to streamable DMA memory with not all the byte\n\t\t * enables turned on.  This is an error on several\n\t\t * RISC PCI controllers, in particular sparc64.\n\t\t *\n\t\t * On 5703/5704 chips, this bit has been reassigned\n\t\t * a different meaning.  In particular, it is used\n\t\t * on those chips to enable a PCI-X workaround.\n\t\t */\n\t\ttp->dma_rwctrl |= DMA_RWCTRL_ASSERT_ALL_BE;\n\t}\n\n\ttw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\n\n\n\tif (tg3_asic_rev(tp) != ASIC_REV_5700 &&\n\t    tg3_asic_rev(tp) != ASIC_REV_5701)\n\t\tgoto out;\n\n\t/* It is best to perform DMA test with maximum write burst size\n\t * to expose the 5700/5701 write DMA bug.\n\t */\n\tsaved_dma_rwctrl = tp->dma_rwctrl;\n\ttp->dma_rwctrl &= ~DMA_RWCTRL_WRITE_BNDRY_MASK;\n\ttw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\n\n\twhile (1) {\n\t\tu32 *p = buf, i;\n\n\t\tfor (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++)\n\t\t\tp[i] = i;\n\n\t\t/* Send the buffer to the chip. */\n\t\tret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, true);\n\t\tif (ret) {\n\t\t\tdev_err(&tp->pdev->dev,\n\t\t\t\t\"%s: Buffer write failed. err = %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Now read it back. */\n\t\tret = tg3_do_test_dma(tp, buf, buf_dma, TEST_BUFFER_SIZE, false);\n\t\tif (ret) {\n\t\t\tdev_err(&tp->pdev->dev, \"%s: Buffer read failed. \"\n\t\t\t\t\"err = %d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Verify it. */\n\t\tfor (i = 0; i < TEST_BUFFER_SIZE / sizeof(u32); i++) {\n\t\t\tif (p[i] == i)\n\t\t\t\tcontinue;\n\n\t\t\tif ((tp->dma_rwctrl & DMA_RWCTRL_WRITE_BNDRY_MASK) !=\n\t\t\t    DMA_RWCTRL_WRITE_BNDRY_16) {\n\t\t\t\ttp->dma_rwctrl &= ~DMA_RWCTRL_WRITE_BNDRY_MASK;\n\t\t\t\ttp->dma_rwctrl |= DMA_RWCTRL_WRITE_BNDRY_16;\n\t\t\t\ttw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdev_err(&tp->pdev->dev,\n\t\t\t\t\t\"%s: Buffer corrupted on read back! \"\n\t\t\t\t\t\"(%d != %d)\\n\", __func__, p[i], i);\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (i == (TEST_BUFFER_SIZE / sizeof(u32))) {\n\t\t\t/* Success. */\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((tp->dma_rwctrl & DMA_RWCTRL_WRITE_BNDRY_MASK) !=\n\t    DMA_RWCTRL_WRITE_BNDRY_16) {\n\t\t/* DMA test passed without adjusting DMA boundary,\n\t\t * now look for chipsets that are known to expose the\n\t\t * DMA bug without failing the test.\n\t\t */\n\t\tif (pci_dev_present(tg3_dma_wait_state_chipsets)) {\n\t\t\ttp->dma_rwctrl &= ~DMA_RWCTRL_WRITE_BNDRY_MASK;\n\t\t\ttp->dma_rwctrl |= DMA_RWCTRL_WRITE_BNDRY_16;\n\t\t} else {\n\t\t\t/* Safe to use the calculated DMA boundary. */\n\t\t\ttp->dma_rwctrl = saved_dma_rwctrl;\n\t\t}\n\n\t\ttw32(TG3PCI_DMA_RW_CTRL, tp->dma_rwctrl);\n\t}\n\nout:\n\tdma_free_coherent(&tp->pdev->dev, TEST_BUFFER_SIZE, buf, buf_dma);\nout_nofree:\n\treturn ret;\n}\n\nstatic void tg3_init_bufmgr_config(struct tg3 *tp)\n{\n\tif (tg3_flag(tp, 57765_PLUS)) {\n\t\ttp->bufmgr_config.mbuf_read_dma_low_water =\n\t\t\tDEFAULT_MB_RDMA_LOW_WATER_5705;\n\t\ttp->bufmgr_config.mbuf_mac_rx_low_water =\n\t\t\tDEFAULT_MB_MACRX_LOW_WATER_57765;\n\t\ttp->bufmgr_config.mbuf_high_water =\n\t\t\tDEFAULT_MB_HIGH_WATER_57765;\n\n\t\ttp->bufmgr_config.mbuf_read_dma_low_water_jumbo =\n\t\t\tDEFAULT_MB_RDMA_LOW_WATER_5705;\n\t\ttp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =\n\t\t\tDEFAULT_MB_MACRX_LOW_WATER_JUMBO_57765;\n\t\ttp->bufmgr_config.mbuf_high_water_jumbo =\n\t\t\tDEFAULT_MB_HIGH_WATER_JUMBO_57765;\n\t} else if (tg3_flag(tp, 5705_PLUS)) {\n\t\ttp->bufmgr_config.mbuf_read_dma_low_water =\n\t\t\tDEFAULT_MB_RDMA_LOW_WATER_5705;\n\t\ttp->bufmgr_config.mbuf_mac_rx_low_water =\n\t\t\tDEFAULT_MB_MACRX_LOW_WATER_5705;\n\t\ttp->bufmgr_config.mbuf_high_water =\n\t\t\tDEFAULT_MB_HIGH_WATER_5705;\n\t\tif (tg3_asic_rev(tp) == ASIC_REV_5906) {\n\t\t\ttp->bufmgr_config.mbuf_mac_rx_low_water =\n\t\t\t\tDEFAULT_MB_MACRX_LOW_WATER_5906;\n\t\t\ttp->bufmgr_config.mbuf_high_water =\n\t\t\t\tDEFAULT_MB_HIGH_WATER_5906;\n\t\t}\n\n\t\ttp->bufmgr_config.mbuf_read_dma_low_water_jumbo =\n\t\t\tDEFAULT_MB_RDMA_LOW_WATER_JUMBO_5780;\n\t\ttp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =\n\t\t\tDEFAULT_MB_MACRX_LOW_WATER_JUMBO_5780;\n\t\ttp->bufmgr_config.mbuf_high_water_jumbo =\n\t\t\tDEFAULT_MB_HIGH_WATER_JUMBO_5780;\n\t} else {\n\t\ttp->bufmgr_config.mbuf_read_dma_low_water =\n\t\t\tDEFAULT_MB_RDMA_LOW_WATER;\n\t\ttp->bufmgr_config.mbuf_mac_rx_low_water =\n\t\t\tDEFAULT_MB_MACRX_LOW_WATER;\n\t\ttp->bufmgr_config.mbuf_high_water =\n\t\t\tDEFAULT_MB_HIGH_WATER;\n\n\t\ttp->bufmgr_config.mbuf_read_dma_low_water_jumbo =\n\t\t\tDEFAULT_MB_RDMA_LOW_WATER_JUMBO;\n\t\ttp->bufmgr_config.mbuf_mac_rx_low_water_jumbo =\n\t\t\tDEFAULT_MB_MACRX_LOW_WATER_JUMBO;\n\t\ttp->bufmgr_config.mbuf_high_water_jumbo =\n\t\t\tDEFAULT_MB_HIGH_WATER_JUMBO;\n\t}\n\n\ttp->bufmgr_config.dma_low_water = DEFAULT_DMA_LOW_WATER;\n\ttp->bufmgr_config.dma_high_water = DEFAULT_DMA_HIGH_WATER;\n}\n\nstatic char *tg3_phy_string(struct tg3 *tp)\n{\n\tswitch (tp->phy_id & TG3_PHY_ID_MASK) {\n\tcase TG3_PHY_ID_BCM5400:\treturn \"5400\";\n\tcase TG3_PHY_ID_BCM5401:\treturn \"5401\";\n\tcase TG3_PHY_ID_BCM5411:\treturn \"5411\";\n\tcase TG3_PHY_ID_BCM5701:\treturn \"5701\";\n\tcase TG3_PHY_ID_BCM5703:\treturn \"5703\";\n\tcase TG3_PHY_ID_BCM5704:\treturn \"5704\";\n\tcase TG3_PHY_ID_BCM5705:\treturn \"5705\";\n\tcase TG3_PHY_ID_BCM5750:\treturn \"5750\";\n\tcase TG3_PHY_ID_BCM5752:\treturn \"5752\";\n\tcase TG3_PHY_ID_BCM5714:\treturn \"5714\";\n\tcase TG3_PHY_ID_BCM5780:\treturn \"5780\";\n\tcase TG3_PHY_ID_BCM5755:\treturn \"5755\";\n\tcase TG3_PHY_ID_BCM5787:\treturn \"5787\";\n\tcase TG3_PHY_ID_BCM5784:\treturn \"5784\";\n\tcase TG3_PHY_ID_BCM5756:\treturn \"5722/5756\";\n\tcase TG3_PHY_ID_BCM5906:\treturn \"5906\";\n\tcase TG3_PHY_ID_BCM5761:\treturn \"5761\";\n\tcase TG3_PHY_ID_BCM5718C:\treturn \"5718C\";\n\tcase TG3_PHY_ID_BCM5718S:\treturn \"5718S\";\n\tcase TG3_PHY_ID_BCM57765:\treturn \"57765\";\n\tcase TG3_PHY_ID_BCM5719C:\treturn \"5719C\";\n\tcase TG3_PHY_ID_BCM5720C:\treturn \"5720C\";\n\tcase TG3_PHY_ID_BCM5762:\treturn \"5762C\";\n\tcase TG3_PHY_ID_BCM8002:\treturn \"8002/serdes\";\n\tcase 0:\t\t\treturn \"serdes\";\n\tdefault:\t\treturn \"unknown\";\n\t}\n}\n\nstatic char *tg3_bus_string(struct tg3 *tp, char *str)\n{\n\tif (tg3_flag(tp, PCI_EXPRESS)) {\n\t\tstrcpy(str, \"PCI Express\");\n\t\treturn str;\n\t} else if (tg3_flag(tp, PCIX_MODE)) {\n\t\tu32 clock_ctrl = tr32(TG3PCI_CLOCK_CTRL) & 0x1f;\n\n\t\tstrcpy(str, \"PCIX:\");\n\n\t\tif ((clock_ctrl == 7) ||\n\t\t    ((tr32(GRC_MISC_CFG) & GRC_MISC_CFG_BOARD_ID_MASK) ==\n\t\t     GRC_MISC_CFG_BOARD_ID_5704CIOBE))\n\t\t\tstrcat(str, \"133MHz\");\n\t\telse if (clock_ctrl == 0)\n\t\t\tstrcat(str, \"33MHz\");\n\t\telse if (clock_ctrl == 2)\n\t\t\tstrcat(str, \"50MHz\");\n\t\telse if (clock_ctrl == 4)\n\t\t\tstrcat(str, \"66MHz\");\n\t\telse if (clock_ctrl == 6)\n\t\t\tstrcat(str, \"100MHz\");\n\t} else {\n\t\tstrcpy(str, \"PCI:\");\n\t\tif (tg3_flag(tp, PCI_HIGH_SPEED))\n\t\t\tstrcat(str, \"66MHz\");\n\t\telse\n\t\t\tstrcat(str, \"33MHz\");\n\t}\n\tif (tg3_flag(tp, PCI_32BIT))\n\t\tstrcat(str, \":32-bit\");\n\telse\n\t\tstrcat(str, \":64-bit\");\n\treturn str;\n}\n\nstatic void tg3_init_coal(struct tg3 *tp)\n{\n\tstruct ethtool_coalesce *ec = &tp->coal;\n\n\tmemset(ec, 0, sizeof(*ec));\n\tec->cmd = ETHTOOL_GCOALESCE;\n\tec->rx_coalesce_usecs = LOW_RXCOL_TICKS;\n\tec->tx_coalesce_usecs = LOW_TXCOL_TICKS;\n\tec->rx_max_coalesced_frames = LOW_RXMAX_FRAMES;\n\tec->tx_max_coalesced_frames = LOW_TXMAX_FRAMES;\n\tec->rx_coalesce_usecs_irq = DEFAULT_RXCOAL_TICK_INT;\n\tec->tx_coalesce_usecs_irq = DEFAULT_TXCOAL_TICK_INT;\n\tec->rx_max_coalesced_frames_irq = DEFAULT_RXCOAL_MAXF_INT;\n\tec->tx_max_coalesced_frames_irq = DEFAULT_TXCOAL_MAXF_INT;\n\tec->stats_block_coalesce_usecs = DEFAULT_STAT_COAL_TICKS;\n\n\tif (tp->coalesce_mode & (HOSTCC_MODE_CLRTICK_RXBD |\n\t\t\t\t HOSTCC_MODE_CLRTICK_TXBD)) {\n\t\tec->rx_coalesce_usecs = LOW_RXCOL_TICKS_CLRTCKS;\n\t\tec->rx_coalesce_usecs_irq = DEFAULT_RXCOAL_TICK_INT_CLRTCKS;\n\t\tec->tx_coalesce_usecs = LOW_TXCOL_TICKS_CLRTCKS;\n\t\tec->tx_coalesce_usecs_irq = DEFAULT_TXCOAL_TICK_INT_CLRTCKS;\n\t}\n\n\tif (tg3_flag(tp, 5705_PLUS)) {\n\t\tec->rx_coalesce_usecs_irq = 0;\n\t\tec->tx_coalesce_usecs_irq = 0;\n\t\tec->stats_block_coalesce_usecs = 0;\n\t}\n}\n\nstatic int tg3_init_one(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct tg3 *tp;\n\tint i, err;\n\tu32 sndmbx, rcvmbx, intmbx;\n\tchar str[40];\n\tu64 dma_mask, persist_dma_mask;\n\tnetdev_features_t features = 0;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device, aborting\\n\");\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_MODULE_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, aborting\\n\");\n\t\tgoto err_out_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\tdev = alloc_etherdev_mq(sizeof(*tp), TG3_IRQ_MAX_VECS);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_res;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\ttp = netdev_priv(dev);\n\ttp->pdev = pdev;\n\ttp->dev = dev;\n\ttp->rx_mode = TG3_DEF_RX_MODE;\n\ttp->tx_mode = TG3_DEF_TX_MODE;\n\ttp->irq_sync = 1;\n\ttp->pcierr_recovery = false;\n\n\tif (tg3_debug > 0)\n\t\ttp->msg_enable = tg3_debug;\n\telse\n\t\ttp->msg_enable = TG3_DEF_MSG_ENABLE;\n\n\tif (pdev_is_ssb_gige_core(pdev)) {\n\t\ttg3_flag_set(tp, IS_SSB_CORE);\n\t\tif (ssb_gige_must_flush_posted_writes(pdev))\n\t\t\ttg3_flag_set(tp, FLUSH_POSTED_WRITES);\n\t\tif (ssb_gige_one_dma_at_once(pdev))\n\t\t\ttg3_flag_set(tp, ONE_DMA_AT_ONCE);\n\t\tif (ssb_gige_have_roboswitch(pdev)) {\n\t\t\ttg3_flag_set(tp, USE_PHYLIB);\n\t\t\ttg3_flag_set(tp, ROBOSWITCH);\n\t\t}\n\t\tif (ssb_gige_is_rgmii(pdev))\n\t\t\ttg3_flag_set(tp, RGMII_MODE);\n\t}\n\n\t/* The word/byte swap controls here control register access byte\n\t * swapping.  DMA data byte swapping is controlled in the GRC_MODE\n\t * setting below.\n\t */\n\ttp->misc_host_ctrl =\n\t\tMISC_HOST_CTRL_MASK_PCI_INT |\n\t\tMISC_HOST_CTRL_WORD_SWAP |\n\t\tMISC_HOST_CTRL_INDIR_ACCESS |\n\t\tMISC_HOST_CTRL_PCISTATE_RW;\n\n\t/* The NONFRM (non-frame) byte/word swap controls take effect\n\t * on descriptor entries, anything which isn't packet data.\n\t *\n\t * The StrongARM chips on the board (one for tx, one for rx)\n\t * are running in big-endian mode.\n\t */\n\ttp->grc_mode = (GRC_MODE_WSWAP_DATA | GRC_MODE_BSWAP_DATA |\n\t\t\tGRC_MODE_WSWAP_NONFRM_DATA);\n#ifdef __BIG_ENDIAN\n\ttp->grc_mode |= GRC_MODE_BSWAP_NONFRM_DATA;\n#endif\n\tspin_lock_init(&tp->lock);\n\tspin_lock_init(&tp->indirect_lock);\n\tINIT_WORK(&tp->reset_task, tg3_reset_task);\n\n\ttp->regs = pci_ioremap_bar(pdev, BAR_0);\n\tif (!tp->regs) {\n\t\tdev_err(&pdev->dev, \"Cannot map device registers, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\n\tif (tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761 ||\n\t    tp->pdev->device == PCI_DEVICE_ID_TIGON3_5761E ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761S ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5761SE ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5719 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5720 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_57767 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_57764 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5762 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5725 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_5727 ||\n\t    tp->pdev->device == TG3PCI_DEVICE_TIGON3_57787) {\n\t\ttg3_flag_set(tp, ENABLE_APE);\n\t\ttp->aperegs = pci_ioremap_bar(pdev, BAR_2);\n\t\tif (!tp->aperegs) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Cannot map APE registers, aborting\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_iounmap;\n\t\t}\n\t}\n\n\ttp->rx_pending = TG3_DEF_RX_RING_PENDING;\n\ttp->rx_jumbo_pending = TG3_DEF_RX_JUMBO_RING_PENDING;\n\n\tdev->ethtool_ops = &tg3_ethtool_ops;\n\tdev->watchdog_timeo = TG3_TX_TIMEOUT;\n\tdev->netdev_ops = &tg3_netdev_ops;\n\tdev->irq = pdev->irq;\n\n\terr = tg3_get_invariants(tp, ent);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Problem fetching invariants of chip, aborting\\n\");\n\t\tgoto err_out_apeunmap;\n\t}\n\n\t/* The EPB bridge inside 5714, 5715, and 5780 and any\n\t * device behind the EPB cannot support DMA addresses > 40-bit.\n\t * On 64-bit systems with IOMMU, use 40-bit dma_mask.\n\t * On 64-bit systems without IOMMU, use 64-bit dma_mask and\n\t * do DMA address check in tg3_start_xmit().\n\t */\n\tif (tg3_flag(tp, IS_5788))\n\t\tpersist_dma_mask = dma_mask = DMA_BIT_MASK(32);\n\telse if (tg3_flag(tp, 40BIT_DMA_BUG)) {\n\t\tpersist_dma_mask = dma_mask = DMA_BIT_MASK(40);\n#ifdef CONFIG_HIGHMEM\n\t\tdma_mask = DMA_BIT_MASK(64);\n#endif\n\t} else\n\t\tpersist_dma_mask = dma_mask = DMA_BIT_MASK(64);\n\n\t/* Configure DMA attributes. */\n\tif (dma_mask > DMA_BIT_MASK(32)) {\n\t\terr = pci_set_dma_mask(pdev, dma_mask);\n\t\tif (!err) {\n\t\t\tfeatures |= NETIF_F_HIGHDMA;\n\t\t\terr = pci_set_consistent_dma_mask(pdev,\n\t\t\t\t\t\t\t  persist_dma_mask);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Unable to obtain 64 bit \"\n\t\t\t\t\t\"DMA for consistent allocations\\n\");\n\t\t\t\tgoto err_out_apeunmap;\n\t\t\t}\n\t\t}\n\t}\n\tif (err || dma_mask == DMA_BIT_MASK(32)) {\n\t\terr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"No usable DMA configuration, aborting\\n\");\n\t\t\tgoto err_out_apeunmap;\n\t\t}\n\t}\n\n\ttg3_init_bufmgr_config(tp);\n\n\t/* 5700 B0 chips do not support checksumming correctly due\n\t * to hardware bugs.\n\t */\n\tif (tg3_chip_rev_id(tp) != CHIPREV_ID_5700_B0) {\n\t\tfeatures |= NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\n\n\t\tif (tg3_flag(tp, 5755_PLUS))\n\t\t\tfeatures |= NETIF_F_IPV6_CSUM;\n\t}\n\n\t/* TSO is on by default on chips that support hardware TSO.\n\t * Firmware TSO on older chips gives lower performance, so it\n\t * is off by default, but can be enabled using ethtool.\n\t */\n\tif ((tg3_flag(tp, HW_TSO_1) ||\n\t     tg3_flag(tp, HW_TSO_2) ||\n\t     tg3_flag(tp, HW_TSO_3)) &&\n\t    (features & NETIF_F_IP_CSUM))\n\t\tfeatures |= NETIF_F_TSO;\n\tif (tg3_flag(tp, HW_TSO_2) || tg3_flag(tp, HW_TSO_3)) {\n\t\tif (features & NETIF_F_IPV6_CSUM)\n\t\t\tfeatures |= NETIF_F_TSO6;\n\t\tif (tg3_flag(tp, HW_TSO_3) ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5761 ||\n\t\t    (tg3_asic_rev(tp) == ASIC_REV_5784 &&\n\t\t     tg3_chip_rev(tp) != CHIPREV_5784_AX) ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_5785 ||\n\t\t    tg3_asic_rev(tp) == ASIC_REV_57780)\n\t\t\tfeatures |= NETIF_F_TSO_ECN;\n\t}\n\n\tdev->features |= features | NETIF_F_HW_VLAN_CTAG_TX |\n\t\t\t NETIF_F_HW_VLAN_CTAG_RX;\n\tdev->vlan_features |= features;\n\n\t/*\n\t * Add loopback capability only for a subset of devices that support\n\t * MAC-LOOPBACK. Eventually this need to be enhanced to allow INT-PHY\n\t * loopback for the remaining devices.\n\t */\n\tif (tg3_asic_rev(tp) != ASIC_REV_5780 &&\n\t    !tg3_flag(tp, CPMU_PRESENT))\n\t\t/* Add the loopback capability */\n\t\tfeatures |= NETIF_F_LOOPBACK;\n\n\tdev->hw_features |= features;\n\tdev->priv_flags |= IFF_UNICAST_FLT;\n\n\t/* MTU range: 60 - 9000 or 1500, depending on hardware */\n\tdev->min_mtu = TG3_MIN_MTU;\n\tdev->max_mtu = TG3_MAX_MTU(tp);\n\n\tif (tg3_chip_rev_id(tp) == CHIPREV_ID_5705_A1 &&\n\t    !tg3_flag(tp, TSO_CAPABLE) &&\n\t    !(tr32(TG3PCI_PCISTATE) & PCISTATE_BUS_SPEED_HIGH)) {\n\t\ttg3_flag_set(tp, MAX_RXPEND_64);\n\t\ttp->rx_pending = 63;\n\t}\n\n\terr = tg3_get_device_address(tp);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Could not obtain valid ethernet address, aborting\\n\");\n\t\tgoto err_out_apeunmap;\n\t}\n\n\tintmbx = MAILBOX_INTERRUPT_0 + TG3_64BIT_REG_LOW;\n\trcvmbx = MAILBOX_RCVRET_CON_IDX_0 + TG3_64BIT_REG_LOW;\n\tsndmbx = MAILBOX_SNDHOST_PROD_IDX_0 + TG3_64BIT_REG_LOW;\n\tfor (i = 0; i < tp->irq_max; i++) {\n\t\tstruct tg3_napi *tnapi = &tp->napi[i];\n\n\t\ttnapi->tp = tp;\n\t\ttnapi->tx_pending = TG3_DEF_TX_RING_PENDING;\n\n\t\ttnapi->int_mbox = intmbx;\n\t\tif (i <= 4)\n\t\t\tintmbx += 0x8;\n\t\telse\n\t\t\tintmbx += 0x4;\n\n\t\ttnapi->consmbox = rcvmbx;\n\t\ttnapi->prodmbox = sndmbx;\n\n\t\tif (i)\n\t\t\ttnapi->coal_now = HOSTCC_MODE_COAL_VEC1_NOW << (i - 1);\n\t\telse\n\t\t\ttnapi->coal_now = HOSTCC_MODE_NOW;\n\n\t\tif (!tg3_flag(tp, SUPPORT_MSIX))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we support MSIX, we'll be using RSS.  If we're using\n\t\t * RSS, the first vector only handles link interrupts and the\n\t\t * remaining vectors handle rx and tx interrupts.  Reuse the\n\t\t * mailbox values for the next iteration.  The values we setup\n\t\t * above are still useful for the single vectored mode.\n\t\t */\n\t\tif (!i)\n\t\t\tcontinue;\n\n\t\trcvmbx += 0x8;\n\n\t\tif (sndmbx & 0x4)\n\t\t\tsndmbx -= 0x4;\n\t\telse\n\t\t\tsndmbx += 0xc;\n\t}\n\n\t/*\n\t * Reset chip in case UNDI or EFI driver did not shutdown\n\t * DMA self test will enable WDMAC and we'll see (spurious)\n\t * pending DMA on the PCI bus at that point.\n\t */\n\tif ((tr32(HOSTCC_MODE) & HOSTCC_MODE_ENABLE) ||\n\t    (tr32(WDMAC_MODE) & WDMAC_MODE_ENABLE)) {\n\t\ttg3_full_lock(tp, 0);\n\t\ttw32(MEMARB_MODE, MEMARB_MODE_ENABLE);\n\t\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\t\ttg3_full_unlock(tp);\n\t}\n\n\terr = tg3_test_dma(tp);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"DMA engine test failed, aborting\\n\");\n\t\tgoto err_out_apeunmap;\n\t}\n\n\ttg3_init_coal(tp);\n\n\tpci_set_drvdata(pdev, dev);\n\n\tif (tg3_asic_rev(tp) == ASIC_REV_5719 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5720 ||\n\t    tg3_asic_rev(tp) == ASIC_REV_5762)\n\t\ttg3_flag_set(tp, PTP_CAPABLE);\n\n\ttg3_timer_init(tp);\n\n\ttg3_carrier_off(tp);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device, aborting\\n\");\n\t\tgoto err_out_apeunmap;\n\t}\n\n\tif (tg3_flag(tp, PTP_CAPABLE)) {\n\t\ttg3_ptp_init(tp);\n\t\ttp->ptp_clock = ptp_clock_register(&tp->ptp_info,\n\t\t\t\t\t\t   &tp->pdev->dev);\n\t\tif (IS_ERR(tp->ptp_clock))\n\t\t\ttp->ptp_clock = NULL;\n\t}\n\n\tnetdev_info(dev, \"Tigon3 [partno(%s) rev %04x] (%s) MAC address %pM\\n\",\n\t\t    tp->board_part_number,\n\t\t    tg3_chip_rev_id(tp),\n\t\t    tg3_bus_string(tp, str),\n\t\t    dev->dev_addr);\n\n\tif (!(tp->phy_flags & TG3_PHYFLG_IS_CONNECTED)) {\n\t\tchar *ethtype;\n\n\t\tif (tp->phy_flags & TG3_PHYFLG_10_100_ONLY)\n\t\t\tethtype = \"10/100Base-TX\";\n\t\telse if (tp->phy_flags & TG3_PHYFLG_ANY_SERDES)\n\t\t\tethtype = \"1000Base-SX\";\n\t\telse\n\t\t\tethtype = \"10/100/1000Base-T\";\n\n\t\tnetdev_info(dev, \"attached PHY is %s (%s Ethernet) \"\n\t\t\t    \"(WireSpeed[%d], EEE[%d])\\n\",\n\t\t\t    tg3_phy_string(tp), ethtype,\n\t\t\t    (tp->phy_flags & TG3_PHYFLG_NO_ETH_WIRE_SPEED) == 0,\n\t\t\t    (tp->phy_flags & TG3_PHYFLG_EEE_CAP) != 0);\n\t}\n\n\tnetdev_info(dev, \"RXcsums[%d] LinkChgREG[%d] MIirq[%d] ASF[%d] TSOcap[%d]\\n\",\n\t\t    (dev->features & NETIF_F_RXCSUM) != 0,\n\t\t    tg3_flag(tp, USE_LINKCHG_REG) != 0,\n\t\t    (tp->phy_flags & TG3_PHYFLG_USE_MI_INTERRUPT) != 0,\n\t\t    tg3_flag(tp, ENABLE_ASF) != 0,\n\t\t    tg3_flag(tp, TSO_CAPABLE) != 0);\n\tnetdev_info(dev, \"dma_rwctrl[%08x] dma_mask[%d-bit]\\n\",\n\t\t    tp->dma_rwctrl,\n\t\t    pdev->dma_mask == DMA_BIT_MASK(32) ? 32 :\n\t\t    ((u64)pdev->dma_mask) == DMA_BIT_MASK(40) ? 40 : 64);\n\n\tpci_save_state(pdev);\n\n\treturn 0;\n\nerr_out_apeunmap:\n\tif (tp->aperegs) {\n\t\tiounmap(tp->aperegs);\n\t\ttp->aperegs = NULL;\n\t}\n\nerr_out_iounmap:\n\tif (tp->regs) {\n\t\tiounmap(tp->regs);\n\t\ttp->regs = NULL;\n\t}\n\nerr_out_free_dev:\n\tfree_netdev(dev);\n\nerr_out_free_res:\n\tpci_release_regions(pdev);\n\nerr_out_disable_pdev:\n\tif (pci_is_enabled(pdev))\n\t\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic void tg3_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tstruct tg3 *tp = netdev_priv(dev);\n\n\t\ttg3_ptp_fini(tp);\n\n\t\trelease_firmware(tp->fw);\n\n\t\ttg3_reset_task_cancel(tp);\n\n\t\tif (tg3_flag(tp, USE_PHYLIB)) {\n\t\t\ttg3_phy_fini(tp);\n\t\t\ttg3_mdio_fini(tp);\n\t\t}\n\n\t\tunregister_netdev(dev);\n\t\tif (tp->aperegs) {\n\t\t\tiounmap(tp->aperegs);\n\t\t\ttp->aperegs = NULL;\n\t\t}\n\t\tif (tp->regs) {\n\t\t\tiounmap(tp->regs);\n\t\t\ttp->regs = NULL;\n\t\t}\n\t\tfree_netdev(dev);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tg3_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err = 0;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto unlock;\n\n\ttg3_reset_task_cancel(tp);\n\ttg3_phy_stop(tp);\n\ttg3_netif_stop(tp);\n\n\ttg3_timer_stop(tp);\n\n\ttg3_full_lock(tp, 1);\n\ttg3_disable_ints(tp);\n\ttg3_full_unlock(tp);\n\n\tnetif_device_detach(dev);\n\n\ttg3_full_lock(tp, 0);\n\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 1);\n\ttg3_flag_clear(tp, INIT_COMPLETE);\n\ttg3_full_unlock(tp);\n\n\terr = tg3_power_down_prepare(tp);\n\tif (err) {\n\t\tint err2;\n\n\t\ttg3_full_lock(tp, 0);\n\n\t\ttg3_flag_set(tp, INIT_COMPLETE);\n\t\terr2 = tg3_restart_hw(tp, true);\n\t\tif (err2)\n\t\t\tgoto out;\n\n\t\ttg3_timer_start(tp);\n\n\t\tnetif_device_attach(dev);\n\t\ttg3_netif_start(tp);\n\nout:\n\t\ttg3_full_unlock(tp);\n\n\t\tif (!err2)\n\t\t\ttg3_phy_start(tp);\n\t}\n\nunlock:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int tg3_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct tg3 *tp = netdev_priv(dev);\n\tint err = 0;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto unlock;\n\n\tnetif_device_attach(dev);\n\n\ttg3_full_lock(tp, 0);\n\n\ttg3_ape_driver_state_change(tp, RESET_KIND_INIT);\n\n\ttg3_flag_set(tp, INIT_COMPLETE);\n\terr = tg3_restart_hw(tp,\n\t\t\t     !(tp->phy_flags & TG3_PHYFLG_KEEP_LINK_ON_PWRDN));\n\tif (err)\n\t\tgoto out;\n\n\ttg3_timer_start(tp);\n\n\ttg3_netif_start(tp);\n\nout:\n\ttg3_full_unlock(tp);\n\n\tif (!err)\n\t\ttg3_phy_start(tp);\n\nunlock:\n\trtnl_unlock();\n\treturn err;\n}\n#endif /* CONFIG_PM_SLEEP */\n\nstatic SIMPLE_DEV_PM_OPS(tg3_pm_ops, tg3_suspend, tg3_resume);\n\nstatic void tg3_shutdown(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct tg3 *tp = netdev_priv(dev);\n\n\trtnl_lock();\n\tnetif_device_detach(dev);\n\n\tif (netif_running(dev))\n\t\tdev_close(dev);\n\n\tif (system_state == SYSTEM_POWER_OFF)\n\t\ttg3_power_down(tp);\n\n\trtnl_unlock();\n}\n\n/**\n * tg3_io_error_detected - called when PCI error is detected\n * @pdev: Pointer to PCI device\n * @state: The current pci connection state\n *\n * This function is called after a PCI bus error affecting\n * this device has been detected.\n */\nstatic pci_ers_result_t tg3_io_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t      pci_channel_state_t state)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct tg3 *tp = netdev_priv(netdev);\n\tpci_ers_result_t err = PCI_ERS_RESULT_NEED_RESET;\n\n\tnetdev_info(netdev, \"PCI I/O error detected\\n\");\n\n\trtnl_lock();\n\n\t/* Could be second call or maybe we don't have netdev yet */\n\tif (!netdev || tp->pcierr_recovery || !netif_running(netdev))\n\t\tgoto done;\n\n\t/* We needn't recover from permanent error */\n\tif (state == pci_channel_io_frozen)\n\t\ttp->pcierr_recovery = true;\n\n\ttg3_phy_stop(tp);\n\n\ttg3_netif_stop(tp);\n\n\ttg3_timer_stop(tp);\n\n\t/* Want to make sure that the reset task doesn't run */\n\ttg3_reset_task_cancel(tp);\n\n\tnetif_device_detach(netdev);\n\n\t/* Clean up software state, even if MMIO is blocked */\n\ttg3_full_lock(tp, 0);\n\ttg3_halt(tp, RESET_KIND_SHUTDOWN, 0);\n\ttg3_full_unlock(tp);\n\ndone:\n\tif (state == pci_channel_io_perm_failure) {\n\t\tif (netdev) {\n\t\t\ttg3_napi_enable(tp);\n\t\t\tdev_close(netdev);\n\t\t}\n\t\terr = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpci_disable_device(pdev);\n\t}\n\n\trtnl_unlock();\n\n\treturn err;\n}\n\n/**\n * tg3_io_slot_reset - called after the pci bus has been reset.\n * @pdev: Pointer to PCI device\n *\n * Restart the card from scratch, as if from a cold-boot.\n * At this point, the card has exprienced a hard reset,\n * followed by fixups by BIOS, and has its config space\n * set up identically to what it was at cold boot.\n */\nstatic pci_ers_result_t tg3_io_slot_reset(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct tg3 *tp = netdev_priv(netdev);\n\tpci_ers_result_t rc = PCI_ERS_RESULT_DISCONNECT;\n\tint err;\n\n\trtnl_lock();\n\n\tif (pci_enable_device(pdev)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Cannot re-enable PCI device after reset.\\n\");\n\t\tgoto done;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_restore_state(pdev);\n\tpci_save_state(pdev);\n\n\tif (!netdev || !netif_running(netdev)) {\n\t\trc = PCI_ERS_RESULT_RECOVERED;\n\t\tgoto done;\n\t}\n\n\terr = tg3_power_up(tp);\n\tif (err)\n\t\tgoto done;\n\n\trc = PCI_ERS_RESULT_RECOVERED;\n\ndone:\n\tif (rc != PCI_ERS_RESULT_RECOVERED && netdev && netif_running(netdev)) {\n\t\ttg3_napi_enable(tp);\n\t\tdev_close(netdev);\n\t}\n\trtnl_unlock();\n\n\treturn rc;\n}\n\n/**\n * tg3_io_resume - called when traffic can start flowing again.\n * @pdev: Pointer to PCI device\n *\n * This callback is called when the error recovery driver tells\n * us that its OK to resume normal operation.\n */\nstatic void tg3_io_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct tg3 *tp = netdev_priv(netdev);\n\tint err;\n\n\trtnl_lock();\n\n\tif (!netdev || !netif_running(netdev))\n\t\tgoto done;\n\n\ttg3_full_lock(tp, 0);\n\ttg3_ape_driver_state_change(tp, RESET_KIND_INIT);\n\ttg3_flag_set(tp, INIT_COMPLETE);\n\terr = tg3_restart_hw(tp, true);\n\tif (err) {\n\t\ttg3_full_unlock(tp);\n\t\tnetdev_err(netdev, \"Cannot restart hardware after reset.\\n\");\n\t\tgoto done;\n\t}\n\n\tnetif_device_attach(netdev);\n\n\ttg3_timer_start(tp);\n\n\ttg3_netif_start(tp);\n\n\ttg3_full_unlock(tp);\n\n\ttg3_phy_start(tp);\n\ndone:\n\ttp->pcierr_recovery = false;\n\trtnl_unlock();\n}\n\nstatic const struct pci_error_handlers tg3_err_handler = {\n\t.error_detected\t= tg3_io_error_detected,\n\t.slot_reset\t= tg3_io_slot_reset,\n\t.resume\t\t= tg3_io_resume\n};\n\nstatic struct pci_driver tg3_driver = {\n\t.name\t\t= DRV_MODULE_NAME,\n\t.id_table\t= tg3_pci_tbl,\n\t.probe\t\t= tg3_init_one,\n\t.remove\t\t= tg3_remove_one,\n\t.err_handler\t= &tg3_err_handler,\n\t.driver.pm\t= &tg3_pm_ops,\n\t.shutdown\t= tg3_shutdown,\n};\n\nmodule_pci_driver(tg3_driver);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 10717}, "message": "warn: inconsistent indenting"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/broadcom/tg3.c", "reportHash": "6f1112903263cb6cef53c612ab0854cd", "checkerName": "smatch.check_indenting", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 12040}, "message": "warn: potential spectre issue 'data' [r]"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/broadcom/tg3.c", "reportHash": "8a37e44dec5d3254e21b8be9d173ebcb", "checkerName": "smatch.check_spectre", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
