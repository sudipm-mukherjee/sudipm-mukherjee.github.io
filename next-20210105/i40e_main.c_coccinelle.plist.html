<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/net/ethernet/intel/i40e/i40e_main.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 2013 - 2018 Intel Corporation. */\n\n#include <linux/etherdevice.h>\n#include <linux/of_net.h>\n#include <linux/pci.h>\n#include <linux/bpf.h>\n#include <generated/utsrelease.h>\n\n/* Local includes */\n#include \"i40e.h\"\n#include \"i40e_diag.h\"\n#include \"i40e_xsk.h\"\n#include <net/udp_tunnel.h>\n#include <net/xdp_sock_drv.h>\n/* All i40e tracepoints are defined by the include below, which\n * must be included exactly once across the whole kernel with\n * CREATE_TRACE_POINTS defined\n */\n#define CREATE_TRACE_POINTS\n#include \"i40e_trace.h\"\n\nconst char i40e_driver_name[] = \"i40e\";\nstatic const char i40e_driver_string[] =\n\t\t\t\"Intel(R) Ethernet Connection XL710 Network Driver\";\n\nstatic const char i40e_copyright[] = \"Copyright (c) 2013 - 2019 Intel Corporation.\";\n\n/* a bit of forward declarations */\nstatic void i40e_vsi_reinit_locked(struct i40e_vsi *vsi);\nstatic void i40e_handle_reset_warning(struct i40e_pf *pf, bool lock_acquired);\nstatic int i40e_add_vsi(struct i40e_vsi *vsi);\nstatic int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi);\nstatic int i40e_setup_pf_switch(struct i40e_pf *pf, bool reinit);\nstatic int i40e_setup_misc_vector(struct i40e_pf *pf);\nstatic void i40e_determine_queue_usage(struct i40e_pf *pf);\nstatic int i40e_setup_pf_filter_control(struct i40e_pf *pf);\nstatic void i40e_prep_for_reset(struct i40e_pf *pf, bool lock_acquired);\nstatic void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit,\n\t\t\t\t   bool lock_acquired);\nstatic int i40e_reset(struct i40e_pf *pf);\nstatic void i40e_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired);\nstatic int i40e_setup_misc_vector_for_recovery_mode(struct i40e_pf *pf);\nstatic int i40e_restore_interrupt_scheme(struct i40e_pf *pf);\nstatic bool i40e_check_recovery_mode(struct i40e_pf *pf);\nstatic int i40e_init_recovery_mode(struct i40e_pf *pf, struct i40e_hw *hw);\nstatic void i40e_fdir_sb_setup(struct i40e_pf *pf);\nstatic int i40e_veb_get_bw_info(struct i40e_veb *veb);\nstatic int i40e_get_capabilities(struct i40e_pf *pf,\n\t\t\t\t enum i40e_admin_queue_opc list_type);\nstatic bool i40e_is_total_port_shutdown_enabled(struct i40e_pf *pf);\n\n/* i40e_pci_tbl - PCI Device ID Table\n *\n * Last entry must be all 0s\n *\n * { Vendor ID, Device ID, SubVendor ID, SubDevice ID,\n *   Class, Class Mask, private data (not used) }\n */\nstatic const struct pci_device_id i40e_pci_tbl[] = {\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_SFP_XL710), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_QEMU), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_KX_B), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_KX_C), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_QSFP_A), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_QSFP_B), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_QSFP_C), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_10G_BASE_T), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_10G_BASE_T4), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_10G_BASE_T_BC), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_10G_SFP), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_10G_B), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_KX_X722), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_QSFP_X722), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_SFP_X722), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_1G_BASE_T_X722), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_10G_BASE_T_X722), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_SFP_I_X722), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_20G_KR2), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_20G_KR2_A), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_X710_N3000), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_XXV710_N3000), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_25G_B), 0},\n\t{PCI_VDEVICE(INTEL, I40E_DEV_ID_25G_SFP28), 0},\n\t/* required last entry */\n\t{0, }\n};\nMODULE_DEVICE_TABLE(pci, i40e_pci_tbl);\n\n#define I40E_MAX_VF_COUNT 128\nstatic int debug = -1;\nmodule_param(debug, uint, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all), Debug mask (0x8XXXXXXX)\");\n\nMODULE_AUTHOR(\"Intel Corporation, <e1000-devel@lists.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Intel(R) Ethernet Connection XL710 Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic struct workqueue_struct *i40e_wq;\n\n/**\n * i40e_allocate_dma_mem_d - OS specific memory alloc for shared code\n * @hw:   pointer to the HW structure\n * @mem:  ptr to mem struct to fill out\n * @size: size of memory requested\n * @alignment: what to align the allocation to\n **/\nint i40e_allocate_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem,\n\t\t\t    u64 size, u32 alignment)\n{\n\tstruct i40e_pf *pf = (struct i40e_pf *)hw->back;\n\n\tmem->size = ALIGN(size, alignment);\n\tmem->va = dma_alloc_coherent(&pf->pdev->dev, mem->size, &mem->pa,\n\t\t\t\t     GFP_KERNEL);\n\tif (!mem->va)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * i40e_free_dma_mem_d - OS specific memory free for shared code\n * @hw:   pointer to the HW structure\n * @mem:  ptr to mem struct to free\n **/\nint i40e_free_dma_mem_d(struct i40e_hw *hw, struct i40e_dma_mem *mem)\n{\n\tstruct i40e_pf *pf = (struct i40e_pf *)hw->back;\n\n\tdma_free_coherent(&pf->pdev->dev, mem->size, mem->va, mem->pa);\n\tmem->va = NULL;\n\tmem->pa = 0;\n\tmem->size = 0;\n\n\treturn 0;\n}\n\n/**\n * i40e_allocate_virt_mem_d - OS specific memory alloc for shared code\n * @hw:   pointer to the HW structure\n * @mem:  ptr to mem struct to fill out\n * @size: size of memory requested\n **/\nint i40e_allocate_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem,\n\t\t\t     u32 size)\n{\n\tmem->size = size;\n\tmem->va = kzalloc(size, GFP_KERNEL);\n\n\tif (!mem->va)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n/**\n * i40e_free_virt_mem_d - OS specific memory free for shared code\n * @hw:   pointer to the HW structure\n * @mem:  ptr to mem struct to free\n **/\nint i40e_free_virt_mem_d(struct i40e_hw *hw, struct i40e_virt_mem *mem)\n{\n\t/* it's ok to kfree a NULL pointer */\n\tkfree(mem->va);\n\tmem->va = NULL;\n\tmem->size = 0;\n\n\treturn 0;\n}\n\n/**\n * i40e_get_lump - find a lump of free generic resource\n * @pf: board private structure\n * @pile: the pile of resource to search\n * @needed: the number of items needed\n * @id: an owner id to stick on the items assigned\n *\n * Returns the base item index of the lump, or negative for error\n *\n * The search_hint trick and lack of advanced fit-finding only work\n * because we're highly likely to have all the same size lump requests.\n * Linear search time and any fragmentation should be minimal.\n **/\nstatic int i40e_get_lump(struct i40e_pf *pf, struct i40e_lump_tracking *pile,\n\t\t\t u16 needed, u16 id)\n{\n\tint ret = -ENOMEM;\n\tint i, j;\n\n\tif (!pile || needed == 0 || id >= I40E_PILE_VALID_BIT) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"param err: pile=%s needed=%d id=0x%04x\\n\",\n\t\t\t pile ? \"<valid>\" : \"<null>\", needed, id);\n\t\treturn -EINVAL;\n\t}\n\n\t/* start the linear search with an imperfect hint */\n\ti = pile->search_hint;\n\twhile (i < pile->num_entries) {\n\t\t/* skip already allocated entries */\n\t\tif (pile->list[i] & I40E_PILE_VALID_BIT) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* do we have enough in this lump? */\n\t\tfor (j = 0; (j < needed) && ((i+j) < pile->num_entries); j++) {\n\t\t\tif (pile->list[i+j] & I40E_PILE_VALID_BIT)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j == needed) {\n\t\t\t/* there was enough, so assign it to the requestor */\n\t\t\tfor (j = 0; j < needed; j++)\n\t\t\t\tpile->list[i+j] = id | I40E_PILE_VALID_BIT;\n\t\t\tret = i;\n\t\t\tpile->search_hint = i + j;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* not enough, so skip over it and continue looking */\n\t\ti += j;\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_put_lump - return a lump of generic resource\n * @pile: the pile of resource to search\n * @index: the base item index\n * @id: the owner id of the items assigned\n *\n * Returns the count of items in the lump\n **/\nstatic int i40e_put_lump(struct i40e_lump_tracking *pile, u16 index, u16 id)\n{\n\tint valid_id = (id | I40E_PILE_VALID_BIT);\n\tint count = 0;\n\tint i;\n\n\tif (!pile || index >= pile->num_entries)\n\t\treturn -EINVAL;\n\n\tfor (i = index;\n\t     i < pile->num_entries && pile->list[i] == valid_id;\n\t     i++) {\n\t\tpile->list[i] = 0;\n\t\tcount++;\n\t}\n\n\tif (count && index < pile->search_hint)\n\t\tpile->search_hint = index;\n\n\treturn count;\n}\n\n/**\n * i40e_find_vsi_from_id - searches for the vsi with the given id\n * @pf: the pf structure to search for the vsi\n * @id: id of the vsi it is searching for\n **/\nstruct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id)\n{\n\tint i;\n\n\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\tif (pf->vsi[i] && (pf->vsi[i]->id == id))\n\t\t\treturn pf->vsi[i];\n\n\treturn NULL;\n}\n\n/**\n * i40e_service_event_schedule - Schedule the service task to wake up\n * @pf: board private structure\n *\n * If not already scheduled, this puts the task into the work queue\n **/\nvoid i40e_service_event_schedule(struct i40e_pf *pf)\n{\n\tif ((!test_bit(__I40E_DOWN, pf->state) &&\n\t     !test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state)) ||\n\t      test_bit(__I40E_RECOVERY_MODE, pf->state))\n\t\tqueue_work(i40e_wq, &pf->service_task);\n}\n\n/**\n * i40e_tx_timeout - Respond to a Tx Hang\n * @netdev: network interface device structure\n * @txqueue: queue number timing out\n *\n * If any port has noticed a Tx timeout, it is likely that the whole\n * device is munged, not just the one netdev port, so go for the full\n * reset.\n **/\nstatic void i40e_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_ring *tx_ring = NULL;\n\tunsigned int i;\n\tu32 head, val;\n\n\tpf->tx_timeout_count++;\n\n\t/* with txqueue index, find the tx_ring struct */\n\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\tif (vsi->tx_rings[i] && vsi->tx_rings[i]->desc) {\n\t\t\tif (txqueue ==\n\t\t\t    vsi->tx_rings[i]->queue_index) {\n\t\t\t\ttx_ring = vsi->tx_rings[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (time_after(jiffies, (pf->tx_timeout_last_recovery + HZ*20)))\n\t\tpf->tx_timeout_recovery_level = 1;  /* reset after some time */\n\telse if (time_before(jiffies,\n\t\t      (pf->tx_timeout_last_recovery + netdev->watchdog_timeo)))\n\t\treturn;   /* don't do any new action before the next timeout */\n\n\t/* don't kick off another recovery if one is already pending */\n\tif (test_and_set_bit(__I40E_TIMEOUT_RECOVERY_PENDING, pf->state))\n\t\treturn;\n\n\tif (tx_ring) {\n\t\thead = i40e_get_head(tx_ring);\n\t\t/* Read interrupt register */\n\t\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\t\tval = rd32(&pf->hw,\n\t\t\t     I40E_PFINT_DYN_CTLN(tx_ring->q_vector->v_idx +\n\t\t\t\t\t\ttx_ring->vsi->base_vector - 1));\n\t\telse\n\t\t\tval = rd32(&pf->hw, I40E_PFINT_DYN_CTL0);\n\n\t\tnetdev_info(netdev, \"tx_timeout: VSI_seid: %d, Q %d, NTC: 0x%x, HWB: 0x%x, NTU: 0x%x, TAIL: 0x%x, INT: 0x%x\\n\",\n\t\t\t    vsi->seid, txqueue, tx_ring->next_to_clean,\n\t\t\t    head, tx_ring->next_to_use,\n\t\t\t    readl(tx_ring->tail), val);\n\t}\n\n\tpf->tx_timeout_last_recovery = jiffies;\n\tnetdev_info(netdev, \"tx_timeout recovery level %d, txqueue %d\\n\",\n\t\t    pf->tx_timeout_recovery_level, txqueue);\n\n\tswitch (pf->tx_timeout_recovery_level) {\n\tcase 1:\n\t\tset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t\tbreak;\n\tcase 2:\n\t\tset_bit(__I40E_CORE_RESET_REQUESTED, pf->state);\n\t\tbreak;\n\tcase 3:\n\t\tset_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(netdev, \"tx_timeout recovery unsuccessful\\n\");\n\t\tbreak;\n\t}\n\n\ti40e_service_event_schedule(pf);\n\tpf->tx_timeout_recovery_level++;\n}\n\n/**\n * i40e_get_vsi_stats_struct - Get System Network Statistics\n * @vsi: the VSI we care about\n *\n * Returns the address of the device statistics structure.\n * The statistics are actually updated from the service task.\n **/\nstruct rtnl_link_stats64 *i40e_get_vsi_stats_struct(struct i40e_vsi *vsi)\n{\n\treturn &vsi->net_stats;\n}\n\n/**\n * i40e_get_netdev_stats_struct_tx - populate stats from a Tx ring\n * @ring: Tx ring to get statistics from\n * @stats: statistics entry to be updated\n **/\nstatic void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,\n\t\t\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tu64 bytes, packets;\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_irq(&ring->syncp);\n\t\tpackets = ring->stats.packets;\n\t\tbytes   = ring->stats.bytes;\n\t} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\n\n\tstats->tx_packets += packets;\n\tstats->tx_bytes   += bytes;\n}\n\n/**\n * i40e_get_netdev_stats_struct - Get statistics for netdev interface\n * @netdev: network interface device structure\n * @stats: data structure to store statistics\n *\n * Returns the address of the device statistics structure.\n * The statistics are actually updated from the service task.\n **/\nstatic void i40e_get_netdev_stats_struct(struct net_device *netdev,\n\t\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct rtnl_link_stats64 *vsi_stats = i40e_get_vsi_stats_struct(vsi);\n\tstruct i40e_ring *ring;\n\tint i;\n\n\tif (test_bit(__I40E_VSI_DOWN, vsi->state))\n\t\treturn;\n\n\tif (!vsi->tx_rings)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\tu64 bytes, packets;\n\t\tunsigned int start;\n\n\t\tring = READ_ONCE(vsi->tx_rings[i]);\n\t\tif (!ring)\n\t\t\tcontinue;\n\t\ti40e_get_netdev_stats_struct_tx(ring, stats);\n\n\t\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\t\tring = READ_ONCE(vsi->xdp_rings[i]);\n\t\t\tif (!ring)\n\t\t\t\tcontinue;\n\t\t\ti40e_get_netdev_stats_struct_tx(ring, stats);\n\t\t}\n\n\t\tring = READ_ONCE(vsi->rx_rings[i]);\n\t\tif (!ring)\n\t\t\tcontinue;\n\t\tdo {\n\t\t\tstart   = u64_stats_fetch_begin_irq(&ring->syncp);\n\t\t\tpackets = ring->stats.packets;\n\t\t\tbytes   = ring->stats.bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\n\n\t\tstats->rx_packets += packets;\n\t\tstats->rx_bytes   += bytes;\n\n\t}\n\trcu_read_unlock();\n\n\t/* following stats updated by i40e_watchdog_subtask() */\n\tstats->multicast\t= vsi_stats->multicast;\n\tstats->tx_errors\t= vsi_stats->tx_errors;\n\tstats->tx_dropped\t= vsi_stats->tx_dropped;\n\tstats->rx_errors\t= vsi_stats->rx_errors;\n\tstats->rx_dropped\t= vsi_stats->rx_dropped;\n\tstats->rx_crc_errors\t= vsi_stats->rx_crc_errors;\n\tstats->rx_length_errors\t= vsi_stats->rx_length_errors;\n}\n\n/**\n * i40e_vsi_reset_stats - Resets all stats of the given vsi\n * @vsi: the VSI to have its stats reset\n **/\nvoid i40e_vsi_reset_stats(struct i40e_vsi *vsi)\n{\n\tstruct rtnl_link_stats64 *ns;\n\tint i;\n\n\tif (!vsi)\n\t\treturn;\n\n\tns = i40e_get_vsi_stats_struct(vsi);\n\tmemset(ns, 0, sizeof(*ns));\n\tmemset(&vsi->net_stats_offsets, 0, sizeof(vsi->net_stats_offsets));\n\tmemset(&vsi->eth_stats, 0, sizeof(vsi->eth_stats));\n\tmemset(&vsi->eth_stats_offsets, 0, sizeof(vsi->eth_stats_offsets));\n\tif (vsi->rx_rings && vsi->rx_rings[0]) {\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\t\tmemset(&vsi->rx_rings[i]->stats, 0,\n\t\t\t       sizeof(vsi->rx_rings[i]->stats));\n\t\t\tmemset(&vsi->rx_rings[i]->rx_stats, 0,\n\t\t\t       sizeof(vsi->rx_rings[i]->rx_stats));\n\t\t\tmemset(&vsi->tx_rings[i]->stats, 0,\n\t\t\t       sizeof(vsi->tx_rings[i]->stats));\n\t\t\tmemset(&vsi->tx_rings[i]->tx_stats, 0,\n\t\t\t       sizeof(vsi->tx_rings[i]->tx_stats));\n\t\t}\n\t}\n\tvsi->stat_offsets_loaded = false;\n}\n\n/**\n * i40e_pf_reset_stats - Reset all of the stats for the given PF\n * @pf: the PF to be reset\n **/\nvoid i40e_pf_reset_stats(struct i40e_pf *pf)\n{\n\tint i;\n\n\tmemset(&pf->stats, 0, sizeof(pf->stats));\n\tmemset(&pf->stats_offsets, 0, sizeof(pf->stats_offsets));\n\tpf->stat_offsets_loaded = false;\n\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tif (pf->veb[i]) {\n\t\t\tmemset(&pf->veb[i]->stats, 0,\n\t\t\t       sizeof(pf->veb[i]->stats));\n\t\t\tmemset(&pf->veb[i]->stats_offsets, 0,\n\t\t\t       sizeof(pf->veb[i]->stats_offsets));\n\t\t\tmemset(&pf->veb[i]->tc_stats, 0,\n\t\t\t       sizeof(pf->veb[i]->tc_stats));\n\t\t\tmemset(&pf->veb[i]->tc_stats_offsets, 0,\n\t\t\t       sizeof(pf->veb[i]->tc_stats_offsets));\n\t\t\tpf->veb[i]->stat_offsets_loaded = false;\n\t\t}\n\t}\n\tpf->hw_csum_rx_error = 0;\n}\n\n/**\n * i40e_stat_update48 - read and update a 48 bit stat from the chip\n * @hw: ptr to the hardware info\n * @hireg: the high 32 bit reg to read\n * @loreg: the low 32 bit reg to read\n * @offset_loaded: has the initial offset been loaded yet\n * @offset: ptr to current offset value\n * @stat: ptr to the stat\n *\n * Since the device stats are not reset at PFReset, they likely will not\n * be zeroed when the driver starts.  We'll save the first values read\n * and use them as offsets to be subtracted from the raw values in order\n * to report stats that count from zero.  In the process, we also manage\n * the potential roll-over.\n **/\nstatic void i40e_stat_update48(struct i40e_hw *hw, u32 hireg, u32 loreg,\n\t\t\t       bool offset_loaded, u64 *offset, u64 *stat)\n{\n\tu64 new_data;\n\n\tif (hw->device_id == I40E_DEV_ID_QEMU) {\n\t\tnew_data = rd32(hw, loreg);\n\t\tnew_data |= ((u64)(rd32(hw, hireg) & 0xFFFF)) << 32;\n\t} else {\n\t\tnew_data = rd64(hw, loreg);\n\t}\n\tif (!offset_loaded)\n\t\t*offset = new_data;\n\tif (likely(new_data >= *offset))\n\t\t*stat = new_data - *offset;\n\telse\n\t\t*stat = (new_data + BIT_ULL(48)) - *offset;\n\t*stat &= 0xFFFFFFFFFFFFULL;\n}\n\n/**\n * i40e_stat_update32 - read and update a 32 bit stat from the chip\n * @hw: ptr to the hardware info\n * @reg: the hw reg to read\n * @offset_loaded: has the initial offset been loaded yet\n * @offset: ptr to current offset value\n * @stat: ptr to the stat\n **/\nstatic void i40e_stat_update32(struct i40e_hw *hw, u32 reg,\n\t\t\t       bool offset_loaded, u64 *offset, u64 *stat)\n{\n\tu32 new_data;\n\n\tnew_data = rd32(hw, reg);\n\tif (!offset_loaded)\n\t\t*offset = new_data;\n\tif (likely(new_data >= *offset))\n\t\t*stat = (u32)(new_data - *offset);\n\telse\n\t\t*stat = (u32)((new_data + BIT_ULL(32)) - *offset);\n}\n\n/**\n * i40e_stat_update_and_clear32 - read and clear hw reg, update a 32 bit stat\n * @hw: ptr to the hardware info\n * @reg: the hw reg to read and clear\n * @stat: ptr to the stat\n **/\nstatic void i40e_stat_update_and_clear32(struct i40e_hw *hw, u32 reg, u64 *stat)\n{\n\tu32 new_data = rd32(hw, reg);\n\n\twr32(hw, reg, 1); /* must write a nonzero value to clear register */\n\t*stat += new_data;\n}\n\n/**\n * i40e_update_eth_stats - Update VSI-specific ethernet statistics counters.\n * @vsi: the VSI to be updated\n **/\nvoid i40e_update_eth_stats(struct i40e_vsi *vsi)\n{\n\tint stat_idx = le16_to_cpu(vsi->info.stat_counter_idx);\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_eth_stats *oes;\n\tstruct i40e_eth_stats *es;     /* device's eth stats */\n\n\tes = &vsi->eth_stats;\n\toes = &vsi->eth_stats_offsets;\n\n\t/* Gather up the stats that the hw collects */\n\ti40e_stat_update32(hw, I40E_GLV_TEPC(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->tx_errors, &es->tx_errors);\n\ti40e_stat_update32(hw, I40E_GLV_RDPC(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->rx_discards, &es->rx_discards);\n\ti40e_stat_update32(hw, I40E_GLV_RUPP(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->rx_unknown_protocol, &es->rx_unknown_protocol);\n\n\ti40e_stat_update48(hw, I40E_GLV_GORCH(stat_idx),\n\t\t\t   I40E_GLV_GORCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->rx_bytes, &es->rx_bytes);\n\ti40e_stat_update48(hw, I40E_GLV_UPRCH(stat_idx),\n\t\t\t   I40E_GLV_UPRCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->rx_unicast, &es->rx_unicast);\n\ti40e_stat_update48(hw, I40E_GLV_MPRCH(stat_idx),\n\t\t\t   I40E_GLV_MPRCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->rx_multicast, &es->rx_multicast);\n\ti40e_stat_update48(hw, I40E_GLV_BPRCH(stat_idx),\n\t\t\t   I40E_GLV_BPRCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->rx_broadcast, &es->rx_broadcast);\n\n\ti40e_stat_update48(hw, I40E_GLV_GOTCH(stat_idx),\n\t\t\t   I40E_GLV_GOTCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->tx_bytes, &es->tx_bytes);\n\ti40e_stat_update48(hw, I40E_GLV_UPTCH(stat_idx),\n\t\t\t   I40E_GLV_UPTCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->tx_unicast, &es->tx_unicast);\n\ti40e_stat_update48(hw, I40E_GLV_MPTCH(stat_idx),\n\t\t\t   I40E_GLV_MPTCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->tx_multicast, &es->tx_multicast);\n\ti40e_stat_update48(hw, I40E_GLV_BPTCH(stat_idx),\n\t\t\t   I40E_GLV_BPTCL(stat_idx),\n\t\t\t   vsi->stat_offsets_loaded,\n\t\t\t   &oes->tx_broadcast, &es->tx_broadcast);\n\tvsi->stat_offsets_loaded = true;\n}\n\n/**\n * i40e_update_veb_stats - Update Switch component statistics\n * @veb: the VEB being updated\n **/\nvoid i40e_update_veb_stats(struct i40e_veb *veb)\n{\n\tstruct i40e_pf *pf = veb->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_eth_stats *oes;\n\tstruct i40e_eth_stats *es;     /* device's eth stats */\n\tstruct i40e_veb_tc_stats *veb_oes;\n\tstruct i40e_veb_tc_stats *veb_es;\n\tint i, idx = 0;\n\n\tidx = veb->stats_idx;\n\tes = &veb->stats;\n\toes = &veb->stats_offsets;\n\tveb_es = &veb->tc_stats;\n\tveb_oes = &veb->tc_stats_offsets;\n\n\t/* Gather up the stats that the hw collects */\n\ti40e_stat_update32(hw, I40E_GLSW_TDPC(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->tx_discards, &es->tx_discards);\n\tif (hw->revision_id > 0)\n\t\ti40e_stat_update32(hw, I40E_GLSW_RUPP(idx),\n\t\t\t\t   veb->stat_offsets_loaded,\n\t\t\t\t   &oes->rx_unknown_protocol,\n\t\t\t\t   &es->rx_unknown_protocol);\n\ti40e_stat_update48(hw, I40E_GLSW_GORCH(idx), I40E_GLSW_GORCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->rx_bytes, &es->rx_bytes);\n\ti40e_stat_update48(hw, I40E_GLSW_UPRCH(idx), I40E_GLSW_UPRCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->rx_unicast, &es->rx_unicast);\n\ti40e_stat_update48(hw, I40E_GLSW_MPRCH(idx), I40E_GLSW_MPRCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->rx_multicast, &es->rx_multicast);\n\ti40e_stat_update48(hw, I40E_GLSW_BPRCH(idx), I40E_GLSW_BPRCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->rx_broadcast, &es->rx_broadcast);\n\n\ti40e_stat_update48(hw, I40E_GLSW_GOTCH(idx), I40E_GLSW_GOTCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->tx_bytes, &es->tx_bytes);\n\ti40e_stat_update48(hw, I40E_GLSW_UPTCH(idx), I40E_GLSW_UPTCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->tx_unicast, &es->tx_unicast);\n\ti40e_stat_update48(hw, I40E_GLSW_MPTCH(idx), I40E_GLSW_MPTCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->tx_multicast, &es->tx_multicast);\n\ti40e_stat_update48(hw, I40E_GLSW_BPTCH(idx), I40E_GLSW_BPTCL(idx),\n\t\t\t   veb->stat_offsets_loaded,\n\t\t\t   &oes->tx_broadcast, &es->tx_broadcast);\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\ti40e_stat_update48(hw, I40E_GLVEBTC_RPCH(i, idx),\n\t\t\t\t   I40E_GLVEBTC_RPCL(i, idx),\n\t\t\t\t   veb->stat_offsets_loaded,\n\t\t\t\t   &veb_oes->tc_rx_packets[i],\n\t\t\t\t   &veb_es->tc_rx_packets[i]);\n\t\ti40e_stat_update48(hw, I40E_GLVEBTC_RBCH(i, idx),\n\t\t\t\t   I40E_GLVEBTC_RBCL(i, idx),\n\t\t\t\t   veb->stat_offsets_loaded,\n\t\t\t\t   &veb_oes->tc_rx_bytes[i],\n\t\t\t\t   &veb_es->tc_rx_bytes[i]);\n\t\ti40e_stat_update48(hw, I40E_GLVEBTC_TPCH(i, idx),\n\t\t\t\t   I40E_GLVEBTC_TPCL(i, idx),\n\t\t\t\t   veb->stat_offsets_loaded,\n\t\t\t\t   &veb_oes->tc_tx_packets[i],\n\t\t\t\t   &veb_es->tc_tx_packets[i]);\n\t\ti40e_stat_update48(hw, I40E_GLVEBTC_TBCH(i, idx),\n\t\t\t\t   I40E_GLVEBTC_TBCL(i, idx),\n\t\t\t\t   veb->stat_offsets_loaded,\n\t\t\t\t   &veb_oes->tc_tx_bytes[i],\n\t\t\t\t   &veb_es->tc_tx_bytes[i]);\n\t}\n\tveb->stat_offsets_loaded = true;\n}\n\n/**\n * i40e_update_vsi_stats - Update the vsi statistics counters.\n * @vsi: the VSI to be updated\n *\n * There are a few instances where we store the same stat in a\n * couple of different structs.  This is partly because we have\n * the netdev stats that need to be filled out, which is slightly\n * different from the \"eth_stats\" defined by the chip and used in\n * VF communications.  We sort it out here.\n **/\nstatic void i40e_update_vsi_stats(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct rtnl_link_stats64 *ons;\n\tstruct rtnl_link_stats64 *ns;   /* netdev stats */\n\tstruct i40e_eth_stats *oes;\n\tstruct i40e_eth_stats *es;     /* device's eth stats */\n\tu32 tx_restart, tx_busy;\n\tstruct i40e_ring *p;\n\tu32 rx_page, rx_buf;\n\tu64 bytes, packets;\n\tunsigned int start;\n\tu64 tx_linearize;\n\tu64 tx_force_wb;\n\tu64 rx_p, rx_b;\n\tu64 tx_p, tx_b;\n\tu16 q;\n\n\tif (test_bit(__I40E_VSI_DOWN, vsi->state) ||\n\t    test_bit(__I40E_CONFIG_BUSY, pf->state))\n\t\treturn;\n\n\tns = i40e_get_vsi_stats_struct(vsi);\n\tons = &vsi->net_stats_offsets;\n\tes = &vsi->eth_stats;\n\toes = &vsi->eth_stats_offsets;\n\n\t/* Gather up the netdev and vsi stats that the driver collects\n\t * on the fly during packet processing\n\t */\n\trx_b = rx_p = 0;\n\ttx_b = tx_p = 0;\n\ttx_restart = tx_busy = tx_linearize = tx_force_wb = 0;\n\trx_page = 0;\n\trx_buf = 0;\n\trcu_read_lock();\n\tfor (q = 0; q < vsi->num_queue_pairs; q++) {\n\t\t/* locate Tx ring */\n\t\tp = READ_ONCE(vsi->tx_rings[q]);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&p->syncp);\n\t\t\tpackets = p->stats.packets;\n\t\t\tbytes = p->stats.bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&p->syncp, start));\n\t\ttx_b += bytes;\n\t\ttx_p += packets;\n\t\ttx_restart += p->tx_stats.restart_queue;\n\t\ttx_busy += p->tx_stats.tx_busy;\n\t\ttx_linearize += p->tx_stats.tx_linearize;\n\t\ttx_force_wb += p->tx_stats.tx_force_wb;\n\n\t\t/* locate Rx ring */\n\t\tp = READ_ONCE(vsi->rx_rings[q]);\n\t\tif (!p)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_irq(&p->syncp);\n\t\t\tpackets = p->stats.packets;\n\t\t\tbytes = p->stats.bytes;\n\t\t} while (u64_stats_fetch_retry_irq(&p->syncp, start));\n\t\trx_b += bytes;\n\t\trx_p += packets;\n\t\trx_buf += p->rx_stats.alloc_buff_failed;\n\t\trx_page += p->rx_stats.alloc_page_failed;\n\n\t\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\t\t/* locate XDP ring */\n\t\t\tp = READ_ONCE(vsi->xdp_rings[q]);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\n\t\t\tdo {\n\t\t\t\tstart = u64_stats_fetch_begin_irq(&p->syncp);\n\t\t\t\tpackets = p->stats.packets;\n\t\t\t\tbytes = p->stats.bytes;\n\t\t\t} while (u64_stats_fetch_retry_irq(&p->syncp, start));\n\t\t\ttx_b += bytes;\n\t\t\ttx_p += packets;\n\t\t\ttx_restart += p->tx_stats.restart_queue;\n\t\t\ttx_busy += p->tx_stats.tx_busy;\n\t\t\ttx_linearize += p->tx_stats.tx_linearize;\n\t\t\ttx_force_wb += p->tx_stats.tx_force_wb;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tvsi->tx_restart = tx_restart;\n\tvsi->tx_busy = tx_busy;\n\tvsi->tx_linearize = tx_linearize;\n\tvsi->tx_force_wb = tx_force_wb;\n\tvsi->rx_page_failed = rx_page;\n\tvsi->rx_buf_failed = rx_buf;\n\n\tns->rx_packets = rx_p;\n\tns->rx_bytes = rx_b;\n\tns->tx_packets = tx_p;\n\tns->tx_bytes = tx_b;\n\n\t/* update netdev stats from eth stats */\n\ti40e_update_eth_stats(vsi);\n\tons->tx_errors = oes->tx_errors;\n\tns->tx_errors = es->tx_errors;\n\tons->multicast = oes->rx_multicast;\n\tns->multicast = es->rx_multicast;\n\tons->rx_dropped = oes->rx_discards;\n\tns->rx_dropped = es->rx_discards;\n\tons->tx_dropped = oes->tx_discards;\n\tns->tx_dropped = es->tx_discards;\n\n\t/* pull in a couple PF stats if this is the main vsi */\n\tif (vsi == pf->vsi[pf->lan_vsi]) {\n\t\tns->rx_crc_errors = pf->stats.crc_errors;\n\t\tns->rx_errors = pf->stats.crc_errors + pf->stats.illegal_bytes;\n\t\tns->rx_length_errors = pf->stats.rx_length_errors;\n\t}\n}\n\n/**\n * i40e_update_pf_stats - Update the PF statistics counters.\n * @pf: the PF to be updated\n **/\nstatic void i40e_update_pf_stats(struct i40e_pf *pf)\n{\n\tstruct i40e_hw_port_stats *osd = &pf->stats_offsets;\n\tstruct i40e_hw_port_stats *nsd = &pf->stats;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 val;\n\tint i;\n\n\ti40e_stat_update48(hw, I40E_GLPRT_GORCH(hw->port),\n\t\t\t   I40E_GLPRT_GORCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.rx_bytes, &nsd->eth.rx_bytes);\n\ti40e_stat_update48(hw, I40E_GLPRT_GOTCH(hw->port),\n\t\t\t   I40E_GLPRT_GOTCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.tx_bytes, &nsd->eth.tx_bytes);\n\ti40e_stat_update32(hw, I40E_GLPRT_RDPC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.rx_discards,\n\t\t\t   &nsd->eth.rx_discards);\n\ti40e_stat_update48(hw, I40E_GLPRT_UPRCH(hw->port),\n\t\t\t   I40E_GLPRT_UPRCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.rx_unicast,\n\t\t\t   &nsd->eth.rx_unicast);\n\ti40e_stat_update48(hw, I40E_GLPRT_MPRCH(hw->port),\n\t\t\t   I40E_GLPRT_MPRCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.rx_multicast,\n\t\t\t   &nsd->eth.rx_multicast);\n\ti40e_stat_update48(hw, I40E_GLPRT_BPRCH(hw->port),\n\t\t\t   I40E_GLPRT_BPRCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.rx_broadcast,\n\t\t\t   &nsd->eth.rx_broadcast);\n\ti40e_stat_update48(hw, I40E_GLPRT_UPTCH(hw->port),\n\t\t\t   I40E_GLPRT_UPTCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.tx_unicast,\n\t\t\t   &nsd->eth.tx_unicast);\n\ti40e_stat_update48(hw, I40E_GLPRT_MPTCH(hw->port),\n\t\t\t   I40E_GLPRT_MPTCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.tx_multicast,\n\t\t\t   &nsd->eth.tx_multicast);\n\ti40e_stat_update48(hw, I40E_GLPRT_BPTCH(hw->port),\n\t\t\t   I40E_GLPRT_BPTCL(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->eth.tx_broadcast,\n\t\t\t   &nsd->eth.tx_broadcast);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_TDOLD(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_dropped_link_down,\n\t\t\t   &nsd->tx_dropped_link_down);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_CRCERRS(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->crc_errors, &nsd->crc_errors);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_ILLERRC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->illegal_bytes, &nsd->illegal_bytes);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_MLFC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->mac_local_faults,\n\t\t\t   &nsd->mac_local_faults);\n\ti40e_stat_update32(hw, I40E_GLPRT_MRFC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->mac_remote_faults,\n\t\t\t   &nsd->mac_remote_faults);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_RLEC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_length_errors,\n\t\t\t   &nsd->rx_length_errors);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_LXONRXC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->link_xon_rx, &nsd->link_xon_rx);\n\ti40e_stat_update32(hw, I40E_GLPRT_LXONTXC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->link_xon_tx, &nsd->link_xon_tx);\n\ti40e_stat_update32(hw, I40E_GLPRT_LXOFFRXC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->link_xoff_rx, &nsd->link_xoff_rx);\n\ti40e_stat_update32(hw, I40E_GLPRT_LXOFFTXC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->link_xoff_tx, &nsd->link_xoff_tx);\n\n\tfor (i = 0; i < 8; i++) {\n\t\ti40e_stat_update32(hw, I40E_GLPRT_PXOFFRXC(hw->port, i),\n\t\t\t\t   pf->stat_offsets_loaded,\n\t\t\t\t   &osd->priority_xoff_rx[i],\n\t\t\t\t   &nsd->priority_xoff_rx[i]);\n\t\ti40e_stat_update32(hw, I40E_GLPRT_PXONRXC(hw->port, i),\n\t\t\t\t   pf->stat_offsets_loaded,\n\t\t\t\t   &osd->priority_xon_rx[i],\n\t\t\t\t   &nsd->priority_xon_rx[i]);\n\t\ti40e_stat_update32(hw, I40E_GLPRT_PXONTXC(hw->port, i),\n\t\t\t\t   pf->stat_offsets_loaded,\n\t\t\t\t   &osd->priority_xon_tx[i],\n\t\t\t\t   &nsd->priority_xon_tx[i]);\n\t\ti40e_stat_update32(hw, I40E_GLPRT_PXOFFTXC(hw->port, i),\n\t\t\t\t   pf->stat_offsets_loaded,\n\t\t\t\t   &osd->priority_xoff_tx[i],\n\t\t\t\t   &nsd->priority_xoff_tx[i]);\n\t\ti40e_stat_update32(hw,\n\t\t\t\t   I40E_GLPRT_RXON2OFFCNT(hw->port, i),\n\t\t\t\t   pf->stat_offsets_loaded,\n\t\t\t\t   &osd->priority_xon_2_xoff[i],\n\t\t\t\t   &nsd->priority_xon_2_xoff[i]);\n\t}\n\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC64H(hw->port),\n\t\t\t   I40E_GLPRT_PRC64L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_64, &nsd->rx_size_64);\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC127H(hw->port),\n\t\t\t   I40E_GLPRT_PRC127L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_127, &nsd->rx_size_127);\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC255H(hw->port),\n\t\t\t   I40E_GLPRT_PRC255L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_255, &nsd->rx_size_255);\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC511H(hw->port),\n\t\t\t   I40E_GLPRT_PRC511L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_511, &nsd->rx_size_511);\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC1023H(hw->port),\n\t\t\t   I40E_GLPRT_PRC1023L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_1023, &nsd->rx_size_1023);\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC1522H(hw->port),\n\t\t\t   I40E_GLPRT_PRC1522L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_1522, &nsd->rx_size_1522);\n\ti40e_stat_update48(hw, I40E_GLPRT_PRC9522H(hw->port),\n\t\t\t   I40E_GLPRT_PRC9522L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_size_big, &nsd->rx_size_big);\n\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC64H(hw->port),\n\t\t\t   I40E_GLPRT_PTC64L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_64, &nsd->tx_size_64);\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC127H(hw->port),\n\t\t\t   I40E_GLPRT_PTC127L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_127, &nsd->tx_size_127);\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC255H(hw->port),\n\t\t\t   I40E_GLPRT_PTC255L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_255, &nsd->tx_size_255);\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC511H(hw->port),\n\t\t\t   I40E_GLPRT_PTC511L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_511, &nsd->tx_size_511);\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC1023H(hw->port),\n\t\t\t   I40E_GLPRT_PTC1023L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_1023, &nsd->tx_size_1023);\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC1522H(hw->port),\n\t\t\t   I40E_GLPRT_PTC1522L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_1522, &nsd->tx_size_1522);\n\ti40e_stat_update48(hw, I40E_GLPRT_PTC9522H(hw->port),\n\t\t\t   I40E_GLPRT_PTC9522L(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_size_big, &nsd->tx_size_big);\n\n\ti40e_stat_update32(hw, I40E_GLPRT_RUC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_undersize, &nsd->rx_undersize);\n\ti40e_stat_update32(hw, I40E_GLPRT_RFC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_fragments, &nsd->rx_fragments);\n\ti40e_stat_update32(hw, I40E_GLPRT_ROC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_oversize, &nsd->rx_oversize);\n\ti40e_stat_update32(hw, I40E_GLPRT_RJC(hw->port),\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_jabber, &nsd->rx_jabber);\n\n\t/* FDIR stats */\n\ti40e_stat_update_and_clear32(hw,\n\t\t\tI40E_GLQF_PCNT(I40E_FD_ATR_STAT_IDX(hw->pf_id)),\n\t\t\t&nsd->fd_atr_match);\n\ti40e_stat_update_and_clear32(hw,\n\t\t\tI40E_GLQF_PCNT(I40E_FD_SB_STAT_IDX(hw->pf_id)),\n\t\t\t&nsd->fd_sb_match);\n\ti40e_stat_update_and_clear32(hw,\n\t\t\tI40E_GLQF_PCNT(I40E_FD_ATR_TUNNEL_STAT_IDX(hw->pf_id)),\n\t\t\t&nsd->fd_atr_tunnel_match);\n\n\tval = rd32(hw, I40E_PRTPM_EEE_STAT);\n\tnsd->tx_lpi_status =\n\t\t       (val & I40E_PRTPM_EEE_STAT_TX_LPI_STATUS_MASK) >>\n\t\t\tI40E_PRTPM_EEE_STAT_TX_LPI_STATUS_SHIFT;\n\tnsd->rx_lpi_status =\n\t\t       (val & I40E_PRTPM_EEE_STAT_RX_LPI_STATUS_MASK) >>\n\t\t\tI40E_PRTPM_EEE_STAT_RX_LPI_STATUS_SHIFT;\n\ti40e_stat_update32(hw, I40E_PRTPM_TLPIC,\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->tx_lpi_count, &nsd->tx_lpi_count);\n\ti40e_stat_update32(hw, I40E_PRTPM_RLPIC,\n\t\t\t   pf->stat_offsets_loaded,\n\t\t\t   &osd->rx_lpi_count, &nsd->rx_lpi_count);\n\n\tif (pf->flags & I40E_FLAG_FD_SB_ENABLED &&\n\t    !test_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state))\n\t\tnsd->fd_sb_status = true;\n\telse\n\t\tnsd->fd_sb_status = false;\n\n\tif (pf->flags & I40E_FLAG_FD_ATR_ENABLED &&\n\t    !test_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state))\n\t\tnsd->fd_atr_status = true;\n\telse\n\t\tnsd->fd_atr_status = false;\n\n\tpf->stat_offsets_loaded = true;\n}\n\n/**\n * i40e_update_stats - Update the various statistics counters.\n * @vsi: the VSI to be updated\n *\n * Update the various stats for this VSI and its related entities.\n **/\nvoid i40e_update_stats(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\tif (vsi == pf->vsi[pf->lan_vsi])\n\t\ti40e_update_pf_stats(pf);\n\n\ti40e_update_vsi_stats(vsi);\n}\n\n/**\n * i40e_count_filters - counts VSI mac filters\n * @vsi: the VSI to be searched\n *\n * Returns count of mac filters\n **/\nint i40e_count_filters(struct i40e_vsi *vsi)\n{\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\tint bkt;\n\tint cnt = 0;\n\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist)\n\t\t++cnt;\n\n\treturn cnt;\n}\n\n/**\n * i40e_find_filter - Search VSI filter list for specific mac/vlan filter\n * @vsi: the VSI to be searched\n * @macaddr: the MAC address\n * @vlan: the vlan\n *\n * Returns ptr to the filter object or NULL\n **/\nstatic struct i40e_mac_filter *i40e_find_filter(struct i40e_vsi *vsi,\n\t\t\t\t\t\tconst u8 *macaddr, s16 vlan)\n{\n\tstruct i40e_mac_filter *f;\n\tu64 key;\n\n\tif (!vsi || !macaddr)\n\t\treturn NULL;\n\n\tkey = i40e_addr_to_hkey(macaddr);\n\thash_for_each_possible(vsi->mac_filter_hash, f, hlist, key) {\n\t\tif ((ether_addr_equal(macaddr, f->macaddr)) &&\n\t\t    (vlan == f->vlan))\n\t\t\treturn f;\n\t}\n\treturn NULL;\n}\n\n/**\n * i40e_find_mac - Find a mac addr in the macvlan filters list\n * @vsi: the VSI to be searched\n * @macaddr: the MAC address we are searching for\n *\n * Returns the first filter with the provided MAC address or NULL if\n * MAC address was not found\n **/\nstruct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, const u8 *macaddr)\n{\n\tstruct i40e_mac_filter *f;\n\tu64 key;\n\n\tif (!vsi || !macaddr)\n\t\treturn NULL;\n\n\tkey = i40e_addr_to_hkey(macaddr);\n\thash_for_each_possible(vsi->mac_filter_hash, f, hlist, key) {\n\t\tif ((ether_addr_equal(macaddr, f->macaddr)))\n\t\t\treturn f;\n\t}\n\treturn NULL;\n}\n\n/**\n * i40e_is_vsi_in_vlan - Check if VSI is in vlan mode\n * @vsi: the VSI to be searched\n *\n * Returns true if VSI is in vlan mode or false otherwise\n **/\nbool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi)\n{\n\t/* If we have a PVID, always operate in VLAN mode */\n\tif (vsi->info.pvid)\n\t\treturn true;\n\n\t/* We need to operate in VLAN mode whenever we have any filters with\n\t * a VLAN other than I40E_VLAN_ALL. We could check the table each\n\t * time, incurring search cost repeatedly. However, we can notice two\n\t * things:\n\t *\n\t * 1) the only place where we can gain a VLAN filter is in\n\t *    i40e_add_filter.\n\t *\n\t * 2) the only place where filters are actually removed is in\n\t *    i40e_sync_filters_subtask.\n\t *\n\t * Thus, we can simply use a boolean value, has_vlan_filters which we\n\t * will set to true when we add a VLAN filter in i40e_add_filter. Then\n\t * we have to perform the full search after deleting filters in\n\t * i40e_sync_filters_subtask, but we already have to search\n\t * filters here and can perform the check at the same time. This\n\t * results in avoiding embedding a loop for VLAN mode inside another\n\t * loop over all the filters, and should maintain correctness as noted\n\t * above.\n\t */\n\treturn vsi->has_vlan_filter;\n}\n\n/**\n * i40e_correct_mac_vlan_filters - Correct non-VLAN filters if necessary\n * @vsi: the VSI to configure\n * @tmp_add_list: list of filters ready to be added\n * @tmp_del_list: list of filters ready to be deleted\n * @vlan_filters: the number of active VLAN filters\n *\n * Update VLAN=0 and VLAN=-1 (I40E_VLAN_ANY) filters properly so that they\n * behave as expected. If we have any active VLAN filters remaining or about\n * to be added then we need to update non-VLAN filters to be marked as VLAN=0\n * so that they only match against untagged traffic. If we no longer have any\n * active VLAN filters, we need to make all non-VLAN filters marked as VLAN=-1\n * so that they match against both tagged and untagged traffic. In this way,\n * we ensure that we correctly receive the desired traffic. This ensures that\n * when we have an active VLAN we will receive only untagged traffic and\n * traffic matching active VLANs. If we have no active VLANs then we will\n * operate in non-VLAN mode and receive all traffic, tagged or untagged.\n *\n * Finally, in a similar fashion, this function also corrects filters when\n * there is an active PVID assigned to this VSI.\n *\n * In case of memory allocation failure return -ENOMEM. Otherwise, return 0.\n *\n * This function is only expected to be called from within\n * i40e_sync_vsi_filters.\n *\n * NOTE: This function expects to be called while under the\n * mac_filter_hash_lock\n */\nstatic int i40e_correct_mac_vlan_filters(struct i40e_vsi *vsi,\n\t\t\t\t\t struct hlist_head *tmp_add_list,\n\t\t\t\t\t struct hlist_head *tmp_del_list,\n\t\t\t\t\t int vlan_filters)\n{\n\ts16 pvid = le16_to_cpu(vsi->info.pvid);\n\tstruct i40e_mac_filter *f, *add_head;\n\tstruct i40e_new_mac_filter *new;\n\tstruct hlist_node *h;\n\tint bkt, new_vlan;\n\n\t/* To determine if a particular filter needs to be replaced we\n\t * have the three following conditions:\n\t *\n\t * a) if we have a PVID assigned, then all filters which are\n\t *    not marked as VLAN=PVID must be replaced with filters that\n\t *    are.\n\t * b) otherwise, if we have any active VLANS, all filters\n\t *    which are marked as VLAN=-1 must be replaced with\n\t *    filters marked as VLAN=0\n\t * c) finally, if we do not have any active VLANS, all filters\n\t *    which are marked as VLAN=0 must be replaced with filters\n\t *    marked as VLAN=-1\n\t */\n\n\t/* Update the filters about to be added in place */\n\thlist_for_each_entry(new, tmp_add_list, hlist) {\n\t\tif (pvid && new->f->vlan != pvid)\n\t\t\tnew->f->vlan = pvid;\n\t\telse if (vlan_filters && new->f->vlan == I40E_VLAN_ANY)\n\t\t\tnew->f->vlan = 0;\n\t\telse if (!vlan_filters && new->f->vlan == 0)\n\t\t\tnew->f->vlan = I40E_VLAN_ANY;\n\t}\n\n\t/* Update the remaining active filters */\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\t/* Combine the checks for whether a filter needs to be changed\n\t\t * and then determine the new VLAN inside the if block, in\n\t\t * order to avoid duplicating code for adding the new filter\n\t\t * then deleting the old filter.\n\t\t */\n\t\tif ((pvid && f->vlan != pvid) ||\n\t\t    (vlan_filters && f->vlan == I40E_VLAN_ANY) ||\n\t\t    (!vlan_filters && f->vlan == 0)) {\n\t\t\t/* Determine the new vlan we will be adding */\n\t\t\tif (pvid)\n\t\t\t\tnew_vlan = pvid;\n\t\t\telse if (vlan_filters)\n\t\t\t\tnew_vlan = 0;\n\t\t\telse\n\t\t\t\tnew_vlan = I40E_VLAN_ANY;\n\n\t\t\t/* Create the new filter */\n\t\t\tadd_head = i40e_add_filter(vsi, f->macaddr, new_vlan);\n\t\t\tif (!add_head)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t/* Create a temporary i40e_new_mac_filter */\n\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\tif (!new)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnew->f = add_head;\n\t\t\tnew->state = add_head->state;\n\n\t\t\t/* Add the new filter to the tmp list */\n\t\t\thlist_add_head(&new->hlist, tmp_add_list);\n\n\t\t\t/* Put the original filter into the delete list */\n\t\t\tf->state = I40E_FILTER_REMOVE;\n\t\t\thash_del(&f->hlist);\n\t\t\thlist_add_head(&f->hlist, tmp_del_list);\n\t\t}\n\t}\n\n\tvsi->has_vlan_filter = !!vlan_filters;\n\n\treturn 0;\n}\n\n/**\n * i40e_rm_default_mac_filter - Remove the default MAC filter set by NVM\n * @vsi: the PF Main VSI - inappropriate for any other VSI\n * @macaddr: the MAC address\n *\n * Remove whatever filter the firmware set up so the driver can manage\n * its own filtering intelligently.\n **/\nstatic void i40e_rm_default_mac_filter(struct i40e_vsi *vsi, u8 *macaddr)\n{\n\tstruct i40e_aqc_remove_macvlan_element_data element;\n\tstruct i40e_pf *pf = vsi->back;\n\n\t/* Only appropriate for the PF main VSI */\n\tif (vsi->type != I40E_VSI_MAIN)\n\t\treturn;\n\n\tmemset(&element, 0, sizeof(element));\n\tether_addr_copy(element.mac_addr, macaddr);\n\telement.vlan_tag = 0;\n\t/* Ignore error returns, some firmware does it this way... */\n\telement.flags = I40E_AQC_MACVLAN_DEL_PERFECT_MATCH;\n\ti40e_aq_remove_macvlan(&pf->hw, vsi->seid, &element, 1, NULL);\n\n\tmemset(&element, 0, sizeof(element));\n\tether_addr_copy(element.mac_addr, macaddr);\n\telement.vlan_tag = 0;\n\t/* ...and some firmware does it this way. */\n\telement.flags = I40E_AQC_MACVLAN_DEL_PERFECT_MATCH |\n\t\t\tI40E_AQC_MACVLAN_DEL_IGNORE_VLAN;\n\ti40e_aq_remove_macvlan(&pf->hw, vsi->seid, &element, 1, NULL);\n}\n\n/**\n * i40e_add_filter - Add a mac/vlan filter to the VSI\n * @vsi: the VSI to be searched\n * @macaddr: the MAC address\n * @vlan: the vlan\n *\n * Returns ptr to the filter object or NULL when no memory available.\n *\n * NOTE: This function is expected to be called with mac_filter_hash_lock\n * being held.\n **/\nstruct i40e_mac_filter *i40e_add_filter(struct i40e_vsi *vsi,\n\t\t\t\t\tconst u8 *macaddr, s16 vlan)\n{\n\tstruct i40e_mac_filter *f;\n\tu64 key;\n\n\tif (!vsi || !macaddr)\n\t\treturn NULL;\n\n\tf = i40e_find_filter(vsi, macaddr, vlan);\n\tif (!f) {\n\t\tf = kzalloc(sizeof(*f), GFP_ATOMIC);\n\t\tif (!f)\n\t\t\treturn NULL;\n\n\t\t/* Update the boolean indicating if we need to function in\n\t\t * VLAN mode.\n\t\t */\n\t\tif (vlan >= 0)\n\t\t\tvsi->has_vlan_filter = true;\n\n\t\tether_addr_copy(f->macaddr, macaddr);\n\t\tf->vlan = vlan;\n\t\tf->state = I40E_FILTER_NEW;\n\t\tINIT_HLIST_NODE(&f->hlist);\n\n\t\tkey = i40e_addr_to_hkey(macaddr);\n\t\thash_add(vsi->mac_filter_hash, &f->hlist, key);\n\n\t\tvsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\t\tset_bit(__I40E_MACVLAN_SYNC_PENDING, vsi->back->state);\n\t}\n\n\t/* If we're asked to add a filter that has been marked for removal, it\n\t * is safe to simply restore it to active state. __i40e_del_filter\n\t * will have simply deleted any filters which were previously marked\n\t * NEW or FAILED, so if it is currently marked REMOVE it must have\n\t * previously been ACTIVE. Since we haven't yet run the sync filters\n\t * task, just restore this filter to the ACTIVE state so that the\n\t * sync task leaves it in place\n\t */\n\tif (f->state == I40E_FILTER_REMOVE)\n\t\tf->state = I40E_FILTER_ACTIVE;\n\n\treturn f;\n}\n\n/**\n * __i40e_del_filter - Remove a specific filter from the VSI\n * @vsi: VSI to remove from\n * @f: the filter to remove from the list\n *\n * This function should be called instead of i40e_del_filter only if you know\n * the exact filter you will remove already, such as via i40e_find_filter or\n * i40e_find_mac.\n *\n * NOTE: This function is expected to be called with mac_filter_hash_lock\n * being held.\n * ANOTHER NOTE: This function MUST be called from within the context of\n * the \"safe\" variants of any list iterators, e.g. list_for_each_entry_safe()\n * instead of list_for_each_entry().\n **/\nvoid __i40e_del_filter(struct i40e_vsi *vsi, struct i40e_mac_filter *f)\n{\n\tif (!f)\n\t\treturn;\n\n\t/* If the filter was never added to firmware then we can just delete it\n\t * directly and we don't want to set the status to remove or else an\n\t * admin queue command will unnecessarily fire.\n\t */\n\tif ((f->state == I40E_FILTER_FAILED) ||\n\t    (f->state == I40E_FILTER_NEW)) {\n\t\thash_del(&f->hlist);\n\t\tkfree(f);\n\t} else {\n\t\tf->state = I40E_FILTER_REMOVE;\n\t}\n\n\tvsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\tset_bit(__I40E_MACVLAN_SYNC_PENDING, vsi->back->state);\n}\n\n/**\n * i40e_del_filter - Remove a MAC/VLAN filter from the VSI\n * @vsi: the VSI to be searched\n * @macaddr: the MAC address\n * @vlan: the VLAN\n *\n * NOTE: This function is expected to be called with mac_filter_hash_lock\n * being held.\n * ANOTHER NOTE: This function MUST be called from within the context of\n * the \"safe\" variants of any list iterators, e.g. list_for_each_entry_safe()\n * instead of list_for_each_entry().\n **/\nvoid i40e_del_filter(struct i40e_vsi *vsi, const u8 *macaddr, s16 vlan)\n{\n\tstruct i40e_mac_filter *f;\n\n\tif (!vsi || !macaddr)\n\t\treturn;\n\n\tf = i40e_find_filter(vsi, macaddr, vlan);\n\t__i40e_del_filter(vsi, f);\n}\n\n/**\n * i40e_add_mac_filter - Add a MAC filter for all active VLANs\n * @vsi: the VSI to be searched\n * @macaddr: the mac address to be filtered\n *\n * If we're not in VLAN mode, just add the filter to I40E_VLAN_ANY. Otherwise,\n * go through all the macvlan filters and add a macvlan filter for each\n * unique vlan that already exists. If a PVID has been assigned, instead only\n * add the macaddr to that VLAN.\n *\n * Returns last filter added on success, else NULL\n **/\nstruct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,\n\t\t\t\t\t    const u8 *macaddr)\n{\n\tstruct i40e_mac_filter *f, *add = NULL;\n\tstruct hlist_node *h;\n\tint bkt;\n\n\tif (vsi->info.pvid)\n\t\treturn i40e_add_filter(vsi, macaddr,\n\t\t\t\t       le16_to_cpu(vsi->info.pvid));\n\n\tif (!i40e_is_vsi_in_vlan(vsi))\n\t\treturn i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);\n\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\tif (f->state == I40E_FILTER_REMOVE)\n\t\t\tcontinue;\n\t\tadd = i40e_add_filter(vsi, macaddr, f->vlan);\n\t\tif (!add)\n\t\t\treturn NULL;\n\t}\n\n\treturn add;\n}\n\n/**\n * i40e_del_mac_filter - Remove a MAC filter from all VLANs\n * @vsi: the VSI to be searched\n * @macaddr: the mac address to be removed\n *\n * Removes a given MAC address from a VSI regardless of what VLAN it has been\n * associated with.\n *\n * Returns 0 for success, or error\n **/\nint i40e_del_mac_filter(struct i40e_vsi *vsi, const u8 *macaddr)\n{\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\tbool found = false;\n\tint bkt;\n\n\tlockdep_assert_held(&vsi->mac_filter_hash_lock);\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\tif (ether_addr_equal(macaddr, f->macaddr)) {\n\t\t\t__i40e_del_filter(vsi, f);\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn 0;\n\telse\n\t\treturn -ENOENT;\n}\n\n/**\n * i40e_set_mac - NDO callback to set mac address\n * @netdev: network interface device structure\n * @p: pointer to an address structure\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int i40e_set_mac(struct net_device *netdev, void *p)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (ether_addr_equal(netdev->dev_addr, addr->sa_data)) {\n\t\tnetdev_info(netdev, \"already using mac address %pM\\n\",\n\t\t\t    addr->sa_data);\n\t\treturn 0;\n\t}\n\n\tif (test_bit(__I40E_DOWN, pf->state) ||\n\t    test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (ether_addr_equal(hw->mac.addr, addr->sa_data))\n\t\tnetdev_info(netdev, \"returning to hw mac address %pM\\n\",\n\t\t\t    hw->mac.addr);\n\telse\n\t\tnetdev_info(netdev, \"set new mac address %pM\\n\", addr->sa_data);\n\n\t/* Copy the address first, so that we avoid a possible race with\n\t * .set_rx_mode().\n\t * - Remove old address from MAC filter\n\t * - Copy new address\n\t * - Add new address to MAC filter\n\t */\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\ti40e_del_mac_filter(vsi, netdev->dev_addr);\n\tether_addr_copy(netdev->dev_addr, addr->sa_data);\n\ti40e_add_mac_filter(vsi, netdev->dev_addr);\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\tif (vsi->type == I40E_VSI_MAIN) {\n\t\ti40e_status ret;\n\n\t\tret = i40e_aq_mac_address_write(hw, I40E_AQC_WRITE_TYPE_LAA_WOL,\n\t\t\t\t\t\taddr->sa_data, NULL);\n\t\tif (ret)\n\t\t\tnetdev_info(netdev, \"Ignoring error from firmware on LAA update, status %s, AQ ret %s\\n\",\n\t\t\t\t    i40e_stat_str(hw, ret),\n\t\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t}\n\n\t/* schedule our worker thread which will take care of\n\t * applying the new filter changes\n\t */\n\ti40e_service_event_schedule(pf);\n\treturn 0;\n}\n\n/**\n * i40e_config_rss_aq - Prepare for RSS using AQ commands\n * @vsi: vsi structure\n * @seed: RSS hash seed\n * @lut: pointer to lookup table of lut_size\n * @lut_size: size of the lookup table\n **/\nstatic int i40e_config_rss_aq(struct i40e_vsi *vsi, const u8 *seed,\n\t\t\t      u8 *lut, u16 lut_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint ret = 0;\n\n\tif (seed) {\n\t\tstruct i40e_aqc_get_set_rss_key_data *seed_dw =\n\t\t\t(struct i40e_aqc_get_set_rss_key_data *)seed;\n\t\tret = i40e_aq_set_rss_key(hw, vsi->id, seed_dw);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Cannot set RSS key, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(hw, ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (lut) {\n\t\tbool pf_lut = vsi->type == I40E_VSI_MAIN;\n\n\t\tret = i40e_aq_set_rss_lut(hw, vsi->id, pf_lut, lut, lut_size);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Cannot set RSS lut, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(hw, ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/**\n * i40e_vsi_config_rss - Prepare for VSI(VMDq) RSS if used\n * @vsi: VSI structure\n **/\nstatic int i40e_vsi_config_rss(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tu8 seed[I40E_HKEY_ARRAY_SIZE];\n\tu8 *lut;\n\tint ret;\n\n\tif (!(pf->hw_features & I40E_HW_RSS_AQ_CAPABLE))\n\t\treturn 0;\n\tif (!vsi->rss_size)\n\t\tvsi->rss_size = min_t(int, pf->alloc_rss_size,\n\t\t\t\t      vsi->num_queue_pairs);\n\tif (!vsi->rss_size)\n\t\treturn -EINVAL;\n\tlut = kzalloc(vsi->rss_table_size, GFP_KERNEL);\n\tif (!lut)\n\t\treturn -ENOMEM;\n\n\t/* Use the user configured hash keys and lookup table if there is one,\n\t * otherwise use default\n\t */\n\tif (vsi->rss_lut_user)\n\t\tmemcpy(lut, vsi->rss_lut_user, vsi->rss_table_size);\n\telse\n\t\ti40e_fill_rss_lut(pf, lut, vsi->rss_table_size, vsi->rss_size);\n\tif (vsi->rss_hkey_user)\n\t\tmemcpy(seed, vsi->rss_hkey_user, I40E_HKEY_ARRAY_SIZE);\n\telse\n\t\tnetdev_rss_key_fill((void *)seed, I40E_HKEY_ARRAY_SIZE);\n\tret = i40e_config_rss_aq(vsi, seed, lut, vsi->rss_table_size);\n\tkfree(lut);\n\treturn ret;\n}\n\n/**\n * i40e_vsi_setup_queue_map_mqprio - Prepares mqprio based tc_config\n * @vsi: the VSI being configured,\n * @ctxt: VSI context structure\n * @enabled_tc: number of traffic classes to enable\n *\n * Prepares VSI tc_config to have queue configurations based on MQPRIO options.\n **/\nstatic int i40e_vsi_setup_queue_map_mqprio(struct i40e_vsi *vsi,\n\t\t\t\t\t   struct i40e_vsi_context *ctxt,\n\t\t\t\t\t   u8 enabled_tc)\n{\n\tu16 qcount = 0, max_qcount, qmap, sections = 0;\n\tint i, override_q, pow, num_qps, ret;\n\tu8 netdev_tc = 0, offset = 0;\n\n\tif (vsi->type != I40E_VSI_MAIN)\n\t\treturn -EINVAL;\n\tsections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;\n\tsections |= I40E_AQ_VSI_PROP_SCHED_VALID;\n\tvsi->tc_config.numtc = vsi->mqprio_qopt.qopt.num_tc;\n\tvsi->tc_config.enabled_tc = enabled_tc ? enabled_tc : 1;\n\tnum_qps = vsi->mqprio_qopt.qopt.count[0];\n\n\t/* find the next higher power-of-2 of num queue pairs */\n\tpow = ilog2(num_qps);\n\tif (!is_power_of_2(num_qps))\n\t\tpow++;\n\tqmap = (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |\n\t\t(pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);\n\n\t/* Setup queue offset/count for all TCs for given VSI */\n\tmax_qcount = vsi->mqprio_qopt.qopt.count[0];\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t/* See if the given TC is enabled for the given VSI */\n\t\tif (vsi->tc_config.enabled_tc & BIT(i)) {\n\t\t\toffset = vsi->mqprio_qopt.qopt.offset[i];\n\t\t\tqcount = vsi->mqprio_qopt.qopt.count[i];\n\t\t\tif (qcount > max_qcount)\n\t\t\t\tmax_qcount = qcount;\n\t\t\tvsi->tc_config.tc_info[i].qoffset = offset;\n\t\t\tvsi->tc_config.tc_info[i].qcount = qcount;\n\t\t\tvsi->tc_config.tc_info[i].netdev_tc = netdev_tc++;\n\t\t} else {\n\t\t\t/* TC is not enabled so set the offset to\n\t\t\t * default queue and allocate one queue\n\t\t\t * for the given TC.\n\t\t\t */\n\t\t\tvsi->tc_config.tc_info[i].qoffset = 0;\n\t\t\tvsi->tc_config.tc_info[i].qcount = 1;\n\t\t\tvsi->tc_config.tc_info[i].netdev_tc = 0;\n\t\t}\n\t}\n\n\t/* Set actual Tx/Rx queue pairs */\n\tvsi->num_queue_pairs = offset + qcount;\n\n\t/* Setup queue TC[0].qmap for given VSI context */\n\tctxt->info.tc_mapping[0] = cpu_to_le16(qmap);\n\tctxt->info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);\n\tctxt->info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);\n\tctxt->info.valid_sections |= cpu_to_le16(sections);\n\n\t/* Reconfigure RSS for main VSI with max queue count */\n\tvsi->rss_size = max_qcount;\n\tret = i40e_vsi_config_rss(vsi);\n\tif (ret) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed to reconfig rss for num_queues (%u)\\n\",\n\t\t\t max_qcount);\n\t\treturn ret;\n\t}\n\tvsi->reconfig_rss = true;\n\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\"Reconfigured rss with num_queues (%u)\\n\", max_qcount);\n\n\t/* Find queue count available for channel VSIs and starting offset\n\t * for channel VSIs\n\t */\n\toverride_q = vsi->mqprio_qopt.qopt.count[0];\n\tif (override_q && override_q < vsi->num_queue_pairs) {\n\t\tvsi->cnt_q_avail = vsi->num_queue_pairs - override_q;\n\t\tvsi->next_base_queue = override_q;\n\t}\n\treturn 0;\n}\n\n/**\n * i40e_vsi_setup_queue_map - Setup a VSI queue map based on enabled_tc\n * @vsi: the VSI being setup\n * @ctxt: VSI context structure\n * @enabled_tc: Enabled TCs bitmap\n * @is_add: True if called before Add VSI\n *\n * Setup VSI queue mapping for enabled traffic classes.\n **/\nstatic void i40e_vsi_setup_queue_map(struct i40e_vsi *vsi,\n\t\t\t\t     struct i40e_vsi_context *ctxt,\n\t\t\t\t     u8 enabled_tc,\n\t\t\t\t     bool is_add)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tu16 sections = 0;\n\tu8 netdev_tc = 0;\n\tu16 numtc = 1;\n\tu16 qcount;\n\tu8 offset;\n\tu16 qmap;\n\tint i;\n\tu16 num_tc_qps = 0;\n\n\tsections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;\n\toffset = 0;\n\n\t/* Number of queues per enabled TC */\n\tnum_tc_qps = vsi->alloc_queue_pairs;\n\tif (enabled_tc && (vsi->back->flags & I40E_FLAG_DCB_ENABLED)) {\n\t\t/* Find numtc from enabled TC bitmap */\n\t\tfor (i = 0, numtc = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t\tif (enabled_tc & BIT(i)) /* TC is enabled */\n\t\t\t\tnumtc++;\n\t\t}\n\t\tif (!numtc) {\n\t\t\tdev_warn(&pf->pdev->dev, \"DCB is enabled but no TC enabled, forcing TC0\\n\");\n\t\t\tnumtc = 1;\n\t\t}\n\t\tnum_tc_qps = num_tc_qps / numtc;\n\t\tnum_tc_qps = min_t(int, num_tc_qps,\n\t\t\t\t   i40e_pf_get_max_q_per_tc(pf));\n\t}\n\n\tvsi->tc_config.numtc = numtc;\n\tvsi->tc_config.enabled_tc = enabled_tc ? enabled_tc : 1;\n\n\t/* Do not allow use more TC queue pairs than MSI-X vectors exist */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\tnum_tc_qps = min_t(int, num_tc_qps, pf->num_lan_msix);\n\n\t/* Setup queue offset/count for all TCs for given VSI */\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t/* See if the given TC is enabled for the given VSI */\n\t\tif (vsi->tc_config.enabled_tc & BIT(i)) {\n\t\t\t/* TC is enabled */\n\t\t\tint pow, num_qps;\n\n\t\t\tswitch (vsi->type) {\n\t\t\tcase I40E_VSI_MAIN:\n\t\t\t\tif (!(pf->flags & (I40E_FLAG_FD_SB_ENABLED |\n\t\t\t\t    I40E_FLAG_FD_ATR_ENABLED)) ||\n\t\t\t\t    vsi->tc_config.enabled_tc != 1) {\n\t\t\t\t\tqcount = min_t(int, pf->alloc_rss_size,\n\t\t\t\t\t\t       num_tc_qps);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase I40E_VSI_FDIR:\n\t\t\tcase I40E_VSI_SRIOV:\n\t\t\tcase I40E_VSI_VMDQ2:\n\t\t\tdefault:\n\t\t\t\tqcount = num_tc_qps;\n\t\t\t\tWARN_ON(i != 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvsi->tc_config.tc_info[i].qoffset = offset;\n\t\t\tvsi->tc_config.tc_info[i].qcount = qcount;\n\n\t\t\t/* find the next higher power-of-2 of num queue pairs */\n\t\t\tnum_qps = qcount;\n\t\t\tpow = 0;\n\t\t\twhile (num_qps && (BIT_ULL(pow) < qcount)) {\n\t\t\t\tpow++;\n\t\t\t\tnum_qps >>= 1;\n\t\t\t}\n\n\t\t\tvsi->tc_config.tc_info[i].netdev_tc = netdev_tc++;\n\t\t\tqmap =\n\t\t\t    (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |\n\t\t\t    (pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);\n\n\t\t\toffset += qcount;\n\t\t} else {\n\t\t\t/* TC is not enabled so set the offset to\n\t\t\t * default queue and allocate one queue\n\t\t\t * for the given TC.\n\t\t\t */\n\t\t\tvsi->tc_config.tc_info[i].qoffset = 0;\n\t\t\tvsi->tc_config.tc_info[i].qcount = 1;\n\t\t\tvsi->tc_config.tc_info[i].netdev_tc = 0;\n\n\t\t\tqmap = 0;\n\t\t}\n\t\tctxt->info.tc_mapping[i] = cpu_to_le16(qmap);\n\t}\n\n\t/* Set actual Tx/Rx queue pairs */\n\tvsi->num_queue_pairs = offset;\n\tif ((vsi->type == I40E_VSI_MAIN) && (numtc == 1)) {\n\t\tif (vsi->req_queue_pairs > 0)\n\t\t\tvsi->num_queue_pairs = vsi->req_queue_pairs;\n\t\telse if (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\t\tvsi->num_queue_pairs = pf->num_lan_msix;\n\t}\n\n\t/* Scheduler section valid can only be set for ADD VSI */\n\tif (is_add) {\n\t\tsections |= I40E_AQ_VSI_PROP_SCHED_VALID;\n\n\t\tctxt->info.up_enable_bits = enabled_tc;\n\t}\n\tif (vsi->type == I40E_VSI_SRIOV) {\n\t\tctxt->info.mapping_flags |=\n\t\t\t\t     cpu_to_le16(I40E_AQ_VSI_QUE_MAP_NONCONTIG);\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\t\tctxt->info.queue_mapping[i] =\n\t\t\t\t\t       cpu_to_le16(vsi->base_queue + i);\n\t} else {\n\t\tctxt->info.mapping_flags |=\n\t\t\t\t\tcpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);\n\t\tctxt->info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);\n\t}\n\tctxt->info.valid_sections |= cpu_to_le16(sections);\n}\n\n/**\n * i40e_addr_sync - Callback for dev_(mc|uc)_sync to add address\n * @netdev: the netdevice\n * @addr: address to add\n *\n * Called by __dev_(mc|uc)_sync when an address needs to be added. We call\n * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.\n */\nstatic int i40e_addr_sync(struct net_device *netdev, const u8 *addr)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\tif (i40e_add_mac_filter(vsi, addr))\n\t\treturn 0;\n\telse\n\t\treturn -ENOMEM;\n}\n\n/**\n * i40e_addr_unsync - Callback for dev_(mc|uc)_sync to remove address\n * @netdev: the netdevice\n * @addr: address to add\n *\n * Called by __dev_(mc|uc)_sync when an address needs to be removed. We call\n * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.\n */\nstatic int i40e_addr_unsync(struct net_device *netdev, const u8 *addr)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\t/* Under some circumstances, we might receive a request to delete\n\t * our own device address from our uc list. Because we store the\n\t * device address in the VSI's MAC/VLAN filter list, we need to ignore\n\t * such requests and not delete our device address from this list.\n\t */\n\tif (ether_addr_equal(addr, netdev->dev_addr))\n\t\treturn 0;\n\n\ti40e_del_mac_filter(vsi, addr);\n\n\treturn 0;\n}\n\n/**\n * i40e_set_rx_mode - NDO callback to set the netdev filters\n * @netdev: network interface device structure\n **/\nstatic void i40e_set_rx_mode(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\n\t__dev_uc_sync(netdev, i40e_addr_sync, i40e_addr_unsync);\n\t__dev_mc_sync(netdev, i40e_addr_sync, i40e_addr_unsync);\n\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\t/* check for other flag changes */\n\tif (vsi->current_netdev_flags != vsi->netdev->flags) {\n\t\tvsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\t\tset_bit(__I40E_MACVLAN_SYNC_PENDING, vsi->back->state);\n\t}\n}\n\n/**\n * i40e_undo_del_filter_entries - Undo the changes made to MAC filter entries\n * @vsi: Pointer to VSI struct\n * @from: Pointer to list which contains MAC filter entries - changes to\n *        those entries needs to be undone.\n *\n * MAC filter entries from this list were slated for deletion.\n **/\nstatic void i40e_undo_del_filter_entries(struct i40e_vsi *vsi,\n\t\t\t\t\t struct hlist_head *from)\n{\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\n\thlist_for_each_entry_safe(f, h, from, hlist) {\n\t\tu64 key = i40e_addr_to_hkey(f->macaddr);\n\n\t\t/* Move the element back into MAC filter list*/\n\t\thlist_del(&f->hlist);\n\t\thash_add(vsi->mac_filter_hash, &f->hlist, key);\n\t}\n}\n\n/**\n * i40e_undo_add_filter_entries - Undo the changes made to MAC filter entries\n * @vsi: Pointer to vsi struct\n * @from: Pointer to list which contains MAC filter entries - changes to\n *        those entries needs to be undone.\n *\n * MAC filter entries from this list were slated for addition.\n **/\nstatic void i40e_undo_add_filter_entries(struct i40e_vsi *vsi,\n\t\t\t\t\t struct hlist_head *from)\n{\n\tstruct i40e_new_mac_filter *new;\n\tstruct hlist_node *h;\n\n\thlist_for_each_entry_safe(new, h, from, hlist) {\n\t\t/* We can simply free the wrapper structure */\n\t\thlist_del(&new->hlist);\n\t\tkfree(new);\n\t}\n}\n\n/**\n * i40e_next_entry - Get the next non-broadcast filter from a list\n * @next: pointer to filter in list\n *\n * Returns the next non-broadcast filter in the list. Required so that we\n * ignore broadcast filters within the list, since these are not handled via\n * the normal firmware update path.\n */\nstatic\nstruct i40e_new_mac_filter *i40e_next_filter(struct i40e_new_mac_filter *next)\n{\n\thlist_for_each_entry_continue(next, hlist) {\n\t\tif (!is_broadcast_ether_addr(next->f->macaddr))\n\t\t\treturn next;\n\t}\n\n\treturn NULL;\n}\n\n/**\n * i40e_update_filter_state - Update filter state based on return data\n * from firmware\n * @count: Number of filters added\n * @add_list: return data from fw\n * @add_head: pointer to first filter in current batch\n *\n * MAC filter entries from list were slated to be added to device. Returns\n * number of successful filters. Note that 0 does NOT mean success!\n **/\nstatic int\ni40e_update_filter_state(int count,\n\t\t\t struct i40e_aqc_add_macvlan_element_data *add_list,\n\t\t\t struct i40e_new_mac_filter *add_head)\n{\n\tint retval = 0;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* Always check status of each filter. We don't need to check\n\t\t * the firmware return status because we pre-set the filter\n\t\t * status to I40E_AQC_MM_ERR_NO_RES when sending the filter\n\t\t * request to the adminq. Thus, if it no longer matches then\n\t\t * we know the filter is active.\n\t\t */\n\t\tif (add_list[i].match_method == I40E_AQC_MM_ERR_NO_RES) {\n\t\t\tadd_head->state = I40E_FILTER_FAILED;\n\t\t} else {\n\t\t\tadd_head->state = I40E_FILTER_ACTIVE;\n\t\t\tretval++;\n\t\t}\n\n\t\tadd_head = i40e_next_filter(add_head);\n\t\tif (!add_head)\n\t\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/**\n * i40e_aqc_del_filters - Request firmware to delete a set of filters\n * @vsi: ptr to the VSI\n * @vsi_name: name to display in messages\n * @list: the list of filters to send to firmware\n * @num_del: the number of filters to delete\n * @retval: Set to -EIO on failure to delete\n *\n * Send a request to firmware via AdminQ to delete a set of filters. Uses\n * *retval instead of a return value so that success does not force ret_val to\n * be set to 0. This ensures that a sequence of calls to this function\n * preserve the previous value of *retval on successful delete.\n */\nstatic\nvoid i40e_aqc_del_filters(struct i40e_vsi *vsi, const char *vsi_name,\n\t\t\t  struct i40e_aqc_remove_macvlan_element_data *list,\n\t\t\t  int num_del, int *retval)\n{\n\tstruct i40e_hw *hw = &vsi->back->hw;\n\ti40e_status aq_ret;\n\tint aq_err;\n\n\taq_ret = i40e_aq_remove_macvlan(hw, vsi->seid, list, num_del, NULL);\n\taq_err = hw->aq.asq_last_status;\n\n\t/* Explicitly ignore and do not report when firmware returns ENOENT */\n\tif (aq_ret && !(aq_err == I40E_AQ_RC_ENOENT)) {\n\t\t*retval = -EIO;\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"ignoring delete macvlan error on %s, err %s, aq_err %s\\n\",\n\t\t\t vsi_name, i40e_stat_str(hw, aq_ret),\n\t\t\t i40e_aq_str(hw, aq_err));\n\t}\n}\n\n/**\n * i40e_aqc_add_filters - Request firmware to add a set of filters\n * @vsi: ptr to the VSI\n * @vsi_name: name to display in messages\n * @list: the list of filters to send to firmware\n * @add_head: Position in the add hlist\n * @num_add: the number of filters to add\n *\n * Send a request to firmware via AdminQ to add a chunk of filters. Will set\n * __I40E_VSI_OVERFLOW_PROMISC bit in vsi->state if the firmware has run out of\n * space for more filters.\n */\nstatic\nvoid i40e_aqc_add_filters(struct i40e_vsi *vsi, const char *vsi_name,\n\t\t\t  struct i40e_aqc_add_macvlan_element_data *list,\n\t\t\t  struct i40e_new_mac_filter *add_head,\n\t\t\t  int num_add)\n{\n\tstruct i40e_hw *hw = &vsi->back->hw;\n\tint aq_err, fcnt;\n\n\ti40e_aq_add_macvlan(hw, vsi->seid, list, num_add, NULL);\n\taq_err = hw->aq.asq_last_status;\n\tfcnt = i40e_update_filter_state(num_add, list, add_head);\n\n\tif (fcnt != num_add) {\n\t\tif (vsi->type == I40E_VSI_MAIN) {\n\t\t\tset_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\t\t\tdev_warn(&vsi->back->pdev->dev,\n\t\t\t\t \"Error %s adding RX filters on %s, promiscuous mode forced on\\n\",\n\t\t\t\t i40e_aq_str(hw, aq_err), vsi_name);\n\t\t} else if (vsi->type == I40E_VSI_SRIOV ||\n\t\t\t   vsi->type == I40E_VSI_VMDQ1 ||\n\t\t\t   vsi->type == I40E_VSI_VMDQ2) {\n\t\t\tdev_warn(&vsi->back->pdev->dev,\n\t\t\t\t \"Error %s adding RX filters on %s, please set promiscuous on manually for %s\\n\",\n\t\t\t\t i40e_aq_str(hw, aq_err), vsi_name, vsi_name);\n\t\t} else {\n\t\t\tdev_warn(&vsi->back->pdev->dev,\n\t\t\t\t \"Error %s adding RX filters on %s, incorrect VSI type: %i.\\n\",\n\t\t\t\t i40e_aq_str(hw, aq_err), vsi_name, vsi->type);\n\t\t}\n\t}\n}\n\n/**\n * i40e_aqc_broadcast_filter - Set promiscuous broadcast flags\n * @vsi: pointer to the VSI\n * @vsi_name: the VSI name\n * @f: filter data\n *\n * This function sets or clears the promiscuous broadcast flags for VLAN\n * filters in order to properly receive broadcast frames. Assumes that only\n * broadcast filters are passed.\n *\n * Returns status indicating success or failure;\n **/\nstatic i40e_status\ni40e_aqc_broadcast_filter(struct i40e_vsi *vsi, const char *vsi_name,\n\t\t\t  struct i40e_mac_filter *f)\n{\n\tbool enable = f->state == I40E_FILTER_NEW;\n\tstruct i40e_hw *hw = &vsi->back->hw;\n\ti40e_status aq_ret;\n\n\tif (f->vlan == I40E_VLAN_ANY) {\n\t\taq_ret = i40e_aq_set_vsi_broadcast(hw,\n\t\t\t\t\t\t   vsi->seid,\n\t\t\t\t\t\t   enable,\n\t\t\t\t\t\t   NULL);\n\t} else {\n\t\taq_ret = i40e_aq_set_vsi_bc_promisc_on_vlan(hw,\n\t\t\t\t\t\t\t    vsi->seid,\n\t\t\t\t\t\t\t    enable,\n\t\t\t\t\t\t\t    f->vlan,\n\t\t\t\t\t\t\t    NULL);\n\t}\n\n\tif (aq_ret) {\n\t\tset_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\t\tdev_warn(&vsi->back->pdev->dev,\n\t\t\t \"Error %s, forcing overflow promiscuous on %s\\n\",\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status),\n\t\t\t vsi_name);\n\t}\n\n\treturn aq_ret;\n}\n\n/**\n * i40e_set_promiscuous - set promiscuous mode\n * @pf: board private structure\n * @promisc: promisc on or off\n *\n * There are different ways of setting promiscuous mode on a PF depending on\n * what state/environment we're in.  This identifies and sets it appropriately.\n * Returns 0 on success.\n **/\nstatic int i40e_set_promiscuous(struct i40e_pf *pf, bool promisc)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status aq_ret;\n\n\tif (vsi->type == I40E_VSI_MAIN &&\n\t    pf->lan_veb != I40E_NO_VEB &&\n\t    !(pf->flags & I40E_FLAG_MFP_ENABLED)) {\n\t\t/* set defport ON for Main VSI instead of true promisc\n\t\t * this way we will get all unicast/multicast and VLAN\n\t\t * promisc behavior but will not get VF or VMDq traffic\n\t\t * replicated on the Main VSI.\n\t\t */\n\t\tif (promisc)\n\t\t\taq_ret = i40e_aq_set_default_vsi(hw,\n\t\t\t\t\t\t\t vsi->seid,\n\t\t\t\t\t\t\t NULL);\n\t\telse\n\t\t\taq_ret = i40e_aq_clear_default_vsi(hw,\n\t\t\t\t\t\t\t   vsi->seid,\n\t\t\t\t\t\t\t   NULL);\n\t\tif (aq_ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Set default VSI failed, err %s, aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(hw, aq_ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t}\n\t} else {\n\t\taq_ret = i40e_aq_set_vsi_unicast_promiscuous(\n\t\t\t\t\t\t  hw,\n\t\t\t\t\t\t  vsi->seid,\n\t\t\t\t\t\t  promisc, NULL,\n\t\t\t\t\t\t  true);\n\t\tif (aq_ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"set unicast promisc failed, err %s, aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(hw, aq_ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t}\n\t\taq_ret = i40e_aq_set_vsi_multicast_promiscuous(\n\t\t\t\t\t\t  hw,\n\t\t\t\t\t\t  vsi->seid,\n\t\t\t\t\t\t  promisc, NULL);\n\t\tif (aq_ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"set multicast promisc failed, err %s, aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(hw, aq_ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t}\n\t}\n\n\tif (!aq_ret)\n\t\tpf->cur_promisc = promisc;\n\n\treturn aq_ret;\n}\n\n/**\n * i40e_sync_vsi_filters - Update the VSI filter list to the HW\n * @vsi: ptr to the VSI\n *\n * Push any outstanding VSI filter changes through the AdminQ.\n *\n * Returns 0 or error value\n **/\nint i40e_sync_vsi_filters(struct i40e_vsi *vsi)\n{\n\tstruct hlist_head tmp_add_list, tmp_del_list;\n\tstruct i40e_mac_filter *f;\n\tstruct i40e_new_mac_filter *new, *add_head = NULL;\n\tstruct i40e_hw *hw = &vsi->back->hw;\n\tbool old_overflow, new_overflow;\n\tunsigned int failed_filters = 0;\n\tunsigned int vlan_filters = 0;\n\tchar vsi_name[16] = \"PF\";\n\tint filter_list_len = 0;\n\ti40e_status aq_ret = 0;\n\tu32 changed_flags = 0;\n\tstruct hlist_node *h;\n\tstruct i40e_pf *pf;\n\tint num_add = 0;\n\tint num_del = 0;\n\tint retval = 0;\n\tu16 cmd_flags;\n\tint list_size;\n\tint bkt;\n\n\t/* empty array typed pointers, kcalloc later */\n\tstruct i40e_aqc_add_macvlan_element_data *add_list;\n\tstruct i40e_aqc_remove_macvlan_element_data *del_list;\n\n\twhile (test_and_set_bit(__I40E_VSI_SYNCING_FILTERS, vsi->state))\n\t\tusleep_range(1000, 2000);\n\tpf = vsi->back;\n\n\told_overflow = test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\n\tif (vsi->netdev) {\n\t\tchanged_flags = vsi->current_netdev_flags ^ vsi->netdev->flags;\n\t\tvsi->current_netdev_flags = vsi->netdev->flags;\n\t}\n\n\tINIT_HLIST_HEAD(&tmp_add_list);\n\tINIT_HLIST_HEAD(&tmp_del_list);\n\n\tif (vsi->type == I40E_VSI_SRIOV)\n\t\tsnprintf(vsi_name, sizeof(vsi_name) - 1, \"VF %d\", vsi->vf_id);\n\telse if (vsi->type != I40E_VSI_MAIN)\n\t\tsnprintf(vsi_name, sizeof(vsi_name) - 1, \"vsi %d\", vsi->seid);\n\n\tif (vsi->flags & I40E_VSI_FLAG_FILTER_CHANGED) {\n\t\tvsi->flags &= ~I40E_VSI_FLAG_FILTER_CHANGED;\n\n\t\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t\t/* Create a list of filters to delete. */\n\t\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\t\tif (f->state == I40E_FILTER_REMOVE) {\n\t\t\t\t/* Move the element into temporary del_list */\n\t\t\t\thash_del(&f->hlist);\n\t\t\t\thlist_add_head(&f->hlist, &tmp_del_list);\n\n\t\t\t\t/* Avoid counting removed filters */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f->state == I40E_FILTER_NEW) {\n\t\t\t\t/* Create a temporary i40e_new_mac_filter */\n\t\t\t\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\t\t\t\tif (!new)\n\t\t\t\t\tgoto err_no_memory_locked;\n\n\t\t\t\t/* Store pointer to the real filter */\n\t\t\t\tnew->f = f;\n\t\t\t\tnew->state = f->state;\n\n\t\t\t\t/* Add it to the hash list */\n\t\t\t\thlist_add_head(&new->hlist, &tmp_add_list);\n\t\t\t}\n\n\t\t\t/* Count the number of active (current and new) VLAN\n\t\t\t * filters we have now. Does not count filters which\n\t\t\t * are marked for deletion.\n\t\t\t */\n\t\t\tif (f->vlan > 0)\n\t\t\t\tvlan_filters++;\n\t\t}\n\n\t\tretval = i40e_correct_mac_vlan_filters(vsi,\n\t\t\t\t\t\t       &tmp_add_list,\n\t\t\t\t\t\t       &tmp_del_list,\n\t\t\t\t\t\t       vlan_filters);\n\t\tif (retval)\n\t\t\tgoto err_no_memory_locked;\n\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t}\n\n\t/* Now process 'del_list' outside the lock */\n\tif (!hlist_empty(&tmp_del_list)) {\n\t\tfilter_list_len = hw->aq.asq_buf_size /\n\t\t\t    sizeof(struct i40e_aqc_remove_macvlan_element_data);\n\t\tlist_size = filter_list_len *\n\t\t\t    sizeof(struct i40e_aqc_remove_macvlan_element_data);\n\t\tdel_list = kzalloc(list_size, GFP_ATOMIC);\n\t\tif (!del_list)\n\t\t\tgoto err_no_memory;\n\n\t\thlist_for_each_entry_safe(f, h, &tmp_del_list, hlist) {\n\t\t\tcmd_flags = 0;\n\n\t\t\t/* handle broadcast filters by updating the broadcast\n\t\t\t * promiscuous flag and release filter list.\n\t\t\t */\n\t\t\tif (is_broadcast_ether_addr(f->macaddr)) {\n\t\t\t\ti40e_aqc_broadcast_filter(vsi, vsi_name, f);\n\n\t\t\t\thlist_del(&f->hlist);\n\t\t\t\tkfree(f);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* add to delete list */\n\t\t\tether_addr_copy(del_list[num_del].mac_addr, f->macaddr);\n\t\t\tif (f->vlan == I40E_VLAN_ANY) {\n\t\t\t\tdel_list[num_del].vlan_tag = 0;\n\t\t\t\tcmd_flags |= I40E_AQC_MACVLAN_DEL_IGNORE_VLAN;\n\t\t\t} else {\n\t\t\t\tdel_list[num_del].vlan_tag =\n\t\t\t\t\tcpu_to_le16((u16)(f->vlan));\n\t\t\t}\n\n\t\t\tcmd_flags |= I40E_AQC_MACVLAN_DEL_PERFECT_MATCH;\n\t\t\tdel_list[num_del].flags = cmd_flags;\n\t\t\tnum_del++;\n\n\t\t\t/* flush a full buffer */\n\t\t\tif (num_del == filter_list_len) {\n\t\t\t\ti40e_aqc_del_filters(vsi, vsi_name, del_list,\n\t\t\t\t\t\t     num_del, &retval);\n\t\t\t\tmemset(del_list, 0, list_size);\n\t\t\t\tnum_del = 0;\n\t\t\t}\n\t\t\t/* Release memory for MAC filter entries which were\n\t\t\t * synced up with HW.\n\t\t\t */\n\t\t\thlist_del(&f->hlist);\n\t\t\tkfree(f);\n\t\t}\n\n\t\tif (num_del) {\n\t\t\ti40e_aqc_del_filters(vsi, vsi_name, del_list,\n\t\t\t\t\t     num_del, &retval);\n\t\t}\n\n\t\tkfree(del_list);\n\t\tdel_list = NULL;\n\t}\n\n\tif (!hlist_empty(&tmp_add_list)) {\n\t\t/* Do all the adds now. */\n\t\tfilter_list_len = hw->aq.asq_buf_size /\n\t\t\t       sizeof(struct i40e_aqc_add_macvlan_element_data);\n\t\tlist_size = filter_list_len *\n\t\t\t       sizeof(struct i40e_aqc_add_macvlan_element_data);\n\t\tadd_list = kzalloc(list_size, GFP_ATOMIC);\n\t\tif (!add_list)\n\t\t\tgoto err_no_memory;\n\n\t\tnum_add = 0;\n\t\thlist_for_each_entry_safe(new, h, &tmp_add_list, hlist) {\n\t\t\t/* handle broadcast filters by updating the broadcast\n\t\t\t * promiscuous flag instead of adding a MAC filter.\n\t\t\t */\n\t\t\tif (is_broadcast_ether_addr(new->f->macaddr)) {\n\t\t\t\tif (i40e_aqc_broadcast_filter(vsi, vsi_name,\n\t\t\t\t\t\t\t      new->f))\n\t\t\t\t\tnew->state = I40E_FILTER_FAILED;\n\t\t\t\telse\n\t\t\t\t\tnew->state = I40E_FILTER_ACTIVE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* add to add array */\n\t\t\tif (num_add == 0)\n\t\t\t\tadd_head = new;\n\t\t\tcmd_flags = 0;\n\t\t\tether_addr_copy(add_list[num_add].mac_addr,\n\t\t\t\t\tnew->f->macaddr);\n\t\t\tif (new->f->vlan == I40E_VLAN_ANY) {\n\t\t\t\tadd_list[num_add].vlan_tag = 0;\n\t\t\t\tcmd_flags |= I40E_AQC_MACVLAN_ADD_IGNORE_VLAN;\n\t\t\t} else {\n\t\t\t\tadd_list[num_add].vlan_tag =\n\t\t\t\t\tcpu_to_le16((u16)(new->f->vlan));\n\t\t\t}\n\t\t\tadd_list[num_add].queue_number = 0;\n\t\t\t/* set invalid match method for later detection */\n\t\t\tadd_list[num_add].match_method = I40E_AQC_MM_ERR_NO_RES;\n\t\t\tcmd_flags |= I40E_AQC_MACVLAN_ADD_PERFECT_MATCH;\n\t\t\tadd_list[num_add].flags = cpu_to_le16(cmd_flags);\n\t\t\tnum_add++;\n\n\t\t\t/* flush a full buffer */\n\t\t\tif (num_add == filter_list_len) {\n\t\t\t\ti40e_aqc_add_filters(vsi, vsi_name, add_list,\n\t\t\t\t\t\t     add_head, num_add);\n\t\t\t\tmemset(add_list, 0, list_size);\n\t\t\t\tnum_add = 0;\n\t\t\t}\n\t\t}\n\t\tif (num_add) {\n\t\t\ti40e_aqc_add_filters(vsi, vsi_name, add_list, add_head,\n\t\t\t\t\t     num_add);\n\t\t}\n\t\t/* Now move all of the filters from the temp add list back to\n\t\t * the VSI's list.\n\t\t */\n\t\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t\thlist_for_each_entry_safe(new, h, &tmp_add_list, hlist) {\n\t\t\t/* Only update the state if we're still NEW */\n\t\t\tif (new->f->state == I40E_FILTER_NEW)\n\t\t\t\tnew->f->state = new->state;\n\t\t\thlist_del(&new->hlist);\n\t\t\tkfree(new);\n\t\t}\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t\tkfree(add_list);\n\t\tadd_list = NULL;\n\t}\n\n\t/* Determine the number of active and failed filters. */\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\tvsi->active_filters = 0;\n\thash_for_each(vsi->mac_filter_hash, bkt, f, hlist) {\n\t\tif (f->state == I40E_FILTER_ACTIVE)\n\t\t\tvsi->active_filters++;\n\t\telse if (f->state == I40E_FILTER_FAILED)\n\t\t\tfailed_filters++;\n\t}\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\t/* Check if we are able to exit overflow promiscuous mode. We can\n\t * safely exit if we didn't just enter, we no longer have any failed\n\t * filters, and we have reduced filters below the threshold value.\n\t */\n\tif (old_overflow && !failed_filters &&\n\t    vsi->active_filters < vsi->promisc_threshold) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"filter logjam cleared on %s, leaving overflow promiscuous mode\\n\",\n\t\t\t vsi_name);\n\t\tclear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\t\tvsi->promisc_threshold = 0;\n\t}\n\n\t/* if the VF is not trusted do not do promisc */\n\tif ((vsi->type == I40E_VSI_SRIOV) && !pf->vf[vsi->vf_id].trusted) {\n\t\tclear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\t\tgoto out;\n\t}\n\n\tnew_overflow = test_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\n\t/* If we are entering overflow promiscuous, we need to calculate a new\n\t * threshold for when we are safe to exit\n\t */\n\tif (!old_overflow && new_overflow)\n\t\tvsi->promisc_threshold = (vsi->active_filters * 3) / 4;\n\n\t/* check for changes in promiscuous modes */\n\tif (changed_flags & IFF_ALLMULTI) {\n\t\tbool cur_multipromisc;\n\n\t\tcur_multipromisc = !!(vsi->current_netdev_flags & IFF_ALLMULTI);\n\t\taq_ret = i40e_aq_set_vsi_multicast_promiscuous(&vsi->back->hw,\n\t\t\t\t\t\t\t       vsi->seid,\n\t\t\t\t\t\t\t       cur_multipromisc,\n\t\t\t\t\t\t\t       NULL);\n\t\tif (aq_ret) {\n\t\t\tretval = i40e_aq_rc_to_posix(aq_ret,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"set multi promisc failed on %s, err %s aq_err %s\\n\",\n\t\t\t\t vsi_name,\n\t\t\t\t i40e_stat_str(hw, aq_ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev, \"%s is %s allmulti mode.\\n\",\n\t\t\t\t vsi->netdev->name,\n\t\t\t\t cur_multipromisc ? \"entering\" : \"leaving\");\n\t\t}\n\t}\n\n\tif ((changed_flags & IFF_PROMISC) || old_overflow != new_overflow) {\n\t\tbool cur_promisc;\n\n\t\tcur_promisc = (!!(vsi->current_netdev_flags & IFF_PROMISC) ||\n\t\t\t       new_overflow);\n\t\taq_ret = i40e_set_promiscuous(pf, cur_promisc);\n\t\tif (aq_ret) {\n\t\t\tretval = i40e_aq_rc_to_posix(aq_ret,\n\t\t\t\t\t\t     hw->aq.asq_last_status);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Setting promiscuous %s failed on %s, err %s aq_err %s\\n\",\n\t\t\t\t cur_promisc ? \"on\" : \"off\",\n\t\t\t\t vsi_name,\n\t\t\t\t i40e_stat_str(hw, aq_ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t}\n\t}\nout:\n\t/* if something went wrong then set the changed flag so we try again */\n\tif (retval)\n\t\tvsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\n\tclear_bit(__I40E_VSI_SYNCING_FILTERS, vsi->state);\n\treturn retval;\n\nerr_no_memory:\n\t/* Restore elements on the temporary add and delete lists */\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\nerr_no_memory_locked:\n\ti40e_undo_del_filter_entries(vsi, &tmp_del_list);\n\ti40e_undo_add_filter_entries(vsi, &tmp_add_list);\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\tvsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\tclear_bit(__I40E_VSI_SYNCING_FILTERS, vsi->state);\n\treturn -ENOMEM;\n}\n\n/**\n * i40e_sync_filters_subtask - Sync the VSI filter list with HW\n * @pf: board private structure\n **/\nstatic void i40e_sync_filters_subtask(struct i40e_pf *pf)\n{\n\tint v;\n\n\tif (!pf)\n\t\treturn;\n\tif (!test_and_clear_bit(__I40E_MACVLAN_SYNC_PENDING, pf->state))\n\t\treturn;\n\tif (test_and_set_bit(__I40E_VF_DISABLE, pf->state)) {\n\t\tset_bit(__I40E_MACVLAN_SYNC_PENDING, pf->state);\n\t\treturn;\n\t}\n\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (pf->vsi[v] &&\n\t\t    (pf->vsi[v]->flags & I40E_VSI_FLAG_FILTER_CHANGED)) {\n\t\t\tint ret = i40e_sync_vsi_filters(pf->vsi[v]);\n\n\t\t\tif (ret) {\n\t\t\t\t/* come back and try again later */\n\t\t\t\tset_bit(__I40E_MACVLAN_SYNC_PENDING,\n\t\t\t\t\tpf->state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tclear_bit(__I40E_VF_DISABLE, pf->state);\n}\n\n/**\n * i40e_max_xdp_frame_size - returns the maximum allowed frame size for XDP\n * @vsi: the vsi\n **/\nstatic int i40e_max_xdp_frame_size(struct i40e_vsi *vsi)\n{\n\tif (PAGE_SIZE >= 8192 || (vsi->back->flags & I40E_FLAG_LEGACY_RX))\n\t\treturn I40E_RXBUFFER_2048;\n\telse\n\t\treturn I40E_RXBUFFER_3072;\n}\n\n/**\n * i40e_change_mtu - NDO callback to change the Maximum Transfer Unit\n * @netdev: network interface device structure\n * @new_mtu: new value for maximum frame size\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int i40e_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\tint frame_size = new_mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\n\n\t\tif (frame_size > i40e_max_xdp_frame_size(vsi))\n\t\t\treturn -EINVAL;\n\t}\n\n\tnetdev_dbg(netdev, \"changing MTU from %d to %d\\n\",\n\t\t   netdev->mtu, new_mtu);\n\tnetdev->mtu = new_mtu;\n\tif (netif_running(netdev))\n\t\ti40e_vsi_reinit_locked(vsi);\n\tset_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);\n\tset_bit(__I40E_CLIENT_L2_CHANGE, pf->state);\n\treturn 0;\n}\n\n/**\n * i40e_ioctl - Access the hwtstamp interface\n * @netdev: network interface device structure\n * @ifr: interface request data\n * @cmd: ioctl command\n **/\nint i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\n\tswitch (cmd) {\n\tcase SIOCGHWTSTAMP:\n\t\treturn i40e_ptp_get_ts_config(pf, ifr);\n\tcase SIOCSHWTSTAMP:\n\t\treturn i40e_ptp_set_ts_config(pf, ifr);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n/**\n * i40e_vlan_stripping_enable - Turn on vlan stripping for the VSI\n * @vsi: the vsi being adjusted\n **/\nvoid i40e_vlan_stripping_enable(struct i40e_vsi *vsi)\n{\n\tstruct i40e_vsi_context ctxt;\n\ti40e_status ret;\n\n\t/* Don't modify stripping options if a port VLAN is active */\n\tif (vsi->info.pvid)\n\t\treturn;\n\n\tif ((vsi->info.valid_sections &\n\t     cpu_to_le16(I40E_AQ_VSI_PROP_VLAN_VALID)) &&\n\t    ((vsi->info.port_vlan_flags & I40E_AQ_VSI_PVLAN_MODE_MASK) == 0))\n\t\treturn;  /* already enabled */\n\n\tvsi->info.valid_sections = cpu_to_le16(I40E_AQ_VSI_PROP_VLAN_VALID);\n\tvsi->info.port_vlan_flags = I40E_AQ_VSI_PVLAN_MODE_ALL |\n\t\t\t\t    I40E_AQ_VSI_PVLAN_EMOD_STR_BOTH;\n\n\tctxt.seid = vsi->seid;\n\tctxt.info = vsi->info;\n\tret = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"update vlan stripping failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&vsi->back->hw, ret),\n\t\t\t i40e_aq_str(&vsi->back->hw,\n\t\t\t\t     vsi->back->hw.aq.asq_last_status));\n\t}\n}\n\n/**\n * i40e_vlan_stripping_disable - Turn off vlan stripping for the VSI\n * @vsi: the vsi being adjusted\n **/\nvoid i40e_vlan_stripping_disable(struct i40e_vsi *vsi)\n{\n\tstruct i40e_vsi_context ctxt;\n\ti40e_status ret;\n\n\t/* Don't modify stripping options if a port VLAN is active */\n\tif (vsi->info.pvid)\n\t\treturn;\n\n\tif ((vsi->info.valid_sections &\n\t     cpu_to_le16(I40E_AQ_VSI_PROP_VLAN_VALID)) &&\n\t    ((vsi->info.port_vlan_flags & I40E_AQ_VSI_PVLAN_EMOD_MASK) ==\n\t     I40E_AQ_VSI_PVLAN_EMOD_MASK))\n\t\treturn;  /* already disabled */\n\n\tvsi->info.valid_sections = cpu_to_le16(I40E_AQ_VSI_PROP_VLAN_VALID);\n\tvsi->info.port_vlan_flags = I40E_AQ_VSI_PVLAN_MODE_ALL |\n\t\t\t\t    I40E_AQ_VSI_PVLAN_EMOD_NOTHING;\n\n\tctxt.seid = vsi->seid;\n\tctxt.info = vsi->info;\n\tret = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"update vlan stripping failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&vsi->back->hw, ret),\n\t\t\t i40e_aq_str(&vsi->back->hw,\n\t\t\t\t     vsi->back->hw.aq.asq_last_status));\n\t}\n}\n\n/**\n * i40e_add_vlan_all_mac - Add a MAC/VLAN filter for each existing MAC address\n * @vsi: the vsi being configured\n * @vid: vlan id to be added (0 = untagged only , -1 = any)\n *\n * This is a helper function for adding a new MAC/VLAN filter with the\n * specified VLAN for each existing MAC address already in the hash table.\n * This function does *not* perform any accounting to update filters based on\n * VLAN mode.\n *\n * NOTE: this function expects to be called while under the\n * mac_filter_hash_lock\n **/\nint i40e_add_vlan_all_mac(struct i40e_vsi *vsi, s16 vid)\n{\n\tstruct i40e_mac_filter *f, *add_f;\n\tstruct hlist_node *h;\n\tint bkt;\n\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\tif (f->state == I40E_FILTER_REMOVE)\n\t\t\tcontinue;\n\t\tadd_f = i40e_add_filter(vsi, f->macaddr, vid);\n\t\tif (!add_f) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"Could not add vlan filter %d for %pM\\n\",\n\t\t\t\t vid, f->macaddr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_add_vlan - Add VSI membership for given VLAN\n * @vsi: the VSI being configured\n * @vid: VLAN id to be added\n **/\nint i40e_vsi_add_vlan(struct i40e_vsi *vsi, u16 vid)\n{\n\tint err;\n\n\tif (vsi->info.pvid)\n\t\treturn -EINVAL;\n\n\t/* The network stack will attempt to add VID=0, with the intention to\n\t * receive priority tagged packets with a VLAN of 0. Our HW receives\n\t * these packets by default when configured to receive untagged\n\t * packets, so we don't need to add a filter for this case.\n\t * Additionally, HW interprets adding a VID=0 filter as meaning to\n\t * receive *only* tagged traffic and stops receiving untagged traffic.\n\t * Thus, we do not want to actually add a filter for VID=0\n\t */\n\tif (!vid)\n\t\treturn 0;\n\n\t/* Locked once because all functions invoked below iterates list*/\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\terr = i40e_add_vlan_all_mac(vsi, vid);\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\tif (err)\n\t\treturn err;\n\n\t/* schedule our worker thread which will take care of\n\t * applying the new filter changes\n\t */\n\ti40e_service_event_schedule(vsi->back);\n\treturn 0;\n}\n\n/**\n * i40e_rm_vlan_all_mac - Remove MAC/VLAN pair for all MAC with the given VLAN\n * @vsi: the vsi being configured\n * @vid: vlan id to be removed (0 = untagged only , -1 = any)\n *\n * This function should be used to remove all VLAN filters which match the\n * given VID. It does not schedule the service event and does not take the\n * mac_filter_hash_lock so it may be combined with other operations under\n * a single invocation of the mac_filter_hash_lock.\n *\n * NOTE: this function expects to be called while under the\n * mac_filter_hash_lock\n */\nvoid i40e_rm_vlan_all_mac(struct i40e_vsi *vsi, s16 vid)\n{\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\tint bkt;\n\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\tif (f->vlan == vid)\n\t\t\t__i40e_del_filter(vsi, f);\n\t}\n}\n\n/**\n * i40e_vsi_kill_vlan - Remove VSI membership for given VLAN\n * @vsi: the VSI being configured\n * @vid: VLAN id to be removed\n **/\nvoid i40e_vsi_kill_vlan(struct i40e_vsi *vsi, u16 vid)\n{\n\tif (!vid || vsi->info.pvid)\n\t\treturn;\n\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\ti40e_rm_vlan_all_mac(vsi, vid);\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\t/* schedule our worker thread which will take care of\n\t * applying the new filter changes\n\t */\n\ti40e_service_event_schedule(vsi->back);\n}\n\n/**\n * i40e_vlan_rx_add_vid - Add a vlan id filter to HW offload\n * @netdev: network interface to be adjusted\n * @proto: unused protocol value\n * @vid: vlan id to be added\n *\n * net_device_ops implementation for adding vlan ids\n **/\nstatic int i40e_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t__always_unused __be16 proto, u16 vid)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tint ret = 0;\n\n\tif (vid >= VLAN_N_VID)\n\t\treturn -EINVAL;\n\n\tret = i40e_vsi_add_vlan(vsi, vid);\n\tif (!ret)\n\t\tset_bit(vid, vsi->active_vlans);\n\n\treturn ret;\n}\n\n/**\n * i40e_vlan_rx_add_vid_up - Add a vlan id filter to HW offload in UP path\n * @netdev: network interface to be adjusted\n * @proto: unused protocol value\n * @vid: vlan id to be added\n **/\nstatic void i40e_vlan_rx_add_vid_up(struct net_device *netdev,\n\t\t\t\t    __always_unused __be16 proto, u16 vid)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\tif (vid >= VLAN_N_VID)\n\t\treturn;\n\tset_bit(vid, vsi->active_vlans);\n}\n\n/**\n * i40e_vlan_rx_kill_vid - Remove a vlan id filter from HW offload\n * @netdev: network interface to be adjusted\n * @proto: unused protocol value\n * @vid: vlan id to be removed\n *\n * net_device_ops implementation for removing vlan ids\n **/\nstatic int i40e_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t __always_unused __be16 proto, u16 vid)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\t/* return code is ignored as there is nothing a user\n\t * can do about failure to remove and a log message was\n\t * already printed from the other function\n\t */\n\ti40e_vsi_kill_vlan(vsi, vid);\n\n\tclear_bit(vid, vsi->active_vlans);\n\n\treturn 0;\n}\n\n/**\n * i40e_restore_vlan - Reinstate vlans when vsi/netdev comes back up\n * @vsi: the vsi being brought back up\n **/\nstatic void i40e_restore_vlan(struct i40e_vsi *vsi)\n{\n\tu16 vid;\n\n\tif (!vsi->netdev)\n\t\treturn;\n\n\tif (vsi->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\ti40e_vlan_stripping_enable(vsi);\n\telse\n\t\ti40e_vlan_stripping_disable(vsi);\n\n\tfor_each_set_bit(vid, vsi->active_vlans, VLAN_N_VID)\n\t\ti40e_vlan_rx_add_vid_up(vsi->netdev, htons(ETH_P_8021Q),\n\t\t\t\t\tvid);\n}\n\n/**\n * i40e_vsi_add_pvid - Add pvid for the VSI\n * @vsi: the vsi being adjusted\n * @vid: the vlan id to set as a PVID\n **/\nint i40e_vsi_add_pvid(struct i40e_vsi *vsi, u16 vid)\n{\n\tstruct i40e_vsi_context ctxt;\n\ti40e_status ret;\n\n\tvsi->info.valid_sections = cpu_to_le16(I40E_AQ_VSI_PROP_VLAN_VALID);\n\tvsi->info.pvid = cpu_to_le16(vid);\n\tvsi->info.port_vlan_flags = I40E_AQ_VSI_PVLAN_MODE_TAGGED |\n\t\t\t\t    I40E_AQ_VSI_PVLAN_INSERT_PVID |\n\t\t\t\t    I40E_AQ_VSI_PVLAN_EMOD_STR;\n\n\tctxt.seid = vsi->seid;\n\tctxt.info = vsi->info;\n\tret = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"add pvid failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&vsi->back->hw, ret),\n\t\t\t i40e_aq_str(&vsi->back->hw,\n\t\t\t\t     vsi->back->hw.aq.asq_last_status));\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_remove_pvid - Remove the pvid from the VSI\n * @vsi: the vsi being adjusted\n *\n * Just use the vlan_rx_register() service to put it back to normal\n **/\nvoid i40e_vsi_remove_pvid(struct i40e_vsi *vsi)\n{\n\tvsi->info.pvid = 0;\n\n\ti40e_vlan_stripping_disable(vsi);\n}\n\n/**\n * i40e_vsi_setup_tx_resources - Allocate VSI Tx queue resources\n * @vsi: ptr to the VSI\n *\n * If this function returns with an error, then it's possible one or\n * more of the rings is populated (while the rest are not).  It is the\n * callers duty to clean those orphaned rings.\n *\n * Return 0 on success, negative on failure\n **/\nstatic int i40e_vsi_setup_tx_resources(struct i40e_vsi *vsi)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < vsi->num_queue_pairs && !err; i++)\n\t\terr = i40e_setup_tx_descriptors(vsi->tx_rings[i]);\n\n\tif (!i40e_enabled_xdp_vsi(vsi))\n\t\treturn err;\n\n\tfor (i = 0; i < vsi->num_queue_pairs && !err; i++)\n\t\terr = i40e_setup_tx_descriptors(vsi->xdp_rings[i]);\n\n\treturn err;\n}\n\n/**\n * i40e_vsi_free_tx_resources - Free Tx resources for VSI queues\n * @vsi: ptr to the VSI\n *\n * Free VSI's transmit software resources\n **/\nstatic void i40e_vsi_free_tx_resources(struct i40e_vsi *vsi)\n{\n\tint i;\n\n\tif (vsi->tx_rings) {\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\t\tif (vsi->tx_rings[i] && vsi->tx_rings[i]->desc)\n\t\t\t\ti40e_free_tx_resources(vsi->tx_rings[i]);\n\t}\n\n\tif (vsi->xdp_rings) {\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\t\tif (vsi->xdp_rings[i] && vsi->xdp_rings[i]->desc)\n\t\t\t\ti40e_free_tx_resources(vsi->xdp_rings[i]);\n\t}\n}\n\n/**\n * i40e_vsi_setup_rx_resources - Allocate VSI queues Rx resources\n * @vsi: ptr to the VSI\n *\n * If this function returns with an error, then it's possible one or\n * more of the rings is populated (while the rest are not).  It is the\n * callers duty to clean those orphaned rings.\n *\n * Return 0 on success, negative on failure\n **/\nstatic int i40e_vsi_setup_rx_resources(struct i40e_vsi *vsi)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < vsi->num_queue_pairs && !err; i++)\n\t\terr = i40e_setup_rx_descriptors(vsi->rx_rings[i]);\n\treturn err;\n}\n\n/**\n * i40e_vsi_free_rx_resources - Free Rx Resources for VSI queues\n * @vsi: ptr to the VSI\n *\n * Free all receive software resources\n **/\nstatic void i40e_vsi_free_rx_resources(struct i40e_vsi *vsi)\n{\n\tint i;\n\n\tif (!vsi->rx_rings)\n\t\treturn;\n\n\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\tif (vsi->rx_rings[i] && vsi->rx_rings[i]->desc)\n\t\t\ti40e_free_rx_resources(vsi->rx_rings[i]);\n}\n\n/**\n * i40e_config_xps_tx_ring - Configure XPS for a Tx ring\n * @ring: The Tx ring to configure\n *\n * This enables/disables XPS for a given Tx descriptor ring\n * based on the TCs enabled for the VSI that ring belongs to.\n **/\nstatic void i40e_config_xps_tx_ring(struct i40e_ring *ring)\n{\n\tint cpu;\n\n\tif (!ring->q_vector || !ring->netdev || ring->ch)\n\t\treturn;\n\n\t/* We only initialize XPS once, so as not to overwrite user settings */\n\tif (test_and_set_bit(__I40E_TX_XPS_INIT_DONE, ring->state))\n\t\treturn;\n\n\tcpu = cpumask_local_spread(ring->q_vector->v_idx, -1);\n\tnetif_set_xps_queue(ring->netdev, get_cpu_mask(cpu),\n\t\t\t    ring->queue_index);\n}\n\n/**\n * i40e_xsk_pool - Retrieve the AF_XDP buffer pool if XDP and ZC is enabled\n * @ring: The Tx or Rx ring\n *\n * Returns the AF_XDP buffer pool or NULL.\n **/\nstatic struct xsk_buff_pool *i40e_xsk_pool(struct i40e_ring *ring)\n{\n\tbool xdp_on = i40e_enabled_xdp_vsi(ring->vsi);\n\tint qid = ring->queue_index;\n\n\tif (ring_is_xdp(ring))\n\t\tqid -= ring->vsi->alloc_queue_pairs;\n\n\tif (!xdp_on || !test_bit(qid, ring->vsi->af_xdp_zc_qps))\n\t\treturn NULL;\n\n\treturn xsk_get_pool_from_qid(ring->vsi->netdev, qid);\n}\n\n/**\n * i40e_configure_tx_ring - Configure a transmit ring context and rest\n * @ring: The Tx ring to configure\n *\n * Configure the Tx descriptor ring in the HMC context.\n **/\nstatic int i40e_configure_tx_ring(struct i40e_ring *ring)\n{\n\tstruct i40e_vsi *vsi = ring->vsi;\n\tu16 pf_q = vsi->base_queue + ring->queue_index;\n\tstruct i40e_hw *hw = &vsi->back->hw;\n\tstruct i40e_hmc_obj_txq tx_ctx;\n\ti40e_status err = 0;\n\tu32 qtx_ctl = 0;\n\n\tif (ring_is_xdp(ring))\n\t\tring->xsk_pool = i40e_xsk_pool(ring);\n\n\t/* some ATR related tx ring init */\n\tif (vsi->back->flags & I40E_FLAG_FD_ATR_ENABLED) {\n\t\tring->atr_sample_rate = vsi->back->atr_sample_rate;\n\t\tring->atr_count = 0;\n\t} else {\n\t\tring->atr_sample_rate = 0;\n\t}\n\n\t/* configure XPS */\n\ti40e_config_xps_tx_ring(ring);\n\n\t/* clear the context structure first */\n\tmemset(&tx_ctx, 0, sizeof(tx_ctx));\n\n\ttx_ctx.new_context = 1;\n\ttx_ctx.base = (ring->dma / 128);\n\ttx_ctx.qlen = ring->count;\n\ttx_ctx.fd_ena = !!(vsi->back->flags & (I40E_FLAG_FD_SB_ENABLED |\n\t\t\t\t\t       I40E_FLAG_FD_ATR_ENABLED));\n\ttx_ctx.timesync_ena = !!(vsi->back->flags & I40E_FLAG_PTP);\n\t/* FDIR VSI tx ring can still use RS bit and writebacks */\n\tif (vsi->type != I40E_VSI_FDIR)\n\t\ttx_ctx.head_wb_ena = 1;\n\ttx_ctx.head_wb_addr = ring->dma +\n\t\t\t      (ring->count * sizeof(struct i40e_tx_desc));\n\n\t/* As part of VSI creation/update, FW allocates certain\n\t * Tx arbitration queue sets for each TC enabled for\n\t * the VSI. The FW returns the handles to these queue\n\t * sets as part of the response buffer to Add VSI,\n\t * Update VSI, etc. AQ commands. It is expected that\n\t * these queue set handles be associated with the Tx\n\t * queues by the driver as part of the TX queue context\n\t * initialization. This has to be done regardless of\n\t * DCB as by default everything is mapped to TC0.\n\t */\n\n\tif (ring->ch)\n\t\ttx_ctx.rdylist =\n\t\t\tle16_to_cpu(ring->ch->info.qs_handle[ring->dcb_tc]);\n\n\telse\n\t\ttx_ctx.rdylist = le16_to_cpu(vsi->info.qs_handle[ring->dcb_tc]);\n\n\ttx_ctx.rdylist_act = 0;\n\n\t/* clear the context in the HMC */\n\terr = i40e_clear_lan_tx_queue_context(hw, pf_q);\n\tif (err) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed to clear LAN Tx queue context on Tx ring %d (pf_q %d), error: %d\\n\",\n\t\t\t ring->queue_index, pf_q, err);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* set the context in the HMC */\n\terr = i40e_set_lan_tx_queue_context(hw, pf_q, &tx_ctx);\n\tif (err) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed to set LAN Tx queue context on Tx ring %d (pf_q %d, error: %d\\n\",\n\t\t\t ring->queue_index, pf_q, err);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Now associate this queue with this PCI function */\n\tif (ring->ch) {\n\t\tif (ring->ch->type == I40E_VSI_VMDQ2)\n\t\t\tqtx_ctl = I40E_QTX_CTL_VM_QUEUE;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tqtx_ctl |= (ring->ch->vsi_number <<\n\t\t\t    I40E_QTX_CTL_VFVM_INDX_SHIFT) &\n\t\t\t    I40E_QTX_CTL_VFVM_INDX_MASK;\n\t} else {\n\t\tif (vsi->type == I40E_VSI_VMDQ2) {\n\t\t\tqtx_ctl = I40E_QTX_CTL_VM_QUEUE;\n\t\t\tqtx_ctl |= ((vsi->id) << I40E_QTX_CTL_VFVM_INDX_SHIFT) &\n\t\t\t\t    I40E_QTX_CTL_VFVM_INDX_MASK;\n\t\t} else {\n\t\t\tqtx_ctl = I40E_QTX_CTL_PF_QUEUE;\n\t\t}\n\t}\n\n\tqtx_ctl |= ((hw->pf_id << I40E_QTX_CTL_PF_INDX_SHIFT) &\n\t\t    I40E_QTX_CTL_PF_INDX_MASK);\n\twr32(hw, I40E_QTX_CTL(pf_q), qtx_ctl);\n\ti40e_flush(hw);\n\n\t/* cache tail off for easier writes later */\n\tring->tail = hw->hw_addr + I40E_QTX_TAIL(pf_q);\n\n\treturn 0;\n}\n\n/**\n * i40e_configure_rx_ring - Configure a receive ring context\n * @ring: The Rx ring to configure\n *\n * Configure the Rx descriptor ring in the HMC context.\n **/\nstatic int i40e_configure_rx_ring(struct i40e_ring *ring)\n{\n\tstruct i40e_vsi *vsi = ring->vsi;\n\tu32 chain_len = vsi->back->hw.func_caps.rx_buf_chain_len;\n\tu16 pf_q = vsi->base_queue + ring->queue_index;\n\tstruct i40e_hw *hw = &vsi->back->hw;\n\tstruct i40e_hmc_obj_rxq rx_ctx;\n\ti40e_status err = 0;\n\tbool ok;\n\tint ret;\n\n\tbitmap_zero(ring->state, __I40E_RING_STATE_NBITS);\n\n\t/* clear the context structure first */\n\tmemset(&rx_ctx, 0, sizeof(rx_ctx));\n\n\tif (ring->vsi->type == I40E_VSI_MAIN)\n\t\txdp_rxq_info_unreg_mem_model(&ring->xdp_rxq);\n\n\tkfree(ring->rx_bi);\n\tring->xsk_pool = i40e_xsk_pool(ring);\n\tif (ring->xsk_pool) {\n\t\tret = i40e_alloc_rx_bi_zc(ring);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tring->rx_buf_len =\n\t\t  xsk_pool_get_rx_frame_size(ring->xsk_pool);\n\t\t/* For AF_XDP ZC, we disallow packets to span on\n\t\t * multiple buffers, thus letting us skip that\n\t\t * handling in the fast-path.\n\t\t */\n\t\tchain_len = 1;\n\t\tret = xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,\n\t\t\t\t\t\t MEM_TYPE_XSK_BUFF_POOL,\n\t\t\t\t\t\t NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Registered XDP mem model MEM_TYPE_XSK_BUFF_POOL on Rx ring %d\\n\",\n\t\t\t ring->queue_index);\n\n\t} else {\n\t\tret = i40e_alloc_rx_bi(ring);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tring->rx_buf_len = vsi->rx_buf_len;\n\t\tif (ring->vsi->type == I40E_VSI_MAIN) {\n\t\t\tret = xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,\n\t\t\t\t\t\t\t MEM_TYPE_PAGE_SHARED,\n\t\t\t\t\t\t\t NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\trx_ctx.dbuff = DIV_ROUND_UP(ring->rx_buf_len,\n\t\t\t\t    BIT_ULL(I40E_RXQ_CTX_DBUFF_SHIFT));\n\n\trx_ctx.base = (ring->dma / 128);\n\trx_ctx.qlen = ring->count;\n\n\t/* use 16 byte descriptors */\n\trx_ctx.dsize = 0;\n\n\t/* descriptor type is always zero\n\t * rx_ctx.dtype = 0;\n\t */\n\trx_ctx.hsplit_0 = 0;\n\n\trx_ctx.rxmax = min_t(u16, vsi->max_frame, chain_len * ring->rx_buf_len);\n\tif (hw->revision_id == 0)\n\t\trx_ctx.lrxqthresh = 0;\n\telse\n\t\trx_ctx.lrxqthresh = 1;\n\trx_ctx.crcstrip = 1;\n\trx_ctx.l2tsel = 1;\n\t/* this controls whether VLAN is stripped from inner headers */\n\trx_ctx.showiv = 0;\n\t/* set the prefena field to 1 because the manual says to */\n\trx_ctx.prefena = 1;\n\n\t/* clear the context in the HMC */\n\terr = i40e_clear_lan_rx_queue_context(hw, pf_q);\n\tif (err) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed to clear LAN Rx queue context on Rx ring %d (pf_q %d), error: %d\\n\",\n\t\t\t ring->queue_index, pf_q, err);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* set the context in the HMC */\n\terr = i40e_set_lan_rx_queue_context(hw, pf_q, &rx_ctx);\n\tif (err) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed to set LAN Rx queue context on Rx ring %d (pf_q %d), error: %d\\n\",\n\t\t\t ring->queue_index, pf_q, err);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* configure Rx buffer alignment */\n\tif (!vsi->netdev || (vsi->back->flags & I40E_FLAG_LEGACY_RX))\n\t\tclear_ring_build_skb_enabled(ring);\n\telse\n\t\tset_ring_build_skb_enabled(ring);\n\n\t/* cache tail for quicker writes, and clear the reg before use */\n\tring->tail = hw->hw_addr + I40E_QRX_TAIL(pf_q);\n\twritel(0, ring->tail);\n\n\tif (ring->xsk_pool) {\n\t\txsk_pool_set_rxq_info(ring->xsk_pool, &ring->xdp_rxq);\n\t\tok = i40e_alloc_rx_buffers_zc(ring, I40E_DESC_UNUSED(ring));\n\t} else {\n\t\tok = !i40e_alloc_rx_buffers(ring, I40E_DESC_UNUSED(ring));\n\t}\n\tif (!ok) {\n\t\t/* Log this in case the user has forgotten to give the kernel\n\t\t * any buffers, even later in the application.\n\t\t */\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed to allocate some buffers on %sRx ring %d (pf_q %d)\\n\",\n\t\t\t ring->xsk_pool ? \"AF_XDP ZC enabled \" : \"\",\n\t\t\t ring->queue_index, pf_q);\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_configure_tx - Configure the VSI for Tx\n * @vsi: VSI structure describing this set of rings and resources\n *\n * Configure the Tx VSI for operation.\n **/\nstatic int i40e_vsi_configure_tx(struct i40e_vsi *vsi)\n{\n\tint err = 0;\n\tu16 i;\n\n\tfor (i = 0; (i < vsi->num_queue_pairs) && !err; i++)\n\t\terr = i40e_configure_tx_ring(vsi->tx_rings[i]);\n\n\tif (err || !i40e_enabled_xdp_vsi(vsi))\n\t\treturn err;\n\n\tfor (i = 0; (i < vsi->num_queue_pairs) && !err; i++)\n\t\terr = i40e_configure_tx_ring(vsi->xdp_rings[i]);\n\n\treturn err;\n}\n\n/**\n * i40e_vsi_configure_rx - Configure the VSI for Rx\n * @vsi: the VSI being configured\n *\n * Configure the Rx VSI for operation.\n **/\nstatic int i40e_vsi_configure_rx(struct i40e_vsi *vsi)\n{\n\tint err = 0;\n\tu16 i;\n\n\tif (!vsi->netdev || (vsi->back->flags & I40E_FLAG_LEGACY_RX)) {\n\t\tvsi->max_frame = I40E_MAX_RXBUFFER;\n\t\tvsi->rx_buf_len = I40E_RXBUFFER_2048;\n#if (PAGE_SIZE < 8192)\n\t} else if (!I40E_2K_TOO_SMALL_WITH_PADDING &&\n\t\t   (vsi->netdev->mtu <= ETH_DATA_LEN)) {\n\t\tvsi->max_frame = I40E_RXBUFFER_1536 - NET_IP_ALIGN;\n\t\tvsi->rx_buf_len = I40E_RXBUFFER_1536 - NET_IP_ALIGN;\n#endif\n\t} else {\n\t\tvsi->max_frame = I40E_MAX_RXBUFFER;\n\t\tvsi->rx_buf_len = (PAGE_SIZE < 8192) ? I40E_RXBUFFER_3072 :\n\t\t\t\t\t\t       I40E_RXBUFFER_2048;\n\t}\n\n\t/* set up individual rings */\n\tfor (i = 0; i < vsi->num_queue_pairs && !err; i++)\n\t\terr = i40e_configure_rx_ring(vsi->rx_rings[i]);\n\n\treturn err;\n}\n\n/**\n * i40e_vsi_config_dcb_rings - Update rings to reflect DCB TC\n * @vsi: ptr to the VSI\n **/\nstatic void i40e_vsi_config_dcb_rings(struct i40e_vsi *vsi)\n{\n\tstruct i40e_ring *tx_ring, *rx_ring;\n\tu16 qoffset, qcount;\n\tint i, n;\n\n\tif (!(vsi->back->flags & I40E_FLAG_DCB_ENABLED)) {\n\t\t/* Reset the TC information */\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\t\trx_ring = vsi->rx_rings[i];\n\t\t\ttx_ring = vsi->tx_rings[i];\n\t\t\trx_ring->dcb_tc = 0;\n\t\t\ttx_ring->dcb_tc = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (n = 0; n < I40E_MAX_TRAFFIC_CLASS; n++) {\n\t\tif (!(vsi->tc_config.enabled_tc & BIT_ULL(n)))\n\t\t\tcontinue;\n\n\t\tqoffset = vsi->tc_config.tc_info[n].qoffset;\n\t\tqcount = vsi->tc_config.tc_info[n].qcount;\n\t\tfor (i = qoffset; i < (qoffset + qcount); i++) {\n\t\t\trx_ring = vsi->rx_rings[i];\n\t\t\ttx_ring = vsi->tx_rings[i];\n\t\t\trx_ring->dcb_tc = n;\n\t\t\ttx_ring->dcb_tc = n;\n\t\t}\n\t}\n}\n\n/**\n * i40e_set_vsi_rx_mode - Call set_rx_mode on a VSI\n * @vsi: ptr to the VSI\n **/\nstatic void i40e_set_vsi_rx_mode(struct i40e_vsi *vsi)\n{\n\tif (vsi->netdev)\n\t\ti40e_set_rx_mode(vsi->netdev);\n}\n\n/**\n * i40e_fdir_filter_restore - Restore the Sideband Flow Director filters\n * @vsi: Pointer to the targeted VSI\n *\n * This function replays the hlist on the hw where all the SB Flow Director\n * filters were saved.\n **/\nstatic void i40e_fdir_filter_restore(struct i40e_vsi *vsi)\n{\n\tstruct i40e_fdir_filter *filter;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct hlist_node *node;\n\n\tif (!(pf->flags & I40E_FLAG_FD_SB_ENABLED))\n\t\treturn;\n\n\t/* Reset FDir counters as we're replaying all existing filters */\n\tpf->fd_tcp4_filter_cnt = 0;\n\tpf->fd_udp4_filter_cnt = 0;\n\tpf->fd_sctp4_filter_cnt = 0;\n\tpf->fd_ip4_filter_cnt = 0;\n\n\thlist_for_each_entry_safe(filter, node,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\ti40e_add_del_fdir(vsi, filter, true);\n\t}\n}\n\n/**\n * i40e_vsi_configure - Set up the VSI for action\n * @vsi: the VSI being configured\n **/\nstatic int i40e_vsi_configure(struct i40e_vsi *vsi)\n{\n\tint err;\n\n\ti40e_set_vsi_rx_mode(vsi);\n\ti40e_restore_vlan(vsi);\n\ti40e_vsi_config_dcb_rings(vsi);\n\terr = i40e_vsi_configure_tx(vsi);\n\tif (!err)\n\t\terr = i40e_vsi_configure_rx(vsi);\n\n\treturn err;\n}\n\n/**\n * i40e_vsi_configure_msix - MSIX mode Interrupt Config in the HW\n * @vsi: the VSI being configured\n **/\nstatic void i40e_vsi_configure_msix(struct i40e_vsi *vsi)\n{\n\tbool has_xdp = i40e_enabled_xdp_vsi(vsi);\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 vector;\n\tint i, q;\n\tu32 qp;\n\n\t/* The interrupt indexing is offset by 1 in the PFINT_ITRn\n\t * and PFINT_LNKLSTn registers, e.g.:\n\t *   PFINT_ITRn[0..n-1] gets msix-1..msix-n  (qpair interrupts)\n\t */\n\tqp = vsi->base_queue;\n\tvector = vsi->base_vector;\n\tfor (i = 0; i < vsi->num_q_vectors; i++, vector++) {\n\t\tstruct i40e_q_vector *q_vector = vsi->q_vectors[i];\n\n\t\tq_vector->rx.next_update = jiffies + 1;\n\t\tq_vector->rx.target_itr =\n\t\t\tITR_TO_REG(vsi->rx_rings[i]->itr_setting);\n\t\twr32(hw, I40E_PFINT_ITRN(I40E_RX_ITR, vector - 1),\n\t\t     q_vector->rx.target_itr >> 1);\n\t\tq_vector->rx.current_itr = q_vector->rx.target_itr;\n\n\t\tq_vector->tx.next_update = jiffies + 1;\n\t\tq_vector->tx.target_itr =\n\t\t\tITR_TO_REG(vsi->tx_rings[i]->itr_setting);\n\t\twr32(hw, I40E_PFINT_ITRN(I40E_TX_ITR, vector - 1),\n\t\t     q_vector->tx.target_itr >> 1);\n\t\tq_vector->tx.current_itr = q_vector->tx.target_itr;\n\n\t\twr32(hw, I40E_PFINT_RATEN(vector - 1),\n\t\t     i40e_intrl_usec_to_reg(vsi->int_rate_limit));\n\n\t\t/* Linked list for the queuepairs assigned to this vector */\n\t\twr32(hw, I40E_PFINT_LNKLSTN(vector - 1), qp);\n\t\tfor (q = 0; q < q_vector->num_ringpairs; q++) {\n\t\t\tu32 nextqp = has_xdp ? qp + vsi->alloc_queue_pairs : qp;\n\t\t\tu32 val;\n\n\t\t\tval = I40E_QINT_RQCTL_CAUSE_ENA_MASK |\n\t\t\t      (I40E_RX_ITR << I40E_QINT_RQCTL_ITR_INDX_SHIFT) |\n\t\t\t      (vector << I40E_QINT_RQCTL_MSIX_INDX_SHIFT) |\n\t\t\t      (nextqp << I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT) |\n\t\t\t      (I40E_QUEUE_TYPE_TX <<\n\t\t\t       I40E_QINT_RQCTL_NEXTQ_TYPE_SHIFT);\n\n\t\t\twr32(hw, I40E_QINT_RQCTL(qp), val);\n\n\t\t\tif (has_xdp) {\n\t\t\t\tval = I40E_QINT_TQCTL_CAUSE_ENA_MASK |\n\t\t\t\t      (I40E_TX_ITR << I40E_QINT_TQCTL_ITR_INDX_SHIFT) |\n\t\t\t\t      (vector << I40E_QINT_TQCTL_MSIX_INDX_SHIFT) |\n\t\t\t\t      (qp << I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT) |\n\t\t\t\t      (I40E_QUEUE_TYPE_TX <<\n\t\t\t\t       I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT);\n\n\t\t\t\twr32(hw, I40E_QINT_TQCTL(nextqp), val);\n\t\t\t}\n\n\t\t\tval = I40E_QINT_TQCTL_CAUSE_ENA_MASK |\n\t\t\t      (I40E_TX_ITR << I40E_QINT_TQCTL_ITR_INDX_SHIFT) |\n\t\t\t      (vector << I40E_QINT_TQCTL_MSIX_INDX_SHIFT) |\n\t\t\t      ((qp + 1) << I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT) |\n\t\t\t      (I40E_QUEUE_TYPE_RX <<\n\t\t\t       I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT);\n\n\t\t\t/* Terminate the linked list */\n\t\t\tif (q == (q_vector->num_ringpairs - 1))\n\t\t\t\tval |= (I40E_QUEUE_END_OF_LIST <<\n\t\t\t\t\tI40E_QINT_TQCTL_NEXTQ_INDX_SHIFT);\n\n\t\t\twr32(hw, I40E_QINT_TQCTL(qp), val);\n\t\t\tqp++;\n\t\t}\n\t}\n\n\ti40e_flush(hw);\n}\n\n/**\n * i40e_enable_misc_int_causes - enable the non-queue interrupts\n * @pf: pointer to private device data structure\n **/\nstatic void i40e_enable_misc_int_causes(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 val;\n\n\t/* clear things first */\n\twr32(hw, I40E_PFINT_ICR0_ENA, 0);  /* disable all */\n\trd32(hw, I40E_PFINT_ICR0);         /* read to clear */\n\n\tval = I40E_PFINT_ICR0_ENA_ECC_ERR_MASK       |\n\t      I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK    |\n\t      I40E_PFINT_ICR0_ENA_GRST_MASK          |\n\t      I40E_PFINT_ICR0_ENA_PCI_EXCEPTION_MASK |\n\t      I40E_PFINT_ICR0_ENA_GPIO_MASK          |\n\t      I40E_PFINT_ICR0_ENA_HMC_ERR_MASK       |\n\t      I40E_PFINT_ICR0_ENA_VFLR_MASK          |\n\t      I40E_PFINT_ICR0_ENA_ADMINQ_MASK;\n\n\tif (pf->flags & I40E_FLAG_IWARP_ENABLED)\n\t\tval |= I40E_PFINT_ICR0_ENA_PE_CRITERR_MASK;\n\n\tif (pf->flags & I40E_FLAG_PTP)\n\t\tval |= I40E_PFINT_ICR0_ENA_TIMESYNC_MASK;\n\n\twr32(hw, I40E_PFINT_ICR0_ENA, val);\n\n\t/* SW_ITR_IDX = 0, but don't change INTENA */\n\twr32(hw, I40E_PFINT_DYN_CTL0, I40E_PFINT_DYN_CTL0_SW_ITR_INDX_MASK |\n\t\t\t\t\tI40E_PFINT_DYN_CTL0_INTENA_MSK_MASK);\n\n\t/* OTHER_ITR_IDX = 0 */\n\twr32(hw, I40E_PFINT_STAT_CTL0, 0);\n}\n\n/**\n * i40e_configure_msi_and_legacy - Legacy mode interrupt config in the HW\n * @vsi: the VSI being configured\n **/\nstatic void i40e_configure_msi_and_legacy(struct i40e_vsi *vsi)\n{\n\tu32 nextqp = i40e_enabled_xdp_vsi(vsi) ? vsi->alloc_queue_pairs : 0;\n\tstruct i40e_q_vector *q_vector = vsi->q_vectors[0];\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 val;\n\n\t/* set the ITR configuration */\n\tq_vector->rx.next_update = jiffies + 1;\n\tq_vector->rx.target_itr = ITR_TO_REG(vsi->rx_rings[0]->itr_setting);\n\twr32(hw, I40E_PFINT_ITR0(I40E_RX_ITR), q_vector->rx.target_itr >> 1);\n\tq_vector->rx.current_itr = q_vector->rx.target_itr;\n\tq_vector->tx.next_update = jiffies + 1;\n\tq_vector->tx.target_itr = ITR_TO_REG(vsi->tx_rings[0]->itr_setting);\n\twr32(hw, I40E_PFINT_ITR0(I40E_TX_ITR), q_vector->tx.target_itr >> 1);\n\tq_vector->tx.current_itr = q_vector->tx.target_itr;\n\n\ti40e_enable_misc_int_causes(pf);\n\n\t/* FIRSTQ_INDX = 0, FIRSTQ_TYPE = 0 (rx) */\n\twr32(hw, I40E_PFINT_LNKLST0, 0);\n\n\t/* Associate the queue pair to the vector and enable the queue int */\n\tval = I40E_QINT_RQCTL_CAUSE_ENA_MASK\t\t       |\n\t      (I40E_RX_ITR << I40E_QINT_RQCTL_ITR_INDX_SHIFT)  |\n\t      (nextqp\t   << I40E_QINT_RQCTL_NEXTQ_INDX_SHIFT)|\n\t      (I40E_QUEUE_TYPE_TX << I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT);\n\n\twr32(hw, I40E_QINT_RQCTL(0), val);\n\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\tval = I40E_QINT_TQCTL_CAUSE_ENA_MASK\t\t     |\n\t\t      (I40E_TX_ITR << I40E_QINT_TQCTL_ITR_INDX_SHIFT)|\n\t\t      (I40E_QUEUE_TYPE_TX\n\t\t       << I40E_QINT_TQCTL_NEXTQ_TYPE_SHIFT);\n\n\t\twr32(hw, I40E_QINT_TQCTL(nextqp), val);\n\t}\n\n\tval = I40E_QINT_TQCTL_CAUSE_ENA_MASK\t\t      |\n\t      (I40E_TX_ITR << I40E_QINT_TQCTL_ITR_INDX_SHIFT) |\n\t      (I40E_QUEUE_END_OF_LIST << I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT);\n\n\twr32(hw, I40E_QINT_TQCTL(0), val);\n\ti40e_flush(hw);\n}\n\n/**\n * i40e_irq_dynamic_disable_icr0 - Disable default interrupt generation for icr0\n * @pf: board private structure\n **/\nvoid i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\n\twr32(hw, I40E_PFINT_DYN_CTL0,\n\t     I40E_ITR_NONE << I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT);\n\ti40e_flush(hw);\n}\n\n/**\n * i40e_irq_dynamic_enable_icr0 - Enable default interrupt generation for icr0\n * @pf: board private structure\n **/\nvoid i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 val;\n\n\tval = I40E_PFINT_DYN_CTL0_INTENA_MASK   |\n\t      I40E_PFINT_DYN_CTL0_CLEARPBA_MASK |\n\t      (I40E_ITR_NONE << I40E_PFINT_DYN_CTL0_ITR_INDX_SHIFT);\n\n\twr32(hw, I40E_PFINT_DYN_CTL0, val);\n\ti40e_flush(hw);\n}\n\n/**\n * i40e_msix_clean_rings - MSIX mode Interrupt Handler\n * @irq: interrupt number\n * @data: pointer to a q_vector\n **/\nstatic irqreturn_t i40e_msix_clean_rings(int irq, void *data)\n{\n\tstruct i40e_q_vector *q_vector = data;\n\n\tif (!q_vector->tx.ring && !q_vector->rx.ring)\n\t\treturn IRQ_HANDLED;\n\n\tnapi_schedule_irqoff(&q_vector->napi);\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * i40e_irq_affinity_notify - Callback for affinity changes\n * @notify: context as to what irq was changed\n * @mask: the new affinity mask\n *\n * This is a callback function used by the irq_set_affinity_notifier function\n * so that we may register to receive changes to the irq affinity masks.\n **/\nstatic void i40e_irq_affinity_notify(struct irq_affinity_notify *notify,\n\t\t\t\t     const cpumask_t *mask)\n{\n\tstruct i40e_q_vector *q_vector =\n\t\tcontainer_of(notify, struct i40e_q_vector, affinity_notify);\n\n\tcpumask_copy(&q_vector->affinity_mask, mask);\n}\n\n/**\n * i40e_irq_affinity_release - Callback for affinity notifier release\n * @ref: internal core kernel usage\n *\n * This is a callback function used by the irq_set_affinity_notifier function\n * to inform the current notification subscriber that they will no longer\n * receive notifications.\n **/\nstatic void i40e_irq_affinity_release(struct kref *ref) {}\n\n/**\n * i40e_vsi_request_irq_msix - Initialize MSI-X interrupts\n * @vsi: the VSI being configured\n * @basename: name for the vector\n *\n * Allocates MSI-X vectors and requests interrupts from the kernel.\n **/\nstatic int i40e_vsi_request_irq_msix(struct i40e_vsi *vsi, char *basename)\n{\n\tint q_vectors = vsi->num_q_vectors;\n\tstruct i40e_pf *pf = vsi->back;\n\tint base = vsi->base_vector;\n\tint rx_int_idx = 0;\n\tint tx_int_idx = 0;\n\tint vector, err;\n\tint irq_num;\n\tint cpu;\n\n\tfor (vector = 0; vector < q_vectors; vector++) {\n\t\tstruct i40e_q_vector *q_vector = vsi->q_vectors[vector];\n\n\t\tirq_num = pf->msix_entries[base + vector].vector;\n\n\t\tif (q_vector->tx.ring && q_vector->rx.ring) {\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\n\t\t\t\t \"%s-%s-%d\", basename, \"TxRx\", rx_int_idx++);\n\t\t\ttx_int_idx++;\n\t\t} else if (q_vector->rx.ring) {\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\n\t\t\t\t \"%s-%s-%d\", basename, \"rx\", rx_int_idx++);\n\t\t} else if (q_vector->tx.ring) {\n\t\t\tsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\n\t\t\t\t \"%s-%s-%d\", basename, \"tx\", tx_int_idx++);\n\t\t} else {\n\t\t\t/* skip this unused q_vector */\n\t\t\tcontinue;\n\t\t}\n\t\terr = request_irq(irq_num,\n\t\t\t\t  vsi->irq_handler,\n\t\t\t\t  0,\n\t\t\t\t  q_vector->name,\n\t\t\t\t  q_vector);\n\t\tif (err) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"MSIX request_irq failed, error: %d\\n\", err);\n\t\t\tgoto free_queue_irqs;\n\t\t}\n\n\t\t/* register for affinity change notifications */\n\t\tq_vector->affinity_notify.notify = i40e_irq_affinity_notify;\n\t\tq_vector->affinity_notify.release = i40e_irq_affinity_release;\n\t\tirq_set_affinity_notifier(irq_num, &q_vector->affinity_notify);\n\t\t/* Spread affinity hints out across online CPUs.\n\t\t *\n\t\t * get_cpu_mask returns a static constant mask with\n\t\t * a permanent lifetime so it's ok to pass to\n\t\t * irq_set_affinity_hint without making a copy.\n\t\t */\n\t\tcpu = cpumask_local_spread(q_vector->v_idx, -1);\n\t\tirq_set_affinity_hint(irq_num, get_cpu_mask(cpu));\n\t}\n\n\tvsi->irqs_ready = true;\n\treturn 0;\n\nfree_queue_irqs:\n\twhile (vector) {\n\t\tvector--;\n\t\tirq_num = pf->msix_entries[base + vector].vector;\n\t\tirq_set_affinity_notifier(irq_num, NULL);\n\t\tirq_set_affinity_hint(irq_num, NULL);\n\t\tfree_irq(irq_num, &vsi->q_vectors[vector]);\n\t}\n\treturn err;\n}\n\n/**\n * i40e_vsi_disable_irq - Mask off queue interrupt generation on the VSI\n * @vsi: the VSI being un-configured\n **/\nstatic void i40e_vsi_disable_irq(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint base = vsi->base_vector;\n\tint i;\n\n\t/* disable interrupt causation from each queue */\n\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\tu32 val;\n\n\t\tval = rd32(hw, I40E_QINT_TQCTL(vsi->tx_rings[i]->reg_idx));\n\t\tval &= ~I40E_QINT_TQCTL_CAUSE_ENA_MASK;\n\t\twr32(hw, I40E_QINT_TQCTL(vsi->tx_rings[i]->reg_idx), val);\n\n\t\tval = rd32(hw, I40E_QINT_RQCTL(vsi->rx_rings[i]->reg_idx));\n\t\tval &= ~I40E_QINT_RQCTL_CAUSE_ENA_MASK;\n\t\twr32(hw, I40E_QINT_RQCTL(vsi->rx_rings[i]->reg_idx), val);\n\n\t\tif (!i40e_enabled_xdp_vsi(vsi))\n\t\t\tcontinue;\n\t\twr32(hw, I40E_QINT_TQCTL(vsi->xdp_rings[i]->reg_idx), 0);\n\t}\n\n\t/* disable each interrupt */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tfor (i = vsi->base_vector;\n\t\t     i < (vsi->num_q_vectors + vsi->base_vector); i++)\n\t\t\twr32(hw, I40E_PFINT_DYN_CTLN(i - 1), 0);\n\n\t\ti40e_flush(hw);\n\t\tfor (i = 0; i < vsi->num_q_vectors; i++)\n\t\t\tsynchronize_irq(pf->msix_entries[i + base].vector);\n\t} else {\n\t\t/* Legacy and MSI mode - this stops all interrupt handling */\n\t\twr32(hw, I40E_PFINT_ICR0_ENA, 0);\n\t\twr32(hw, I40E_PFINT_DYN_CTL0, 0);\n\t\ti40e_flush(hw);\n\t\tsynchronize_irq(pf->pdev->irq);\n\t}\n}\n\n/**\n * i40e_vsi_enable_irq - Enable IRQ for the given VSI\n * @vsi: the VSI being configured\n **/\nstatic int i40e_vsi_enable_irq(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint i;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tfor (i = 0; i < vsi->num_q_vectors; i++)\n\t\t\ti40e_irq_dynamic_enable(vsi, i);\n\t} else {\n\t\ti40e_irq_dynamic_enable_icr0(pf);\n\t}\n\n\ti40e_flush(&pf->hw);\n\treturn 0;\n}\n\n/**\n * i40e_free_misc_vector - Free the vector that handles non-queue events\n * @pf: board private structure\n **/\nstatic void i40e_free_misc_vector(struct i40e_pf *pf)\n{\n\t/* Disable ICR 0 */\n\twr32(&pf->hw, I40E_PFINT_ICR0_ENA, 0);\n\ti40e_flush(&pf->hw);\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED && pf->msix_entries) {\n\t\tsynchronize_irq(pf->msix_entries[0].vector);\n\t\tfree_irq(pf->msix_entries[0].vector, pf);\n\t\tclear_bit(__I40E_MISC_IRQ_REQUESTED, pf->state);\n\t}\n}\n\n/**\n * i40e_intr - MSI/Legacy and non-queue interrupt handler\n * @irq: interrupt number\n * @data: pointer to a q_vector\n *\n * This is the handler used for all MSI/Legacy interrupts, and deals\n * with both queue and non-queue interrupts.  This is also used in\n * MSIX mode to handle the non-queue interrupts.\n **/\nstatic irqreturn_t i40e_intr(int irq, void *data)\n{\n\tstruct i40e_pf *pf = (struct i40e_pf *)data;\n\tstruct i40e_hw *hw = &pf->hw;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 icr0, icr0_remaining;\n\tu32 val, ena_mask;\n\n\ticr0 = rd32(hw, I40E_PFINT_ICR0);\n\tena_mask = rd32(hw, I40E_PFINT_ICR0_ENA);\n\n\t/* if sharing a legacy IRQ, we might get called w/o an intr pending */\n\tif ((icr0 & I40E_PFINT_ICR0_INTEVENT_MASK) == 0)\n\t\tgoto enable_intr;\n\n\t/* if interrupt but no bits showing, must be SWINT */\n\tif (((icr0 & ~I40E_PFINT_ICR0_INTEVENT_MASK) == 0) ||\n\t    (icr0 & I40E_PFINT_ICR0_SWINT_MASK))\n\t\tpf->sw_int_count++;\n\n\tif ((pf->flags & I40E_FLAG_IWARP_ENABLED) &&\n\t    (icr0 & I40E_PFINT_ICR0_ENA_PE_CRITERR_MASK)) {\n\t\tena_mask &= ~I40E_PFINT_ICR0_ENA_PE_CRITERR_MASK;\n\t\tdev_dbg(&pf->pdev->dev, \"cleared PE_CRITERR\\n\");\n\t\tset_bit(__I40E_CORE_RESET_REQUESTED, pf->state);\n\t}\n\n\t/* only q0 is used in MSI/Legacy mode, and none are used in MSIX */\n\tif (icr0 & I40E_PFINT_ICR0_QUEUE_0_MASK) {\n\t\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\t\tstruct i40e_q_vector *q_vector = vsi->q_vectors[0];\n\n\t\t/* We do not have a way to disarm Queue causes while leaving\n\t\t * interrupt enabled for all other causes, ideally\n\t\t * interrupt should be disabled while we are in NAPI but\n\t\t * this is not a performance path and napi_schedule()\n\t\t * can deal with rescheduling.\n\t\t */\n\t\tif (!test_bit(__I40E_DOWN, pf->state))\n\t\t\tnapi_schedule_irqoff(&q_vector->napi);\n\t}\n\n\tif (icr0 & I40E_PFINT_ICR0_ADMINQ_MASK) {\n\t\tena_mask &= ~I40E_PFINT_ICR0_ENA_ADMINQ_MASK;\n\t\tset_bit(__I40E_ADMINQ_EVENT_PENDING, pf->state);\n\t\ti40e_debug(&pf->hw, I40E_DEBUG_NVM, \"AdminQ event\\n\");\n\t}\n\n\tif (icr0 & I40E_PFINT_ICR0_MAL_DETECT_MASK) {\n\t\tena_mask &= ~I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK;\n\t\tset_bit(__I40E_MDD_EVENT_PENDING, pf->state);\n\t}\n\n\tif (icr0 & I40E_PFINT_ICR0_VFLR_MASK) {\n\t\t/* disable any further VFLR event notifications */\n\t\tif (test_bit(__I40E_VF_RESETS_DISABLED, pf->state)) {\n\t\t\tu32 reg = rd32(hw, I40E_PFINT_ICR0_ENA);\n\n\t\t\treg &= ~I40E_PFINT_ICR0_VFLR_MASK;\n\t\t\twr32(hw, I40E_PFINT_ICR0_ENA, reg);\n\t\t} else {\n\t\t\tena_mask &= ~I40E_PFINT_ICR0_ENA_VFLR_MASK;\n\t\t\tset_bit(__I40E_VFLR_EVENT_PENDING, pf->state);\n\t\t}\n\t}\n\n\tif (icr0 & I40E_PFINT_ICR0_GRST_MASK) {\n\t\tif (!test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))\n\t\t\tset_bit(__I40E_RESET_INTR_RECEIVED, pf->state);\n\t\tena_mask &= ~I40E_PFINT_ICR0_ENA_GRST_MASK;\n\t\tval = rd32(hw, I40E_GLGEN_RSTAT);\n\t\tval = (val & I40E_GLGEN_RSTAT_RESET_TYPE_MASK)\n\t\t       >> I40E_GLGEN_RSTAT_RESET_TYPE_SHIFT;\n\t\tif (val == I40E_RESET_CORER) {\n\t\t\tpf->corer_count++;\n\t\t} else if (val == I40E_RESET_GLOBR) {\n\t\t\tpf->globr_count++;\n\t\t} else if (val == I40E_RESET_EMPR) {\n\t\t\tpf->empr_count++;\n\t\t\tset_bit(__I40E_EMP_RESET_INTR_RECEIVED, pf->state);\n\t\t}\n\t}\n\n\tif (icr0 & I40E_PFINT_ICR0_HMC_ERR_MASK) {\n\t\ticr0 &= ~I40E_PFINT_ICR0_HMC_ERR_MASK;\n\t\tdev_info(&pf->pdev->dev, \"HMC error interrupt\\n\");\n\t\tdev_info(&pf->pdev->dev, \"HMC error info 0x%x, HMC error data 0x%x\\n\",\n\t\t\t rd32(hw, I40E_PFHMC_ERRORINFO),\n\t\t\t rd32(hw, I40E_PFHMC_ERRORDATA));\n\t}\n\n\tif (icr0 & I40E_PFINT_ICR0_TIMESYNC_MASK) {\n\t\tu32 prttsyn_stat = rd32(hw, I40E_PRTTSYN_STAT_0);\n\n\t\tif (prttsyn_stat & I40E_PRTTSYN_STAT_0_TXTIME_MASK) {\n\t\t\ticr0 &= ~I40E_PFINT_ICR0_ENA_TIMESYNC_MASK;\n\t\t\ti40e_ptp_tx_hwtstamp(pf);\n\t\t}\n\t}\n\n\t/* If a critical error is pending we have no choice but to reset the\n\t * device.\n\t * Report and mask out any remaining unexpected interrupts.\n\t */\n\ticr0_remaining = icr0 & ena_mask;\n\tif (icr0_remaining) {\n\t\tdev_info(&pf->pdev->dev, \"unhandled interrupt icr0=0x%08x\\n\",\n\t\t\t icr0_remaining);\n\t\tif ((icr0_remaining & I40E_PFINT_ICR0_PE_CRITERR_MASK) ||\n\t\t    (icr0_remaining & I40E_PFINT_ICR0_PCI_EXCEPTION_MASK) ||\n\t\t    (icr0_remaining & I40E_PFINT_ICR0_ECC_ERR_MASK)) {\n\t\t\tdev_info(&pf->pdev->dev, \"device will be reset\\n\");\n\t\t\tset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t\t\ti40e_service_event_schedule(pf);\n\t\t}\n\t\tena_mask &= ~icr0_remaining;\n\t}\n\tret = IRQ_HANDLED;\n\nenable_intr:\n\t/* re-enable interrupt causes */\n\twr32(hw, I40E_PFINT_ICR0_ENA, ena_mask);\n\tif (!test_bit(__I40E_DOWN, pf->state) ||\n\t    test_bit(__I40E_RECOVERY_MODE, pf->state)) {\n\t\ti40e_service_event_schedule(pf);\n\t\ti40e_irq_dynamic_enable_icr0(pf);\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_clean_fdir_tx_irq - Reclaim resources after transmit completes\n * @tx_ring:  tx ring to clean\n * @budget:   how many cleans we're allowed\n *\n * Returns true if there's any budget left (e.g. the clean is finished)\n **/\nstatic bool i40e_clean_fdir_tx_irq(struct i40e_ring *tx_ring, int budget)\n{\n\tstruct i40e_vsi *vsi = tx_ring->vsi;\n\tu16 i = tx_ring->next_to_clean;\n\tstruct i40e_tx_buffer *tx_buf;\n\tstruct i40e_tx_desc *tx_desc;\n\n\ttx_buf = &tx_ring->tx_bi[i];\n\ttx_desc = I40E_TX_DESC(tx_ring, i);\n\ti -= tx_ring->count;\n\n\tdo {\n\t\tstruct i40e_tx_desc *eop_desc = tx_buf->next_to_watch;\n\n\t\t/* if next_to_watch is not set then there is no work pending */\n\t\tif (!eop_desc)\n\t\t\tbreak;\n\n\t\t/* prevent any other reads prior to eop_desc */\n\t\tsmp_rmb();\n\n\t\t/* if the descriptor isn't done, no work yet to do */\n\t\tif (!(eop_desc->cmd_type_offset_bsz &\n\t\t      cpu_to_le64(I40E_TX_DESC_DTYPE_DESC_DONE)))\n\t\t\tbreak;\n\n\t\t/* clear next_to_watch to prevent false hangs */\n\t\ttx_buf->next_to_watch = NULL;\n\n\t\ttx_desc->buffer_addr = 0;\n\t\ttx_desc->cmd_type_offset_bsz = 0;\n\t\t/* move past filter desc */\n\t\ttx_buf++;\n\t\ttx_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\ti -= tx_ring->count;\n\t\t\ttx_buf = tx_ring->tx_bi;\n\t\t\ttx_desc = I40E_TX_DESC(tx_ring, 0);\n\t\t}\n\t\t/* unmap skb header data */\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buf, dma),\n\t\t\t\t dma_unmap_len(tx_buf, len),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (tx_buf->tx_flags & I40E_TX_FLAGS_FD_SB)\n\t\t\tkfree(tx_buf->raw_buf);\n\n\t\ttx_buf->raw_buf = NULL;\n\t\ttx_buf->tx_flags = 0;\n\t\ttx_buf->next_to_watch = NULL;\n\t\tdma_unmap_len_set(tx_buf, len, 0);\n\t\ttx_desc->buffer_addr = 0;\n\t\ttx_desc->cmd_type_offset_bsz = 0;\n\n\t\t/* move us past the eop_desc for start of next FD desc */\n\t\ttx_buf++;\n\t\ttx_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\ti -= tx_ring->count;\n\t\t\ttx_buf = tx_ring->tx_bi;\n\t\t\ttx_desc = I40E_TX_DESC(tx_ring, 0);\n\t\t}\n\n\t\t/* update budget accounting */\n\t\tbudget--;\n\t} while (likely(budget));\n\n\ti += tx_ring->count;\n\ttx_ring->next_to_clean = i;\n\n\tif (vsi->back->flags & I40E_FLAG_MSIX_ENABLED)\n\t\ti40e_irq_dynamic_enable(vsi, tx_ring->q_vector->v_idx);\n\n\treturn budget > 0;\n}\n\n/**\n * i40e_fdir_clean_ring - Interrupt Handler for FDIR SB ring\n * @irq: interrupt number\n * @data: pointer to a q_vector\n **/\nstatic irqreturn_t i40e_fdir_clean_ring(int irq, void *data)\n{\n\tstruct i40e_q_vector *q_vector = data;\n\tstruct i40e_vsi *vsi;\n\n\tif (!q_vector->tx.ring)\n\t\treturn IRQ_HANDLED;\n\n\tvsi = q_vector->tx.ring->vsi;\n\ti40e_clean_fdir_tx_irq(q_vector->tx.ring, vsi->work_limit);\n\n\treturn IRQ_HANDLED;\n}\n\n/**\n * i40e_map_vector_to_qp - Assigns the queue pair to the vector\n * @vsi: the VSI being configured\n * @v_idx: vector index\n * @qp_idx: queue pair index\n **/\nstatic void i40e_map_vector_to_qp(struct i40e_vsi *vsi, int v_idx, int qp_idx)\n{\n\tstruct i40e_q_vector *q_vector = vsi->q_vectors[v_idx];\n\tstruct i40e_ring *tx_ring = vsi->tx_rings[qp_idx];\n\tstruct i40e_ring *rx_ring = vsi->rx_rings[qp_idx];\n\n\ttx_ring->q_vector = q_vector;\n\ttx_ring->next = q_vector->tx.ring;\n\tq_vector->tx.ring = tx_ring;\n\tq_vector->tx.count++;\n\n\t/* Place XDP Tx ring in the same q_vector ring list as regular Tx */\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\tstruct i40e_ring *xdp_ring = vsi->xdp_rings[qp_idx];\n\n\t\txdp_ring->q_vector = q_vector;\n\t\txdp_ring->next = q_vector->tx.ring;\n\t\tq_vector->tx.ring = xdp_ring;\n\t\tq_vector->tx.count++;\n\t}\n\n\trx_ring->q_vector = q_vector;\n\trx_ring->next = q_vector->rx.ring;\n\tq_vector->rx.ring = rx_ring;\n\tq_vector->rx.count++;\n}\n\n/**\n * i40e_vsi_map_rings_to_vectors - Maps descriptor rings to vectors\n * @vsi: the VSI being configured\n *\n * This function maps descriptor rings to the queue-specific vectors\n * we were allotted through the MSI-X enabling code.  Ideally, we'd have\n * one vector per queue pair, but on a constrained vector budget, we\n * group the queue pairs as \"efficiently\" as possible.\n **/\nstatic void i40e_vsi_map_rings_to_vectors(struct i40e_vsi *vsi)\n{\n\tint qp_remaining = vsi->num_queue_pairs;\n\tint q_vectors = vsi->num_q_vectors;\n\tint num_ringpairs;\n\tint v_start = 0;\n\tint qp_idx = 0;\n\n\t/* If we don't have enough vectors for a 1-to-1 mapping, we'll have to\n\t * group them so there are multiple queues per vector.\n\t * It is also important to go through all the vectors available to be\n\t * sure that if we don't use all the vectors, that the remaining vectors\n\t * are cleared. This is especially important when decreasing the\n\t * number of queues in use.\n\t */\n\tfor (; v_start < q_vectors; v_start++) {\n\t\tstruct i40e_q_vector *q_vector = vsi->q_vectors[v_start];\n\n\t\tnum_ringpairs = DIV_ROUND_UP(qp_remaining, q_vectors - v_start);\n\n\t\tq_vector->num_ringpairs = num_ringpairs;\n\t\tq_vector->reg_idx = q_vector->v_idx + vsi->base_vector - 1;\n\n\t\tq_vector->rx.count = 0;\n\t\tq_vector->tx.count = 0;\n\t\tq_vector->rx.ring = NULL;\n\t\tq_vector->tx.ring = NULL;\n\n\t\twhile (num_ringpairs--) {\n\t\t\ti40e_map_vector_to_qp(vsi, v_start, qp_idx);\n\t\t\tqp_idx++;\n\t\t\tqp_remaining--;\n\t\t}\n\t}\n}\n\n/**\n * i40e_vsi_request_irq - Request IRQ from the OS\n * @vsi: the VSI being configured\n * @basename: name for the vector\n **/\nstatic int i40e_vsi_request_irq(struct i40e_vsi *vsi, char *basename)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint err;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\terr = i40e_vsi_request_irq_msix(vsi, basename);\n\telse if (pf->flags & I40E_FLAG_MSI_ENABLED)\n\t\terr = request_irq(pf->pdev->irq, i40e_intr, 0,\n\t\t\t\t  pf->int_name, pf);\n\telse\n\t\terr = request_irq(pf->pdev->irq, i40e_intr, IRQF_SHARED,\n\t\t\t\t  pf->int_name, pf);\n\n\tif (err)\n\t\tdev_info(&pf->pdev->dev, \"request_irq failed, Error %d\\n\", err);\n\n\treturn err;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n/**\n * i40e_netpoll - A Polling 'interrupt' handler\n * @netdev: network interface device structure\n *\n * This is used by netconsole to send skbs without having to re-enable\n * interrupts.  It's not called while the normal interrupt routine is executing.\n **/\nstatic void i40e_netpoll(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint i;\n\n\t/* if interface is down do nothing */\n\tif (test_bit(__I40E_VSI_DOWN, vsi->state))\n\t\treturn;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tfor (i = 0; i < vsi->num_q_vectors; i++)\n\t\t\ti40e_msix_clean_rings(0, vsi->q_vectors[i]);\n\t} else {\n\t\ti40e_intr(pf->pdev->irq, netdev);\n\t}\n}\n#endif\n\n#define I40E_QTX_ENA_WAIT_COUNT 50\n\n/**\n * i40e_pf_txq_wait - Wait for a PF's Tx queue to be enabled or disabled\n * @pf: the PF being configured\n * @pf_q: the PF queue\n * @enable: enable or disable state of the queue\n *\n * This routine will wait for the given Tx queue of the PF to reach the\n * enabled or disabled state.\n * Returns -ETIMEDOUT in case of failing to reach the requested state after\n * multiple retries; else will return 0 in case of success.\n **/\nstatic int i40e_pf_txq_wait(struct i40e_pf *pf, int pf_q, bool enable)\n{\n\tint i;\n\tu32 tx_reg;\n\n\tfor (i = 0; i < I40E_QUEUE_WAIT_RETRY_LIMIT; i++) {\n\t\ttx_reg = rd32(&pf->hw, I40E_QTX_ENA(pf_q));\n\t\tif (enable == !!(tx_reg & I40E_QTX_ENA_QENA_STAT_MASK))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\tif (i >= I40E_QUEUE_WAIT_RETRY_LIMIT)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n/**\n * i40e_control_tx_q - Start or stop a particular Tx queue\n * @pf: the PF structure\n * @pf_q: the PF queue to configure\n * @enable: start or stop the queue\n *\n * This function enables or disables a single queue. Note that any delay\n * required after the operation is expected to be handled by the caller of\n * this function.\n **/\nstatic void i40e_control_tx_q(struct i40e_pf *pf, int pf_q, bool enable)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 tx_reg;\n\tint i;\n\n\t/* warn the TX unit of coming changes */\n\ti40e_pre_tx_queue_cfg(&pf->hw, pf_q, enable);\n\tif (!enable)\n\t\tusleep_range(10, 20);\n\n\tfor (i = 0; i < I40E_QTX_ENA_WAIT_COUNT; i++) {\n\t\ttx_reg = rd32(hw, I40E_QTX_ENA(pf_q));\n\t\tif (((tx_reg >> I40E_QTX_ENA_QENA_REQ_SHIFT) & 1) ==\n\t\t    ((tx_reg >> I40E_QTX_ENA_QENA_STAT_SHIFT) & 1))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t/* Skip if the queue is already in the requested state */\n\tif (enable == !!(tx_reg & I40E_QTX_ENA_QENA_STAT_MASK))\n\t\treturn;\n\n\t/* turn on/off the queue */\n\tif (enable) {\n\t\twr32(hw, I40E_QTX_HEAD(pf_q), 0);\n\t\ttx_reg |= I40E_QTX_ENA_QENA_REQ_MASK;\n\t} else {\n\t\ttx_reg &= ~I40E_QTX_ENA_QENA_REQ_MASK;\n\t}\n\n\twr32(hw, I40E_QTX_ENA(pf_q), tx_reg);\n}\n\n/**\n * i40e_control_wait_tx_q - Start/stop Tx queue and wait for completion\n * @seid: VSI SEID\n * @pf: the PF structure\n * @pf_q: the PF queue to configure\n * @is_xdp: true if the queue is used for XDP\n * @enable: start or stop the queue\n **/\nint i40e_control_wait_tx_q(int seid, struct i40e_pf *pf, int pf_q,\n\t\t\t   bool is_xdp, bool enable)\n{\n\tint ret;\n\n\ti40e_control_tx_q(pf, pf_q, enable);\n\n\t/* wait for the change to finish */\n\tret = i40e_pf_txq_wait(pf, pf_q, enable);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VSI seid %d %sTx ring %d %sable timeout\\n\",\n\t\t\t seid, (is_xdp ? \"XDP \" : \"\"), pf_q,\n\t\t\t (enable ? \"en\" : \"dis\"));\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_vsi_control_tx - Start or stop a VSI's rings\n * @vsi: the VSI being configured\n * @enable: start or stop the rings\n **/\nstatic int i40e_vsi_control_tx(struct i40e_vsi *vsi, bool enable)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint i, pf_q, ret = 0;\n\n\tpf_q = vsi->base_queue;\n\tfor (i = 0; i < vsi->num_queue_pairs; i++, pf_q++) {\n\t\tret = i40e_control_wait_tx_q(vsi->seid, pf,\n\t\t\t\t\t     pf_q,\n\t\t\t\t\t     false /*is xdp*/, enable);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (!i40e_enabled_xdp_vsi(vsi))\n\t\t\tcontinue;\n\n\t\tret = i40e_control_wait_tx_q(vsi->seid, pf,\n\t\t\t\t\t     pf_q + vsi->alloc_queue_pairs,\n\t\t\t\t\t     true /*is xdp*/, enable);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n/**\n * i40e_pf_rxq_wait - Wait for a PF's Rx queue to be enabled or disabled\n * @pf: the PF being configured\n * @pf_q: the PF queue\n * @enable: enable or disable state of the queue\n *\n * This routine will wait for the given Rx queue of the PF to reach the\n * enabled or disabled state.\n * Returns -ETIMEDOUT in case of failing to reach the requested state after\n * multiple retries; else will return 0 in case of success.\n **/\nstatic int i40e_pf_rxq_wait(struct i40e_pf *pf, int pf_q, bool enable)\n{\n\tint i;\n\tu32 rx_reg;\n\n\tfor (i = 0; i < I40E_QUEUE_WAIT_RETRY_LIMIT; i++) {\n\t\trx_reg = rd32(&pf->hw, I40E_QRX_ENA(pf_q));\n\t\tif (enable == !!(rx_reg & I40E_QRX_ENA_QENA_STAT_MASK))\n\t\t\tbreak;\n\n\t\tusleep_range(10, 20);\n\t}\n\tif (i >= I40E_QUEUE_WAIT_RETRY_LIMIT)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n/**\n * i40e_control_rx_q - Start or stop a particular Rx queue\n * @pf: the PF structure\n * @pf_q: the PF queue to configure\n * @enable: start or stop the queue\n *\n * This function enables or disables a single queue. Note that\n * any delay required after the operation is expected to be\n * handled by the caller of this function.\n **/\nstatic void i40e_control_rx_q(struct i40e_pf *pf, int pf_q, bool enable)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 rx_reg;\n\tint i;\n\n\tfor (i = 0; i < I40E_QTX_ENA_WAIT_COUNT; i++) {\n\t\trx_reg = rd32(hw, I40E_QRX_ENA(pf_q));\n\t\tif (((rx_reg >> I40E_QRX_ENA_QENA_REQ_SHIFT) & 1) ==\n\t\t    ((rx_reg >> I40E_QRX_ENA_QENA_STAT_SHIFT) & 1))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t/* Skip if the queue is already in the requested state */\n\tif (enable == !!(rx_reg & I40E_QRX_ENA_QENA_STAT_MASK))\n\t\treturn;\n\n\t/* turn on/off the queue */\n\tif (enable)\n\t\trx_reg |= I40E_QRX_ENA_QENA_REQ_MASK;\n\telse\n\t\trx_reg &= ~I40E_QRX_ENA_QENA_REQ_MASK;\n\n\twr32(hw, I40E_QRX_ENA(pf_q), rx_reg);\n}\n\n/**\n * i40e_control_wait_rx_q\n * @pf: the PF structure\n * @pf_q: queue being configured\n * @enable: start or stop the rings\n *\n * This function enables or disables a single queue along with waiting\n * for the change to finish. The caller of this function should handle\n * the delays needed in the case of disabling queues.\n **/\nint i40e_control_wait_rx_q(struct i40e_pf *pf, int pf_q, bool enable)\n{\n\tint ret = 0;\n\n\ti40e_control_rx_q(pf, pf_q, enable);\n\n\t/* wait for the change to finish */\n\tret = i40e_pf_rxq_wait(pf, pf_q, enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\n/**\n * i40e_vsi_control_rx - Start or stop a VSI's rings\n * @vsi: the VSI being configured\n * @enable: start or stop the rings\n **/\nstatic int i40e_vsi_control_rx(struct i40e_vsi *vsi, bool enable)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint i, pf_q, ret = 0;\n\n\tpf_q = vsi->base_queue;\n\tfor (i = 0; i < vsi->num_queue_pairs; i++, pf_q++) {\n\t\tret = i40e_control_wait_rx_q(pf, pf_q, enable);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VSI seid %d Rx ring %d %sable timeout\\n\",\n\t\t\t\t vsi->seid, pf_q, (enable ? \"en\" : \"dis\"));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Due to HW errata, on Rx disable only, the register can indicate done\n\t * before it really is. Needs 50ms to be sure\n\t */\n\tif (!enable)\n\t\tmdelay(50);\n\n\treturn ret;\n}\n\n/**\n * i40e_vsi_start_rings - Start a VSI's rings\n * @vsi: the VSI being configured\n **/\nint i40e_vsi_start_rings(struct i40e_vsi *vsi)\n{\n\tint ret = 0;\n\n\t/* do rx first for enable and last for disable */\n\tret = i40e_vsi_control_rx(vsi, true);\n\tif (ret)\n\t\treturn ret;\n\tret = i40e_vsi_control_tx(vsi, true);\n\n\treturn ret;\n}\n\n/**\n * i40e_vsi_stop_rings - Stop a VSI's rings\n * @vsi: the VSI being configured\n **/\nvoid i40e_vsi_stop_rings(struct i40e_vsi *vsi)\n{\n\t/* When port TX is suspended, don't wait */\n\tif (test_bit(__I40E_PORT_SUSPENDED, vsi->back->state))\n\t\treturn i40e_vsi_stop_rings_no_wait(vsi);\n\n\t/* do rx first for enable and last for disable\n\t * Ignore return value, we need to shutdown whatever we can\n\t */\n\ti40e_vsi_control_tx(vsi, false);\n\ti40e_vsi_control_rx(vsi, false);\n}\n\n/**\n * i40e_vsi_stop_rings_no_wait - Stop a VSI's rings and do not delay\n * @vsi: the VSI being shutdown\n *\n * This function stops all the rings for a VSI but does not delay to verify\n * that rings have been disabled. It is expected that the caller is shutting\n * down multiple VSIs at once and will delay together for all the VSIs after\n * initiating the shutdown. This is particularly useful for shutting down lots\n * of VFs together. Otherwise, a large delay can be incurred while configuring\n * each VSI in serial.\n **/\nvoid i40e_vsi_stop_rings_no_wait(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint i, pf_q;\n\n\tpf_q = vsi->base_queue;\n\tfor (i = 0; i < vsi->num_queue_pairs; i++, pf_q++) {\n\t\ti40e_control_tx_q(pf, pf_q, false);\n\t\ti40e_control_rx_q(pf, pf_q, false);\n\t}\n}\n\n/**\n * i40e_vsi_free_irq - Free the irq association with the OS\n * @vsi: the VSI being configured\n **/\nstatic void i40e_vsi_free_irq(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint base = vsi->base_vector;\n\tu32 val, qp;\n\tint i;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tif (!vsi->q_vectors)\n\t\t\treturn;\n\n\t\tif (!vsi->irqs_ready)\n\t\t\treturn;\n\n\t\tvsi->irqs_ready = false;\n\t\tfor (i = 0; i < vsi->num_q_vectors; i++) {\n\t\t\tint irq_num;\n\t\t\tu16 vector;\n\n\t\t\tvector = i + base;\n\t\t\tirq_num = pf->msix_entries[vector].vector;\n\n\t\t\t/* free only the irqs that were actually requested */\n\t\t\tif (!vsi->q_vectors[i] ||\n\t\t\t    !vsi->q_vectors[i]->num_ringpairs)\n\t\t\t\tcontinue;\n\n\t\t\t/* clear the affinity notifier in the IRQ descriptor */\n\t\t\tirq_set_affinity_notifier(irq_num, NULL);\n\t\t\t/* remove our suggested affinity mask for this IRQ */\n\t\t\tirq_set_affinity_hint(irq_num, NULL);\n\t\t\tsynchronize_irq(irq_num);\n\t\t\tfree_irq(irq_num, vsi->q_vectors[i]);\n\n\t\t\t/* Tear down the interrupt queue link list\n\t\t\t *\n\t\t\t * We know that they come in pairs and always\n\t\t\t * the Rx first, then the Tx.  To clear the\n\t\t\t * link list, stick the EOL value into the\n\t\t\t * next_q field of the registers.\n\t\t\t */\n\t\t\tval = rd32(hw, I40E_PFINT_LNKLSTN(vector - 1));\n\t\t\tqp = (val & I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK)\n\t\t\t\t>> I40E_PFINT_LNKLSTN_FIRSTQ_INDX_SHIFT;\n\t\t\tval |= I40E_QUEUE_END_OF_LIST\n\t\t\t\t<< I40E_PFINT_LNKLSTN_FIRSTQ_INDX_SHIFT;\n\t\t\twr32(hw, I40E_PFINT_LNKLSTN(vector - 1), val);\n\n\t\t\twhile (qp != I40E_QUEUE_END_OF_LIST) {\n\t\t\t\tu32 next;\n\n\t\t\t\tval = rd32(hw, I40E_QINT_RQCTL(qp));\n\n\t\t\t\tval &= ~(I40E_QINT_RQCTL_MSIX_INDX_MASK  |\n\t\t\t\t\t I40E_QINT_RQCTL_MSIX0_INDX_MASK |\n\t\t\t\t\t I40E_QINT_RQCTL_CAUSE_ENA_MASK  |\n\t\t\t\t\t I40E_QINT_RQCTL_INTEVENT_MASK);\n\n\t\t\t\tval |= (I40E_QINT_RQCTL_ITR_INDX_MASK |\n\t\t\t\t\t I40E_QINT_RQCTL_NEXTQ_INDX_MASK);\n\n\t\t\t\twr32(hw, I40E_QINT_RQCTL(qp), val);\n\n\t\t\t\tval = rd32(hw, I40E_QINT_TQCTL(qp));\n\n\t\t\t\tnext = (val & I40E_QINT_TQCTL_NEXTQ_INDX_MASK)\n\t\t\t\t\t>> I40E_QINT_TQCTL_NEXTQ_INDX_SHIFT;\n\n\t\t\t\tval &= ~(I40E_QINT_TQCTL_MSIX_INDX_MASK  |\n\t\t\t\t\t I40E_QINT_TQCTL_MSIX0_INDX_MASK |\n\t\t\t\t\t I40E_QINT_TQCTL_CAUSE_ENA_MASK  |\n\t\t\t\t\t I40E_QINT_TQCTL_INTEVENT_MASK);\n\n\t\t\t\tval |= (I40E_QINT_TQCTL_ITR_INDX_MASK |\n\t\t\t\t\t I40E_QINT_TQCTL_NEXTQ_INDX_MASK);\n\n\t\t\t\twr32(hw, I40E_QINT_TQCTL(qp), val);\n\t\t\t\tqp = next;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfree_irq(pf->pdev->irq, pf);\n\n\t\tval = rd32(hw, I40E_PFINT_LNKLST0);\n\t\tqp = (val & I40E_PFINT_LNKLSTN_FIRSTQ_INDX_MASK)\n\t\t\t>> I40E_PFINT_LNKLSTN_FIRSTQ_INDX_SHIFT;\n\t\tval |= I40E_QUEUE_END_OF_LIST\n\t\t\t<< I40E_PFINT_LNKLST0_FIRSTQ_INDX_SHIFT;\n\t\twr32(hw, I40E_PFINT_LNKLST0, val);\n\n\t\tval = rd32(hw, I40E_QINT_RQCTL(qp));\n\t\tval &= ~(I40E_QINT_RQCTL_MSIX_INDX_MASK  |\n\t\t\t I40E_QINT_RQCTL_MSIX0_INDX_MASK |\n\t\t\t I40E_QINT_RQCTL_CAUSE_ENA_MASK  |\n\t\t\t I40E_QINT_RQCTL_INTEVENT_MASK);\n\n\t\tval |= (I40E_QINT_RQCTL_ITR_INDX_MASK |\n\t\t\tI40E_QINT_RQCTL_NEXTQ_INDX_MASK);\n\n\t\twr32(hw, I40E_QINT_RQCTL(qp), val);\n\n\t\tval = rd32(hw, I40E_QINT_TQCTL(qp));\n\n\t\tval &= ~(I40E_QINT_TQCTL_MSIX_INDX_MASK  |\n\t\t\t I40E_QINT_TQCTL_MSIX0_INDX_MASK |\n\t\t\t I40E_QINT_TQCTL_CAUSE_ENA_MASK  |\n\t\t\t I40E_QINT_TQCTL_INTEVENT_MASK);\n\n\t\tval |= (I40E_QINT_TQCTL_ITR_INDX_MASK |\n\t\t\tI40E_QINT_TQCTL_NEXTQ_INDX_MASK);\n\n\t\twr32(hw, I40E_QINT_TQCTL(qp), val);\n\t}\n}\n\n/**\n * i40e_free_q_vector - Free memory allocated for specific interrupt vector\n * @vsi: the VSI being configured\n * @v_idx: Index of vector to be freed\n *\n * This function frees the memory allocated to the q_vector.  In addition if\n * NAPI is enabled it will delete any references to the NAPI struct prior\n * to freeing the q_vector.\n **/\nstatic void i40e_free_q_vector(struct i40e_vsi *vsi, int v_idx)\n{\n\tstruct i40e_q_vector *q_vector = vsi->q_vectors[v_idx];\n\tstruct i40e_ring *ring;\n\n\tif (!q_vector)\n\t\treturn;\n\n\t/* disassociate q_vector from rings */\n\ti40e_for_each_ring(ring, q_vector->tx)\n\t\tring->q_vector = NULL;\n\n\ti40e_for_each_ring(ring, q_vector->rx)\n\t\tring->q_vector = NULL;\n\n\t/* only VSI w/ an associated netdev is set up w/ NAPI */\n\tif (vsi->netdev)\n\t\tnetif_napi_del(&q_vector->napi);\n\n\tvsi->q_vectors[v_idx] = NULL;\n\n\tkfree_rcu(q_vector, rcu);\n}\n\n/**\n * i40e_vsi_free_q_vectors - Free memory allocated for interrupt vectors\n * @vsi: the VSI being un-configured\n *\n * This frees the memory allocated to the q_vectors and\n * deletes references to the NAPI struct.\n **/\nstatic void i40e_vsi_free_q_vectors(struct i40e_vsi *vsi)\n{\n\tint v_idx;\n\n\tfor (v_idx = 0; v_idx < vsi->num_q_vectors; v_idx++)\n\t\ti40e_free_q_vector(vsi, v_idx);\n}\n\n/**\n * i40e_reset_interrupt_capability - Disable interrupt setup in OS\n * @pf: board private structure\n **/\nstatic void i40e_reset_interrupt_capability(struct i40e_pf *pf)\n{\n\t/* If we're in Legacy mode, the interrupt was cleaned in vsi_close */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tpci_disable_msix(pf->pdev);\n\t\tkfree(pf->msix_entries);\n\t\tpf->msix_entries = NULL;\n\t\tkfree(pf->irq_pile);\n\t\tpf->irq_pile = NULL;\n\t} else if (pf->flags & I40E_FLAG_MSI_ENABLED) {\n\t\tpci_disable_msi(pf->pdev);\n\t}\n\tpf->flags &= ~(I40E_FLAG_MSIX_ENABLED | I40E_FLAG_MSI_ENABLED);\n}\n\n/**\n * i40e_clear_interrupt_scheme - Clear the current interrupt scheme settings\n * @pf: board private structure\n *\n * We go through and clear interrupt specific resources and reset the structure\n * to pre-load conditions\n **/\nstatic void i40e_clear_interrupt_scheme(struct i40e_pf *pf)\n{\n\tint i;\n\n\ti40e_free_misc_vector(pf);\n\n\ti40e_put_lump(pf->irq_pile, pf->iwarp_base_vector,\n\t\t      I40E_IWARP_IRQ_PILE_ID);\n\n\ti40e_put_lump(pf->irq_pile, 0, I40E_PILE_VALID_BIT-1);\n\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\tif (pf->vsi[i])\n\t\t\ti40e_vsi_free_q_vectors(pf->vsi[i]);\n\ti40e_reset_interrupt_capability(pf);\n}\n\n/**\n * i40e_napi_enable_all - Enable NAPI for all q_vectors in the VSI\n * @vsi: the VSI being configured\n **/\nstatic void i40e_napi_enable_all(struct i40e_vsi *vsi)\n{\n\tint q_idx;\n\n\tif (!vsi->netdev)\n\t\treturn;\n\n\tfor (q_idx = 0; q_idx < vsi->num_q_vectors; q_idx++) {\n\t\tstruct i40e_q_vector *q_vector = vsi->q_vectors[q_idx];\n\n\t\tif (q_vector->rx.ring || q_vector->tx.ring)\n\t\t\tnapi_enable(&q_vector->napi);\n\t}\n}\n\n/**\n * i40e_napi_disable_all - Disable NAPI for all q_vectors in the VSI\n * @vsi: the VSI being configured\n **/\nstatic void i40e_napi_disable_all(struct i40e_vsi *vsi)\n{\n\tint q_idx;\n\n\tif (!vsi->netdev)\n\t\treturn;\n\n\tfor (q_idx = 0; q_idx < vsi->num_q_vectors; q_idx++) {\n\t\tstruct i40e_q_vector *q_vector = vsi->q_vectors[q_idx];\n\n\t\tif (q_vector->rx.ring || q_vector->tx.ring)\n\t\t\tnapi_disable(&q_vector->napi);\n\t}\n}\n\n/**\n * i40e_vsi_close - Shut down a VSI\n * @vsi: the vsi to be quelled\n **/\nstatic void i40e_vsi_close(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tif (!test_and_set_bit(__I40E_VSI_DOWN, vsi->state))\n\t\ti40e_down(vsi);\n\ti40e_vsi_free_irq(vsi);\n\ti40e_vsi_free_tx_resources(vsi);\n\ti40e_vsi_free_rx_resources(vsi);\n\tvsi->current_netdev_flags = 0;\n\tset_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);\n\tif (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))\n\t\tset_bit(__I40E_CLIENT_RESET, pf->state);\n}\n\n/**\n * i40e_quiesce_vsi - Pause a given VSI\n * @vsi: the VSI being paused\n **/\nstatic void i40e_quiesce_vsi(struct i40e_vsi *vsi)\n{\n\tif (test_bit(__I40E_VSI_DOWN, vsi->state))\n\t\treturn;\n\n\tset_bit(__I40E_VSI_NEEDS_RESTART, vsi->state);\n\tif (vsi->netdev && netif_running(vsi->netdev))\n\t\tvsi->netdev->netdev_ops->ndo_stop(vsi->netdev);\n\telse\n\t\ti40e_vsi_close(vsi);\n}\n\n/**\n * i40e_unquiesce_vsi - Resume a given VSI\n * @vsi: the VSI being resumed\n **/\nstatic void i40e_unquiesce_vsi(struct i40e_vsi *vsi)\n{\n\tif (!test_and_clear_bit(__I40E_VSI_NEEDS_RESTART, vsi->state))\n\t\treturn;\n\n\tif (vsi->netdev && netif_running(vsi->netdev))\n\t\tvsi->netdev->netdev_ops->ndo_open(vsi->netdev);\n\telse\n\t\ti40e_vsi_open(vsi);   /* this clears the DOWN bit */\n}\n\n/**\n * i40e_pf_quiesce_all_vsi - Pause all VSIs on a PF\n * @pf: the PF\n **/\nstatic void i40e_pf_quiesce_all_vsi(struct i40e_pf *pf)\n{\n\tint v;\n\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (pf->vsi[v])\n\t\t\ti40e_quiesce_vsi(pf->vsi[v]);\n\t}\n}\n\n/**\n * i40e_pf_unquiesce_all_vsi - Resume all VSIs on a PF\n * @pf: the PF\n **/\nstatic void i40e_pf_unquiesce_all_vsi(struct i40e_pf *pf)\n{\n\tint v;\n\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (pf->vsi[v])\n\t\t\ti40e_unquiesce_vsi(pf->vsi[v]);\n\t}\n}\n\n/**\n * i40e_vsi_wait_queues_disabled - Wait for VSI's queues to be disabled\n * @vsi: the VSI being configured\n *\n * Wait until all queues on a given VSI have been disabled.\n **/\nint i40e_vsi_wait_queues_disabled(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint i, pf_q, ret;\n\n\tpf_q = vsi->base_queue;\n\tfor (i = 0; i < vsi->num_queue_pairs; i++, pf_q++) {\n\t\t/* Check and wait for the Tx queue */\n\t\tret = i40e_pf_txq_wait(pf, pf_q, false);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VSI seid %d Tx ring %d disable timeout\\n\",\n\t\t\t\t vsi->seid, pf_q);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!i40e_enabled_xdp_vsi(vsi))\n\t\t\tgoto wait_rx;\n\n\t\t/* Check and wait for the XDP Tx queue */\n\t\tret = i40e_pf_txq_wait(pf, pf_q + vsi->alloc_queue_pairs,\n\t\t\t\t       false);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VSI seid %d XDP Tx ring %d disable timeout\\n\",\n\t\t\t\t vsi->seid, pf_q);\n\t\t\treturn ret;\n\t\t}\nwait_rx:\n\t\t/* Check and wait for the Rx queue */\n\t\tret = i40e_pf_rxq_wait(pf, pf_q, false);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"VSI seid %d Rx ring %d disable timeout\\n\",\n\t\t\t\t vsi->seid, pf_q);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_I40E_DCB\n/**\n * i40e_pf_wait_queues_disabled - Wait for all queues of PF VSIs to be disabled\n * @pf: the PF\n *\n * This function waits for the queues to be in disabled state for all the\n * VSIs that are managed by this PF.\n **/\nstatic int i40e_pf_wait_queues_disabled(struct i40e_pf *pf)\n{\n\tint v, ret = 0;\n\n\tfor (v = 0; v < pf->hw.func_caps.num_vsis; v++) {\n\t\tif (pf->vsi[v]) {\n\t\t\tret = i40e_vsi_wait_queues_disabled(pf->vsi[v]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n#endif\n\n/**\n * i40e_get_iscsi_tc_map - Return TC map for iSCSI APP\n * @pf: pointer to PF\n *\n * Get TC map for ISCSI PF type that will include iSCSI TC\n * and LAN TC.\n **/\nstatic u8 i40e_get_iscsi_tc_map(struct i40e_pf *pf)\n{\n\tstruct i40e_dcb_app_priority_table app;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu8 enabled_tc = 1; /* TC0 is always enabled */\n\tu8 tc, i;\n\t/* Get the iSCSI APP TLV */\n\tstruct i40e_dcbx_config *dcbcfg = &hw->local_dcbx_config;\n\n\tfor (i = 0; i < dcbcfg->numapps; i++) {\n\t\tapp = dcbcfg->app[i];\n\t\tif (app.selector == I40E_APP_SEL_TCPIP &&\n\t\t    app.protocolid == I40E_APP_PROTOID_ISCSI) {\n\t\t\ttc = dcbcfg->etscfg.prioritytable[app.priority];\n\t\t\tenabled_tc |= BIT(tc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn enabled_tc;\n}\n\n/**\n * i40e_dcb_get_num_tc -  Get the number of TCs from DCBx config\n * @dcbcfg: the corresponding DCBx configuration structure\n *\n * Return the number of TCs from given DCBx configuration\n **/\nstatic u8 i40e_dcb_get_num_tc(struct i40e_dcbx_config *dcbcfg)\n{\n\tint i, tc_unused = 0;\n\tu8 num_tc = 0;\n\tu8 ret = 0;\n\n\t/* Scan the ETS Config Priority Table to find\n\t * traffic class enabled for a given priority\n\t * and create a bitmask of enabled TCs\n\t */\n\tfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++)\n\t\tnum_tc |= BIT(dcbcfg->etscfg.prioritytable[i]);\n\n\t/* Now scan the bitmask to check for\n\t * contiguous TCs starting with TC0\n\t */\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (num_tc & BIT(i)) {\n\t\t\tif (!tc_unused) {\n\t\t\t\tret++;\n\t\t\t} else {\n\t\t\t\tpr_err(\"Non-contiguous TC - Disabling DCB\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\ttc_unused = 1;\n\t\t}\n\t}\n\n\t/* There is always at least TC0 */\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}\n\n/**\n * i40e_dcb_get_enabled_tc - Get enabled traffic classes\n * @dcbcfg: the corresponding DCBx configuration structure\n *\n * Query the current DCB configuration and return the number of\n * traffic classes enabled from the given DCBX config\n **/\nstatic u8 i40e_dcb_get_enabled_tc(struct i40e_dcbx_config *dcbcfg)\n{\n\tu8 num_tc = i40e_dcb_get_num_tc(dcbcfg);\n\tu8 enabled_tc = 1;\n\tu8 i;\n\n\tfor (i = 0; i < num_tc; i++)\n\t\tenabled_tc |= BIT(i);\n\n\treturn enabled_tc;\n}\n\n/**\n * i40e_mqprio_get_enabled_tc - Get enabled traffic classes\n * @pf: PF being queried\n *\n * Query the current MQPRIO configuration and return the number of\n * traffic classes enabled.\n **/\nstatic u8 i40e_mqprio_get_enabled_tc(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tu8 num_tc = vsi->mqprio_qopt.qopt.num_tc;\n\tu8 enabled_tc = 1, i;\n\n\tfor (i = 1; i < num_tc; i++)\n\t\tenabled_tc |= BIT(i);\n\treturn enabled_tc;\n}\n\n/**\n * i40e_pf_get_num_tc - Get enabled traffic classes for PF\n * @pf: PF being queried\n *\n * Return number of traffic classes enabled for the given PF\n **/\nstatic u8 i40e_pf_get_num_tc(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tu8 i, enabled_tc = 1;\n\tu8 num_tc = 0;\n\tstruct i40e_dcbx_config *dcbcfg = &hw->local_dcbx_config;\n\n\tif (pf->flags & I40E_FLAG_TC_MQPRIO)\n\t\treturn pf->vsi[pf->lan_vsi]->mqprio_qopt.qopt.num_tc;\n\n\t/* If neither MQPRIO nor DCB is enabled, then always use single TC */\n\tif (!(pf->flags & I40E_FLAG_DCB_ENABLED))\n\t\treturn 1;\n\n\t/* SFP mode will be enabled for all TCs on port */\n\tif (!(pf->flags & I40E_FLAG_MFP_ENABLED))\n\t\treturn i40e_dcb_get_num_tc(dcbcfg);\n\n\t/* MFP mode return count of enabled TCs for this PF */\n\tif (pf->hw.func_caps.iscsi)\n\t\tenabled_tc =  i40e_get_iscsi_tc_map(pf);\n\telse\n\t\treturn 1; /* Only TC0 */\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (enabled_tc & BIT(i))\n\t\t\tnum_tc++;\n\t}\n\treturn num_tc;\n}\n\n/**\n * i40e_pf_get_pf_tc_map - Get bitmap for enabled traffic classes\n * @pf: PF being queried\n *\n * Return a bitmap for enabled traffic classes for this PF.\n **/\nstatic u8 i40e_pf_get_tc_map(struct i40e_pf *pf)\n{\n\tif (pf->flags & I40E_FLAG_TC_MQPRIO)\n\t\treturn i40e_mqprio_get_enabled_tc(pf);\n\n\t/* If neither MQPRIO nor DCB is enabled for this PF then just return\n\t * default TC\n\t */\n\tif (!(pf->flags & I40E_FLAG_DCB_ENABLED))\n\t\treturn I40E_DEFAULT_TRAFFIC_CLASS;\n\n\t/* SFP mode we want PF to be enabled for all TCs */\n\tif (!(pf->flags & I40E_FLAG_MFP_ENABLED))\n\t\treturn i40e_dcb_get_enabled_tc(&pf->hw.local_dcbx_config);\n\n\t/* MFP enabled and iSCSI PF type */\n\tif (pf->hw.func_caps.iscsi)\n\t\treturn i40e_get_iscsi_tc_map(pf);\n\telse\n\t\treturn I40E_DEFAULT_TRAFFIC_CLASS;\n}\n\n/**\n * i40e_vsi_get_bw_info - Query VSI BW Information\n * @vsi: the VSI being queried\n *\n * Returns 0 on success, negative value on failure\n **/\nstatic int i40e_vsi_get_bw_info(struct i40e_vsi *vsi)\n{\n\tstruct i40e_aqc_query_vsi_ets_sla_config_resp bw_ets_config = {0};\n\tstruct i40e_aqc_query_vsi_bw_config_resp bw_config = {0};\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret;\n\tu32 tc_bw_max;\n\tint i;\n\n\t/* Get the VSI level BW configuration */\n\tret = i40e_aq_query_vsi_bw_config(hw, vsi->seid, &bw_config, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get PF vsi bw config, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EINVAL;\n\t}\n\n\t/* Get the VSI level BW configuration per TC */\n\tret = i40e_aq_query_vsi_ets_sla_config(hw, vsi->seid, &bw_ets_config,\n\t\t\t\t\t       NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get PF vsi ets bw config, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EINVAL;\n\t}\n\n\tif (bw_config.tc_valid_bits != bw_ets_config.tc_valid_bits) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Enabled TCs mismatch from querying VSI BW info 0x%08x 0x%08x\\n\",\n\t\t\t bw_config.tc_valid_bits,\n\t\t\t bw_ets_config.tc_valid_bits);\n\t\t/* Still continuing */\n\t}\n\n\tvsi->bw_limit = le16_to_cpu(bw_config.port_bw_limit);\n\tvsi->bw_max_quanta = bw_config.max_bw;\n\ttc_bw_max = le16_to_cpu(bw_ets_config.tc_bw_max[0]) |\n\t\t    (le16_to_cpu(bw_ets_config.tc_bw_max[1]) << 16);\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tvsi->bw_ets_share_credits[i] = bw_ets_config.share_credits[i];\n\t\tvsi->bw_ets_limit_credits[i] =\n\t\t\t\t\tle16_to_cpu(bw_ets_config.credits[i]);\n\t\t/* 3 bits out of 4 for each TC */\n\t\tvsi->bw_ets_max_quanta[i] = (u8)((tc_bw_max >> (i*4)) & 0x7);\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_configure_bw_alloc - Configure VSI BW allocation per TC\n * @vsi: the VSI being configured\n * @enabled_tc: TC bitmap\n * @bw_share: BW shared credits per TC\n *\n * Returns 0 on success, negative value on failure\n **/\nstatic int i40e_vsi_configure_bw_alloc(struct i40e_vsi *vsi, u8 enabled_tc,\n\t\t\t\t       u8 *bw_share)\n{\n\tstruct i40e_aqc_configure_vsi_tc_bw_data bw_data;\n\tstruct i40e_pf *pf = vsi->back;\n\ti40e_status ret;\n\tint i;\n\n\t/* There is no need to reset BW when mqprio mode is on.  */\n\tif (pf->flags & I40E_FLAG_TC_MQPRIO)\n\t\treturn 0;\n\tif (!vsi->mqprio_qopt.qopt.hw && !(pf->flags & I40E_FLAG_DCB_ENABLED)) {\n\t\tret = i40e_set_bw_limit(vsi, vsi->seid, 0);\n\t\tif (ret)\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Failed to reset tx rate for vsi->seid %u\\n\",\n\t\t\t\t vsi->seid);\n\t\treturn ret;\n\t}\n\tbw_data.tc_valid_bits = enabled_tc;\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tbw_data.tc_bw_credits[i] = bw_share[i];\n\n\tret = i40e_aq_config_vsi_tc_bw(&pf->hw, vsi->seid, &bw_data, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"AQ command Config VSI BW allocation per TC failed = %d\\n\",\n\t\t\t pf->hw.aq.asq_last_status);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tvsi->info.qs_handle[i] = bw_data.qs_handles[i];\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_config_netdev_tc - Setup the netdev TC configuration\n * @vsi: the VSI being configured\n * @enabled_tc: TC map to be enabled\n *\n **/\nstatic void i40e_vsi_config_netdev_tc(struct i40e_vsi *vsi, u8 enabled_tc)\n{\n\tstruct net_device *netdev = vsi->netdev;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu8 netdev_tc = 0;\n\tint i;\n\tstruct i40e_dcbx_config *dcbcfg = &hw->local_dcbx_config;\n\n\tif (!netdev)\n\t\treturn;\n\n\tif (!enabled_tc) {\n\t\tnetdev_reset_tc(netdev);\n\t\treturn;\n\t}\n\n\t/* Set up actual enabled TCs on the VSI */\n\tif (netdev_set_num_tc(netdev, vsi->tc_config.numtc))\n\t\treturn;\n\n\t/* set per TC queues for the VSI */\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t/* Only set TC queues for enabled tcs\n\t\t *\n\t\t * e.g. For a VSI that has TC0 and TC3 enabled the\n\t\t * enabled_tc bitmap would be 0x00001001; the driver\n\t\t * will set the numtc for netdev as 2 that will be\n\t\t * referenced by the netdev layer as TC 0 and 1.\n\t\t */\n\t\tif (vsi->tc_config.enabled_tc & BIT(i))\n\t\t\tnetdev_set_tc_queue(netdev,\n\t\t\t\t\tvsi->tc_config.tc_info[i].netdev_tc,\n\t\t\t\t\tvsi->tc_config.tc_info[i].qcount,\n\t\t\t\t\tvsi->tc_config.tc_info[i].qoffset);\n\t}\n\n\tif (pf->flags & I40E_FLAG_TC_MQPRIO)\n\t\treturn;\n\n\t/* Assign UP2TC map for the VSI */\n\tfor (i = 0; i < I40E_MAX_USER_PRIORITY; i++) {\n\t\t/* Get the actual TC# for the UP */\n\t\tu8 ets_tc = dcbcfg->etscfg.prioritytable[i];\n\t\t/* Get the mapped netdev TC# for the UP */\n\t\tnetdev_tc =  vsi->tc_config.tc_info[ets_tc].netdev_tc;\n\t\tnetdev_set_prio_tc_map(netdev, i, netdev_tc);\n\t}\n}\n\n/**\n * i40e_vsi_update_queue_map - Update our copy of VSi info with new queue map\n * @vsi: the VSI being configured\n * @ctxt: the ctxt buffer returned from AQ VSI update param command\n **/\nstatic void i40e_vsi_update_queue_map(struct i40e_vsi *vsi,\n\t\t\t\t      struct i40e_vsi_context *ctxt)\n{\n\t/* copy just the sections touched not the entire info\n\t * since not all sections are valid as returned by\n\t * update vsi params\n\t */\n\tvsi->info.mapping_flags = ctxt->info.mapping_flags;\n\tmemcpy(&vsi->info.queue_mapping,\n\t       &ctxt->info.queue_mapping, sizeof(vsi->info.queue_mapping));\n\tmemcpy(&vsi->info.tc_mapping, ctxt->info.tc_mapping,\n\t       sizeof(vsi->info.tc_mapping));\n}\n\n/**\n * i40e_vsi_config_tc - Configure VSI Tx Scheduler for given TC map\n * @vsi: VSI to be configured\n * @enabled_tc: TC bitmap\n *\n * This configures a particular VSI for TCs that are mapped to the\n * given TC bitmap. It uses default bandwidth share for TCs across\n * VSIs to configure TC for a particular VSI.\n *\n * NOTE:\n * It is expected that the VSI queues have been quisced before calling\n * this function.\n **/\nstatic int i40e_vsi_config_tc(struct i40e_vsi *vsi, u8 enabled_tc)\n{\n\tu8 bw_share[I40E_MAX_TRAFFIC_CLASS] = {0};\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vsi_context ctxt;\n\tint ret = 0;\n\tint i;\n\n\t/* Check if enabled_tc is same as existing or new TCs */\n\tif (vsi->tc_config.enabled_tc == enabled_tc &&\n\t    vsi->mqprio_qopt.mode != TC_MQPRIO_MODE_CHANNEL)\n\t\treturn ret;\n\n\t/* Enable ETS TCs with equal BW Share for now across all VSIs */\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (enabled_tc & BIT(i))\n\t\t\tbw_share[i] = 1;\n\t}\n\n\tret = i40e_vsi_configure_bw_alloc(vsi, enabled_tc, bw_share);\n\tif (ret) {\n\t\tstruct i40e_aqc_query_vsi_bw_config_resp bw_config = {0};\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed configuring TC map %d for VSI %d\\n\",\n\t\t\t enabled_tc, vsi->seid);\n\t\tret = i40e_aq_query_vsi_bw_config(hw, vsi->seid,\n\t\t\t\t\t\t  &bw_config, NULL);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Failed querying vsi bw info, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(hw, ret),\n\t\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\t\tgoto out;\n\t\t}\n\t\tif ((bw_config.tc_valid_bits & enabled_tc) != enabled_tc) {\n\t\t\tu8 valid_tc = bw_config.tc_valid_bits & enabled_tc;\n\n\t\t\tif (!valid_tc)\n\t\t\t\tvalid_tc = bw_config.tc_valid_bits;\n\t\t\t/* Always enable TC0, no matter what */\n\t\t\tvalid_tc |= 1;\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Requested tc 0x%x, but FW reports 0x%x as valid. Attempting to use 0x%x.\\n\",\n\t\t\t\t enabled_tc, bw_config.tc_valid_bits, valid_tc);\n\t\t\tenabled_tc = valid_tc;\n\t\t}\n\n\t\tret = i40e_vsi_configure_bw_alloc(vsi, enabled_tc, bw_share);\n\t\tif (ret) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Unable to  configure TC map %d for VSI %d\\n\",\n\t\t\t\tenabled_tc, vsi->seid);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Update Queue Pairs Mapping for currently enabled UPs */\n\tctxt.seid = vsi->seid;\n\tctxt.pf_num = vsi->back->hw.pf_id;\n\tctxt.vf_num = 0;\n\tctxt.uplink_seid = vsi->uplink_seid;\n\tctxt.info = vsi->info;\n\tif (vsi->back->flags & I40E_FLAG_TC_MQPRIO) {\n\t\tret = i40e_vsi_setup_queue_map_mqprio(vsi, &ctxt, enabled_tc);\n\t\tif (ret)\n\t\t\tgoto out;\n\t} else {\n\t\ti40e_vsi_setup_queue_map(vsi, &ctxt, enabled_tc, false);\n\t}\n\n\t/* On destroying the qdisc, reset vsi->rss_size, as number of enabled\n\t * queues changed.\n\t */\n\tif (!vsi->mqprio_qopt.qopt.hw && vsi->reconfig_rss) {\n\t\tvsi->rss_size = min_t(int, vsi->back->alloc_rss_size,\n\t\t\t\t      vsi->num_queue_pairs);\n\t\tret = i40e_vsi_config_rss(vsi);\n\t\tif (ret) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"Failed to reconfig rss for num_queues\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tvsi->reconfig_rss = false;\n\t}\n\tif (vsi->back->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\tctxt.info.valid_sections |=\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\n\t\tctxt.info.queueing_opt_flags |= I40E_AQ_VSI_QUE_OPT_TCP_ENA;\n\t}\n\n\t/* Update the VSI after updating the VSI queue-mapping\n\t * information\n\t */\n\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Update vsi tc config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(hw, ret),\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\tgoto out;\n\t}\n\t/* update the local VSI info with updated queue map */\n\ti40e_vsi_update_queue_map(vsi, &ctxt);\n\tvsi->info.valid_sections = 0;\n\n\t/* Update current VSI BW information */\n\tret = i40e_vsi_get_bw_info(vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed updating vsi bw info, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(hw, ret),\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\tgoto out;\n\t}\n\n\t/* Update the netdev TC setup */\n\ti40e_vsi_config_netdev_tc(vsi, enabled_tc);\nout:\n\treturn ret;\n}\n\n/**\n * i40e_get_link_speed - Returns link speed for the interface\n * @vsi: VSI to be configured\n *\n **/\nstatic int i40e_get_link_speed(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\tswitch (pf->hw.phy.link_info.link_speed) {\n\tcase I40E_LINK_SPEED_40GB:\n\t\treturn 40000;\n\tcase I40E_LINK_SPEED_25GB:\n\t\treturn 25000;\n\tcase I40E_LINK_SPEED_20GB:\n\t\treturn 20000;\n\tcase I40E_LINK_SPEED_10GB:\n\t\treturn 10000;\n\tcase I40E_LINK_SPEED_1GB:\n\t\treturn 1000;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * i40e_set_bw_limit - setup BW limit for Tx traffic based on max_tx_rate\n * @vsi: VSI to be configured\n * @seid: seid of the channel/VSI\n * @max_tx_rate: max TX rate to be configured as BW limit\n *\n * Helper function to set BW limit for a given VSI\n **/\nint i40e_set_bw_limit(struct i40e_vsi *vsi, u16 seid, u64 max_tx_rate)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tu64 credits = 0;\n\tint speed = 0;\n\tint ret = 0;\n\n\tspeed = i40e_get_link_speed(vsi);\n\tif (max_tx_rate > speed) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Invalid max tx rate %llu specified for VSI seid %d.\",\n\t\t\tmax_tx_rate, seid);\n\t\treturn -EINVAL;\n\t}\n\tif (max_tx_rate && max_tx_rate < 50) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Setting max tx rate to minimum usable value of 50Mbps.\\n\");\n\t\tmax_tx_rate = 50;\n\t}\n\n\t/* Tx rate credits are in values of 50Mbps, 0 is disabled */\n\tcredits = max_tx_rate;\n\tdo_div(credits, I40E_BW_CREDIT_DIVISOR);\n\tret = i40e_aq_config_vsi_bw_limit(&pf->hw, seid, credits,\n\t\t\t\t\t  I40E_MAX_BW_INACTIVE_ACCUM, NULL);\n\tif (ret)\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed set tx rate (%llu Mbps) for vsi->seid %u, err %s aq_err %s\\n\",\n\t\t\tmax_tx_rate, seid, i40e_stat_str(&pf->hw, ret),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\treturn ret;\n}\n\n/**\n * i40e_remove_queue_channels - Remove queue channels for the TCs\n * @vsi: VSI to be configured\n *\n * Remove queue channels for the TCs\n **/\nstatic void i40e_remove_queue_channels(struct i40e_vsi *vsi)\n{\n\tenum i40e_admin_queue_err last_aq_status;\n\tstruct i40e_cloud_filter *cfilter;\n\tstruct i40e_channel *ch, *ch_tmp;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct hlist_node *node;\n\tint ret, i;\n\n\t/* Reset rss size that was stored when reconfiguring rss for\n\t * channel VSIs with non-power-of-2 queue count.\n\t */\n\tvsi->current_rss_size = 0;\n\n\t/* perform cleanup for channels if they exist */\n\tif (list_empty(&vsi->ch_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->ch_list, list) {\n\t\tstruct i40e_vsi *p_vsi;\n\n\t\tlist_del(&ch->list);\n\t\tp_vsi = ch->parent_vsi;\n\t\tif (!p_vsi || !ch->initialized) {\n\t\t\tkfree(ch);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Reset queue contexts */\n\t\tfor (i = 0; i < ch->num_queue_pairs; i++) {\n\t\t\tstruct i40e_ring *tx_ring, *rx_ring;\n\t\t\tu16 pf_q;\n\n\t\t\tpf_q = ch->base_queue + i;\n\t\t\ttx_ring = vsi->tx_rings[pf_q];\n\t\t\ttx_ring->ch = NULL;\n\n\t\t\trx_ring = vsi->rx_rings[pf_q];\n\t\t\trx_ring->ch = NULL;\n\t\t}\n\n\t\t/* Reset BW configured for this VSI via mqprio */\n\t\tret = i40e_set_bw_limit(vsi, ch->seid, 0);\n\t\tif (ret)\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"Failed to reset tx rate for ch->seid %u\\n\",\n\t\t\t\t ch->seid);\n\n\t\t/* delete cloud filters associated with this channel */\n\t\thlist_for_each_entry_safe(cfilter, node,\n\t\t\t\t\t  &pf->cloud_filter_list, cloud_node) {\n\t\t\tif (cfilter->seid != ch->seid)\n\t\t\t\tcontinue;\n\n\t\t\thash_del(&cfilter->cloud_node);\n\t\t\tif (cfilter->dst_port)\n\t\t\t\tret = i40e_add_del_cloud_filter_big_buf(vsi,\n\t\t\t\t\t\t\t\t\tcfilter,\n\t\t\t\t\t\t\t\t\tfalse);\n\t\t\telse\n\t\t\t\tret = i40e_add_del_cloud_filter(vsi, cfilter,\n\t\t\t\t\t\t\t\tfalse);\n\t\t\tlast_aq_status = pf->hw.aq.asq_last_status;\n\t\t\tif (ret)\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Failed to delete cloud filter, err %s aq_err %s\\n\",\n\t\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t\t i40e_aq_str(&pf->hw, last_aq_status));\n\t\t\tkfree(cfilter);\n\t\t}\n\n\t\t/* delete VSI from FW */\n\t\tret = i40e_aq_delete_element(&vsi->back->hw, ch->seid,\n\t\t\t\t\t     NULL);\n\t\tif (ret)\n\t\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\t\"unable to remove channel (%d) for parent VSI(%d)\\n\",\n\t\t\t\tch->seid, p_vsi->seid);\n\t\tkfree(ch);\n\t}\n\tINIT_LIST_HEAD(&vsi->ch_list);\n}\n\n/**\n * i40e_is_any_channel - channel exist or not\n * @vsi: ptr to VSI to which channels are associated with\n *\n * Returns true or false if channel(s) exist for associated VSI or not\n **/\nstatic bool i40e_is_any_channel(struct i40e_vsi *vsi)\n{\n\tstruct i40e_channel *ch, *ch_tmp;\n\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->ch_list, list) {\n\t\tif (ch->initialized)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * i40e_get_max_queues_for_channel\n * @vsi: ptr to VSI to which channels are associated with\n *\n * Helper function which returns max value among the queue counts set on the\n * channels/TCs created.\n **/\nstatic int i40e_get_max_queues_for_channel(struct i40e_vsi *vsi)\n{\n\tstruct i40e_channel *ch, *ch_tmp;\n\tint max = 0;\n\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->ch_list, list) {\n\t\tif (!ch->initialized)\n\t\t\tcontinue;\n\t\tif (ch->num_queue_pairs > max)\n\t\t\tmax = ch->num_queue_pairs;\n\t}\n\n\treturn max;\n}\n\n/**\n * i40e_validate_num_queues - validate num_queues w.r.t channel\n * @pf: ptr to PF device\n * @num_queues: number of queues\n * @vsi: the parent VSI\n * @reconfig_rss: indicates should the RSS be reconfigured or not\n *\n * This function validates number of queues in the context of new channel\n * which is being established and determines if RSS should be reconfigured\n * or not for parent VSI.\n **/\nstatic int i40e_validate_num_queues(struct i40e_pf *pf, int num_queues,\n\t\t\t\t    struct i40e_vsi *vsi, bool *reconfig_rss)\n{\n\tint max_ch_queues;\n\n\tif (!reconfig_rss)\n\t\treturn -EINVAL;\n\n\t*reconfig_rss = false;\n\tif (vsi->current_rss_size) {\n\t\tif (num_queues > vsi->current_rss_size) {\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"Error: num_queues (%d) > vsi's current_size(%d)\\n\",\n\t\t\t\tnum_queues, vsi->current_rss_size);\n\t\t\treturn -EINVAL;\n\t\t} else if ((num_queues < vsi->current_rss_size) &&\n\t\t\t   (!is_power_of_2(num_queues))) {\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"Error: num_queues (%d) < vsi's current_size(%d), but not power of 2\\n\",\n\t\t\t\tnum_queues, vsi->current_rss_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!is_power_of_2(num_queues)) {\n\t\t/* Find the max num_queues configured for channel if channel\n\t\t * exist.\n\t\t * if channel exist, then enforce 'num_queues' to be more than\n\t\t * max ever queues configured for channel.\n\t\t */\n\t\tmax_ch_queues = i40e_get_max_queues_for_channel(vsi);\n\t\tif (num_queues < max_ch_queues) {\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"Error: num_queues (%d) < max queues configured for channel(%d)\\n\",\n\t\t\t\tnum_queues, max_ch_queues);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*reconfig_rss = true;\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_reconfig_rss - reconfig RSS based on specified rss_size\n * @vsi: the VSI being setup\n * @rss_size: size of RSS, accordingly LUT gets reprogrammed\n *\n * This function reconfigures RSS by reprogramming LUTs using 'rss_size'\n **/\nstatic int i40e_vsi_reconfig_rss(struct i40e_vsi *vsi, u16 rss_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tu8 seed[I40E_HKEY_ARRAY_SIZE];\n\tstruct i40e_hw *hw = &pf->hw;\n\tint local_rss_size;\n\tu8 *lut;\n\tint ret;\n\n\tif (!vsi->rss_size)\n\t\treturn -EINVAL;\n\n\tif (rss_size > vsi->rss_size)\n\t\treturn -EINVAL;\n\n\tlocal_rss_size = min_t(int, vsi->rss_size, rss_size);\n\tlut = kzalloc(vsi->rss_table_size, GFP_KERNEL);\n\tif (!lut)\n\t\treturn -ENOMEM;\n\n\t/* Ignoring user configured lut if there is one */\n\ti40e_fill_rss_lut(pf, lut, vsi->rss_table_size, local_rss_size);\n\n\t/* Use user configured hash key if there is one, otherwise\n\t * use default.\n\t */\n\tif (vsi->rss_hkey_user)\n\t\tmemcpy(seed, vsi->rss_hkey_user, I40E_HKEY_ARRAY_SIZE);\n\telse\n\t\tnetdev_rss_key_fill((void *)seed, I40E_HKEY_ARRAY_SIZE);\n\n\tret = i40e_config_rss(vsi, seed, lut, vsi->rss_table_size);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Cannot set RSS lut, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(hw, ret),\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\tkfree(lut);\n\t\treturn ret;\n\t}\n\tkfree(lut);\n\n\t/* Do the update w.r.t. storing rss_size */\n\tif (!vsi->orig_rss_size)\n\t\tvsi->orig_rss_size = vsi->rss_size;\n\tvsi->current_rss_size = local_rss_size;\n\n\treturn ret;\n}\n\n/**\n * i40e_channel_setup_queue_map - Setup a channel queue map\n * @pf: ptr to PF device\n * @ctxt: VSI context structure\n * @ch: ptr to channel structure\n *\n * Setup queue map for a specific channel\n **/\nstatic void i40e_channel_setup_queue_map(struct i40e_pf *pf,\n\t\t\t\t\t struct i40e_vsi_context *ctxt,\n\t\t\t\t\t struct i40e_channel *ch)\n{\n\tu16 qcount, qmap, sections = 0;\n\tu8 offset = 0;\n\tint pow;\n\n\tsections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;\n\tsections |= I40E_AQ_VSI_PROP_SCHED_VALID;\n\n\tqcount = min_t(int, ch->num_queue_pairs, pf->num_lan_msix);\n\tch->num_queue_pairs = qcount;\n\n\t/* find the next higher power-of-2 of num queue pairs */\n\tpow = ilog2(qcount);\n\tif (!is_power_of_2(qcount))\n\t\tpow++;\n\n\tqmap = (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |\n\t\t(pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);\n\n\t/* Setup queue TC[0].qmap for given VSI context */\n\tctxt->info.tc_mapping[0] = cpu_to_le16(qmap);\n\n\tctxt->info.up_enable_bits = 0x1; /* TC0 enabled */\n\tctxt->info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);\n\tctxt->info.queue_mapping[0] = cpu_to_le16(ch->base_queue);\n\tctxt->info.valid_sections |= cpu_to_le16(sections);\n}\n\n/**\n * i40e_add_channel - add a channel by adding VSI\n * @pf: ptr to PF device\n * @uplink_seid: underlying HW switching element (VEB) ID\n * @ch: ptr to channel structure\n *\n * Add a channel (VSI) using add_vsi and queue_map\n **/\nstatic int i40e_add_channel(struct i40e_pf *pf, u16 uplink_seid,\n\t\t\t    struct i40e_channel *ch)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vsi_context ctxt;\n\tu8 enabled_tc = 0x1; /* TC0 enabled */\n\tint ret;\n\n\tif (ch->type != I40E_VSI_VMDQ2) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"add new vsi failed, ch->type %d\\n\", ch->type);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tctxt.pf_num = hw->pf_id;\n\tctxt.vf_num = 0;\n\tctxt.uplink_seid = uplink_seid;\n\tctxt.connection_type = I40E_AQ_VSI_CONN_TYPE_NORMAL;\n\tif (ch->type == I40E_VSI_VMDQ2)\n\t\tctxt.flags = I40E_AQ_VSI_TYPE_VMDQ2;\n\n\tif (pf->flags & I40E_FLAG_VEB_MODE_ENABLED) {\n\t\tctxt.info.valid_sections |=\n\t\t     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\t\tctxt.info.switch_id =\n\t\t   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\n\t}\n\n\t/* Set queue map for a given VSI context */\n\ti40e_channel_setup_queue_map(pf, &ctxt, ch);\n\n\t/* Now time to create VSI */\n\tret = i40e_aq_add_vsi(hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"add new vsi failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\treturn -ENOENT;\n\t}\n\n\t/* Success, update channel, set enabled_tc only if the channel\n\t * is not a macvlan\n\t */\n\tch->enabled_tc = !i40e_is_channel_macvlan(ch) && enabled_tc;\n\tch->seid = ctxt.seid;\n\tch->vsi_number = ctxt.vsi_number;\n\tch->stat_counter_idx = cpu_to_le16(ctxt.info.stat_counter_idx);\n\n\t/* copy just the sections touched not the entire info\n\t * since not all sections are valid as returned by\n\t * update vsi params\n\t */\n\tch->info.mapping_flags = ctxt.info.mapping_flags;\n\tmemcpy(&ch->info.queue_mapping,\n\t       &ctxt.info.queue_mapping, sizeof(ctxt.info.queue_mapping));\n\tmemcpy(&ch->info.tc_mapping, ctxt.info.tc_mapping,\n\t       sizeof(ctxt.info.tc_mapping));\n\n\treturn 0;\n}\n\nstatic int i40e_channel_config_bw(struct i40e_vsi *vsi, struct i40e_channel *ch,\n\t\t\t\t  u8 *bw_share)\n{\n\tstruct i40e_aqc_configure_vsi_tc_bw_data bw_data;\n\ti40e_status ret;\n\tint i;\n\n\tbw_data.tc_valid_bits = ch->enabled_tc;\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tbw_data.tc_bw_credits[i] = bw_share[i];\n\n\tret = i40e_aq_config_vsi_tc_bw(&vsi->back->hw, ch->seid,\n\t\t\t\t       &bw_data, NULL);\n\tif (ret) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Config VSI BW allocation per TC failed, aq_err: %d for new_vsi->seid %u\\n\",\n\t\t\t vsi->back->hw.aq.asq_last_status, ch->seid);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)\n\t\tch->info.qs_handle[i] = bw_data.qs_handles[i];\n\n\treturn 0;\n}\n\n/**\n * i40e_channel_config_tx_ring - config TX ring associated with new channel\n * @pf: ptr to PF device\n * @vsi: the VSI being setup\n * @ch: ptr to channel structure\n *\n * Configure TX rings associated with channel (VSI) since queues are being\n * from parent VSI.\n **/\nstatic int i40e_channel_config_tx_ring(struct i40e_pf *pf,\n\t\t\t\t       struct i40e_vsi *vsi,\n\t\t\t\t       struct i40e_channel *ch)\n{\n\ti40e_status ret;\n\tint i;\n\tu8 bw_share[I40E_MAX_TRAFFIC_CLASS] = {0};\n\n\t/* Enable ETS TCs with equal BW Share for now across all VSIs */\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (ch->enabled_tc & BIT(i))\n\t\t\tbw_share[i] = 1;\n\t}\n\n\t/* configure BW for new VSI */\n\tret = i40e_channel_config_bw(vsi, ch, bw_share);\n\tif (ret) {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Failed configuring TC map %d for channel (seid %u)\\n\",\n\t\t\t ch->enabled_tc, ch->seid);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ch->num_queue_pairs; i++) {\n\t\tstruct i40e_ring *tx_ring, *rx_ring;\n\t\tu16 pf_q;\n\n\t\tpf_q = ch->base_queue + i;\n\n\t\t/* Get to TX ring ptr of main VSI, for re-setup TX queue\n\t\t * context\n\t\t */\n\t\ttx_ring = vsi->tx_rings[pf_q];\n\t\ttx_ring->ch = ch;\n\n\t\t/* Get the RX ring ptr */\n\t\trx_ring = vsi->rx_rings[pf_q];\n\t\trx_ring->ch = ch;\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_setup_hw_channel - setup new channel\n * @pf: ptr to PF device\n * @vsi: the VSI being setup\n * @ch: ptr to channel structure\n * @uplink_seid: underlying HW switching element (VEB) ID\n * @type: type of channel to be created (VMDq2/VF)\n *\n * Setup new channel (VSI) based on specified type (VMDq2/VF)\n * and configures TX rings accordingly\n **/\nstatic inline int i40e_setup_hw_channel(struct i40e_pf *pf,\n\t\t\t\t\tstruct i40e_vsi *vsi,\n\t\t\t\t\tstruct i40e_channel *ch,\n\t\t\t\t\tu16 uplink_seid, u8 type)\n{\n\tint ret;\n\n\tch->initialized = false;\n\tch->base_queue = vsi->next_base_queue;\n\tch->type = type;\n\n\t/* Proceed with creation of channel (VMDq2) VSI */\n\tret = i40e_add_channel(pf, uplink_seid, ch);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"failed to add_channel using uplink_seid %u\\n\",\n\t\t\t uplink_seid);\n\t\treturn ret;\n\t}\n\n\t/* Mark the successful creation of channel */\n\tch->initialized = true;\n\n\t/* Reconfigure TX queues using QTX_CTL register */\n\tret = i40e_channel_config_tx_ring(pf, vsi, ch);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"failed to configure TX rings for channel %u\\n\",\n\t\t\t ch->seid);\n\t\treturn ret;\n\t}\n\n\t/* update 'next_base_queue' */\n\tvsi->next_base_queue = vsi->next_base_queue + ch->num_queue_pairs;\n\tdev_dbg(&pf->pdev->dev,\n\t\t\"Added channel: vsi_seid %u, vsi_number %u, stat_counter_idx %u, num_queue_pairs %u, pf->next_base_queue %d\\n\",\n\t\tch->seid, ch->vsi_number, ch->stat_counter_idx,\n\t\tch->num_queue_pairs,\n\t\tvsi->next_base_queue);\n\treturn ret;\n}\n\n/**\n * i40e_setup_channel - setup new channel using uplink element\n * @pf: ptr to PF device\n * @vsi: pointer to the VSI to set up the channel within\n * @ch: ptr to channel structure\n *\n * Setup new channel (VSI) based on specified type (VMDq2/VF)\n * and uplink switching element (uplink_seid)\n **/\nstatic bool i40e_setup_channel(struct i40e_pf *pf, struct i40e_vsi *vsi,\n\t\t\t       struct i40e_channel *ch)\n{\n\tu8 vsi_type;\n\tu16 seid;\n\tint ret;\n\n\tif (vsi->type == I40E_VSI_MAIN) {\n\t\tvsi_type = I40E_VSI_VMDQ2;\n\t} else {\n\t\tdev_err(&pf->pdev->dev, \"unsupported parent vsi type(%d)\\n\",\n\t\t\tvsi->type);\n\t\treturn false;\n\t}\n\n\t/* underlying switching element */\n\tseid = pf->vsi[pf->lan_vsi]->uplink_seid;\n\n\t/* create channel (VSI), configure TX rings */\n\tret = i40e_setup_hw_channel(pf, vsi, ch, seid, vsi_type);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev, \"failed to setup hw_channel\\n\");\n\t\treturn false;\n\t}\n\n\treturn ch->initialized ? true : false;\n}\n\n/**\n * i40e_validate_and_set_switch_mode - sets up switch mode correctly\n * @vsi: ptr to VSI which has PF backing\n *\n * Sets up switch mode correctly if it needs to be changed and perform\n * what are allowed modes.\n **/\nstatic int i40e_validate_and_set_switch_mode(struct i40e_vsi *vsi)\n{\n\tu8 mode;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint ret;\n\n\tret = i40e_get_capabilities(pf, i40e_aqc_opc_list_dev_capabilities);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (hw->dev_caps.switch_mode) {\n\t\t/* if switch mode is set, support mode2 (non-tunneled for\n\t\t * cloud filter) for now\n\t\t */\n\t\tu32 switch_mode = hw->dev_caps.switch_mode &\n\t\t\t\t  I40E_SWITCH_MODE_MASK;\n\t\tif (switch_mode >= I40E_CLOUD_FILTER_MODE1) {\n\t\t\tif (switch_mode == I40E_CLOUD_FILTER_MODE2)\n\t\t\t\treturn 0;\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Invalid switch_mode (%d), only non-tunneled mode for cloud filter is supported\\n\",\n\t\t\t\thw->dev_caps.switch_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* Set Bit 7 to be valid */\n\tmode = I40E_AQ_SET_SWITCH_BIT7_VALID;\n\n\t/* Set L4type for TCP support */\n\tmode |= I40E_AQ_SET_SWITCH_L4_TYPE_TCP;\n\n\t/* Set cloud filter mode */\n\tmode |= I40E_AQ_SET_SWITCH_MODE_NON_TUNNEL;\n\n\t/* Prep mode field for set_switch_config */\n\tret = i40e_aq_set_switch_config(hw, pf->last_sw_conf_flags,\n\t\t\t\t\tpf->last_sw_conf_valid_flags,\n\t\t\t\t\tmode, NULL);\n\tif (ret && hw->aq.asq_last_status != I40E_AQ_RC_ESRCH)\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"couldn't set switch config bits, err %s aq_err %s\\n\",\n\t\t\ti40e_stat_str(hw, ret),\n\t\t\ti40e_aq_str(hw,\n\t\t\t\t    hw->aq.asq_last_status));\n\n\treturn ret;\n}\n\n/**\n * i40e_create_queue_channel - function to create channel\n * @vsi: VSI to be configured\n * @ch: ptr to channel (it contains channel specific params)\n *\n * This function creates channel (VSI) using num_queues specified by user,\n * reconfigs RSS if needed.\n **/\nint i40e_create_queue_channel(struct i40e_vsi *vsi,\n\t\t\t      struct i40e_channel *ch)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tbool reconfig_rss;\n\tint err;\n\n\tif (!ch)\n\t\treturn -EINVAL;\n\n\tif (!ch->num_queue_pairs) {\n\t\tdev_err(&pf->pdev->dev, \"Invalid num_queues requested: %d\\n\",\n\t\t\tch->num_queue_pairs);\n\t\treturn -EINVAL;\n\t}\n\n\t/* validate user requested num_queues for channel */\n\terr = i40e_validate_num_queues(pf, ch->num_queue_pairs, vsi,\n\t\t\t\t       &reconfig_rss);\n\tif (err) {\n\t\tdev_info(&pf->pdev->dev, \"Failed to validate num_queues (%d)\\n\",\n\t\t\t ch->num_queue_pairs);\n\t\treturn -EINVAL;\n\t}\n\n\t/* By default we are in VEPA mode, if this is the first VF/VMDq\n\t * VSI to be added switch to VEB mode.\n\t */\n\tif ((!(pf->flags & I40E_FLAG_VEB_MODE_ENABLED)) ||\n\t    (!i40e_is_any_channel(vsi))) {\n\t\tif (!is_power_of_2(vsi->tc_config.tc_info[0].qcount)) {\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"Failed to create channel. Override queues (%u) not power of 2\\n\",\n\t\t\t\tvsi->tc_config.tc_info[0].qcount);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!(pf->flags & I40E_FLAG_VEB_MODE_ENABLED)) {\n\t\t\tpf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\n\n\t\t\tif (vsi->type == I40E_VSI_MAIN) {\n\t\t\t\tif (pf->flags & I40E_FLAG_TC_MQPRIO)\n\t\t\t\t\ti40e_do_reset(pf, I40E_PF_RESET_FLAG,\n\t\t\t\t\t\t      true);\n\t\t\t\telse\n\t\t\t\t\ti40e_do_reset_safe(pf,\n\t\t\t\t\t\t\t   I40E_PF_RESET_FLAG);\n\t\t\t}\n\t\t}\n\t\t/* now onwards for main VSI, number of queues will be value\n\t\t * of TC0's queue count\n\t\t */\n\t}\n\n\t/* By this time, vsi->cnt_q_avail shall be set to non-zero and\n\t * it should be more than num_queues\n\t */\n\tif (!vsi->cnt_q_avail || vsi->cnt_q_avail < ch->num_queue_pairs) {\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Error: cnt_q_avail (%u) less than num_queues %d\\n\",\n\t\t\tvsi->cnt_q_avail, ch->num_queue_pairs);\n\t\treturn -EINVAL;\n\t}\n\n\t/* reconfig_rss only if vsi type is MAIN_VSI */\n\tif (reconfig_rss && (vsi->type == I40E_VSI_MAIN)) {\n\t\terr = i40e_vsi_reconfig_rss(vsi, ch->num_queue_pairs);\n\t\tif (err) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Error: unable to reconfig rss for num_queues (%u)\\n\",\n\t\t\t\t ch->num_queue_pairs);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!i40e_setup_channel(pf, vsi, ch)) {\n\t\tdev_info(&pf->pdev->dev, \"Failed to setup channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&pf->pdev->dev,\n\t\t \"Setup channel (id:%u) utilizing num_queues %d\\n\",\n\t\t ch->seid, ch->num_queue_pairs);\n\n\t/* configure VSI for BW limit */\n\tif (ch->max_tx_rate) {\n\t\tu64 credits = ch->max_tx_rate;\n\n\t\tif (i40e_set_bw_limit(vsi, ch->seid, ch->max_tx_rate))\n\t\t\treturn -EINVAL;\n\n\t\tdo_div(credits, I40E_BW_CREDIT_DIVISOR);\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\\n\",\n\t\t\tch->max_tx_rate,\n\t\t\tcredits,\n\t\t\tch->seid);\n\t}\n\n\t/* in case of VF, this will be main SRIOV VSI */\n\tch->parent_vsi = vsi;\n\n\t/* and update main_vsi's count for queue_available to use */\n\tvsi->cnt_q_avail -= ch->num_queue_pairs;\n\n\treturn 0;\n}\n\n/**\n * i40e_configure_queue_channels - Add queue channel for the given TCs\n * @vsi: VSI to be configured\n *\n * Configures queue channel mapping to the given TCs\n **/\nstatic int i40e_configure_queue_channels(struct i40e_vsi *vsi)\n{\n\tstruct i40e_channel *ch;\n\tu64 max_rate = 0;\n\tint ret = 0, i;\n\n\t/* Create app vsi with the TCs. Main VSI with TC0 is already set up */\n\tvsi->tc_seid_map[0] = vsi->seid;\n\tfor (i = 1; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (vsi->tc_config.enabled_tc & BIT(i)) {\n\t\t\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\t\t\tif (!ch) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\n\t\t\tINIT_LIST_HEAD(&ch->list);\n\t\t\tch->num_queue_pairs =\n\t\t\t\tvsi->tc_config.tc_info[i].qcount;\n\t\t\tch->base_queue =\n\t\t\t\tvsi->tc_config.tc_info[i].qoffset;\n\n\t\t\t/* Bandwidth limit through tc interface is in bytes/s,\n\t\t\t * change to Mbit/s\n\t\t\t */\n\t\t\tmax_rate = vsi->mqprio_qopt.max_rate[i];\n\t\t\tdo_div(max_rate, I40E_BW_MBPS_DIVISOR);\n\t\t\tch->max_tx_rate = max_rate;\n\n\t\t\tlist_add_tail(&ch->list, &vsi->ch_list);\n\n\t\t\tret = i40e_create_queue_channel(vsi, ch);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\t\t\"Failed creating queue channel with TC%d: queues %d\\n\",\n\t\t\t\t\ti, ch->num_queue_pairs);\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\tvsi->tc_seid_map[i] = ch->seid;\n\t\t}\n\t}\n\treturn ret;\n\nerr_free:\n\ti40e_remove_queue_channels(vsi);\n\treturn ret;\n}\n\n/**\n * i40e_veb_config_tc - Configure TCs for given VEB\n * @veb: given VEB\n * @enabled_tc: TC bitmap\n *\n * Configures given TC bitmap for VEB (switching) element\n **/\nint i40e_veb_config_tc(struct i40e_veb *veb, u8 enabled_tc)\n{\n\tstruct i40e_aqc_configure_switching_comp_bw_config_data bw_data = {0};\n\tstruct i40e_pf *pf = veb->pf;\n\tint ret = 0;\n\tint i;\n\n\t/* No TCs or already enabled TCs just return */\n\tif (!enabled_tc || veb->enabled_tc == enabled_tc)\n\t\treturn ret;\n\n\tbw_data.tc_valid_bits = enabled_tc;\n\t/* bw_data.absolute_credits is not set (relative) */\n\n\t/* Enable ETS TCs with equal BW Share for now */\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tif (enabled_tc & BIT(i))\n\t\t\tbw_data.tc_bw_share_credits[i] = 1;\n\t}\n\n\tret = i40e_aq_config_switch_comp_bw_config(&pf->hw, veb->seid,\n\t\t\t\t\t\t   &bw_data, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VEB bw config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\tgoto out;\n\t}\n\n\t/* Update the BW information */\n\tret = i40e_veb_get_bw_info(veb);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed getting veb bw config, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t}\n\nout:\n\treturn ret;\n}\n\n#ifdef CONFIG_I40E_DCB\n/**\n * i40e_dcb_reconfigure - Reconfigure all VEBs and VSIs\n * @pf: PF struct\n *\n * Reconfigure VEB/VSIs on a given PF; it is assumed that\n * the caller would've quiesce all the VSIs before calling\n * this function\n **/\nstatic void i40e_dcb_reconfigure(struct i40e_pf *pf)\n{\n\tu8 tc_map = 0;\n\tint ret;\n\tu8 v;\n\n\t/* Enable the TCs available on PF to all VEBs */\n\ttc_map = i40e_pf_get_tc_map(pf);\n\tfor (v = 0; v < I40E_MAX_VEB; v++) {\n\t\tif (!pf->veb[v])\n\t\t\tcontinue;\n\t\tret = i40e_veb_config_tc(pf->veb[v], tc_map);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Failed configuring TC for VEB seid=%d\\n\",\n\t\t\t\t pf->veb[v]->seid);\n\t\t\t/* Will try to configure as many components */\n\t\t}\n\t}\n\n\t/* Update each VSI */\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (!pf->vsi[v])\n\t\t\tcontinue;\n\n\t\t/* - Enable all TCs for the LAN VSI\n\t\t * - For all others keep them at TC0 for now\n\t\t */\n\t\tif (v == pf->lan_vsi)\n\t\t\ttc_map = i40e_pf_get_tc_map(pf);\n\t\telse\n\t\t\ttc_map = I40E_DEFAULT_TRAFFIC_CLASS;\n\n\t\tret = i40e_vsi_config_tc(pf->vsi[v], tc_map);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Failed configuring TC for VSI seid=%d\\n\",\n\t\t\t\t pf->vsi[v]->seid);\n\t\t\t/* Will try to configure as many components */\n\t\t} else {\n\t\t\t/* Re-configure VSI vectors based on updated TC map */\n\t\t\ti40e_vsi_map_rings_to_vectors(pf->vsi[v]);\n\t\t\tif (pf->vsi[v]->netdev)\n\t\t\t\ti40e_dcbnl_set_all(pf->vsi[v]);\n\t\t}\n\t}\n}\n\n/**\n * i40e_resume_port_tx - Resume port Tx\n * @pf: PF struct\n *\n * Resume a port's Tx and issue a PF reset in case of failure to\n * resume.\n **/\nstatic int i40e_resume_port_tx(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tint ret;\n\n\tret = i40e_aq_resume_port_tx(hw, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Resume Port Tx failed, err %s aq_err %s\\n\",\n\t\t\t  i40e_stat_str(&pf->hw, ret),\n\t\t\t  i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\t/* Schedule PF reset to recover */\n\t\tset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t\ti40e_service_event_schedule(pf);\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_init_pf_dcb - Initialize DCB configuration\n * @pf: PF being configured\n *\n * Query the current DCB configuration and cache it\n * in the hardware structure\n **/\nstatic int i40e_init_pf_dcb(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tint err = 0;\n\n\t/* Do not enable DCB for SW1 and SW2 images even if the FW is capable\n\t * Also do not enable DCBx if FW LLDP agent is disabled\n\t */\n\tif ((pf->hw_features & I40E_HW_NO_DCB_SUPPORT) ||\n\t    (pf->flags & I40E_FLAG_DISABLE_FW_LLDP)) {\n\t\tdev_info(&pf->pdev->dev, \"DCB is not supported or FW LLDP is disabled\\n\");\n\t\terr = I40E_NOT_SUPPORTED;\n\t\tgoto out;\n\t}\n\n\terr = i40e_init_dcb(hw, true);\n\tif (!err) {\n\t\t/* Device/Function is not DCBX capable */\n\t\tif ((!hw->func_caps.dcb) ||\n\t\t    (hw->dcbx_status == I40E_DCBX_STATUS_DISABLED)) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"DCBX offload is not supported or is disabled for this PF.\\n\");\n\t\t} else {\n\t\t\t/* When status is not DISABLED then DCBX in FW */\n\t\t\tpf->dcbx_cap = DCB_CAP_DCBX_LLD_MANAGED |\n\t\t\t\t       DCB_CAP_DCBX_VER_IEEE;\n\n\t\t\tpf->flags |= I40E_FLAG_DCB_CAPABLE;\n\t\t\t/* Enable DCB tagging only when more than one TC\n\t\t\t * or explicitly disable if only one TC\n\t\t\t */\n\t\t\tif (i40e_dcb_get_num_tc(&hw->local_dcbx_config) > 1)\n\t\t\t\tpf->flags |= I40E_FLAG_DCB_ENABLED;\n\t\t\telse\n\t\t\t\tpf->flags &= ~I40E_FLAG_DCB_ENABLED;\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"DCBX offload is supported for this PF.\\n\");\n\t\t}\n\t} else if (pf->hw.aq.asq_last_status == I40E_AQ_RC_EPERM) {\n\t\tdev_info(&pf->pdev->dev, \"FW LLDP disabled for this PF.\\n\");\n\t\tpf->flags |= I40E_FLAG_DISABLE_FW_LLDP;\n\t} else {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Query for DCB configuration failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, err),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t}\n\nout:\n\treturn err;\n}\n#endif /* CONFIG_I40E_DCB */\n\n/**\n * i40e_print_link_message - print link up or down\n * @vsi: the VSI for which link needs a message\n * @isup: true of link is up, false otherwise\n */\nvoid i40e_print_link_message(struct i40e_vsi *vsi, bool isup)\n{\n\tenum i40e_aq_link_speed new_speed;\n\tstruct i40e_pf *pf = vsi->back;\n\tchar *speed = \"Unknown\";\n\tchar *fc = \"Unknown\";\n\tchar *fec = \"\";\n\tchar *req_fec = \"\";\n\tchar *an = \"\";\n\n\tif (isup)\n\t\tnew_speed = pf->hw.phy.link_info.link_speed;\n\telse\n\t\tnew_speed = I40E_LINK_SPEED_UNKNOWN;\n\n\tif ((vsi->current_isup == isup) && (vsi->current_speed == new_speed))\n\t\treturn;\n\tvsi->current_isup = isup;\n\tvsi->current_speed = new_speed;\n\tif (!isup) {\n\t\tnetdev_info(vsi->netdev, \"NIC Link is Down\\n\");\n\t\treturn;\n\t}\n\n\t/* Warn user if link speed on NPAR enabled partition is not at\n\t * least 10GB\n\t */\n\tif (pf->hw.func_caps.npar_enable &&\n\t    (pf->hw.phy.link_info.link_speed == I40E_LINK_SPEED_1GB ||\n\t     pf->hw.phy.link_info.link_speed == I40E_LINK_SPEED_100MB))\n\t\tnetdev_warn(vsi->netdev,\n\t\t\t    \"The partition detected link speed that is less than 10Gbps\\n\");\n\n\tswitch (pf->hw.phy.link_info.link_speed) {\n\tcase I40E_LINK_SPEED_40GB:\n\t\tspeed = \"40 G\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_20GB:\n\t\tspeed = \"20 G\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_25GB:\n\t\tspeed = \"25 G\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_10GB:\n\t\tspeed = \"10 G\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_5GB:\n\t\tspeed = \"5 G\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_2_5GB:\n\t\tspeed = \"2.5 G\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_1GB:\n\t\tspeed = \"1000 M\";\n\t\tbreak;\n\tcase I40E_LINK_SPEED_100MB:\n\t\tspeed = \"100 M\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (pf->hw.fc.current_mode) {\n\tcase I40E_FC_FULL:\n\t\tfc = \"RX/TX\";\n\t\tbreak;\n\tcase I40E_FC_TX_PAUSE:\n\t\tfc = \"TX\";\n\t\tbreak;\n\tcase I40E_FC_RX_PAUSE:\n\t\tfc = \"RX\";\n\t\tbreak;\n\tdefault:\n\t\tfc = \"None\";\n\t\tbreak;\n\t}\n\n\tif (pf->hw.phy.link_info.link_speed == I40E_LINK_SPEED_25GB) {\n\t\treq_fec = \"None\";\n\t\tfec = \"None\";\n\t\tan = \"False\";\n\n\t\tif (pf->hw.phy.link_info.an_info & I40E_AQ_AN_COMPLETED)\n\t\t\tan = \"True\";\n\n\t\tif (pf->hw.phy.link_info.fec_info &\n\t\t    I40E_AQ_CONFIG_FEC_KR_ENA)\n\t\t\tfec = \"CL74 FC-FEC/BASE-R\";\n\t\telse if (pf->hw.phy.link_info.fec_info &\n\t\t\t I40E_AQ_CONFIG_FEC_RS_ENA)\n\t\t\tfec = \"CL108 RS-FEC\";\n\n\t\t/* 'CL108 RS-FEC' should be displayed when RS is requested, or\n\t\t * both RS and FC are requested\n\t\t */\n\t\tif (vsi->back->hw.phy.link_info.req_fec_info &\n\t\t    (I40E_AQ_REQUEST_FEC_KR | I40E_AQ_REQUEST_FEC_RS)) {\n\t\t\tif (vsi->back->hw.phy.link_info.req_fec_info &\n\t\t\t    I40E_AQ_REQUEST_FEC_RS)\n\t\t\t\treq_fec = \"CL108 RS-FEC\";\n\t\t\telse\n\t\t\t\treq_fec = \"CL74 FC-FEC/BASE-R\";\n\t\t}\n\t\tnetdev_info(vsi->netdev,\n\t\t\t    \"NIC Link is Up, %sbps Full Duplex, Requested FEC: %s, Negotiated FEC: %s, Autoneg: %s, Flow Control: %s\\n\",\n\t\t\t    speed, req_fec, fec, an, fc);\n\t} else if (pf->hw.device_id == I40E_DEV_ID_KX_X722) {\n\t\treq_fec = \"None\";\n\t\tfec = \"None\";\n\t\tan = \"False\";\n\n\t\tif (pf->hw.phy.link_info.an_info & I40E_AQ_AN_COMPLETED)\n\t\t\tan = \"True\";\n\n\t\tif (pf->hw.phy.link_info.fec_info &\n\t\t    I40E_AQ_CONFIG_FEC_KR_ENA)\n\t\t\tfec = \"CL74 FC-FEC/BASE-R\";\n\n\t\tif (pf->hw.phy.link_info.req_fec_info &\n\t\t    I40E_AQ_REQUEST_FEC_KR)\n\t\t\treq_fec = \"CL74 FC-FEC/BASE-R\";\n\n\t\tnetdev_info(vsi->netdev,\n\t\t\t    \"NIC Link is Up, %sbps Full Duplex, Requested FEC: %s, Negotiated FEC: %s, Autoneg: %s, Flow Control: %s\\n\",\n\t\t\t    speed, req_fec, fec, an, fc);\n\t} else {\n\t\tnetdev_info(vsi->netdev,\n\t\t\t    \"NIC Link is Up, %sbps Full Duplex, Flow Control: %s\\n\",\n\t\t\t    speed, fc);\n\t}\n\n}\n\n/**\n * i40e_up_complete - Finish the last steps of bringing up a connection\n * @vsi: the VSI being configured\n **/\nstatic int i40e_up_complete(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint err;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\ti40e_vsi_configure_msix(vsi);\n\telse\n\t\ti40e_configure_msi_and_legacy(vsi);\n\n\t/* start rings */\n\terr = i40e_vsi_start_rings(vsi);\n\tif (err)\n\t\treturn err;\n\n\tclear_bit(__I40E_VSI_DOWN, vsi->state);\n\ti40e_napi_enable_all(vsi);\n\ti40e_vsi_enable_irq(vsi);\n\n\tif ((pf->hw.phy.link_info.link_info & I40E_AQ_LINK_UP) &&\n\t    (vsi->netdev)) {\n\t\ti40e_print_link_message(vsi, true);\n\t\tnetif_tx_start_all_queues(vsi->netdev);\n\t\tnetif_carrier_on(vsi->netdev);\n\t}\n\n\t/* replay FDIR SB filters */\n\tif (vsi->type == I40E_VSI_FDIR) {\n\t\t/* reset fd counters */\n\t\tpf->fd_add_err = 0;\n\t\tpf->fd_atr_cnt = 0;\n\t\ti40e_fdir_filter_restore(vsi);\n\t}\n\n\t/* On the next run of the service_task, notify any clients of the new\n\t * opened netdev\n\t */\n\tset_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);\n\ti40e_service_event_schedule(pf);\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_reinit_locked - Reset the VSI\n * @vsi: the VSI being configured\n *\n * Rebuild the ring structs after some configuration\n * has changed, e.g. MTU size.\n **/\nstatic void i40e_vsi_reinit_locked(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\twhile (test_and_set_bit(__I40E_CONFIG_BUSY, pf->state))\n\t\tusleep_range(1000, 2000);\n\ti40e_down(vsi);\n\n\ti40e_up(vsi);\n\tclear_bit(__I40E_CONFIG_BUSY, pf->state);\n}\n\n/**\n * i40e_force_link_state - Force the link status\n * @pf: board private structure\n * @is_up: whether the link state should be forced up or down\n **/\nstatic i40e_status i40e_force_link_state(struct i40e_pf *pf, bool is_up)\n{\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_aq_set_phy_config config = {0};\n\tbool non_zero_phy_type = is_up;\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status err;\n\tu64 mask;\n\tu8 speed;\n\n\t/* Card might've been put in an unstable state by other drivers\n\t * and applications, which causes incorrect speed values being\n\t * set on startup. In order to clear speed registers, we call\n\t * get_phy_capabilities twice, once to get initial state of\n\t * available speeds, and once to get current PHY config.\n\t */\n\terr = i40e_aq_get_phy_capabilities(hw, false, true, &abilities,\n\t\t\t\t\t   NULL);\n\tif (err) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"failed to get phy cap., ret =  %s last_status =  %s\\n\",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn err;\n\t}\n\tspeed = abilities.link_speed;\n\n\t/* Get the current phy config */\n\terr = i40e_aq_get_phy_capabilities(hw, false, false, &abilities,\n\t\t\t\t\t   NULL);\n\tif (err) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"failed to get phy cap., ret =  %s last_status =  %s\\n\",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn err;\n\t}\n\n\t/* If link needs to go up, but was not forced to go down,\n\t * and its speed values are OK, no need for a flap\n\t * if non_zero_phy_type was set, still need to force up\n\t */\n\tif (pf->flags & I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED)\n\t\tnon_zero_phy_type = true;\n\telse if (is_up && abilities.phy_type != 0 && abilities.link_speed != 0)\n\t\treturn I40E_SUCCESS;\n\n\t/* To force link we need to set bits for all supported PHY types,\n\t * but there are now more than 32, so we need to split the bitmap\n\t * across two fields.\n\t */\n\tmask = I40E_PHY_TYPES_BITMASK;\n\tconfig.phy_type =\n\t\tnon_zero_phy_type ? cpu_to_le32((u32)(mask & 0xffffffff)) : 0;\n\tconfig.phy_type_ext =\n\t\tnon_zero_phy_type ? (u8)((mask >> 32) & 0xff) : 0;\n\t/* Copy the old settings, except of phy_type */\n\tconfig.abilities = abilities.abilities;\n\tif (pf->flags & I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED) {\n\t\tif (is_up)\n\t\t\tconfig.abilities |= I40E_AQ_PHY_ENABLE_LINK;\n\t\telse\n\t\t\tconfig.abilities &= ~(I40E_AQ_PHY_ENABLE_LINK);\n\t}\n\tif (abilities.link_speed != 0)\n\t\tconfig.link_speed = abilities.link_speed;\n\telse\n\t\tconfig.link_speed = speed;\n\tconfig.eee_capability = abilities.eee_capability;\n\tconfig.eeer = abilities.eeer_val;\n\tconfig.low_power_ctrl = abilities.d3_lpan;\n\tconfig.fec_config = abilities.fec_cfg_curr_mod_ext_info &\n\t\t\t    I40E_AQ_PHY_FEC_CONFIG_MASK;\n\terr = i40e_aq_set_phy_config(hw, &config, NULL);\n\n\tif (err) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"set phy config ret =  %s last_status =  %s\\n\",\n\t\t\ti40e_stat_str(&pf->hw, err),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn err;\n\t}\n\n\t/* Update the link info */\n\terr = i40e_update_link_info(hw);\n\tif (err) {\n\t\t/* Wait a little bit (on 40G cards it sometimes takes a really\n\t\t * long time for link to come back from the atomic reset)\n\t\t * and try once more\n\t\t */\n\t\tmsleep(1000);\n\t\ti40e_update_link_info(hw);\n\t}\n\n\ti40e_aq_set_link_restart_an(hw, is_up, NULL);\n\n\treturn I40E_SUCCESS;\n}\n\n/**\n * i40e_up - Bring the connection back up after being down\n * @vsi: the VSI being configured\n **/\nint i40e_up(struct i40e_vsi *vsi)\n{\n\tint err;\n\n\tif (vsi->type == I40E_VSI_MAIN &&\n\t    (vsi->back->flags & I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED ||\n\t     vsi->back->flags & I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED))\n\t\ti40e_force_link_state(vsi->back, true);\n\n\terr = i40e_vsi_configure(vsi);\n\tif (!err)\n\t\terr = i40e_up_complete(vsi);\n\n\treturn err;\n}\n\n/**\n * i40e_down - Shutdown the connection processing\n * @vsi: the VSI being stopped\n **/\nvoid i40e_down(struct i40e_vsi *vsi)\n{\n\tint i;\n\n\t/* It is assumed that the caller of this function\n\t * sets the vsi->state __I40E_VSI_DOWN bit.\n\t */\n\tif (vsi->netdev) {\n\t\tnetif_carrier_off(vsi->netdev);\n\t\tnetif_tx_disable(vsi->netdev);\n\t}\n\ti40e_vsi_disable_irq(vsi);\n\ti40e_vsi_stop_rings(vsi);\n\tif (vsi->type == I40E_VSI_MAIN &&\n\t   (vsi->back->flags & I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED ||\n\t    vsi->back->flags & I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED))\n\t\ti40e_force_link_state(vsi->back, false);\n\ti40e_napi_disable_all(vsi);\n\n\tfor (i = 0; i < vsi->num_queue_pairs; i++) {\n\t\ti40e_clean_tx_ring(vsi->tx_rings[i]);\n\t\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\t\t/* Make sure that in-progress ndo_xdp_xmit and\n\t\t\t * ndo_xsk_wakeup calls are completed.\n\t\t\t */\n\t\t\tsynchronize_rcu();\n\t\t\ti40e_clean_tx_ring(vsi->xdp_rings[i]);\n\t\t}\n\t\ti40e_clean_rx_ring(vsi->rx_rings[i]);\n\t}\n\n}\n\n/**\n * i40e_validate_mqprio_qopt- validate queue mapping info\n * @vsi: the VSI being configured\n * @mqprio_qopt: queue parametrs\n **/\nstatic int i40e_validate_mqprio_qopt(struct i40e_vsi *vsi,\n\t\t\t\t     struct tc_mqprio_qopt_offload *mqprio_qopt)\n{\n\tu64 sum_max_rate = 0;\n\tu64 max_rate = 0;\n\tint i;\n\n\tif (mqprio_qopt->qopt.offset[0] != 0 ||\n\t    mqprio_qopt->qopt.num_tc < 1 ||\n\t    mqprio_qopt->qopt.num_tc > I40E_MAX_TRAFFIC_CLASS)\n\t\treturn -EINVAL;\n\tfor (i = 0; ; i++) {\n\t\tif (!mqprio_qopt->qopt.count[i])\n\t\t\treturn -EINVAL;\n\t\tif (mqprio_qopt->min_rate[i]) {\n\t\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\t\"Invalid min tx rate (greater than 0) specified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax_rate = mqprio_qopt->max_rate[i];\n\t\tdo_div(max_rate, I40E_BW_MBPS_DIVISOR);\n\t\tsum_max_rate += max_rate;\n\n\t\tif (i >= mqprio_qopt->qopt.num_tc - 1)\n\t\t\tbreak;\n\t\tif (mqprio_qopt->qopt.offset[i + 1] !=\n\t\t    (mqprio_qopt->qopt.offset[i] + mqprio_qopt->qopt.count[i]))\n\t\t\treturn -EINVAL;\n\t}\n\tif (vsi->num_queue_pairs <\n\t    (mqprio_qopt->qopt.offset[i] + mqprio_qopt->qopt.count[i])) {\n\t\treturn -EINVAL;\n\t}\n\tif (sum_max_rate > i40e_get_link_speed(vsi)) {\n\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\"Invalid max tx rate specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/**\n * i40e_vsi_set_default_tc_config - set default values for tc configuration\n * @vsi: the VSI being configured\n **/\nstatic void i40e_vsi_set_default_tc_config(struct i40e_vsi *vsi)\n{\n\tu16 qcount;\n\tint i;\n\n\t/* Only TC0 is enabled */\n\tvsi->tc_config.numtc = 1;\n\tvsi->tc_config.enabled_tc = 1;\n\tqcount = min_t(int, vsi->alloc_queue_pairs,\n\t\t       i40e_pf_get_max_q_per_tc(vsi->back));\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\t/* For the TC that is not enabled set the offset to to default\n\t\t * queue and allocate one queue for the given TC.\n\t\t */\n\t\tvsi->tc_config.tc_info[i].qoffset = 0;\n\t\tif (i == 0)\n\t\t\tvsi->tc_config.tc_info[i].qcount = qcount;\n\t\telse\n\t\t\tvsi->tc_config.tc_info[i].qcount = 1;\n\t\tvsi->tc_config.tc_info[i].netdev_tc = 0;\n\t}\n}\n\n/**\n * i40e_del_macvlan_filter\n * @hw: pointer to the HW structure\n * @seid: seid of the channel VSI\n * @macaddr: the mac address to apply as a filter\n * @aq_err: store the admin Q error\n *\n * This function deletes a mac filter on the channel VSI which serves as the\n * macvlan. Returns 0 on success.\n **/\nstatic i40e_status i40e_del_macvlan_filter(struct i40e_hw *hw, u16 seid,\n\t\t\t\t\t   const u8 *macaddr, int *aq_err)\n{\n\tstruct i40e_aqc_remove_macvlan_element_data element;\n\ti40e_status status;\n\n\tmemset(&element, 0, sizeof(element));\n\tether_addr_copy(element.mac_addr, macaddr);\n\telement.vlan_tag = 0;\n\telement.flags = I40E_AQC_MACVLAN_DEL_PERFECT_MATCH;\n\tstatus = i40e_aq_remove_macvlan(hw, seid, &element, 1, NULL);\n\t*aq_err = hw->aq.asq_last_status;\n\n\treturn status;\n}\n\n/**\n * i40e_add_macvlan_filter\n * @hw: pointer to the HW structure\n * @seid: seid of the channel VSI\n * @macaddr: the mac address to apply as a filter\n * @aq_err: store the admin Q error\n *\n * This function adds a mac filter on the channel VSI which serves as the\n * macvlan. Returns 0 on success.\n **/\nstatic i40e_status i40e_add_macvlan_filter(struct i40e_hw *hw, u16 seid,\n\t\t\t\t\t   const u8 *macaddr, int *aq_err)\n{\n\tstruct i40e_aqc_add_macvlan_element_data element;\n\ti40e_status status;\n\tu16 cmd_flags = 0;\n\n\tether_addr_copy(element.mac_addr, macaddr);\n\telement.vlan_tag = 0;\n\telement.queue_number = 0;\n\telement.match_method = I40E_AQC_MM_ERR_NO_RES;\n\tcmd_flags |= I40E_AQC_MACVLAN_ADD_PERFECT_MATCH;\n\telement.flags = cpu_to_le16(cmd_flags);\n\tstatus = i40e_aq_add_macvlan(hw, seid, &element, 1, NULL);\n\t*aq_err = hw->aq.asq_last_status;\n\n\treturn status;\n}\n\n/**\n * i40e_reset_ch_rings - Reset the queue contexts in a channel\n * @vsi: the VSI we want to access\n * @ch: the channel we want to access\n */\nstatic void i40e_reset_ch_rings(struct i40e_vsi *vsi, struct i40e_channel *ch)\n{\n\tstruct i40e_ring *tx_ring, *rx_ring;\n\tu16 pf_q;\n\tint i;\n\n\tfor (i = 0; i < ch->num_queue_pairs; i++) {\n\t\tpf_q = ch->base_queue + i;\n\t\ttx_ring = vsi->tx_rings[pf_q];\n\t\ttx_ring->ch = NULL;\n\t\trx_ring = vsi->rx_rings[pf_q];\n\t\trx_ring->ch = NULL;\n\t}\n}\n\n/**\n * i40e_free_macvlan_channels\n * @vsi: the VSI we want to access\n *\n * This function frees the Qs of the channel VSI from\n * the stack and also deletes the channel VSIs which\n * serve as macvlans.\n */\nstatic void i40e_free_macvlan_channels(struct i40e_vsi *vsi)\n{\n\tstruct i40e_channel *ch, *ch_tmp;\n\tint ret;\n\n\tif (list_empty(&vsi->macvlan_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->macvlan_list, list) {\n\t\tstruct i40e_vsi *parent_vsi;\n\n\t\tif (i40e_is_channel_macvlan(ch)) {\n\t\t\ti40e_reset_ch_rings(vsi, ch);\n\t\t\tclear_bit(ch->fwd->bit_no, vsi->fwd_bitmask);\n\t\t\tnetdev_unbind_sb_channel(vsi->netdev, ch->fwd->netdev);\n\t\t\tnetdev_set_sb_channel(ch->fwd->netdev, 0);\n\t\t\tkfree(ch->fwd);\n\t\t\tch->fwd = NULL;\n\t\t}\n\n\t\tlist_del(&ch->list);\n\t\tparent_vsi = ch->parent_vsi;\n\t\tif (!parent_vsi || !ch->initialized) {\n\t\t\tkfree(ch);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove the VSI */\n\t\tret = i40e_aq_delete_element(&vsi->back->hw, ch->seid,\n\t\t\t\t\t     NULL);\n\t\tif (ret)\n\t\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\t\"unable to remove channel (%d) for parent VSI(%d)\\n\",\n\t\t\t\tch->seid, parent_vsi->seid);\n\t\tkfree(ch);\n\t}\n\tvsi->macvlan_cnt = 0;\n}\n\n/**\n * i40e_fwd_ring_up - bring the macvlan device up\n * @vsi: the VSI we want to access\n * @vdev: macvlan netdevice\n * @fwd: the private fwd structure\n */\nstatic int i40e_fwd_ring_up(struct i40e_vsi *vsi, struct net_device *vdev,\n\t\t\t    struct i40e_fwd_adapter *fwd)\n{\n\tint ret = 0, num_tc = 1,  i, aq_err;\n\tstruct i40e_channel *ch, *ch_tmp;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\n\tif (list_empty(&vsi->macvlan_list))\n\t\treturn -EINVAL;\n\n\t/* Go through the list and find an available channel */\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->macvlan_list, list) {\n\t\tif (!i40e_is_channel_macvlan(ch)) {\n\t\t\tch->fwd = fwd;\n\t\t\t/* record configuration for macvlan interface in vdev */\n\t\t\tfor (i = 0; i < num_tc; i++)\n\t\t\t\tnetdev_bind_sb_channel_queue(vsi->netdev, vdev,\n\t\t\t\t\t\t\t     i,\n\t\t\t\t\t\t\t     ch->num_queue_pairs,\n\t\t\t\t\t\t\t     ch->base_queue);\n\t\t\tfor (i = 0; i < ch->num_queue_pairs; i++) {\n\t\t\t\tstruct i40e_ring *tx_ring, *rx_ring;\n\t\t\t\tu16 pf_q;\n\n\t\t\t\tpf_q = ch->base_queue + i;\n\n\t\t\t\t/* Get to TX ring ptr */\n\t\t\t\ttx_ring = vsi->tx_rings[pf_q];\n\t\t\t\ttx_ring->ch = ch;\n\n\t\t\t\t/* Get the RX ring ptr */\n\t\t\t\trx_ring = vsi->rx_rings[pf_q];\n\t\t\t\trx_ring->ch = ch;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Guarantee all rings are updated before we update the\n\t * MAC address filter.\n\t */\n\twmb();\n\n\t/* Add a mac filter */\n\tret = i40e_add_macvlan_filter(hw, ch->seid, vdev->dev_addr, &aq_err);\n\tif (ret) {\n\t\t/* if we cannot add the MAC rule then disable the offload */\n\t\tmacvlan_release_l2fw_offload(vdev);\n\t\tfor (i = 0; i < ch->num_queue_pairs; i++) {\n\t\t\tstruct i40e_ring *rx_ring;\n\t\t\tu16 pf_q;\n\n\t\t\tpf_q = ch->base_queue + i;\n\t\t\trx_ring = vsi->rx_rings[pf_q];\n\t\t\trx_ring->netdev = NULL;\n\t\t}\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Error adding mac filter on macvlan err %s, aq_err %s\\n\",\n\t\t\t  i40e_stat_str(hw, ret),\n\t\t\t  i40e_aq_str(hw, aq_err));\n\t\tnetdev_err(vdev, \"L2fwd offload disabled to L2 filter error\\n\");\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_setup_macvlans - create the channels which will be macvlans\n * @vsi: the VSI we want to access\n * @macvlan_cnt: no. of macvlans to be setup\n * @qcnt: no. of Qs per macvlan\n * @vdev: macvlan netdevice\n */\nstatic int i40e_setup_macvlans(struct i40e_vsi *vsi, u16 macvlan_cnt, u16 qcnt,\n\t\t\t       struct net_device *vdev)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vsi_context ctxt;\n\tu16 sections, qmap, num_qps;\n\tstruct i40e_channel *ch;\n\tint i, pow, ret = 0;\n\tu8 offset = 0;\n\n\tif (vsi->type != I40E_VSI_MAIN || !macvlan_cnt)\n\t\treturn -EINVAL;\n\n\tnum_qps = vsi->num_queue_pairs - (macvlan_cnt * qcnt);\n\n\t/* find the next higher power-of-2 of num queue pairs */\n\tpow = fls(roundup_pow_of_two(num_qps) - 1);\n\n\tqmap = (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |\n\t\t(pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);\n\n\t/* Setup context bits for the main VSI */\n\tsections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;\n\tsections |= I40E_AQ_VSI_PROP_SCHED_VALID;\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tctxt.seid = vsi->seid;\n\tctxt.pf_num = vsi->back->hw.pf_id;\n\tctxt.vf_num = 0;\n\tctxt.uplink_seid = vsi->uplink_seid;\n\tctxt.info = vsi->info;\n\tctxt.info.tc_mapping[0] = cpu_to_le16(qmap);\n\tctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);\n\tctxt.info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);\n\tctxt.info.valid_sections |= cpu_to_le16(sections);\n\n\t/* Reconfigure RSS for main VSI with new max queue count */\n\tvsi->rss_size = max_t(u16, num_qps, qcnt);\n\tret = i40e_vsi_config_rss(vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed to reconfig RSS for num_queues (%u)\\n\",\n\t\t\t vsi->rss_size);\n\t\treturn ret;\n\t}\n\tvsi->reconfig_rss = true;\n\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\"Reconfigured RSS with num_queues (%u)\\n\", vsi->rss_size);\n\tvsi->next_base_queue = num_qps;\n\tvsi->cnt_q_avail = vsi->num_queue_pairs - num_qps;\n\n\t/* Update the VSI after updating the VSI queue-mapping\n\t * information\n\t */\n\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Update vsi tc config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(hw, ret),\n\t\t\t i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn ret;\n\t}\n\t/* update the local VSI info with updated queue map */\n\ti40e_vsi_update_queue_map(vsi, &ctxt);\n\tvsi->info.valid_sections = 0;\n\n\t/* Create channels for macvlans */\n\tINIT_LIST_HEAD(&vsi->macvlan_list);\n\tfor (i = 0; i < macvlan_cnt; i++) {\n\t\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\t\tif (!ch) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\t\tINIT_LIST_HEAD(&ch->list);\n\t\tch->num_queue_pairs = qcnt;\n\t\tif (!i40e_setup_channel(pf, vsi, ch)) {\n\t\t\tret = -EINVAL;\n\t\t\tkfree(ch);\n\t\t\tgoto err_free;\n\t\t}\n\t\tch->parent_vsi = vsi;\n\t\tvsi->cnt_q_avail -= ch->num_queue_pairs;\n\t\tvsi->macvlan_cnt++;\n\t\tlist_add_tail(&ch->list, &vsi->macvlan_list);\n\t}\n\n\treturn ret;\n\nerr_free:\n\tdev_info(&pf->pdev->dev, \"Failed to setup macvlans\\n\");\n\ti40e_free_macvlan_channels(vsi);\n\n\treturn ret;\n}\n\n/**\n * i40e_fwd_add - configure macvlans\n * @netdev: net device to configure\n * @vdev: macvlan netdevice\n **/\nstatic void *i40e_fwd_add(struct net_device *netdev, struct net_device *vdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tu16 q_per_macvlan = 0, macvlan_cnt = 0, vectors;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_fwd_adapter *fwd;\n\tint avail_macvlan, ret;\n\n\tif ((pf->flags & I40E_FLAG_DCB_ENABLED)) {\n\t\tnetdev_info(netdev, \"Macvlans are not supported when DCB is enabled\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif ((pf->flags & I40E_FLAG_TC_MQPRIO)) {\n\t\tnetdev_info(netdev, \"Macvlans are not supported when HW TC offload is on\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (pf->num_lan_msix < I40E_MIN_MACVLAN_VECTORS) {\n\t\tnetdev_info(netdev, \"Not enough vectors available to support macvlans\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* The macvlan device has to be a single Q device so that the\n\t * tc_to_txq field can be reused to pick the tx queue.\n\t */\n\tif (netif_is_multiqueue(vdev))\n\t\treturn ERR_PTR(-ERANGE);\n\n\tif (!vsi->macvlan_cnt) {\n\t\t/* reserve bit 0 for the pf device */\n\t\tset_bit(0, vsi->fwd_bitmask);\n\n\t\t/* Try to reserve as many queues as possible for macvlans. First\n\t\t * reserve 3/4th of max vectors, then half, then quarter and\n\t\t * calculate Qs per macvlan as you go\n\t\t */\n\t\tvectors = pf->num_lan_msix;\n\t\tif (vectors <= I40E_MAX_MACVLANS && vectors > 64) {\n\t\t\t/* allocate 4 Qs per macvlan and 32 Qs to the PF*/\n\t\t\tq_per_macvlan = 4;\n\t\t\tmacvlan_cnt = (vectors - 32) / 4;\n\t\t} else if (vectors <= 64 && vectors > 32) {\n\t\t\t/* allocate 2 Qs per macvlan and 16 Qs to the PF*/\n\t\t\tq_per_macvlan = 2;\n\t\t\tmacvlan_cnt = (vectors - 16) / 2;\n\t\t} else if (vectors <= 32 && vectors > 16) {\n\t\t\t/* allocate 1 Q per macvlan and 16 Qs to the PF*/\n\t\t\tq_per_macvlan = 1;\n\t\t\tmacvlan_cnt = vectors - 16;\n\t\t} else if (vectors <= 16 && vectors > 8) {\n\t\t\t/* allocate 1 Q per macvlan and 8 Qs to the PF */\n\t\t\tq_per_macvlan = 1;\n\t\t\tmacvlan_cnt = vectors - 8;\n\t\t} else {\n\t\t\t/* allocate 1 Q per macvlan and 1 Q to the PF */\n\t\t\tq_per_macvlan = 1;\n\t\t\tmacvlan_cnt = vectors - 1;\n\t\t}\n\n\t\tif (macvlan_cnt == 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\t/* Quiesce VSI queues */\n\t\ti40e_quiesce_vsi(vsi);\n\n\t\t/* sets up the macvlans but does not \"enable\" them */\n\t\tret = i40e_setup_macvlans(vsi, macvlan_cnt, q_per_macvlan,\n\t\t\t\t\t  vdev);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\t/* Unquiesce VSI */\n\t\ti40e_unquiesce_vsi(vsi);\n\t}\n\tavail_macvlan = find_first_zero_bit(vsi->fwd_bitmask,\n\t\t\t\t\t    vsi->macvlan_cnt);\n\tif (avail_macvlan >= I40E_MAX_MACVLANS)\n\t\treturn ERR_PTR(-EBUSY);\n\n\t/* create the fwd struct */\n\tfwd = kzalloc(sizeof(*fwd), GFP_KERNEL);\n\tif (!fwd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_bit(avail_macvlan, vsi->fwd_bitmask);\n\tfwd->bit_no = avail_macvlan;\n\tnetdev_set_sb_channel(vdev, avail_macvlan);\n\tfwd->netdev = vdev;\n\n\tif (!netif_running(netdev))\n\t\treturn fwd;\n\n\t/* Set fwd ring up */\n\tret = i40e_fwd_ring_up(vsi, vdev, fwd);\n\tif (ret) {\n\t\t/* unbind the queues and drop the subordinate channel config */\n\t\tnetdev_unbind_sb_channel(netdev, vdev);\n\t\tnetdev_set_sb_channel(vdev, 0);\n\n\t\tkfree(fwd);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn fwd;\n}\n\n/**\n * i40e_del_all_macvlans - Delete all the mac filters on the channels\n * @vsi: the VSI we want to access\n */\nstatic void i40e_del_all_macvlans(struct i40e_vsi *vsi)\n{\n\tstruct i40e_channel *ch, *ch_tmp;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint aq_err, ret = 0;\n\n\tif (list_empty(&vsi->macvlan_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->macvlan_list, list) {\n\t\tif (i40e_is_channel_macvlan(ch)) {\n\t\t\tret = i40e_del_macvlan_filter(hw, ch->seid,\n\t\t\t\t\t\t      i40e_channel_mac(ch),\n\t\t\t\t\t\t      &aq_err);\n\t\t\tif (!ret) {\n\t\t\t\t/* Reset queue contexts */\n\t\t\t\ti40e_reset_ch_rings(vsi, ch);\n\t\t\t\tclear_bit(ch->fwd->bit_no, vsi->fwd_bitmask);\n\t\t\t\tnetdev_unbind_sb_channel(vsi->netdev,\n\t\t\t\t\t\t\t ch->fwd->netdev);\n\t\t\t\tnetdev_set_sb_channel(ch->fwd->netdev, 0);\n\t\t\t\tkfree(ch->fwd);\n\t\t\t\tch->fwd = NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * i40e_fwd_del - delete macvlan interfaces\n * @netdev: net device to configure\n * @vdev: macvlan netdevice\n */\nstatic void i40e_fwd_del(struct net_device *netdev, void *vdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_fwd_adapter *fwd = vdev;\n\tstruct i40e_channel *ch, *ch_tmp;\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint aq_err, ret = 0;\n\n\t/* Find the channel associated with the macvlan and del mac filter */\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->macvlan_list, list) {\n\t\tif (i40e_is_channel_macvlan(ch) &&\n\t\t    ether_addr_equal(i40e_channel_mac(ch),\n\t\t\t\t     fwd->netdev->dev_addr)) {\n\t\t\tret = i40e_del_macvlan_filter(hw, ch->seid,\n\t\t\t\t\t\t      i40e_channel_mac(ch),\n\t\t\t\t\t\t      &aq_err);\n\t\t\tif (!ret) {\n\t\t\t\t/* Reset queue contexts */\n\t\t\t\ti40e_reset_ch_rings(vsi, ch);\n\t\t\t\tclear_bit(ch->fwd->bit_no, vsi->fwd_bitmask);\n\t\t\t\tnetdev_unbind_sb_channel(netdev, fwd->netdev);\n\t\t\t\tnetdev_set_sb_channel(fwd->netdev, 0);\n\t\t\t\tkfree(ch->fwd);\n\t\t\t\tch->fwd = NULL;\n\t\t\t} else {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"Error deleting mac filter on macvlan err %s, aq_err %s\\n\",\n\t\t\t\t\t  i40e_stat_str(hw, ret),\n\t\t\t\t\t  i40e_aq_str(hw, aq_err));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * i40e_setup_tc - configure multiple traffic classes\n * @netdev: net device to configure\n * @type_data: tc offload data\n **/\nstatic int i40e_setup_tc(struct net_device *netdev, void *type_data)\n{\n\tstruct tc_mqprio_qopt_offload *mqprio_qopt = type_data;\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tu8 enabled_tc = 0, num_tc, hw;\n\tbool need_reset = false;\n\tint old_queue_pairs;\n\tint ret = -EINVAL;\n\tu16 mode;\n\tint i;\n\n\told_queue_pairs = vsi->num_queue_pairs;\n\tnum_tc = mqprio_qopt->qopt.num_tc;\n\thw = mqprio_qopt->qopt.hw;\n\tmode = mqprio_qopt->mode;\n\tif (!hw) {\n\t\tpf->flags &= ~I40E_FLAG_TC_MQPRIO;\n\t\tmemcpy(&vsi->mqprio_qopt, mqprio_qopt, sizeof(*mqprio_qopt));\n\t\tgoto config_tc;\n\t}\n\n\t/* Check if MFP enabled */\n\tif (pf->flags & I40E_FLAG_MFP_ENABLED) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Configuring TC not supported in MFP mode\\n\");\n\t\treturn ret;\n\t}\n\tswitch (mode) {\n\tcase TC_MQPRIO_MODE_DCB:\n\t\tpf->flags &= ~I40E_FLAG_TC_MQPRIO;\n\n\t\t/* Check if DCB enabled to continue */\n\t\tif (!(pf->flags & I40E_FLAG_DCB_ENABLED)) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"DCB is not enabled for adapter\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* Check whether tc count is within enabled limit */\n\t\tif (num_tc > i40e_pf_get_num_tc(pf)) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"TC count greater than enabled on link for adapter\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase TC_MQPRIO_MODE_CHANNEL:\n\t\tif (pf->flags & I40E_FLAG_DCB_ENABLED) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Full offload of TC Mqprio options is not supported when DCB is enabled\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(pf->flags & I40E_FLAG_MSIX_ENABLED))\n\t\t\treturn ret;\n\t\tret = i40e_validate_mqprio_qopt(vsi, mqprio_qopt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmemcpy(&vsi->mqprio_qopt, mqprio_qopt,\n\t\t       sizeof(*mqprio_qopt));\n\t\tpf->flags |= I40E_FLAG_TC_MQPRIO;\n\t\tpf->flags &= ~I40E_FLAG_DCB_ENABLED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nconfig_tc:\n\t/* Generate TC map for number of tc requested */\n\tfor (i = 0; i < num_tc; i++)\n\t\tenabled_tc |= BIT(i);\n\n\t/* Requesting same TC configuration as already enabled */\n\tif (enabled_tc == vsi->tc_config.enabled_tc &&\n\t    mode != TC_MQPRIO_MODE_CHANNEL)\n\t\treturn 0;\n\n\t/* Quiesce VSI queues */\n\ti40e_quiesce_vsi(vsi);\n\n\tif (!hw && !(pf->flags & I40E_FLAG_TC_MQPRIO))\n\t\ti40e_remove_queue_channels(vsi);\n\n\t/* Configure VSI for enabled TCs */\n\tret = i40e_vsi_config_tc(vsi, enabled_tc);\n\tif (ret) {\n\t\tnetdev_info(netdev, \"Failed configuring TC for VSI seid=%d\\n\",\n\t\t\t    vsi->seid);\n\t\tneed_reset = true;\n\t\tgoto exit;\n\t} else {\n\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t \"Setup channel (id:%u) utilizing num_queues %d\\n\",\n\t\t\t vsi->seid, vsi->tc_config.tc_info[0].qcount);\n\t}\n\n\tif (pf->flags & I40E_FLAG_TC_MQPRIO) {\n\t\tif (vsi->mqprio_qopt.max_rate[0]) {\n\t\t\tu64 max_tx_rate = vsi->mqprio_qopt.max_rate[0];\n\n\t\t\tdo_div(max_tx_rate, I40E_BW_MBPS_DIVISOR);\n\t\t\tret = i40e_set_bw_limit(vsi, vsi->seid, max_tx_rate);\n\t\t\tif (!ret) {\n\t\t\t\tu64 credits = max_tx_rate;\n\n\t\t\t\tdo_div(credits, I40E_BW_CREDIT_DIVISOR);\n\t\t\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\t\t\"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\\n\",\n\t\t\t\t\tmax_tx_rate,\n\t\t\t\t\tcredits,\n\t\t\t\t\tvsi->seid);\n\t\t\t} else {\n\t\t\t\tneed_reset = true;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tret = i40e_configure_queue_channels(vsi);\n\t\tif (ret) {\n\t\t\tvsi->num_queue_pairs = old_queue_pairs;\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"Failed configuring queue channels\\n\");\n\t\t\tneed_reset = true;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\t/* Reset the configuration data to defaults, only TC0 is enabled */\n\tif (need_reset) {\n\t\ti40e_vsi_set_default_tc_config(vsi);\n\t\tneed_reset = false;\n\t}\n\n\t/* Unquiesce VSI */\n\ti40e_unquiesce_vsi(vsi);\n\treturn ret;\n}\n\n/**\n * i40e_set_cld_element - sets cloud filter element data\n * @filter: cloud filter rule\n * @cld: ptr to cloud filter element data\n *\n * This is helper function to copy data into cloud filter element\n **/\nstatic inline void\ni40e_set_cld_element(struct i40e_cloud_filter *filter,\n\t\t     struct i40e_aqc_cloud_filters_element_data *cld)\n{\n\tint i, j;\n\tu32 ipa;\n\n\tmemset(cld, 0, sizeof(*cld));\n\tether_addr_copy(cld->outer_mac, filter->dst_mac);\n\tether_addr_copy(cld->inner_mac, filter->src_mac);\n\n\tif (filter->n_proto != ETH_P_IP && filter->n_proto != ETH_P_IPV6)\n\t\treturn;\n\n\tif (filter->n_proto == ETH_P_IPV6) {\n#define IPV6_MAX_INDEX\t(ARRAY_SIZE(filter->dst_ipv6) - 1)\n\t\tfor (i = 0, j = 0; i < ARRAY_SIZE(filter->dst_ipv6);\n\t\t     i++, j += 2) {\n\t\t\tipa = be32_to_cpu(filter->dst_ipv6[IPV6_MAX_INDEX - i]);\n\t\t\tipa = cpu_to_le32(ipa);\n\t\t\tmemcpy(&cld->ipaddr.raw_v6.data[j], &ipa, sizeof(ipa));\n\t\t}\n\t} else {\n\t\tipa = be32_to_cpu(filter->dst_ipv4);\n\t\tmemcpy(&cld->ipaddr.v4.data, &ipa, sizeof(ipa));\n\t}\n\n\tcld->inner_vlan = cpu_to_le16(ntohs(filter->vlan_id));\n\n\t/* tenant_id is not supported by FW now, once the support is enabled\n\t * fill the cld->tenant_id with cpu_to_le32(filter->tenant_id)\n\t */\n\tif (filter->tenant_id)\n\t\treturn;\n}\n\n/**\n * i40e_add_del_cloud_filter - Add/del cloud filter\n * @vsi: pointer to VSI\n * @filter: cloud filter rule\n * @add: if true, add, if false, delete\n *\n * Add or delete a cloud filter for a specific flow spec.\n * Returns 0 if the filter were successfully added.\n **/\nint i40e_add_del_cloud_filter(struct i40e_vsi *vsi,\n\t\t\t      struct i40e_cloud_filter *filter, bool add)\n{\n\tstruct i40e_aqc_cloud_filters_element_data cld_filter;\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret;\n\tstatic const u16 flag_table[128] = {\n\t\t[I40E_CLOUD_FILTER_FLAGS_OMAC]  =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_OMAC,\n\t\t[I40E_CLOUD_FILTER_FLAGS_IMAC]  =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_IMAC,\n\t\t[I40E_CLOUD_FILTER_FLAGS_IMAC_IVLAN]  =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_IMAC_IVLAN,\n\t\t[I40E_CLOUD_FILTER_FLAGS_IMAC_TEN_ID] =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_IMAC_TEN_ID,\n\t\t[I40E_CLOUD_FILTER_FLAGS_OMAC_TEN_ID_IMAC] =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_OMAC_TEN_ID_IMAC,\n\t\t[I40E_CLOUD_FILTER_FLAGS_IMAC_IVLAN_TEN_ID] =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_IMAC_IVLAN_TEN_ID,\n\t\t[I40E_CLOUD_FILTER_FLAGS_IIP] =\n\t\t\tI40E_AQC_ADD_CLOUD_FILTER_IIP,\n\t};\n\n\tif (filter->flags >= ARRAY_SIZE(flag_table))\n\t\treturn I40E_ERR_CONFIG;\n\n\t/* copy element needed to add cloud filter from filter */\n\ti40e_set_cld_element(filter, &cld_filter);\n\n\tif (filter->tunnel_type != I40E_CLOUD_TNL_TYPE_NONE)\n\t\tcld_filter.flags = cpu_to_le16(filter->tunnel_type <<\n\t\t\t\t\t     I40E_AQC_ADD_CLOUD_TNL_TYPE_SHIFT);\n\n\tif (filter->n_proto == ETH_P_IPV6)\n\t\tcld_filter.flags |= cpu_to_le16(flag_table[filter->flags] |\n\t\t\t\t\t\tI40E_AQC_ADD_CLOUD_FLAGS_IPV6);\n\telse\n\t\tcld_filter.flags |= cpu_to_le16(flag_table[filter->flags] |\n\t\t\t\t\t\tI40E_AQC_ADD_CLOUD_FLAGS_IPV4);\n\n\tif (add)\n\t\tret = i40e_aq_add_cloud_filters(&pf->hw, filter->seid,\n\t\t\t\t\t\t&cld_filter, 1);\n\telse\n\t\tret = i40e_aq_rem_cloud_filters(&pf->hw, filter->seid,\n\t\t\t\t\t\t&cld_filter, 1);\n\tif (ret)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Failed to %s cloud filter using l4 port %u, err %d aq_err %d\\n\",\n\t\t\tadd ? \"add\" : \"delete\", filter->dst_port, ret,\n\t\t\tpf->hw.aq.asq_last_status);\n\telse\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"%s cloud filter for VSI: %d\\n\",\n\t\t\t add ? \"Added\" : \"Deleted\", filter->seid);\n\treturn ret;\n}\n\n/**\n * i40e_add_del_cloud_filter_big_buf - Add/del cloud filter using big_buf\n * @vsi: pointer to VSI\n * @filter: cloud filter rule\n * @add: if true, add, if false, delete\n *\n * Add or delete a cloud filter for a specific flow spec using big buffer.\n * Returns 0 if the filter were successfully added.\n **/\nint i40e_add_del_cloud_filter_big_buf(struct i40e_vsi *vsi,\n\t\t\t\t      struct i40e_cloud_filter *filter,\n\t\t\t\t      bool add)\n{\n\tstruct i40e_aqc_cloud_filters_element_bb cld_filter;\n\tstruct i40e_pf *pf = vsi->back;\n\tint ret;\n\n\t/* Both (src/dst) valid mac_addr are not supported */\n\tif ((is_valid_ether_addr(filter->dst_mac) &&\n\t     is_valid_ether_addr(filter->src_mac)) ||\n\t    (is_multicast_ether_addr(filter->dst_mac) &&\n\t     is_multicast_ether_addr(filter->src_mac)))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Big buffer cloud filter needs 'L4 port' to be non-zero. Also, UDP\n\t * ports are not supported via big buffer now.\n\t */\n\tif (!filter->dst_port || filter->ip_proto == IPPROTO_UDP)\n\t\treturn -EOPNOTSUPP;\n\n\t/* adding filter using src_port/src_ip is not supported at this stage */\n\tif (filter->src_port || filter->src_ipv4 ||\n\t    !ipv6_addr_any(&filter->ip.v6.src_ip6))\n\t\treturn -EOPNOTSUPP;\n\n\t/* copy element needed to add cloud filter from filter */\n\ti40e_set_cld_element(filter, &cld_filter.element);\n\n\tif (is_valid_ether_addr(filter->dst_mac) ||\n\t    is_valid_ether_addr(filter->src_mac) ||\n\t    is_multicast_ether_addr(filter->dst_mac) ||\n\t    is_multicast_ether_addr(filter->src_mac)) {\n\t\t/* MAC + IP : unsupported mode */\n\t\tif (filter->dst_ipv4)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t/* since we validated that L4 port must be valid before\n\t\t * we get here, start with respective \"flags\" value\n\t\t * and update if vlan is present or not\n\t\t */\n\t\tcld_filter.element.flags =\n\t\t\tcpu_to_le16(I40E_AQC_ADD_CLOUD_FILTER_MAC_PORT);\n\n\t\tif (filter->vlan_id) {\n\t\t\tcld_filter.element.flags =\n\t\t\tcpu_to_le16(I40E_AQC_ADD_CLOUD_FILTER_MAC_VLAN_PORT);\n\t\t}\n\n\t} else if (filter->dst_ipv4 ||\n\t\t   !ipv6_addr_any(&filter->ip.v6.dst_ip6)) {\n\t\tcld_filter.element.flags =\n\t\t\t\tcpu_to_le16(I40E_AQC_ADD_CLOUD_FILTER_IP_PORT);\n\t\tif (filter->n_proto == ETH_P_IPV6)\n\t\t\tcld_filter.element.flags |=\n\t\t\t\tcpu_to_le16(I40E_AQC_ADD_CLOUD_FLAGS_IPV6);\n\t\telse\n\t\t\tcld_filter.element.flags |=\n\t\t\t\tcpu_to_le16(I40E_AQC_ADD_CLOUD_FLAGS_IPV4);\n\t} else {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"either mac or ip has to be valid for cloud filter\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Now copy L4 port in Byte 6..7 in general fields */\n\tcld_filter.general_fields[I40E_AQC_ADD_CLOUD_FV_FLU_0X16_WORD0] =\n\t\t\t\t\t\tbe16_to_cpu(filter->dst_port);\n\n\tif (add) {\n\t\t/* Validate current device switch mode, change if necessary */\n\t\tret = i40e_validate_and_set_switch_mode(vsi);\n\t\tif (ret) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"failed to set switch mode, ret %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = i40e_aq_add_cloud_filters_bb(&pf->hw, filter->seid,\n\t\t\t\t\t\t   &cld_filter, 1);\n\t} else {\n\t\tret = i40e_aq_rem_cloud_filters_bb(&pf->hw, filter->seid,\n\t\t\t\t\t\t   &cld_filter, 1);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Failed to %s cloud filter(big buffer) err %d aq_err %d\\n\",\n\t\t\tadd ? \"add\" : \"delete\", ret, pf->hw.aq.asq_last_status);\n\telse\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"%s cloud filter for VSI: %d, L4 port: %d\\n\",\n\t\t\t add ? \"add\" : \"delete\", filter->seid,\n\t\t\t ntohs(filter->dst_port));\n\treturn ret;\n}\n\n/**\n * i40e_parse_cls_flower - Parse tc flower filters provided by kernel\n * @vsi: Pointer to VSI\n * @f: Pointer to struct flow_cls_offload\n * @filter: Pointer to cloud filter structure\n *\n **/\nstatic int i40e_parse_cls_flower(struct i40e_vsi *vsi,\n\t\t\t\t struct flow_cls_offload *f,\n\t\t\t\t struct i40e_cloud_filter *filter)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tu16 n_proto_mask = 0, n_proto_key = 0, addr_type = 0;\n\tstruct i40e_pf *pf = vsi->back;\n\tu8 field_flags = 0;\n\n\tif (dissector->used_keys &\n\t    ~(BIT(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT(FLOW_DISSECTOR_KEY_ETH_ADDRS) |\n\t      BIT(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |\n\t      BIT(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |\n\t      BIT(FLOW_DISSECTOR_KEY_PORTS) |\n\t      BIT(FLOW_DISSECTOR_KEY_ENC_KEYID))) {\n\t\tdev_err(&pf->pdev->dev, \"Unsupported key used: 0x%x\\n\",\n\t\t\tdissector->used_keys);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ENC_KEYID)) {\n\t\tstruct flow_match_enc_keyid match;\n\n\t\tflow_rule_match_enc_keyid(rule, &match);\n\t\tif (match.mask->keyid != 0)\n\t\t\tfield_flags |= I40E_CLOUD_FIELD_TEN_ID;\n\n\t\tfilter->tenant_id = be32_to_cpu(match.key->keyid);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tn_proto_key = ntohs(match.key->n_proto);\n\t\tn_proto_mask = ntohs(match.mask->n_proto);\n\n\t\tif (n_proto_key == ETH_P_ALL) {\n\t\t\tn_proto_key = 0;\n\t\t\tn_proto_mask = 0;\n\t\t}\n\t\tfilter->n_proto = n_proto_key & n_proto_mask;\n\t\tfilter->ip_proto = match.key->ip_proto;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\n\t\t/* use is_broadcast and is_zero to check for all 0xf or 0 */\n\t\tif (!is_zero_ether_addr(match.mask->dst)) {\n\t\t\tif (is_broadcast_ether_addr(match.mask->dst)) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_OMAC;\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad ether dest mask %pM\\n\",\n\t\t\t\t\tmatch.mask->dst);\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\n\t\tif (!is_zero_ether_addr(match.mask->src)) {\n\t\t\tif (is_broadcast_ether_addr(match.mask->src)) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_IMAC;\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad ether src mask %pM\\n\",\n\t\t\t\t\tmatch.mask->src);\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\t\tether_addr_copy(filter->dst_mac, match.key->dst);\n\t\tether_addr_copy(filter->src_mac, match.key->src);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tif (match.mask->vlan_id) {\n\t\t\tif (match.mask->vlan_id == VLAN_VID_MASK) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_IVLAN;\n\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad vlan mask 0x%04x\\n\",\n\t\t\t\t\tmatch.mask->vlan_id);\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\n\t\tfilter->vlan_id = cpu_to_be16(match.key->vlan_id);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_CONTROL)) {\n\t\tstruct flow_match_control match;\n\n\t\tflow_rule_match_control(rule, &match);\n\t\taddr_type = match.key->addr_type;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {\n\t\tstruct flow_match_ipv4_addrs match;\n\n\t\tflow_rule_match_ipv4_addrs(rule, &match);\n\t\tif (match.mask->dst) {\n\t\t\tif (match.mask->dst == cpu_to_be32(0xffffffff)) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_IIP;\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad ip dst mask %pI4b\\n\",\n\t\t\t\t\t&match.mask->dst);\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\n\t\tif (match.mask->src) {\n\t\t\tif (match.mask->src == cpu_to_be32(0xffffffff)) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_IIP;\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad ip src mask %pI4b\\n\",\n\t\t\t\t\t&match.mask->src);\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\n\t\tif (field_flags & I40E_CLOUD_FIELD_TEN_ID) {\n\t\t\tdev_err(&pf->pdev->dev, \"Tenant id not allowed for ip filter\\n\");\n\t\t\treturn I40E_ERR_CONFIG;\n\t\t}\n\t\tfilter->dst_ipv4 = match.key->dst;\n\t\tfilter->src_ipv4 = match.key->src;\n\t}\n\n\tif (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {\n\t\tstruct flow_match_ipv6_addrs match;\n\n\t\tflow_rule_match_ipv6_addrs(rule, &match);\n\n\t\t/* src and dest IPV6 address should not be LOOPBACK\n\t\t * (0:0:0:0:0:0:0:1), which can be represented as ::1\n\t\t */\n\t\tif (ipv6_addr_loopback(&match.key->dst) ||\n\t\t    ipv6_addr_loopback(&match.key->src)) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Bad ipv6, addr is LOOPBACK\\n\");\n\t\t\treturn I40E_ERR_CONFIG;\n\t\t}\n\t\tif (!ipv6_addr_any(&match.mask->dst) ||\n\t\t    !ipv6_addr_any(&match.mask->src))\n\t\t\tfield_flags |= I40E_CLOUD_FIELD_IIP;\n\n\t\tmemcpy(&filter->src_ipv6, &match.key->src.s6_addr32,\n\t\t       sizeof(filter->src_ipv6));\n\t\tmemcpy(&filter->dst_ipv6, &match.key->dst.s6_addr32,\n\t\t       sizeof(filter->dst_ipv6));\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_PORTS)) {\n\t\tstruct flow_match_ports match;\n\n\t\tflow_rule_match_ports(rule, &match);\n\t\tif (match.mask->src) {\n\t\t\tif (match.mask->src == cpu_to_be16(0xffff)) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_IIP;\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad src port mask 0x%04x\\n\",\n\t\t\t\t\tbe16_to_cpu(match.mask->src));\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\n\t\tif (match.mask->dst) {\n\t\t\tif (match.mask->dst == cpu_to_be16(0xffff)) {\n\t\t\t\tfield_flags |= I40E_CLOUD_FIELD_IIP;\n\t\t\t} else {\n\t\t\t\tdev_err(&pf->pdev->dev, \"Bad dst port mask 0x%04x\\n\",\n\t\t\t\t\tbe16_to_cpu(match.mask->dst));\n\t\t\t\treturn I40E_ERR_CONFIG;\n\t\t\t}\n\t\t}\n\n\t\tfilter->dst_port = match.key->dst;\n\t\tfilter->src_port = match.key->src;\n\n\t\tswitch (filter->ip_proto) {\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_UDP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Only UDP and TCP transport are supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tfilter->flags = field_flags;\n\treturn 0;\n}\n\n/**\n * i40e_handle_tclass: Forward to a traffic class on the device\n * @vsi: Pointer to VSI\n * @tc: traffic class index on the device\n * @filter: Pointer to cloud filter structure\n *\n **/\nstatic int i40e_handle_tclass(struct i40e_vsi *vsi, u32 tc,\n\t\t\t      struct i40e_cloud_filter *filter)\n{\n\tstruct i40e_channel *ch, *ch_tmp;\n\n\t/* direct to a traffic class on the same device */\n\tif (tc == 0) {\n\t\tfilter->seid = vsi->seid;\n\t\treturn 0;\n\t} else if (vsi->tc_config.enabled_tc & BIT(tc)) {\n\t\tif (!filter->dst_port) {\n\t\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\t\"Specify destination port to direct to traffic class that is not default\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (list_empty(&vsi->ch_list))\n\t\t\treturn -EINVAL;\n\t\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->ch_list,\n\t\t\t\t\t list) {\n\t\t\tif (ch->seid == vsi->tc_seid_map[tc])\n\t\t\t\tfilter->seid = ch->seid;\n\t\t}\n\t\treturn 0;\n\t}\n\tdev_err(&vsi->back->pdev->dev, \"TC is not enabled\\n\");\n\treturn -EINVAL;\n}\n\n/**\n * i40e_configure_clsflower - Configure tc flower filters\n * @vsi: Pointer to VSI\n * @cls_flower: Pointer to struct flow_cls_offload\n *\n **/\nstatic int i40e_configure_clsflower(struct i40e_vsi *vsi,\n\t\t\t\t    struct flow_cls_offload *cls_flower)\n{\n\tint tc = tc_classid_to_hwtc(vsi->netdev, cls_flower->classid);\n\tstruct i40e_cloud_filter *filter = NULL;\n\tstruct i40e_pf *pf = vsi->back;\n\tint err = 0;\n\n\tif (tc < 0) {\n\t\tdev_err(&vsi->back->pdev->dev, \"Invalid traffic class\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t    test_bit(__I40E_RESET_INTR_RECEIVED, pf->state))\n\t\treturn -EBUSY;\n\n\tif (pf->fdir_pf_active_filters ||\n\t    (!hlist_empty(&pf->fdir_filter_list))) {\n\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\"Flow Director Sideband filters exists, turn ntuple off to configure cloud filters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vsi->back->flags & I40E_FLAG_FD_SB_ENABLED) {\n\t\tdev_err(&vsi->back->pdev->dev,\n\t\t\t\"Disable Flow Director Sideband, configuring Cloud filters via tc-flower\\n\");\n\t\tvsi->back->flags &= ~I40E_FLAG_FD_SB_ENABLED;\n\t\tvsi->back->flags |= I40E_FLAG_FD_SB_TO_CLOUD_FILTER;\n\t}\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (!filter)\n\t\treturn -ENOMEM;\n\n\tfilter->cookie = cls_flower->cookie;\n\n\terr = i40e_parse_cls_flower(vsi, cls_flower, filter);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = i40e_handle_tclass(vsi, tc, filter);\n\tif (err < 0)\n\t\tgoto err;\n\n\t/* Add cloud filter */\n\tif (filter->dst_port)\n\t\terr = i40e_add_del_cloud_filter_big_buf(vsi, filter, true);\n\telse\n\t\terr = i40e_add_del_cloud_filter(vsi, filter, true);\n\n\tif (err) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to add cloud filter, err %s\\n\",\n\t\t\ti40e_stat_str(&pf->hw, err));\n\t\tgoto err;\n\t}\n\n\t/* add filter to the ordered list */\n\tINIT_HLIST_NODE(&filter->cloud_node);\n\n\thlist_add_head(&filter->cloud_node, &pf->cloud_filter_list);\n\n\tpf->num_cloud_filters++;\n\n\treturn err;\nerr:\n\tkfree(filter);\n\treturn err;\n}\n\n/**\n * i40e_find_cloud_filter - Find the could filter in the list\n * @vsi: Pointer to VSI\n * @cookie: filter specific cookie\n *\n **/\nstatic struct i40e_cloud_filter *i40e_find_cloud_filter(struct i40e_vsi *vsi,\n\t\t\t\t\t\t\tunsigned long *cookie)\n{\n\tstruct i40e_cloud_filter *filter = NULL;\n\tstruct hlist_node *node2;\n\n\thlist_for_each_entry_safe(filter, node2,\n\t\t\t\t  &vsi->back->cloud_filter_list, cloud_node)\n\t\tif (!memcmp(cookie, &filter->cookie, sizeof(filter->cookie)))\n\t\t\treturn filter;\n\treturn NULL;\n}\n\n/**\n * i40e_delete_clsflower - Remove tc flower filters\n * @vsi: Pointer to VSI\n * @cls_flower: Pointer to struct flow_cls_offload\n *\n **/\nstatic int i40e_delete_clsflower(struct i40e_vsi *vsi,\n\t\t\t\t struct flow_cls_offload *cls_flower)\n{\n\tstruct i40e_cloud_filter *filter = NULL;\n\tstruct i40e_pf *pf = vsi->back;\n\tint err = 0;\n\n\tfilter = i40e_find_cloud_filter(vsi, &cls_flower->cookie);\n\n\tif (!filter)\n\t\treturn -EINVAL;\n\n\thash_del(&filter->cloud_node);\n\n\tif (filter->dst_port)\n\t\terr = i40e_add_del_cloud_filter_big_buf(vsi, filter, false);\n\telse\n\t\terr = i40e_add_del_cloud_filter(vsi, filter, false);\n\n\tkfree(filter);\n\tif (err) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to delete cloud filter, err %s\\n\",\n\t\t\ti40e_stat_str(&pf->hw, err));\n\t\treturn i40e_aq_rc_to_posix(err, pf->hw.aq.asq_last_status);\n\t}\n\n\tpf->num_cloud_filters--;\n\tif (!pf->num_cloud_filters)\n\t\tif ((pf->flags & I40E_FLAG_FD_SB_TO_CLOUD_FILTER) &&\n\t\t    !(pf->flags & I40E_FLAG_FD_SB_INACTIVE)) {\n\t\t\tpf->flags |= I40E_FLAG_FD_SB_ENABLED;\n\t\t\tpf->flags &= ~I40E_FLAG_FD_SB_TO_CLOUD_FILTER;\n\t\t\tpf->flags &= ~I40E_FLAG_FD_SB_INACTIVE;\n\t\t}\n\treturn 0;\n}\n\n/**\n * i40e_setup_tc_cls_flower - flower classifier offloads\n * @np: net device to configure\n * @cls_flower: offload data\n **/\nstatic int i40e_setup_tc_cls_flower(struct i40e_netdev_priv *np,\n\t\t\t\t    struct flow_cls_offload *cls_flower)\n{\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\tswitch (cls_flower->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\treturn i40e_configure_clsflower(vsi, cls_flower);\n\tcase FLOW_CLS_DESTROY:\n\t\treturn i40e_delete_clsflower(vsi, cls_flower);\n\tcase FLOW_CLS_STATS:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int i40e_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t\t  void *cb_priv)\n{\n\tstruct i40e_netdev_priv *np = cb_priv;\n\n\tif (!tc_cls_can_offload_and_chain0(np->vsi->netdev, type_data))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase TC_SETUP_CLSFLOWER:\n\t\treturn i40e_setup_tc_cls_flower(np, type_data);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic LIST_HEAD(i40e_block_cb_list);\n\nstatic int __i40e_setup_tc(struct net_device *netdev, enum tc_setup_type type,\n\t\t\t   void *type_data)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn i40e_setup_tc(netdev, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &i40e_block_cb_list,\n\t\t\t\t\t\t  i40e_setup_tc_block_cb,\n\t\t\t\t\t\t  np, np, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n/**\n * i40e_open - Called when a network interface is made active\n * @netdev: network interface device structure\n *\n * The open entry point is called when a network interface is made\n * active by the system (IFF_UP).  At this point all resources needed\n * for transmit and receive operations are allocated, the interrupt\n * handler is registered with the OS, the netdev watchdog subtask is\n * enabled, and the stack is notified that the interface is ready.\n *\n * Returns 0 on success, negative value on failure\n **/\nint i40e_open(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tint err;\n\n\t/* disallow open during test or if eeprom is broken */\n\tif (test_bit(__I40E_TESTING, pf->state) ||\n\t    test_bit(__I40E_BAD_EEPROM, pf->state))\n\t\treturn -EBUSY;\n\n\tnetif_carrier_off(netdev);\n\n\tif (i40e_force_link_state(pf, true))\n\t\treturn -EAGAIN;\n\n\terr = i40e_vsi_open(vsi);\n\tif (err)\n\t\treturn err;\n\n\t/* configure global TSO hardware offload settings */\n\twr32(&pf->hw, I40E_GLLAN_TSOMSK_F, be32_to_cpu(TCP_FLAG_PSH |\n\t\t\t\t\t\t       TCP_FLAG_FIN) >> 16);\n\twr32(&pf->hw, I40E_GLLAN_TSOMSK_M, be32_to_cpu(TCP_FLAG_PSH |\n\t\t\t\t\t\t       TCP_FLAG_FIN |\n\t\t\t\t\t\t       TCP_FLAG_CWR) >> 16);\n\twr32(&pf->hw, I40E_GLLAN_TSOMSK_L, be32_to_cpu(TCP_FLAG_CWR) >> 16);\n\n\tudp_tunnel_get_rx_info(netdev);\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_open -\n * @vsi: the VSI to open\n *\n * Finish initialization of the VSI.\n *\n * Returns 0 on success, negative value on failure\n *\n * Note: expects to be called while under rtnl_lock()\n **/\nint i40e_vsi_open(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tchar int_name[I40E_INT_NAME_STR_LEN];\n\tint err;\n\n\t/* allocate descriptors */\n\terr = i40e_vsi_setup_tx_resources(vsi);\n\tif (err)\n\t\tgoto err_setup_tx;\n\terr = i40e_vsi_setup_rx_resources(vsi);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\terr = i40e_vsi_configure(vsi);\n\tif (err)\n\t\tgoto err_setup_rx;\n\n\tif (vsi->netdev) {\n\t\tsnprintf(int_name, sizeof(int_name) - 1, \"%s-%s\",\n\t\t\t dev_driver_string(&pf->pdev->dev), vsi->netdev->name);\n\t\terr = i40e_vsi_request_irq(vsi, int_name);\n\t\tif (err)\n\t\t\tgoto err_setup_rx;\n\n\t\t/* Notify the stack of the actual queue counts. */\n\t\terr = netif_set_real_num_tx_queues(vsi->netdev,\n\t\t\t\t\t\t   vsi->num_queue_pairs);\n\t\tif (err)\n\t\t\tgoto err_set_queues;\n\n\t\terr = netif_set_real_num_rx_queues(vsi->netdev,\n\t\t\t\t\t\t   vsi->num_queue_pairs);\n\t\tif (err)\n\t\t\tgoto err_set_queues;\n\n\t} else if (vsi->type == I40E_VSI_FDIR) {\n\t\tsnprintf(int_name, sizeof(int_name) - 1, \"%s-%s:fdir\",\n\t\t\t dev_driver_string(&pf->pdev->dev),\n\t\t\t dev_name(&pf->pdev->dev));\n\t\terr = i40e_vsi_request_irq(vsi, int_name);\n\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto err_setup_rx;\n\t}\n\n\terr = i40e_up_complete(vsi);\n\tif (err)\n\t\tgoto err_up_complete;\n\n\treturn 0;\n\nerr_up_complete:\n\ti40e_down(vsi);\nerr_set_queues:\n\ti40e_vsi_free_irq(vsi);\nerr_setup_rx:\n\ti40e_vsi_free_rx_resources(vsi);\nerr_setup_tx:\n\ti40e_vsi_free_tx_resources(vsi);\n\tif (vsi == pf->vsi[pf->lan_vsi])\n\t\ti40e_do_reset(pf, I40E_PF_RESET_FLAG, true);\n\n\treturn err;\n}\n\n/**\n * i40e_fdir_filter_exit - Cleans up the Flow Director accounting\n * @pf: Pointer to PF\n *\n * This function destroys the hlist where all the Flow Director\n * filters were saved.\n **/\nstatic void i40e_fdir_filter_exit(struct i40e_pf *pf)\n{\n\tstruct i40e_fdir_filter *filter;\n\tstruct i40e_flex_pit *pit_entry, *tmp;\n\tstruct hlist_node *node2;\n\n\thlist_for_each_entry_safe(filter, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\thlist_del(&filter->fdir_node);\n\t\tkfree(filter);\n\t}\n\n\tlist_for_each_entry_safe(pit_entry, tmp, &pf->l3_flex_pit_list, list) {\n\t\tlist_del(&pit_entry->list);\n\t\tkfree(pit_entry);\n\t}\n\tINIT_LIST_HEAD(&pf->l3_flex_pit_list);\n\n\tlist_for_each_entry_safe(pit_entry, tmp, &pf->l4_flex_pit_list, list) {\n\t\tlist_del(&pit_entry->list);\n\t\tkfree(pit_entry);\n\t}\n\tINIT_LIST_HEAD(&pf->l4_flex_pit_list);\n\n\tpf->fdir_pf_active_filters = 0;\n\tpf->fd_tcp4_filter_cnt = 0;\n\tpf->fd_udp4_filter_cnt = 0;\n\tpf->fd_sctp4_filter_cnt = 0;\n\tpf->fd_ip4_filter_cnt = 0;\n\n\t/* Reprogram the default input set for TCP/IPv4 */\n\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_NONF_IPV4_TCP,\n\t\t\t\tI40E_L3_SRC_MASK | I40E_L3_DST_MASK |\n\t\t\t\tI40E_L4_SRC_MASK | I40E_L4_DST_MASK);\n\n\t/* Reprogram the default input set for UDP/IPv4 */\n\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_NONF_IPV4_UDP,\n\t\t\t\tI40E_L3_SRC_MASK | I40E_L3_DST_MASK |\n\t\t\t\tI40E_L4_SRC_MASK | I40E_L4_DST_MASK);\n\n\t/* Reprogram the default input set for SCTP/IPv4 */\n\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_NONF_IPV4_SCTP,\n\t\t\t\tI40E_L3_SRC_MASK | I40E_L3_DST_MASK |\n\t\t\t\tI40E_L4_SRC_MASK | I40E_L4_DST_MASK);\n\n\t/* Reprogram the default input set for Other/IPv4 */\n\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_NONF_IPV4_OTHER,\n\t\t\t\tI40E_L3_SRC_MASK | I40E_L3_DST_MASK);\n\n\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_FRAG_IPV4,\n\t\t\t\tI40E_L3_SRC_MASK | I40E_L3_DST_MASK);\n}\n\n/**\n * i40e_cloud_filter_exit - Cleans up the cloud filters\n * @pf: Pointer to PF\n *\n * This function destroys the hlist where all the cloud filters\n * were saved.\n **/\nstatic void i40e_cloud_filter_exit(struct i40e_pf *pf)\n{\n\tstruct i40e_cloud_filter *cfilter;\n\tstruct hlist_node *node;\n\n\thlist_for_each_entry_safe(cfilter, node,\n\t\t\t\t  &pf->cloud_filter_list, cloud_node) {\n\t\thlist_del(&cfilter->cloud_node);\n\t\tkfree(cfilter);\n\t}\n\tpf->num_cloud_filters = 0;\n\n\tif ((pf->flags & I40E_FLAG_FD_SB_TO_CLOUD_FILTER) &&\n\t    !(pf->flags & I40E_FLAG_FD_SB_INACTIVE)) {\n\t\tpf->flags |= I40E_FLAG_FD_SB_ENABLED;\n\t\tpf->flags &= ~I40E_FLAG_FD_SB_TO_CLOUD_FILTER;\n\t\tpf->flags &= ~I40E_FLAG_FD_SB_INACTIVE;\n\t}\n}\n\n/**\n * i40e_close - Disables a network interface\n * @netdev: network interface device structure\n *\n * The close entry point is called when an interface is de-activated\n * by the OS.  The hardware is still under the driver's control, but\n * this netdev interface is disabled.\n *\n * Returns 0, this is not allowed to fail\n **/\nint i40e_close(struct net_device *netdev)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\ti40e_vsi_close(vsi);\n\n\treturn 0;\n}\n\n/**\n * i40e_do_reset - Start a PF or Core Reset sequence\n * @pf: board private structure\n * @reset_flags: which reset is requested\n * @lock_acquired: indicates whether or not the lock has been acquired\n * before this function was called.\n *\n * The essential difference in resets is that the PF Reset\n * doesn't clear the packet buffers, doesn't reset the PE\n * firmware, and doesn't bother the other PFs on the chip.\n **/\nvoid i40e_do_reset(struct i40e_pf *pf, u32 reset_flags, bool lock_acquired)\n{\n\tu32 val;\n\n\t/* do the biggest reset indicated */\n\tif (reset_flags & BIT_ULL(__I40E_GLOBAL_RESET_REQUESTED)) {\n\n\t\t/* Request a Global Reset\n\t\t *\n\t\t * This will start the chip's countdown to the actual full\n\t\t * chip reset event, and a warning interrupt to be sent\n\t\t * to all PFs, including the requestor.  Our handler\n\t\t * for the warning interrupt will deal with the shutdown\n\t\t * and recovery of the switch setup.\n\t\t */\n\t\tdev_dbg(&pf->pdev->dev, \"GlobalR requested\\n\");\n\t\tval = rd32(&pf->hw, I40E_GLGEN_RTRIG);\n\t\tval |= I40E_GLGEN_RTRIG_GLOBR_MASK;\n\t\twr32(&pf->hw, I40E_GLGEN_RTRIG, val);\n\n\t} else if (reset_flags & BIT_ULL(__I40E_CORE_RESET_REQUESTED)) {\n\n\t\t/* Request a Core Reset\n\t\t *\n\t\t * Same as Global Reset, except does *not* include the MAC/PHY\n\t\t */\n\t\tdev_dbg(&pf->pdev->dev, \"CoreR requested\\n\");\n\t\tval = rd32(&pf->hw, I40E_GLGEN_RTRIG);\n\t\tval |= I40E_GLGEN_RTRIG_CORER_MASK;\n\t\twr32(&pf->hw, I40E_GLGEN_RTRIG, val);\n\t\ti40e_flush(&pf->hw);\n\n\t} else if (reset_flags & I40E_PF_RESET_FLAG) {\n\n\t\t/* Request a PF Reset\n\t\t *\n\t\t * Resets only the PF-specific registers\n\t\t *\n\t\t * This goes directly to the tear-down and rebuild of\n\t\t * the switch, since we need to do all the recovery as\n\t\t * for the Core Reset.\n\t\t */\n\t\tdev_dbg(&pf->pdev->dev, \"PFR requested\\n\");\n\t\ti40e_handle_reset_warning(pf, lock_acquired);\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t pf->flags & I40E_FLAG_DISABLE_FW_LLDP ?\n\t\t\t \"FW LLDP is disabled\\n\" :\n\t\t\t \"FW LLDP is enabled\\n\");\n\n\t} else if (reset_flags & I40E_PF_RESET_AND_REBUILD_FLAG) {\n\t\t/* Request a PF Reset\n\t\t *\n\t\t * Resets PF and reinitializes PFs VSI.\n\t\t */\n\t\ti40e_prep_for_reset(pf, lock_acquired);\n\t\ti40e_reset_and_rebuild(pf, true, lock_acquired);\n\n\t} else if (reset_flags & BIT_ULL(__I40E_REINIT_REQUESTED)) {\n\t\tint v;\n\n\t\t/* Find the VSI(s) that requested a re-init */\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VSI reinit requested\\n\");\n\t\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\t\tstruct i40e_vsi *vsi = pf->vsi[v];\n\n\t\t\tif (vsi != NULL &&\n\t\t\t    test_and_clear_bit(__I40E_VSI_REINIT_REQUESTED,\n\t\t\t\t\t       vsi->state))\n\t\t\t\ti40e_vsi_reinit_locked(pf->vsi[v]);\n\t\t}\n\t} else if (reset_flags & BIT_ULL(__I40E_DOWN_REQUESTED)) {\n\t\tint v;\n\n\t\t/* Find the VSI(s) that needs to be brought down */\n\t\tdev_info(&pf->pdev->dev, \"VSI down requested\\n\");\n\t\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\t\tstruct i40e_vsi *vsi = pf->vsi[v];\n\n\t\t\tif (vsi != NULL &&\n\t\t\t    test_and_clear_bit(__I40E_VSI_DOWN_REQUESTED,\n\t\t\t\t\t       vsi->state)) {\n\t\t\t\tset_bit(__I40E_VSI_DOWN, vsi->state);\n\t\t\t\ti40e_down(vsi);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"bad reset request 0x%08x\\n\", reset_flags);\n\t}\n}\n\n#ifdef CONFIG_I40E_DCB\n/**\n * i40e_dcb_need_reconfig - Check if DCB needs reconfig\n * @pf: board private structure\n * @old_cfg: current DCB config\n * @new_cfg: new DCB config\n **/\nbool i40e_dcb_need_reconfig(struct i40e_pf *pf,\n\t\t\t    struct i40e_dcbx_config *old_cfg,\n\t\t\t    struct i40e_dcbx_config *new_cfg)\n{\n\tbool need_reconfig = false;\n\n\t/* Check if ETS configuration has changed */\n\tif (memcmp(&new_cfg->etscfg,\n\t\t   &old_cfg->etscfg,\n\t\t   sizeof(new_cfg->etscfg))) {\n\t\t/* If Priority Table has changed reconfig is needed */\n\t\tif (memcmp(&new_cfg->etscfg.prioritytable,\n\t\t\t   &old_cfg->etscfg.prioritytable,\n\t\t\t   sizeof(new_cfg->etscfg.prioritytable))) {\n\t\t\tneed_reconfig = true;\n\t\t\tdev_dbg(&pf->pdev->dev, \"ETS UP2TC changed.\\n\");\n\t\t}\n\n\t\tif (memcmp(&new_cfg->etscfg.tcbwtable,\n\t\t\t   &old_cfg->etscfg.tcbwtable,\n\t\t\t   sizeof(new_cfg->etscfg.tcbwtable)))\n\t\t\tdev_dbg(&pf->pdev->dev, \"ETS TC BW Table changed.\\n\");\n\n\t\tif (memcmp(&new_cfg->etscfg.tsatable,\n\t\t\t   &old_cfg->etscfg.tsatable,\n\t\t\t   sizeof(new_cfg->etscfg.tsatable)))\n\t\t\tdev_dbg(&pf->pdev->dev, \"ETS TSA Table changed.\\n\");\n\t}\n\n\t/* Check if PFC configuration has changed */\n\tif (memcmp(&new_cfg->pfc,\n\t\t   &old_cfg->pfc,\n\t\t   sizeof(new_cfg->pfc))) {\n\t\tneed_reconfig = true;\n\t\tdev_dbg(&pf->pdev->dev, \"PFC config change detected.\\n\");\n\t}\n\n\t/* Check if APP Table has changed */\n\tif (memcmp(&new_cfg->app,\n\t\t   &old_cfg->app,\n\t\t   sizeof(new_cfg->app))) {\n\t\tneed_reconfig = true;\n\t\tdev_dbg(&pf->pdev->dev, \"APP Table change detected.\\n\");\n\t}\n\n\tdev_dbg(&pf->pdev->dev, \"dcb need_reconfig=%d\\n\", need_reconfig);\n\treturn need_reconfig;\n}\n\n/**\n * i40e_handle_lldp_event - Handle LLDP Change MIB event\n * @pf: board private structure\n * @e: event info posted on ARQ\n **/\nstatic int i40e_handle_lldp_event(struct i40e_pf *pf,\n\t\t\t\t  struct i40e_arq_event_info *e)\n{\n\tstruct i40e_aqc_lldp_get_mib *mib =\n\t\t(struct i40e_aqc_lldp_get_mib *)&e->desc.params.raw;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_dcbx_config tmp_dcbx_cfg;\n\tbool need_reconfig = false;\n\tint ret = 0;\n\tu8 type;\n\n\t/* Not DCB capable or capability disabled */\n\tif (!(pf->flags & I40E_FLAG_DCB_CAPABLE))\n\t\treturn ret;\n\n\t/* Ignore if event is not for Nearest Bridge */\n\ttype = ((mib->type >> I40E_AQ_LLDP_BRIDGE_TYPE_SHIFT)\n\t\t& I40E_AQ_LLDP_BRIDGE_TYPE_MASK);\n\tdev_dbg(&pf->pdev->dev, \"LLDP event mib bridge type 0x%x\\n\", type);\n\tif (type != I40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE)\n\t\treturn ret;\n\n\t/* Check MIB Type and return if event for Remote MIB update */\n\ttype = mib->type & I40E_AQ_LLDP_MIB_TYPE_MASK;\n\tdev_dbg(&pf->pdev->dev,\n\t\t\"LLDP event mib type %s\\n\", type ? \"remote\" : \"local\");\n\tif (type == I40E_AQ_LLDP_MIB_REMOTE) {\n\t\t/* Update the remote cached instance and return */\n\t\tret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_REMOTE,\n\t\t\t\tI40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,\n\t\t\t\t&hw->remote_dcbx_config);\n\t\tgoto exit;\n\t}\n\n\t/* Store the old configuration */\n\ttmp_dcbx_cfg = hw->local_dcbx_config;\n\n\t/* Reset the old DCBx configuration data */\n\tmemset(&hw->local_dcbx_config, 0, sizeof(hw->local_dcbx_config));\n\t/* Get updated DCBX data from firmware */\n\tret = i40e_get_dcb_config(&pf->hw);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Failed querying DCB configuration data from firmware, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\tgoto exit;\n\t}\n\n\t/* No change detected in DCBX configs */\n\tif (!memcmp(&tmp_dcbx_cfg, &hw->local_dcbx_config,\n\t\t    sizeof(tmp_dcbx_cfg))) {\n\t\tdev_dbg(&pf->pdev->dev, \"No change detected in DCBX configuration.\\n\");\n\t\tgoto exit;\n\t}\n\n\tneed_reconfig = i40e_dcb_need_reconfig(pf, &tmp_dcbx_cfg,\n\t\t\t\t\t       &hw->local_dcbx_config);\n\n\ti40e_dcbnl_flush_apps(pf, &tmp_dcbx_cfg, &hw->local_dcbx_config);\n\n\tif (!need_reconfig)\n\t\tgoto exit;\n\n\t/* Enable DCB tagging only when more than one TC */\n\tif (i40e_dcb_get_num_tc(&hw->local_dcbx_config) > 1)\n\t\tpf->flags |= I40E_FLAG_DCB_ENABLED;\n\telse\n\t\tpf->flags &= ~I40E_FLAG_DCB_ENABLED;\n\n\tset_bit(__I40E_PORT_SUSPENDED, pf->state);\n\t/* Reconfiguration needed quiesce all VSIs */\n\ti40e_pf_quiesce_all_vsi(pf);\n\n\t/* Changes in configuration update VEB/VSI */\n\ti40e_dcb_reconfigure(pf);\n\n\tret = i40e_resume_port_tx(pf);\n\n\tclear_bit(__I40E_PORT_SUSPENDED, pf->state);\n\t/* In case of error no point in resuming VSIs */\n\tif (ret)\n\t\tgoto exit;\n\n\t/* Wait for the PF's queues to be disabled */\n\tret = i40e_pf_wait_queues_disabled(pf);\n\tif (ret) {\n\t\t/* Schedule PF reset to recover */\n\t\tset_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t\ti40e_service_event_schedule(pf);\n\t} else {\n\t\ti40e_pf_unquiesce_all_vsi(pf);\n\t\tset_bit(__I40E_CLIENT_SERVICE_REQUESTED, pf->state);\n\t\tset_bit(__I40E_CLIENT_L2_CHANGE, pf->state);\n\t}\n\nexit:\n\treturn ret;\n}\n#endif /* CONFIG_I40E_DCB */\n\n/**\n * i40e_do_reset_safe - Protected reset path for userland calls.\n * @pf: board private structure\n * @reset_flags: which reset is requested\n *\n **/\nvoid i40e_do_reset_safe(struct i40e_pf *pf, u32 reset_flags)\n{\n\trtnl_lock();\n\ti40e_do_reset(pf, reset_flags, true);\n\trtnl_unlock();\n}\n\n/**\n * i40e_handle_lan_overflow_event - Handler for LAN queue overflow event\n * @pf: board private structure\n * @e: event info posted on ARQ\n *\n * Handler for LAN Queue Overflow Event generated by the firmware for PF\n * and VF queues\n **/\nstatic void i40e_handle_lan_overflow_event(struct i40e_pf *pf,\n\t\t\t\t\t   struct i40e_arq_event_info *e)\n{\n\tstruct i40e_aqc_lan_overflow *data =\n\t\t(struct i40e_aqc_lan_overflow *)&e->desc.params.raw;\n\tu32 queue = le32_to_cpu(data->prtdcb_rupto);\n\tu32 qtx_ctl = le32_to_cpu(data->otx_ctl);\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vf *vf;\n\tu16 vf_id;\n\n\tdev_dbg(&pf->pdev->dev, \"overflow Rx Queue Number = %d QTX_CTL=0x%08x\\n\",\n\t\tqueue, qtx_ctl);\n\n\t/* Queue belongs to VF, find the VF and issue VF reset */\n\tif (((qtx_ctl & I40E_QTX_CTL_PFVF_Q_MASK)\n\t    >> I40E_QTX_CTL_PFVF_Q_SHIFT) == I40E_QTX_CTL_VF_QUEUE) {\n\t\tvf_id = (u16)((qtx_ctl & I40E_QTX_CTL_VFVM_INDX_MASK)\n\t\t\t >> I40E_QTX_CTL_VFVM_INDX_SHIFT);\n\t\tvf_id -= hw->func_caps.vf_base_id;\n\t\tvf = &pf->vf[vf_id];\n\t\ti40e_vc_notify_vf_reset(vf);\n\t\t/* Allow VF to process pending reset notification */\n\t\tmsleep(20);\n\t\ti40e_reset_vf(vf, false);\n\t}\n}\n\n/**\n * i40e_get_cur_guaranteed_fd_count - Get the consumed guaranteed FD filters\n * @pf: board private structure\n **/\nu32 i40e_get_cur_guaranteed_fd_count(struct i40e_pf *pf)\n{\n\tu32 val, fcnt_prog;\n\n\tval = rd32(&pf->hw, I40E_PFQF_FDSTAT);\n\tfcnt_prog = (val & I40E_PFQF_FDSTAT_GUARANT_CNT_MASK);\n\treturn fcnt_prog;\n}\n\n/**\n * i40e_get_current_fd_count - Get total FD filters programmed for this PF\n * @pf: board private structure\n **/\nu32 i40e_get_current_fd_count(struct i40e_pf *pf)\n{\n\tu32 val, fcnt_prog;\n\n\tval = rd32(&pf->hw, I40E_PFQF_FDSTAT);\n\tfcnt_prog = (val & I40E_PFQF_FDSTAT_GUARANT_CNT_MASK) +\n\t\t    ((val & I40E_PFQF_FDSTAT_BEST_CNT_MASK) >>\n\t\t      I40E_PFQF_FDSTAT_BEST_CNT_SHIFT);\n\treturn fcnt_prog;\n}\n\n/**\n * i40e_get_global_fd_count - Get total FD filters programmed on device\n * @pf: board private structure\n **/\nu32 i40e_get_global_fd_count(struct i40e_pf *pf)\n{\n\tu32 val, fcnt_prog;\n\n\tval = rd32(&pf->hw, I40E_GLQF_FDCNT_0);\n\tfcnt_prog = (val & I40E_GLQF_FDCNT_0_GUARANT_CNT_MASK) +\n\t\t    ((val & I40E_GLQF_FDCNT_0_BESTCNT_MASK) >>\n\t\t     I40E_GLQF_FDCNT_0_BESTCNT_SHIFT);\n\treturn fcnt_prog;\n}\n\n/**\n * i40e_reenable_fdir_sb - Restore FDir SB capability\n * @pf: board private structure\n **/\nstatic void i40e_reenable_fdir_sb(struct i40e_pf *pf)\n{\n\tif (test_and_clear_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state))\n\t\tif ((pf->flags & I40E_FLAG_FD_SB_ENABLED) &&\n\t\t    (I40E_DEBUG_FD & pf->hw.debug_mask))\n\t\t\tdev_info(&pf->pdev->dev, \"FD Sideband/ntuple is being enabled since we have space in the table now\\n\");\n}\n\n/**\n * i40e_reenable_fdir_atr - Restore FDir ATR capability\n * @pf: board private structure\n **/\nstatic void i40e_reenable_fdir_atr(struct i40e_pf *pf)\n{\n\tif (test_and_clear_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state)) {\n\t\t/* ATR uses the same filtering logic as SB rules. It only\n\t\t * functions properly if the input set mask is at the default\n\t\t * settings. It is safe to restore the default input set\n\t\t * because there are no active TCPv4 filter rules.\n\t\t */\n\t\ti40e_write_fd_input_set(pf, I40E_FILTER_PCTYPE_NONF_IPV4_TCP,\n\t\t\t\t\tI40E_L3_SRC_MASK | I40E_L3_DST_MASK |\n\t\t\t\t\tI40E_L4_SRC_MASK | I40E_L4_DST_MASK);\n\n\t\tif ((pf->flags & I40E_FLAG_FD_ATR_ENABLED) &&\n\t\t    (I40E_DEBUG_FD & pf->hw.debug_mask))\n\t\t\tdev_info(&pf->pdev->dev, \"ATR is being enabled since we have space in the table and there are no conflicting ntuple rules\\n\");\n\t}\n}\n\n/**\n * i40e_delete_invalid_filter - Delete an invalid FDIR filter\n * @pf: board private structure\n * @filter: FDir filter to remove\n */\nstatic void i40e_delete_invalid_filter(struct i40e_pf *pf,\n\t\t\t\t       struct i40e_fdir_filter *filter)\n{\n\t/* Update counters */\n\tpf->fdir_pf_active_filters--;\n\tpf->fd_inv = 0;\n\n\tswitch (filter->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tpf->fd_tcp4_filter_cnt--;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tpf->fd_udp4_filter_cnt--;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\t\tpf->fd_sctp4_filter_cnt--;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tswitch (filter->ip4_proto) {\n\t\tcase IPPROTO_TCP:\n\t\t\tpf->fd_tcp4_filter_cnt--;\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\tpf->fd_udp4_filter_cnt--;\n\t\t\tbreak;\n\t\tcase IPPROTO_SCTP:\n\t\t\tpf->fd_sctp4_filter_cnt--;\n\t\t\tbreak;\n\t\tcase IPPROTO_IP:\n\t\t\tpf->fd_ip4_filter_cnt--;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* Remove the filter from the list and free memory */\n\thlist_del(&filter->fdir_node);\n\tkfree(filter);\n}\n\n/**\n * i40e_fdir_check_and_reenable - Function to reenabe FD ATR or SB if disabled\n * @pf: board private structure\n **/\nvoid i40e_fdir_check_and_reenable(struct i40e_pf *pf)\n{\n\tstruct i40e_fdir_filter *filter;\n\tu32 fcnt_prog, fcnt_avail;\n\tstruct hlist_node *node;\n\n\tif (test_bit(__I40E_FD_FLUSH_REQUESTED, pf->state))\n\t\treturn;\n\n\t/* Check if we have enough room to re-enable FDir SB capability. */\n\tfcnt_prog = i40e_get_global_fd_count(pf);\n\tfcnt_avail = pf->fdir_pf_filter_count;\n\tif ((fcnt_prog < (fcnt_avail - I40E_FDIR_BUFFER_HEAD_ROOM)) ||\n\t    (pf->fd_add_err == 0) ||\n\t    (i40e_get_current_atr_cnt(pf) < pf->fd_atr_cnt))\n\t\ti40e_reenable_fdir_sb(pf);\n\n\t/* We should wait for even more space before re-enabling ATR.\n\t * Additionally, we cannot enable ATR as long as we still have TCP SB\n\t * rules active.\n\t */\n\tif ((fcnt_prog < (fcnt_avail - I40E_FDIR_BUFFER_HEAD_ROOM_FOR_ATR)) &&\n\t    (pf->fd_tcp4_filter_cnt == 0))\n\t\ti40e_reenable_fdir_atr(pf);\n\n\t/* if hw had a problem adding a filter, delete it */\n\tif (pf->fd_inv > 0) {\n\t\thlist_for_each_entry_safe(filter, node,\n\t\t\t\t\t  &pf->fdir_filter_list, fdir_node)\n\t\t\tif (filter->fd_id == pf->fd_inv)\n\t\t\t\ti40e_delete_invalid_filter(pf, filter);\n\t}\n}\n\n#define I40E_MIN_FD_FLUSH_INTERVAL 10\n#define I40E_MIN_FD_FLUSH_SB_ATR_UNSTABLE 30\n/**\n * i40e_fdir_flush_and_replay - Function to flush all FD filters and replay SB\n * @pf: board private structure\n **/\nstatic void i40e_fdir_flush_and_replay(struct i40e_pf *pf)\n{\n\tunsigned long min_flush_time;\n\tint flush_wait_retry = 50;\n\tbool disable_atr = false;\n\tint fd_room;\n\tint reg;\n\n\tif (!time_after(jiffies, pf->fd_flush_timestamp +\n\t\t\t\t (I40E_MIN_FD_FLUSH_INTERVAL * HZ)))\n\t\treturn;\n\n\t/* If the flush is happening too quick and we have mostly SB rules we\n\t * should not re-enable ATR for some time.\n\t */\n\tmin_flush_time = pf->fd_flush_timestamp +\n\t\t\t (I40E_MIN_FD_FLUSH_SB_ATR_UNSTABLE * HZ);\n\tfd_room = pf->fdir_pf_filter_count - pf->fdir_pf_active_filters;\n\n\tif (!(time_after(jiffies, min_flush_time)) &&\n\t    (fd_room < I40E_FDIR_BUFFER_HEAD_ROOM_FOR_ATR)) {\n\t\tif (I40E_DEBUG_FD & pf->hw.debug_mask)\n\t\t\tdev_info(&pf->pdev->dev, \"ATR disabled, not enough FD filter space.\\n\");\n\t\tdisable_atr = true;\n\t}\n\n\tpf->fd_flush_timestamp = jiffies;\n\tset_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state);\n\t/* flush all filters */\n\twr32(&pf->hw, I40E_PFQF_CTL_1,\n\t     I40E_PFQF_CTL_1_CLEARFDTABLE_MASK);\n\ti40e_flush(&pf->hw);\n\tpf->fd_flush_cnt++;\n\tpf->fd_add_err = 0;\n\tdo {\n\t\t/* Check FD flush status every 5-6msec */\n\t\tusleep_range(5000, 6000);\n\t\treg = rd32(&pf->hw, I40E_PFQF_CTL_1);\n\t\tif (!(reg & I40E_PFQF_CTL_1_CLEARFDTABLE_MASK))\n\t\t\tbreak;\n\t} while (flush_wait_retry--);\n\tif (reg & I40E_PFQF_CTL_1_CLEARFDTABLE_MASK) {\n\t\tdev_warn(&pf->pdev->dev, \"FD table did not flush, needs more time\\n\");\n\t} else {\n\t\t/* replay sideband filters */\n\t\ti40e_fdir_filter_restore(pf->vsi[pf->lan_vsi]);\n\t\tif (!disable_atr && !pf->fd_tcp4_filter_cnt)\n\t\t\tclear_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state);\n\t\tclear_bit(__I40E_FD_FLUSH_REQUESTED, pf->state);\n\t\tif (I40E_DEBUG_FD & pf->hw.debug_mask)\n\t\t\tdev_info(&pf->pdev->dev, \"FD Filter table flushed and FD-SB replayed.\\n\");\n\t}\n}\n\n/**\n * i40e_get_current_atr_count - Get the count of total FD ATR filters programmed\n * @pf: board private structure\n **/\nu32 i40e_get_current_atr_cnt(struct i40e_pf *pf)\n{\n\treturn i40e_get_current_fd_count(pf) - pf->fdir_pf_active_filters;\n}\n\n/**\n * i40e_fdir_reinit_subtask - Worker thread to reinit FDIR filter table\n * @pf: board private structure\n **/\nstatic void i40e_fdir_reinit_subtask(struct i40e_pf *pf)\n{\n\n\t/* if interface is down do nothing */\n\tif (test_bit(__I40E_DOWN, pf->state))\n\t\treturn;\n\n\tif (test_bit(__I40E_FD_FLUSH_REQUESTED, pf->state))\n\t\ti40e_fdir_flush_and_replay(pf);\n\n\ti40e_fdir_check_and_reenable(pf);\n\n}\n\n/**\n * i40e_vsi_link_event - notify VSI of a link event\n * @vsi: vsi to be notified\n * @link_up: link up or down\n **/\nstatic void i40e_vsi_link_event(struct i40e_vsi *vsi, bool link_up)\n{\n\tif (!vsi || test_bit(__I40E_VSI_DOWN, vsi->state))\n\t\treturn;\n\n\tswitch (vsi->type) {\n\tcase I40E_VSI_MAIN:\n\t\tif (!vsi->netdev || !vsi->netdev_registered)\n\t\t\tbreak;\n\n\t\tif (link_up) {\n\t\t\tnetif_carrier_on(vsi->netdev);\n\t\t\tnetif_tx_wake_all_queues(vsi->netdev);\n\t\t} else {\n\t\t\tnetif_carrier_off(vsi->netdev);\n\t\t\tnetif_tx_stop_all_queues(vsi->netdev);\n\t\t}\n\t\tbreak;\n\n\tcase I40E_VSI_SRIOV:\n\tcase I40E_VSI_VMDQ2:\n\tcase I40E_VSI_CTRL:\n\tcase I40E_VSI_IWARP:\n\tcase I40E_VSI_MIRROR:\n\tdefault:\n\t\t/* there is no notification for other VSIs */\n\t\tbreak;\n\t}\n}\n\n/**\n * i40e_veb_link_event - notify elements on the veb of a link event\n * @veb: veb to be notified\n * @link_up: link up or down\n **/\nstatic void i40e_veb_link_event(struct i40e_veb *veb, bool link_up)\n{\n\tstruct i40e_pf *pf;\n\tint i;\n\n\tif (!veb || !veb->pf)\n\t\treturn;\n\tpf = veb->pf;\n\n\t/* depth first... */\n\tfor (i = 0; i < I40E_MAX_VEB; i++)\n\t\tif (pf->veb[i] && (pf->veb[i]->uplink_seid == veb->seid))\n\t\t\ti40e_veb_link_event(pf->veb[i], link_up);\n\n\t/* ... now the local VSIs */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\tif (pf->vsi[i] && (pf->vsi[i]->uplink_seid == veb->seid))\n\t\t\ti40e_vsi_link_event(pf->vsi[i], link_up);\n}\n\n/**\n * i40e_link_event - Update netif_carrier status\n * @pf: board private structure\n **/\nstatic void i40e_link_event(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tu8 new_link_speed, old_link_speed;\n\ti40e_status status;\n\tbool new_link, old_link;\n\n\t/* set this to force the get_link_status call to refresh state */\n\tpf->hw.phy.get_link_info = true;\n\told_link = (pf->hw.phy.link_info_old.link_info & I40E_AQ_LINK_UP);\n\tstatus = i40e_get_link_status(&pf->hw, &new_link);\n\n\t/* On success, disable temp link polling */\n\tif (status == I40E_SUCCESS) {\n\t\tclear_bit(__I40E_TEMP_LINK_POLLING, pf->state);\n\t} else {\n\t\t/* Enable link polling temporarily until i40e_get_link_status\n\t\t * returns I40E_SUCCESS\n\t\t */\n\t\tset_bit(__I40E_TEMP_LINK_POLLING, pf->state);\n\t\tdev_dbg(&pf->pdev->dev, \"couldn't get link state, status: %d\\n\",\n\t\t\tstatus);\n\t\treturn;\n\t}\n\n\told_link_speed = pf->hw.phy.link_info_old.link_speed;\n\tnew_link_speed = pf->hw.phy.link_info.link_speed;\n\n\tif (new_link == old_link &&\n\t    new_link_speed == old_link_speed &&\n\t    (test_bit(__I40E_VSI_DOWN, vsi->state) ||\n\t     new_link == netif_carrier_ok(vsi->netdev)))\n\t\treturn;\n\n\ti40e_print_link_message(vsi, new_link);\n\n\t/* Notify the base of the switch tree connected to\n\t * the link.  Floating VEBs are not notified.\n\t */\n\tif (pf->lan_veb < I40E_MAX_VEB && pf->veb[pf->lan_veb])\n\t\ti40e_veb_link_event(pf->veb[pf->lan_veb], new_link);\n\telse\n\t\ti40e_vsi_link_event(vsi, new_link);\n\n\tif (pf->vf)\n\t\ti40e_vc_notify_link_state(pf);\n\n\tif (pf->flags & I40E_FLAG_PTP)\n\t\ti40e_ptp_set_increment(pf);\n}\n\n/**\n * i40e_watchdog_subtask - periodic checks not using event driven response\n * @pf: board private structure\n **/\nstatic void i40e_watchdog_subtask(struct i40e_pf *pf)\n{\n\tint i;\n\n\t/* if interface is down do nothing */\n\tif (test_bit(__I40E_DOWN, pf->state) ||\n\t    test_bit(__I40E_CONFIG_BUSY, pf->state))\n\t\treturn;\n\n\t/* make sure we don't do these things too often */\n\tif (time_before(jiffies, (pf->service_timer_previous +\n\t\t\t\t  pf->service_timer_period)))\n\t\treturn;\n\tpf->service_timer_previous = jiffies;\n\n\tif ((pf->flags & I40E_FLAG_LINK_POLLING_ENABLED) ||\n\t    test_bit(__I40E_TEMP_LINK_POLLING, pf->state))\n\t\ti40e_link_event(pf);\n\n\t/* Update the stats for active netdevs so the network stack\n\t * can look at updated numbers whenever it cares to\n\t */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++)\n\t\tif (pf->vsi[i] && pf->vsi[i]->netdev)\n\t\t\ti40e_update_stats(pf->vsi[i]);\n\n\tif (pf->flags & I40E_FLAG_VEB_STATS_ENABLED) {\n\t\t/* Update the stats for the active switching components */\n\t\tfor (i = 0; i < I40E_MAX_VEB; i++)\n\t\t\tif (pf->veb[i])\n\t\t\t\ti40e_update_veb_stats(pf->veb[i]);\n\t}\n\n\ti40e_ptp_rx_hang(pf);\n\ti40e_ptp_tx_hang(pf);\n}\n\n/**\n * i40e_reset_subtask - Set up for resetting the device and driver\n * @pf: board private structure\n **/\nstatic void i40e_reset_subtask(struct i40e_pf *pf)\n{\n\tu32 reset_flags = 0;\n\n\tif (test_bit(__I40E_REINIT_REQUESTED, pf->state)) {\n\t\treset_flags |= BIT(__I40E_REINIT_REQUESTED);\n\t\tclear_bit(__I40E_REINIT_REQUESTED, pf->state);\n\t}\n\tif (test_bit(__I40E_PF_RESET_REQUESTED, pf->state)) {\n\t\treset_flags |= BIT(__I40E_PF_RESET_REQUESTED);\n\t\tclear_bit(__I40E_PF_RESET_REQUESTED, pf->state);\n\t}\n\tif (test_bit(__I40E_CORE_RESET_REQUESTED, pf->state)) {\n\t\treset_flags |= BIT(__I40E_CORE_RESET_REQUESTED);\n\t\tclear_bit(__I40E_CORE_RESET_REQUESTED, pf->state);\n\t}\n\tif (test_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state)) {\n\t\treset_flags |= BIT(__I40E_GLOBAL_RESET_REQUESTED);\n\t\tclear_bit(__I40E_GLOBAL_RESET_REQUESTED, pf->state);\n\t}\n\tif (test_bit(__I40E_DOWN_REQUESTED, pf->state)) {\n\t\treset_flags |= BIT(__I40E_DOWN_REQUESTED);\n\t\tclear_bit(__I40E_DOWN_REQUESTED, pf->state);\n\t}\n\n\t/* If there's a recovery already waiting, it takes\n\t * precedence before starting a new reset sequence.\n\t */\n\tif (test_bit(__I40E_RESET_INTR_RECEIVED, pf->state)) {\n\t\ti40e_prep_for_reset(pf, false);\n\t\ti40e_reset(pf);\n\t\ti40e_rebuild(pf, false, false);\n\t}\n\n\t/* If we're already down or resetting, just bail */\n\tif (reset_flags &&\n\t    !test_bit(__I40E_DOWN, pf->state) &&\n\t    !test_bit(__I40E_CONFIG_BUSY, pf->state)) {\n\t\ti40e_do_reset(pf, reset_flags, false);\n\t}\n}\n\n/**\n * i40e_handle_link_event - Handle link event\n * @pf: board private structure\n * @e: event info posted on ARQ\n **/\nstatic void i40e_handle_link_event(struct i40e_pf *pf,\n\t\t\t\t   struct i40e_arq_event_info *e)\n{\n\tstruct i40e_aqc_get_link_status *status =\n\t\t(struct i40e_aqc_get_link_status *)&e->desc.params.raw;\n\n\t/* Do a new status request to re-enable LSE reporting\n\t * and load new status information into the hw struct\n\t * This completely ignores any state information\n\t * in the ARQ event info, instead choosing to always\n\t * issue the AQ update link status command.\n\t */\n\ti40e_link_event(pf);\n\n\t/* Check if module meets thermal requirements */\n\tif (status->phy_type == I40E_PHY_TYPE_NOT_SUPPORTED_HIGH_TEMP) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Rx/Tx is disabled on this device because the module does not meet thermal requirements.\\n\");\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Refer to the Intel(R) Ethernet Adapters and Devices User Guide for a list of supported modules.\\n\");\n\t} else {\n\t\t/* check for unqualified module, if link is down, suppress\n\t\t * the message if link was forced to be down.\n\t\t */\n\t\tif ((status->link_info & I40E_AQ_MEDIA_AVAILABLE) &&\n\t\t    (!(status->an_info & I40E_AQ_QUALIFIED_MODULE)) &&\n\t\t    (!(status->link_info & I40E_AQ_LINK_UP)) &&\n\t\t    (!(pf->flags & I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED))) {\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Rx/Tx is disabled on this device because an unsupported SFP module type was detected.\\n\");\n\t\t\tdev_err(&pf->pdev->dev,\n\t\t\t\t\"Refer to the Intel(R) Ethernet Adapters and Devices User Guide for a list of supported modules.\\n\");\n\t\t}\n\t}\n}\n\n/**\n * i40e_clean_adminq_subtask - Clean the AdminQ rings\n * @pf: board private structure\n **/\nstatic void i40e_clean_adminq_subtask(struct i40e_pf *pf)\n{\n\tstruct i40e_arq_event_info event;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 pending, i = 0;\n\ti40e_status ret;\n\tu16 opcode;\n\tu32 oldval;\n\tu32 val;\n\n\t/* Do not run clean AQ when PF reset fails */\n\tif (test_bit(__I40E_RESET_FAILED, pf->state))\n\t\treturn;\n\n\t/* check for error indications */\n\tval = rd32(&pf->hw, pf->hw.aq.arq.len);\n\toldval = val;\n\tif (val & I40E_PF_ARQLEN_ARQVFE_MASK) {\n\t\tif (hw->debug_mask & I40E_DEBUG_AQ)\n\t\t\tdev_info(&pf->pdev->dev, \"ARQ VF Error detected\\n\");\n\t\tval &= ~I40E_PF_ARQLEN_ARQVFE_MASK;\n\t}\n\tif (val & I40E_PF_ARQLEN_ARQOVFL_MASK) {\n\t\tif (hw->debug_mask & I40E_DEBUG_AQ)\n\t\t\tdev_info(&pf->pdev->dev, \"ARQ Overflow Error detected\\n\");\n\t\tval &= ~I40E_PF_ARQLEN_ARQOVFL_MASK;\n\t\tpf->arq_overflows++;\n\t}\n\tif (val & I40E_PF_ARQLEN_ARQCRIT_MASK) {\n\t\tif (hw->debug_mask & I40E_DEBUG_AQ)\n\t\t\tdev_info(&pf->pdev->dev, \"ARQ Critical Error detected\\n\");\n\t\tval &= ~I40E_PF_ARQLEN_ARQCRIT_MASK;\n\t}\n\tif (oldval != val)\n\t\twr32(&pf->hw, pf->hw.aq.arq.len, val);\n\n\tval = rd32(&pf->hw, pf->hw.aq.asq.len);\n\toldval = val;\n\tif (val & I40E_PF_ATQLEN_ATQVFE_MASK) {\n\t\tif (pf->hw.debug_mask & I40E_DEBUG_AQ)\n\t\t\tdev_info(&pf->pdev->dev, \"ASQ VF Error detected\\n\");\n\t\tval &= ~I40E_PF_ATQLEN_ATQVFE_MASK;\n\t}\n\tif (val & I40E_PF_ATQLEN_ATQOVFL_MASK) {\n\t\tif (pf->hw.debug_mask & I40E_DEBUG_AQ)\n\t\t\tdev_info(&pf->pdev->dev, \"ASQ Overflow Error detected\\n\");\n\t\tval &= ~I40E_PF_ATQLEN_ATQOVFL_MASK;\n\t}\n\tif (val & I40E_PF_ATQLEN_ATQCRIT_MASK) {\n\t\tif (pf->hw.debug_mask & I40E_DEBUG_AQ)\n\t\t\tdev_info(&pf->pdev->dev, \"ASQ Critical Error detected\\n\");\n\t\tval &= ~I40E_PF_ATQLEN_ATQCRIT_MASK;\n\t}\n\tif (oldval != val)\n\t\twr32(&pf->hw, pf->hw.aq.asq.len, val);\n\n\tevent.buf_len = I40E_MAX_AQ_BUF_SIZE;\n\tevent.msg_buf = kzalloc(event.buf_len, GFP_KERNEL);\n\tif (!event.msg_buf)\n\t\treturn;\n\n\tdo {\n\t\tret = i40e_clean_arq_element(hw, &event, &pending);\n\t\tif (ret == I40E_ERR_ADMIN_QUEUE_NO_WORK)\n\t\t\tbreak;\n\t\telse if (ret) {\n\t\t\tdev_info(&pf->pdev->dev, \"ARQ event error %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\topcode = le16_to_cpu(event.desc.opcode);\n\t\tswitch (opcode) {\n\n\t\tcase i40e_aqc_opc_get_link_status:\n\t\t\ti40e_handle_link_event(pf, &event);\n\t\t\tbreak;\n\t\tcase i40e_aqc_opc_send_msg_to_pf:\n\t\t\tret = i40e_vc_process_vf_msg(pf,\n\t\t\t\t\tle16_to_cpu(event.desc.retval),\n\t\t\t\t\tle32_to_cpu(event.desc.cookie_high),\n\t\t\t\t\tle32_to_cpu(event.desc.cookie_low),\n\t\t\t\t\tevent.msg_buf,\n\t\t\t\t\tevent.msg_len);\n\t\t\tbreak;\n\t\tcase i40e_aqc_opc_lldp_update_mib:\n\t\t\tdev_dbg(&pf->pdev->dev, \"ARQ: Update LLDP MIB event received\\n\");\n#ifdef CONFIG_I40E_DCB\n\t\t\trtnl_lock();\n\t\t\tret = i40e_handle_lldp_event(pf, &event);\n\t\t\trtnl_unlock();\n#endif /* CONFIG_I40E_DCB */\n\t\t\tbreak;\n\t\tcase i40e_aqc_opc_event_lan_overflow:\n\t\t\tdev_dbg(&pf->pdev->dev, \"ARQ LAN queue overflow event received\\n\");\n\t\t\ti40e_handle_lan_overflow_event(pf, &event);\n\t\t\tbreak;\n\t\tcase i40e_aqc_opc_send_msg_to_peer:\n\t\t\tdev_info(&pf->pdev->dev, \"ARQ: Msg from other pf\\n\");\n\t\t\tbreak;\n\t\tcase i40e_aqc_opc_nvm_erase:\n\t\tcase i40e_aqc_opc_nvm_update:\n\t\tcase i40e_aqc_opc_oem_post_update:\n\t\t\ti40e_debug(&pf->hw, I40E_DEBUG_NVM,\n\t\t\t\t   \"ARQ NVM operation 0x%04x completed\\n\",\n\t\t\t\t   opcode);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"ARQ: Unknown event 0x%04x ignored\\n\",\n\t\t\t\t opcode);\n\t\t\tbreak;\n\t\t}\n\t} while (i++ < pf->adminq_work_limit);\n\n\tif (i < pf->adminq_work_limit)\n\t\tclear_bit(__I40E_ADMINQ_EVENT_PENDING, pf->state);\n\n\t/* re-enable Admin queue interrupt cause */\n\tval = rd32(hw, I40E_PFINT_ICR0_ENA);\n\tval |=  I40E_PFINT_ICR0_ENA_ADMINQ_MASK;\n\twr32(hw, I40E_PFINT_ICR0_ENA, val);\n\ti40e_flush(hw);\n\n\tkfree(event.msg_buf);\n}\n\n/**\n * i40e_verify_eeprom - make sure eeprom is good to use\n * @pf: board private structure\n **/\nstatic void i40e_verify_eeprom(struct i40e_pf *pf)\n{\n\tint err;\n\n\terr = i40e_diag_eeprom_test(&pf->hw);\n\tif (err) {\n\t\t/* retry in case of garbage read */\n\t\terr = i40e_diag_eeprom_test(&pf->hw);\n\t\tif (err) {\n\t\t\tdev_info(&pf->pdev->dev, \"eeprom check failed (%d), Tx/Rx traffic disabled\\n\",\n\t\t\t\t err);\n\t\t\tset_bit(__I40E_BAD_EEPROM, pf->state);\n\t\t}\n\t}\n\n\tif (!err && test_bit(__I40E_BAD_EEPROM, pf->state)) {\n\t\tdev_info(&pf->pdev->dev, \"eeprom check passed, Tx/Rx traffic enabled\\n\");\n\t\tclear_bit(__I40E_BAD_EEPROM, pf->state);\n\t}\n}\n\n/**\n * i40e_enable_pf_switch_lb\n * @pf: pointer to the PF structure\n *\n * enable switch loop back or die - no point in a return value\n **/\nstatic void i40e_enable_pf_switch_lb(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tstruct i40e_vsi_context ctxt;\n\tint ret;\n\n\tctxt.seid = pf->main_vsi_seid;\n\tctxt.pf_num = pf->hw.pf_id;\n\tctxt.vf_num = 0;\n\tret = i40e_aq_get_vsi_params(&pf->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get PF vsi config, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn;\n\t}\n\tctxt.flags = I40E_AQ_VSI_TYPE_PF;\n\tctxt.info.valid_sections = cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\tctxt.info.switch_id |= cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\n\n\tret = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"update vsi switch failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t}\n}\n\n/**\n * i40e_disable_pf_switch_lb\n * @pf: pointer to the PF structure\n *\n * disable switch loop back or die - no point in a return value\n **/\nstatic void i40e_disable_pf_switch_lb(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tstruct i40e_vsi_context ctxt;\n\tint ret;\n\n\tctxt.seid = pf->main_vsi_seid;\n\tctxt.pf_num = pf->hw.pf_id;\n\tctxt.vf_num = 0;\n\tret = i40e_aq_get_vsi_params(&pf->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get PF vsi config, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn;\n\t}\n\tctxt.flags = I40E_AQ_VSI_TYPE_PF;\n\tctxt.info.valid_sections = cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\tctxt.info.switch_id &= ~cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\n\n\tret = i40e_aq_update_vsi_params(&vsi->back->hw, &ctxt, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"update vsi switch failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t}\n}\n\n/**\n * i40e_config_bridge_mode - Configure the HW bridge mode\n * @veb: pointer to the bridge instance\n *\n * Configure the loop back mode for the LAN VSI that is downlink to the\n * specified HW bridge instance. It is expected this function is called\n * when a new HW bridge is instantiated.\n **/\nstatic void i40e_config_bridge_mode(struct i40e_veb *veb)\n{\n\tstruct i40e_pf *pf = veb->pf;\n\n\tif (pf->hw.debug_mask & I40E_DEBUG_LAN)\n\t\tdev_info(&pf->pdev->dev, \"enabling bridge mode: %s\\n\",\n\t\t\t veb->bridge_mode == BRIDGE_MODE_VEPA ? \"VEPA\" : \"VEB\");\n\tif (veb->bridge_mode & BRIDGE_MODE_VEPA)\n\t\ti40e_disable_pf_switch_lb(pf);\n\telse\n\t\ti40e_enable_pf_switch_lb(pf);\n}\n\n/**\n * i40e_reconstitute_veb - rebuild the VEB and anything connected to it\n * @veb: pointer to the VEB instance\n *\n * This is a recursive function that first builds the attached VSIs then\n * recurses in to build the next layer of VEB.  We track the connections\n * through our own index numbers because the seid's from the HW could\n * change across the reset.\n **/\nstatic int i40e_reconstitute_veb(struct i40e_veb *veb)\n{\n\tstruct i40e_vsi *ctl_vsi = NULL;\n\tstruct i40e_pf *pf = veb->pf;\n\tint v, veb_idx;\n\tint ret;\n\n\t/* build VSI that owns this VEB, temporarily attached to base VEB */\n\tfor (v = 0; v < pf->num_alloc_vsi && !ctl_vsi; v++) {\n\t\tif (pf->vsi[v] &&\n\t\t    pf->vsi[v]->veb_idx == veb->idx &&\n\t\t    pf->vsi[v]->flags & I40E_VSI_FLAG_VEB_OWNER) {\n\t\t\tctl_vsi = pf->vsi[v];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ctl_vsi) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"missing owner VSI for veb_idx %d\\n\", veb->idx);\n\t\tret = -ENOENT;\n\t\tgoto end_reconstitute;\n\t}\n\tif (ctl_vsi != pf->vsi[pf->lan_vsi])\n\t\tctl_vsi->uplink_seid = pf->vsi[pf->lan_vsi]->uplink_seid;\n\tret = i40e_add_vsi(ctl_vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"rebuild of veb_idx %d owner VSI failed: %d\\n\",\n\t\t\t veb->idx, ret);\n\t\tgoto end_reconstitute;\n\t}\n\ti40e_vsi_reset_stats(ctl_vsi);\n\n\t/* create the VEB in the switch and move the VSI onto the VEB */\n\tret = i40e_add_veb(veb, ctl_vsi);\n\tif (ret)\n\t\tgoto end_reconstitute;\n\n\tif (pf->flags & I40E_FLAG_VEB_MODE_ENABLED)\n\t\tveb->bridge_mode = BRIDGE_MODE_VEB;\n\telse\n\t\tveb->bridge_mode = BRIDGE_MODE_VEPA;\n\ti40e_config_bridge_mode(veb);\n\n\t/* create the remaining VSIs attached to this VEB */\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (!pf->vsi[v] || pf->vsi[v] == ctl_vsi)\n\t\t\tcontinue;\n\n\t\tif (pf->vsi[v]->veb_idx == veb->idx) {\n\t\t\tstruct i40e_vsi *vsi = pf->vsi[v];\n\n\t\t\tvsi->uplink_seid = veb->seid;\n\t\t\tret = i40e_add_vsi(vsi);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"rebuild of vsi_idx %d failed: %d\\n\",\n\t\t\t\t\t v, ret);\n\t\t\t\tgoto end_reconstitute;\n\t\t\t}\n\t\t\ti40e_vsi_reset_stats(vsi);\n\t\t}\n\t}\n\n\t/* create any VEBs attached to this VEB - RECURSION */\n\tfor (veb_idx = 0; veb_idx < I40E_MAX_VEB; veb_idx++) {\n\t\tif (pf->veb[veb_idx] && pf->veb[veb_idx]->veb_idx == veb->idx) {\n\t\t\tpf->veb[veb_idx]->uplink_seid = veb->seid;\n\t\t\tret = i40e_reconstitute_veb(pf->veb[veb_idx]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nend_reconstitute:\n\treturn ret;\n}\n\n/**\n * i40e_get_capabilities - get info about the HW\n * @pf: the PF struct\n * @list_type: AQ capability to be queried\n **/\nstatic int i40e_get_capabilities(struct i40e_pf *pf,\n\t\t\t\t enum i40e_admin_queue_opc list_type)\n{\n\tstruct i40e_aqc_list_capabilities_element_resp *cap_buf;\n\tu16 data_size;\n\tint buf_len;\n\tint err;\n\n\tbuf_len = 40 * sizeof(struct i40e_aqc_list_capabilities_element_resp);\n\tdo {\n\t\tcap_buf = kzalloc(buf_len, GFP_KERNEL);\n\t\tif (!cap_buf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* this loads the data into the hw struct for us */\n\t\terr = i40e_aq_discover_capabilities(&pf->hw, cap_buf, buf_len,\n\t\t\t\t\t\t    &data_size, list_type,\n\t\t\t\t\t\t    NULL);\n\t\t/* data loaded, buffer no longer needed */\n\t\tkfree(cap_buf);\n\n\t\tif (pf->hw.aq.asq_last_status == I40E_AQ_RC_ENOMEM) {\n\t\t\t/* retry with a larger buffer */\n\t\t\tbuf_len = data_size;\n\t\t} else if (pf->hw.aq.asq_last_status != I40E_AQ_RC_OK) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"capability discovery failed, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, err),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\treturn -ENODEV;\n\t\t}\n\t} while (err);\n\n\tif (pf->hw.debug_mask & I40E_DEBUG_USER) {\n\t\tif (list_type == i40e_aqc_opc_list_func_capabilities) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"pf=%d, num_vfs=%d, msix_pf=%d, msix_vf=%d, fd_g=%d, fd_b=%d, pf_max_q=%d num_vsi=%d\\n\",\n\t\t\t\t pf->hw.pf_id, pf->hw.func_caps.num_vfs,\n\t\t\t\t pf->hw.func_caps.num_msix_vectors,\n\t\t\t\t pf->hw.func_caps.num_msix_vectors_vf,\n\t\t\t\t pf->hw.func_caps.fd_filters_guaranteed,\n\t\t\t\t pf->hw.func_caps.fd_filters_best_effort,\n\t\t\t\t pf->hw.func_caps.num_tx_qp,\n\t\t\t\t pf->hw.func_caps.num_vsis);\n\t\t} else if (list_type == i40e_aqc_opc_list_dev_capabilities) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"switch_mode=0x%04x, function_valid=0x%08x\\n\",\n\t\t\t\t pf->hw.dev_caps.switch_mode,\n\t\t\t\t pf->hw.dev_caps.valid_functions);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"SR-IOV=%d, num_vfs for all function=%u\\n\",\n\t\t\t\t pf->hw.dev_caps.sr_iov_1_1,\n\t\t\t\t pf->hw.dev_caps.num_vfs);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"num_vsis=%u, num_rx:%u, num_tx=%u\\n\",\n\t\t\t\t pf->hw.dev_caps.num_vsis,\n\t\t\t\t pf->hw.dev_caps.num_rx_qp,\n\t\t\t\t pf->hw.dev_caps.num_tx_qp);\n\t\t}\n\t}\n\tif (list_type == i40e_aqc_opc_list_func_capabilities) {\n#define DEF_NUM_VSI (1 + (pf->hw.func_caps.fcoe ? 1 : 0) \\\n\t\t       + pf->hw.func_caps.num_vfs)\n\t\tif (pf->hw.revision_id == 0 &&\n\t\t    pf->hw.func_caps.num_vsis < DEF_NUM_VSI) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"got num_vsis %d, setting num_vsis to %d\\n\",\n\t\t\t\t pf->hw.func_caps.num_vsis, DEF_NUM_VSI);\n\t\t\tpf->hw.func_caps.num_vsis = DEF_NUM_VSI;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int i40e_vsi_clear(struct i40e_vsi *vsi);\n\n/**\n * i40e_fdir_sb_setup - initialize the Flow Director resources for Sideband\n * @pf: board private structure\n **/\nstatic void i40e_fdir_sb_setup(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi;\n\n\t/* quick workaround for an NVM issue that leaves a critical register\n\t * uninitialized\n\t */\n\tif (!rd32(&pf->hw, I40E_GLQF_HKEY(0))) {\n\t\tstatic const u32 hkey[] = {\n\t\t\t0xe640d33f, 0xcdfe98ab, 0x73fa7161, 0x0d7a7d36,\n\t\t\t0xeacb7d61, 0xaa4f05b6, 0x9c5c89ed, 0xfc425ddb,\n\t\t\t0xa4654832, 0xfc7461d4, 0x8f827619, 0xf5c63c21,\n\t\t\t0x95b3a76d};\n\t\tint i;\n\n\t\tfor (i = 0; i <= I40E_GLQF_HKEY_MAX_INDEX; i++)\n\t\t\twr32(&pf->hw, I40E_GLQF_HKEY(i), hkey[i]);\n\t}\n\n\tif (!(pf->flags & I40E_FLAG_FD_SB_ENABLED))\n\t\treturn;\n\n\t/* find existing VSI and see if it needs configuring */\n\tvsi = i40e_find_vsi_by_type(pf, I40E_VSI_FDIR);\n\n\t/* create a new VSI if none exists */\n\tif (!vsi) {\n\t\tvsi = i40e_vsi_setup(pf, I40E_VSI_FDIR,\n\t\t\t\t     pf->vsi[pf->lan_vsi]->seid, 0);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev, \"Couldn't create FDir VSI\\n\");\n\t\t\tpf->flags &= ~I40E_FLAG_FD_SB_ENABLED;\n\t\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\ti40e_vsi_setup_irqhandler(vsi, i40e_fdir_clean_ring);\n}\n\n/**\n * i40e_fdir_teardown - release the Flow Director resources\n * @pf: board private structure\n **/\nstatic void i40e_fdir_teardown(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi;\n\n\ti40e_fdir_filter_exit(pf);\n\tvsi = i40e_find_vsi_by_type(pf, I40E_VSI_FDIR);\n\tif (vsi)\n\t\ti40e_vsi_release(vsi);\n}\n\n/**\n * i40e_rebuild_cloud_filters - Rebuilds cloud filters for VSIs\n * @vsi: PF main vsi\n * @seid: seid of main or channel VSIs\n *\n * Rebuilds cloud filters associated with main VSI and channel VSIs if they\n * existed before reset\n **/\nstatic int i40e_rebuild_cloud_filters(struct i40e_vsi *vsi, u16 seid)\n{\n\tstruct i40e_cloud_filter *cfilter;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct hlist_node *node;\n\ti40e_status ret;\n\n\t/* Add cloud filters back if they exist */\n\thlist_for_each_entry_safe(cfilter, node, &pf->cloud_filter_list,\n\t\t\t\t  cloud_node) {\n\t\tif (cfilter->seid != seid)\n\t\t\tcontinue;\n\n\t\tif (cfilter->dst_port)\n\t\t\tret = i40e_add_del_cloud_filter_big_buf(vsi, cfilter,\n\t\t\t\t\t\t\t\ttrue);\n\t\telse\n\t\t\tret = i40e_add_del_cloud_filter(vsi, cfilter, true);\n\n\t\tif (ret) {\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"Failed to rebuild cloud filter, err %s aq_err %s\\n\",\n\t\t\t\ti40e_stat_str(&pf->hw, ret),\n\t\t\t\ti40e_aq_str(&pf->hw,\n\t\t\t\t\t    pf->hw.aq.asq_last_status));\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * i40e_rebuild_channels - Rebuilds channel VSIs if they existed before reset\n * @vsi: PF main vsi\n *\n * Rebuilds channel VSIs if they existed before reset\n **/\nstatic int i40e_rebuild_channels(struct i40e_vsi *vsi)\n{\n\tstruct i40e_channel *ch, *ch_tmp;\n\ti40e_status ret;\n\n\tif (list_empty(&vsi->ch_list))\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(ch, ch_tmp, &vsi->ch_list, list) {\n\t\tif (!ch->initialized)\n\t\t\tbreak;\n\t\t/* Proceed with creation of channel (VMDq2) VSI */\n\t\tret = i40e_add_channel(vsi->back, vsi->uplink_seid, ch);\n\t\tif (ret) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"failed to rebuild channels using uplink_seid %u\\n\",\n\t\t\t\t vsi->uplink_seid);\n\t\t\treturn ret;\n\t\t}\n\t\t/* Reconfigure TX queues using QTX_CTL register */\n\t\tret = i40e_channel_config_tx_ring(vsi->back, vsi, ch);\n\t\tif (ret) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"failed to configure TX rings for channel %u\\n\",\n\t\t\t\t ch->seid);\n\t\t\treturn ret;\n\t\t}\n\t\t/* update 'next_base_queue' */\n\t\tvsi->next_base_queue = vsi->next_base_queue +\n\t\t\t\t\t\t\tch->num_queue_pairs;\n\t\tif (ch->max_tx_rate) {\n\t\t\tu64 credits = ch->max_tx_rate;\n\n\t\t\tif (i40e_set_bw_limit(vsi, ch->seid,\n\t\t\t\t\t      ch->max_tx_rate))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdo_div(credits, I40E_BW_CREDIT_DIVISOR);\n\t\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\t\"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\\n\",\n\t\t\t\tch->max_tx_rate,\n\t\t\t\tcredits,\n\t\t\t\tch->seid);\n\t\t}\n\t\tret = i40e_rebuild_cloud_filters(vsi, ch->seid);\n\t\tif (ret) {\n\t\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\t\"Failed to rebuild cloud filters for channel VSI %u\\n\",\n\t\t\t\tch->seid);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * i40e_prep_for_reset - prep for the core to reset\n * @pf: board private structure\n * @lock_acquired: indicates whether or not the lock has been acquired\n * before this function was called.\n *\n * Close up the VFs and other things in prep for PF Reset.\n  **/\nstatic void i40e_prep_for_reset(struct i40e_pf *pf, bool lock_acquired)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret = 0;\n\tu32 v;\n\n\tclear_bit(__I40E_RESET_INTR_RECEIVED, pf->state);\n\tif (test_and_set_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))\n\t\treturn;\n\tif (i40e_check_asq_alive(&pf->hw))\n\t\ti40e_vc_notify_reset(pf);\n\n\tdev_dbg(&pf->pdev->dev, \"Tearing down internal switch for reset\\n\");\n\n\t/* quiesce the VSIs and their queues that are not already DOWN */\n\t/* pf_quiesce_all_vsi modifies netdev structures -rtnl_lock needed */\n\tif (!lock_acquired)\n\t\trtnl_lock();\n\ti40e_pf_quiesce_all_vsi(pf);\n\tif (!lock_acquired)\n\t\trtnl_unlock();\n\n\tfor (v = 0; v < pf->num_alloc_vsi; v++) {\n\t\tif (pf->vsi[v])\n\t\t\tpf->vsi[v]->seid = 0;\n\t}\n\n\ti40e_shutdown_adminq(&pf->hw);\n\n\t/* call shutdown HMC */\n\tif (hw->hmc.hmc_obj) {\n\t\tret = i40e_shutdown_lan_hmc(hw);\n\t\tif (ret)\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"shutdown_lan_hmc failed: %d\\n\", ret);\n\t}\n\n\t/* Save the current PTP time so that we can restore the time after the\n\t * reset completes.\n\t */\n\ti40e_ptp_save_hw_time(pf);\n}\n\n/**\n * i40e_send_version - update firmware with driver version\n * @pf: PF struct\n */\nstatic void i40e_send_version(struct i40e_pf *pf)\n{\n\tstruct i40e_driver_version dv;\n\n\tdv.major_version = 0xff;\n\tdv.minor_version = 0xff;\n\tdv.build_version = 0xff;\n\tdv.subbuild_version = 0;\n\tstrlcpy(dv.driver_string, UTS_RELEASE, sizeof(dv.driver_string));\n\ti40e_aq_send_driver_version(&pf->hw, &dv, NULL);\n}\n\n/**\n * i40e_get_oem_version - get OEM specific version information\n * @hw: pointer to the hardware structure\n **/\nstatic void i40e_get_oem_version(struct i40e_hw *hw)\n{\n\tu16 block_offset = 0xffff;\n\tu16 block_length = 0;\n\tu16 capabilities = 0;\n\tu16 gen_snap = 0;\n\tu16 release = 0;\n\n#define I40E_SR_NVM_OEM_VERSION_PTR\t\t0x1B\n#define I40E_NVM_OEM_LENGTH_OFFSET\t\t0x00\n#define I40E_NVM_OEM_CAPABILITIES_OFFSET\t0x01\n#define I40E_NVM_OEM_GEN_OFFSET\t\t\t0x02\n#define I40E_NVM_OEM_RELEASE_OFFSET\t\t0x03\n#define I40E_NVM_OEM_CAPABILITIES_MASK\t\t0x000F\n#define I40E_NVM_OEM_LENGTH\t\t\t3\n\n\t/* Check if pointer to OEM version block is valid. */\n\ti40e_read_nvm_word(hw, I40E_SR_NVM_OEM_VERSION_PTR, &block_offset);\n\tif (block_offset == 0xffff)\n\t\treturn;\n\n\t/* Check if OEM version block has correct length. */\n\ti40e_read_nvm_word(hw, block_offset + I40E_NVM_OEM_LENGTH_OFFSET,\n\t\t\t   &block_length);\n\tif (block_length < I40E_NVM_OEM_LENGTH)\n\t\treturn;\n\n\t/* Check if OEM version format is as expected. */\n\ti40e_read_nvm_word(hw, block_offset + I40E_NVM_OEM_CAPABILITIES_OFFSET,\n\t\t\t   &capabilities);\n\tif ((capabilities & I40E_NVM_OEM_CAPABILITIES_MASK) != 0)\n\t\treturn;\n\n\ti40e_read_nvm_word(hw, block_offset + I40E_NVM_OEM_GEN_OFFSET,\n\t\t\t   &gen_snap);\n\ti40e_read_nvm_word(hw, block_offset + I40E_NVM_OEM_RELEASE_OFFSET,\n\t\t\t   &release);\n\thw->nvm.oem_ver = (gen_snap << I40E_OEM_SNAP_SHIFT) | release;\n\thw->nvm.eetrack = I40E_OEM_EETRACK_ID;\n}\n\n/**\n * i40e_reset - wait for core reset to finish reset, reset pf if corer not seen\n * @pf: board private structure\n **/\nstatic int i40e_reset(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret;\n\n\tret = i40e_pf_reset(hw);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"PF reset failed, %d\\n\", ret);\n\t\tset_bit(__I40E_RESET_FAILED, pf->state);\n\t\tclear_bit(__I40E_RESET_RECOVERY_PENDING, pf->state);\n\t} else {\n\t\tpf->pfr_count++;\n\t}\n\treturn ret;\n}\n\n/**\n * i40e_rebuild - rebuild using a saved config\n * @pf: board private structure\n * @reinit: if the Main VSI needs to re-initialized.\n * @lock_acquired: indicates whether or not the lock has been acquired\n * before this function was called.\n **/\nstatic void i40e_rebuild(struct i40e_pf *pf, bool reinit, bool lock_acquired)\n{\n\tint old_recovery_mode_bit = test_bit(__I40E_RECOVERY_MODE, pf->state);\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tstruct i40e_hw *hw = &pf->hw;\n\tu8 set_fc_aq_fail = 0;\n\ti40e_status ret;\n\tu32 val;\n\tint v;\n\n\tif (test_bit(__I40E_EMP_RESET_INTR_RECEIVED, pf->state) &&\n\t    i40e_check_recovery_mode(pf)) {\n\t\ti40e_set_ethtool_ops(pf->vsi[pf->lan_vsi]->netdev);\n\t}\n\n\tif (test_bit(__I40E_DOWN, pf->state) &&\n\t    !test_bit(__I40E_RECOVERY_MODE, pf->state) &&\n\t    !old_recovery_mode_bit)\n\t\tgoto clear_recovery;\n\tdev_dbg(&pf->pdev->dev, \"Rebuilding internal switch\\n\");\n\n\t/* rebuild the basics for the AdminQ, HMC, and initial HW switch */\n\tret = i40e_init_adminq(&pf->hw);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"Rebuild AdminQ failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\tgoto clear_recovery;\n\t}\n\ti40e_get_oem_version(&pf->hw);\n\n\tif (test_bit(__I40E_EMP_RESET_INTR_RECEIVED, pf->state) &&\n\t    ((hw->aq.fw_maj_ver == 4 && hw->aq.fw_min_ver <= 33) ||\n\t     hw->aq.fw_maj_ver < 4) && hw->mac.type == I40E_MAC_XL710) {\n\t\t/* The following delay is necessary for 4.33 firmware and older\n\t\t * to recover after EMP reset. 200 ms should suffice but we\n\t\t * put here 300 ms to be sure that FW is ready to operate\n\t\t * after reset.\n\t\t */\n\t\tmdelay(300);\n\t}\n\n\t/* re-verify the eeprom if we just had an EMP reset */\n\tif (test_and_clear_bit(__I40E_EMP_RESET_INTR_RECEIVED, pf->state))\n\t\ti40e_verify_eeprom(pf);\n\n\t/* if we are going out of or into recovery mode we have to act\n\t * accordingly with regard to resources initialization\n\t * and deinitialization\n\t */\n\tif (test_bit(__I40E_RECOVERY_MODE, pf->state) ||\n\t    old_recovery_mode_bit) {\n\t\tif (i40e_get_capabilities(pf,\n\t\t\t\t\t  i40e_aqc_opc_list_func_capabilities))\n\t\t\tgoto end_unlock;\n\n\t\tif (test_bit(__I40E_RECOVERY_MODE, pf->state)) {\n\t\t\t/* we're staying in recovery mode so we'll reinitialize\n\t\t\t * misc vector here\n\t\t\t */\n\t\t\tif (i40e_setup_misc_vector_for_recovery_mode(pf))\n\t\t\t\tgoto end_unlock;\n\t\t} else {\n\t\t\tif (!lock_acquired)\n\t\t\t\trtnl_lock();\n\t\t\t/* we're going out of recovery mode so we'll free\n\t\t\t * the IRQ allocated specifically for recovery mode\n\t\t\t * and restore the interrupt scheme\n\t\t\t */\n\t\t\tfree_irq(pf->pdev->irq, pf);\n\t\t\ti40e_clear_interrupt_scheme(pf);\n\t\t\tif (i40e_restore_interrupt_scheme(pf))\n\t\t\t\tgoto end_unlock;\n\t\t}\n\n\t\t/* tell the firmware that we're starting */\n\t\ti40e_send_version(pf);\n\n\t\t/* bail out in case recovery mode was detected, as there is\n\t\t * no need for further configuration.\n\t\t */\n\t\tgoto end_unlock;\n\t}\n\n\ti40e_clear_pxe_mode(hw);\n\tret = i40e_get_capabilities(pf, i40e_aqc_opc_list_func_capabilities);\n\tif (ret)\n\t\tgoto end_core_reset;\n\n\tret = i40e_init_lan_hmc(hw, hw->func_caps.num_tx_qp,\n\t\t\t\thw->func_caps.num_rx_qp, 0, 0);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"init_lan_hmc failed: %d\\n\", ret);\n\t\tgoto end_core_reset;\n\t}\n\tret = i40e_configure_lan_hmc(hw, I40E_HMC_MODEL_DIRECT_ONLY);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"configure_lan_hmc failed: %d\\n\", ret);\n\t\tgoto end_core_reset;\n\t}\n\n\t/* Enable FW to write a default DCB config on link-up */\n\ti40e_aq_set_dcb_parameters(hw, true, NULL);\n\n#ifdef CONFIG_I40E_DCB\n\tret = i40e_init_pf_dcb(pf);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"DCB init failed %d, disabled\\n\", ret);\n\t\tpf->flags &= ~I40E_FLAG_DCB_CAPABLE;\n\t\t/* Continue without DCB enabled */\n\t}\n#endif /* CONFIG_I40E_DCB */\n\t/* do basic switch setup */\n\tif (!lock_acquired)\n\t\trtnl_lock();\n\tret = i40e_setup_pf_switch(pf, reinit);\n\tif (ret)\n\t\tgoto end_unlock;\n\n\t/* The driver only wants link up/down and module qualification\n\t * reports from firmware.  Note the negative logic.\n\t */\n\tret = i40e_aq_set_phy_int_mask(&pf->hw,\n\t\t\t\t       ~(I40E_AQ_EVENT_LINK_UPDOWN |\n\t\t\t\t\t I40E_AQ_EVENT_MEDIA_NA |\n\t\t\t\t\t I40E_AQ_EVENT_MODULE_QUAL_FAIL), NULL);\n\tif (ret)\n\t\tdev_info(&pf->pdev->dev, \"set phy mask fail, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\n\t/* make sure our flow control settings are restored */\n\tret = i40e_set_fc(&pf->hw, &set_fc_aq_fail, true);\n\tif (ret)\n\t\tdev_dbg(&pf->pdev->dev, \"setting flow control: ret = %s last_status = %s\\n\",\n\t\t\ti40e_stat_str(&pf->hw, ret),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\n\t/* Rebuild the VSIs and VEBs that existed before reset.\n\t * They are still in our local switch element arrays, so only\n\t * need to rebuild the switch model in the HW.\n\t *\n\t * If there were VEBs but the reconstitution failed, we'll try\n\t * try to recover minimal use by getting the basic PF VSI working.\n\t */\n\tif (vsi->uplink_seid != pf->mac_seid) {\n\t\tdev_dbg(&pf->pdev->dev, \"attempting to rebuild switch\\n\");\n\t\t/* find the one VEB connected to the MAC, and find orphans */\n\t\tfor (v = 0; v < I40E_MAX_VEB; v++) {\n\t\t\tif (!pf->veb[v])\n\t\t\t\tcontinue;\n\n\t\t\tif (pf->veb[v]->uplink_seid == pf->mac_seid ||\n\t\t\t    pf->veb[v]->uplink_seid == 0) {\n\t\t\t\tret = i40e_reconstitute_veb(pf->veb[v]);\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t/* If Main VEB failed, we're in deep doodoo,\n\t\t\t\t * so give up rebuilding the switch and set up\n\t\t\t\t * for minimal rebuild of PF VSI.\n\t\t\t\t * If orphan failed, we'll report the error\n\t\t\t\t * but try to keep going.\n\t\t\t\t */\n\t\t\t\tif (pf->veb[v]->uplink_seid == pf->mac_seid) {\n\t\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t\t \"rebuild of switch failed: %d, will try to set up simple PF connection\\n\",\n\t\t\t\t\t\t ret);\n\t\t\t\t\tvsi->uplink_seid = pf->mac_seid;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (pf->veb[v]->uplink_seid == 0) {\n\t\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t\t \"rebuild of orphan VEB failed: %d\\n\",\n\t\t\t\t\t\t ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vsi->uplink_seid == pf->mac_seid) {\n\t\tdev_dbg(&pf->pdev->dev, \"attempting to rebuild PF VSI\\n\");\n\t\t/* no VEB, so rebuild only the Main VSI */\n\t\tret = i40e_add_vsi(vsi);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"rebuild of Main VSI failed: %d\\n\", ret);\n\t\t\tgoto end_unlock;\n\t\t}\n\t}\n\n\tif (vsi->mqprio_qopt.max_rate[0]) {\n\t\tu64 max_tx_rate = vsi->mqprio_qopt.max_rate[0];\n\t\tu64 credits = 0;\n\n\t\tdo_div(max_tx_rate, I40E_BW_MBPS_DIVISOR);\n\t\tret = i40e_set_bw_limit(vsi, vsi->seid, max_tx_rate);\n\t\tif (ret)\n\t\t\tgoto end_unlock;\n\n\t\tcredits = max_tx_rate;\n\t\tdo_div(credits, I40E_BW_CREDIT_DIVISOR);\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Set tx rate of %llu Mbps (count of 50Mbps %llu) for vsi->seid %u\\n\",\n\t\t\tmax_tx_rate,\n\t\t\tcredits,\n\t\t\tvsi->seid);\n\t}\n\n\tret = i40e_rebuild_cloud_filters(vsi, vsi->seid);\n\tif (ret)\n\t\tgoto end_unlock;\n\n\t/* PF Main VSI is rebuild by now, go ahead and rebuild channel VSIs\n\t * for this main VSI if they exist\n\t */\n\tret = i40e_rebuild_channels(vsi);\n\tif (ret)\n\t\tgoto end_unlock;\n\n\t/* Reconfigure hardware for allowing smaller MSS in the case\n\t * of TSO, so that we avoid the MDD being fired and causing\n\t * a reset in the case of small MSS+TSO.\n\t */\n#define I40E_REG_MSS          0x000E64DC\n#define I40E_REG_MSS_MIN_MASK 0x3FF0000\n#define I40E_64BYTE_MSS       0x400000\n\tval = rd32(hw, I40E_REG_MSS);\n\tif ((val & I40E_REG_MSS_MIN_MASK) > I40E_64BYTE_MSS) {\n\t\tval &= ~I40E_REG_MSS_MIN_MASK;\n\t\tval |= I40E_64BYTE_MSS;\n\t\twr32(hw, I40E_REG_MSS, val);\n\t}\n\n\tif (pf->hw_features & I40E_HW_RESTART_AUTONEG) {\n\t\tmsleep(75);\n\t\tret = i40e_aq_set_link_restart_an(&pf->hw, true, NULL);\n\t\tif (ret)\n\t\t\tdev_info(&pf->pdev->dev, \"link restart failed, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t}\n\t/* reinit the misc interrupt */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\tret = i40e_setup_misc_vector(pf);\n\n\t/* Add a filter to drop all Flow control frames from any VSI from being\n\t * transmitted. By doing so we stop a malicious VF from sending out\n\t * PAUSE or PFC frames and potentially controlling traffic for other\n\t * PF/VF VSIs.\n\t * The FW can still send Flow control frames if enabled.\n\t */\n\ti40e_add_filter_to_drop_tx_flow_control_frames(&pf->hw,\n\t\t\t\t\t\t       pf->main_vsi_seid);\n\n\t/* restart the VSIs that were rebuilt and running before the reset */\n\ti40e_pf_unquiesce_all_vsi(pf);\n\n\t/* Release the RTNL lock before we start resetting VFs */\n\tif (!lock_acquired)\n\t\trtnl_unlock();\n\n\t/* Restore promiscuous settings */\n\tret = i40e_set_promiscuous(pf, pf->cur_promisc);\n\tif (ret)\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"Failed to restore promiscuous setting: %s, err %s aq_err %s\\n\",\n\t\t\t pf->cur_promisc ? \"on\" : \"off\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\n\ti40e_reset_all_vfs(pf, true);\n\n\t/* tell the firmware that we're starting */\n\ti40e_send_version(pf);\n\n\t/* We've already released the lock, so don't do it again */\n\tgoto end_core_reset;\n\nend_unlock:\n\tif (!lock_acquired)\n\t\trtnl_unlock();\nend_core_reset:\n\tclear_bit(__I40E_RESET_FAILED, pf->state);\nclear_recovery:\n\tclear_bit(__I40E_RESET_RECOVERY_PENDING, pf->state);\n\tclear_bit(__I40E_TIMEOUT_RECOVERY_PENDING, pf->state);\n}\n\n/**\n * i40e_reset_and_rebuild - reset and rebuild using a saved config\n * @pf: board private structure\n * @reinit: if the Main VSI needs to re-initialized.\n * @lock_acquired: indicates whether or not the lock has been acquired\n * before this function was called.\n **/\nstatic void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit,\n\t\t\t\t   bool lock_acquired)\n{\n\tint ret;\n\t/* Now we wait for GRST to settle out.\n\t * We don't have to delete the VEBs or VSIs from the hw switch\n\t * because the reset will make them disappear.\n\t */\n\tret = i40e_reset(pf);\n\tif (!ret)\n\t\ti40e_rebuild(pf, reinit, lock_acquired);\n}\n\n/**\n * i40e_handle_reset_warning - prep for the PF to reset, reset and rebuild\n * @pf: board private structure\n *\n * Close up the VFs and other things in prep for a Core Reset,\n * then get ready to rebuild the world.\n * @lock_acquired: indicates whether or not the lock has been acquired\n * before this function was called.\n **/\nstatic void i40e_handle_reset_warning(struct i40e_pf *pf, bool lock_acquired)\n{\n\ti40e_prep_for_reset(pf, lock_acquired);\n\ti40e_reset_and_rebuild(pf, false, lock_acquired);\n}\n\n/**\n * i40e_handle_mdd_event\n * @pf: pointer to the PF structure\n *\n * Called from the MDD irq handler to identify possibly malicious vfs\n **/\nstatic void i40e_handle_mdd_event(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tbool mdd_detected = false;\n\tstruct i40e_vf *vf;\n\tu32 reg;\n\tint i;\n\n\tif (!test_bit(__I40E_MDD_EVENT_PENDING, pf->state))\n\t\treturn;\n\n\t/* find what triggered the MDD event */\n\treg = rd32(hw, I40E_GL_MDET_TX);\n\tif (reg & I40E_GL_MDET_TX_VALID_MASK) {\n\t\tu8 pf_num = (reg & I40E_GL_MDET_TX_PF_NUM_MASK) >>\n\t\t\t\tI40E_GL_MDET_TX_PF_NUM_SHIFT;\n\t\tu16 vf_num = (reg & I40E_GL_MDET_TX_VF_NUM_MASK) >>\n\t\t\t\tI40E_GL_MDET_TX_VF_NUM_SHIFT;\n\t\tu8 event = (reg & I40E_GL_MDET_TX_EVENT_MASK) >>\n\t\t\t\tI40E_GL_MDET_TX_EVENT_SHIFT;\n\t\tu16 queue = ((reg & I40E_GL_MDET_TX_QUEUE_MASK) >>\n\t\t\t\tI40E_GL_MDET_TX_QUEUE_SHIFT) -\n\t\t\t\tpf->hw.func_caps.base_queue;\n\t\tif (netif_msg_tx_err(pf))\n\t\t\tdev_info(&pf->pdev->dev, \"Malicious Driver Detection event 0x%02x on TX queue %d PF number 0x%02x VF number 0x%02x\\n\",\n\t\t\t\t event, queue, pf_num, vf_num);\n\t\twr32(hw, I40E_GL_MDET_TX, 0xffffffff);\n\t\tmdd_detected = true;\n\t}\n\treg = rd32(hw, I40E_GL_MDET_RX);\n\tif (reg & I40E_GL_MDET_RX_VALID_MASK) {\n\t\tu8 func = (reg & I40E_GL_MDET_RX_FUNCTION_MASK) >>\n\t\t\t\tI40E_GL_MDET_RX_FUNCTION_SHIFT;\n\t\tu8 event = (reg & I40E_GL_MDET_RX_EVENT_MASK) >>\n\t\t\t\tI40E_GL_MDET_RX_EVENT_SHIFT;\n\t\tu16 queue = ((reg & I40E_GL_MDET_RX_QUEUE_MASK) >>\n\t\t\t\tI40E_GL_MDET_RX_QUEUE_SHIFT) -\n\t\t\t\tpf->hw.func_caps.base_queue;\n\t\tif (netif_msg_rx_err(pf))\n\t\t\tdev_info(&pf->pdev->dev, \"Malicious Driver Detection event 0x%02x on RX queue %d of function 0x%02x\\n\",\n\t\t\t\t event, queue, func);\n\t\twr32(hw, I40E_GL_MDET_RX, 0xffffffff);\n\t\tmdd_detected = true;\n\t}\n\n\tif (mdd_detected) {\n\t\treg = rd32(hw, I40E_PF_MDET_TX);\n\t\tif (reg & I40E_PF_MDET_TX_VALID_MASK) {\n\t\t\twr32(hw, I40E_PF_MDET_TX, 0xFFFF);\n\t\t\tdev_dbg(&pf->pdev->dev, \"TX driver issue detected on PF\\n\");\n\t\t}\n\t\treg = rd32(hw, I40E_PF_MDET_RX);\n\t\tif (reg & I40E_PF_MDET_RX_VALID_MASK) {\n\t\t\twr32(hw, I40E_PF_MDET_RX, 0xFFFF);\n\t\t\tdev_dbg(&pf->pdev->dev, \"RX driver issue detected on PF\\n\");\n\t\t}\n\t}\n\n\t/* see if one of the VFs needs its hand slapped */\n\tfor (i = 0; i < pf->num_alloc_vfs && mdd_detected; i++) {\n\t\tvf = &(pf->vf[i]);\n\t\treg = rd32(hw, I40E_VP_MDET_TX(i));\n\t\tif (reg & I40E_VP_MDET_TX_VALID_MASK) {\n\t\t\twr32(hw, I40E_VP_MDET_TX(i), 0xFFFF);\n\t\t\tvf->num_mdd_events++;\n\t\t\tdev_info(&pf->pdev->dev, \"TX driver issue detected on VF %d\\n\",\n\t\t\t\t i);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Use PF Control I/F to re-enable the VF\\n\");\n\t\t\tset_bit(I40E_VF_STATE_DISABLED, &vf->vf_states);\n\t\t}\n\n\t\treg = rd32(hw, I40E_VP_MDET_RX(i));\n\t\tif (reg & I40E_VP_MDET_RX_VALID_MASK) {\n\t\t\twr32(hw, I40E_VP_MDET_RX(i), 0xFFFF);\n\t\t\tvf->num_mdd_events++;\n\t\t\tdev_info(&pf->pdev->dev, \"RX driver issue detected on VF %d\\n\",\n\t\t\t\t i);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Use PF Control I/F to re-enable the VF\\n\");\n\t\t\tset_bit(I40E_VF_STATE_DISABLED, &vf->vf_states);\n\t\t}\n\t}\n\n\t/* re-enable mdd interrupt cause */\n\tclear_bit(__I40E_MDD_EVENT_PENDING, pf->state);\n\treg = rd32(hw, I40E_PFINT_ICR0_ENA);\n\treg |=  I40E_PFINT_ICR0_ENA_MAL_DETECT_MASK;\n\twr32(hw, I40E_PFINT_ICR0_ENA, reg);\n\ti40e_flush(hw);\n}\n\n/**\n * i40e_service_task - Run the driver's async subtasks\n * @work: pointer to work_struct containing our data\n **/\nstatic void i40e_service_task(struct work_struct *work)\n{\n\tstruct i40e_pf *pf = container_of(work,\n\t\t\t\t\t  struct i40e_pf,\n\t\t\t\t\t  service_task);\n\tunsigned long start_time = jiffies;\n\n\t/* don't bother with service tasks if a reset is in progress */\n\tif (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state) ||\n\t    test_bit(__I40E_SUSPENDED, pf->state))\n\t\treturn;\n\n\tif (test_and_set_bit(__I40E_SERVICE_SCHED, pf->state))\n\t\treturn;\n\n\tif (!test_bit(__I40E_RECOVERY_MODE, pf->state)) {\n\t\ti40e_detect_recover_hung(pf->vsi[pf->lan_vsi]);\n\t\ti40e_sync_filters_subtask(pf);\n\t\ti40e_reset_subtask(pf);\n\t\ti40e_handle_mdd_event(pf);\n\t\ti40e_vc_process_vflr_event(pf);\n\t\ti40e_watchdog_subtask(pf);\n\t\ti40e_fdir_reinit_subtask(pf);\n\t\tif (test_and_clear_bit(__I40E_CLIENT_RESET, pf->state)) {\n\t\t\t/* Client subtask will reopen next time through. */\n\t\t\ti40e_notify_client_of_netdev_close(pf->vsi[pf->lan_vsi],\n\t\t\t\t\t\t\t   true);\n\t\t} else {\n\t\t\ti40e_client_subtask(pf);\n\t\t\tif (test_and_clear_bit(__I40E_CLIENT_L2_CHANGE,\n\t\t\t\t\t       pf->state))\n\t\t\t\ti40e_notify_client_of_l2_param_changes(\n\t\t\t\t\t\t\t\tpf->vsi[pf->lan_vsi]);\n\t\t}\n\t\ti40e_sync_filters_subtask(pf);\n\t} else {\n\t\ti40e_reset_subtask(pf);\n\t}\n\n\ti40e_clean_adminq_subtask(pf);\n\n\t/* flush memory to make sure state is correct before next watchdog */\n\tsmp_mb__before_atomic();\n\tclear_bit(__I40E_SERVICE_SCHED, pf->state);\n\n\t/* If the tasks have taken longer than one timer cycle or there\n\t * is more work to be done, reschedule the service task now\n\t * rather than wait for the timer to tick again.\n\t */\n\tif (time_after(jiffies, (start_time + pf->service_timer_period)) ||\n\t    test_bit(__I40E_ADMINQ_EVENT_PENDING, pf->state)\t\t ||\n\t    test_bit(__I40E_MDD_EVENT_PENDING, pf->state)\t\t ||\n\t    test_bit(__I40E_VFLR_EVENT_PENDING, pf->state))\n\t\ti40e_service_event_schedule(pf);\n}\n\n/**\n * i40e_service_timer - timer callback\n * @t: timer list pointer\n **/\nstatic void i40e_service_timer(struct timer_list *t)\n{\n\tstruct i40e_pf *pf = from_timer(pf, t, service_timer);\n\n\tmod_timer(&pf->service_timer,\n\t\t  round_jiffies(jiffies + pf->service_timer_period));\n\ti40e_service_event_schedule(pf);\n}\n\n/**\n * i40e_set_num_rings_in_vsi - Determine number of rings in the VSI\n * @vsi: the VSI being configured\n **/\nstatic int i40e_set_num_rings_in_vsi(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\tswitch (vsi->type) {\n\tcase I40E_VSI_MAIN:\n\t\tvsi->alloc_queue_pairs = pf->num_lan_qps;\n\t\tif (!vsi->num_tx_desc)\n\t\t\tvsi->num_tx_desc = ALIGN(I40E_DEFAULT_NUM_DESCRIPTORS,\n\t\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tif (!vsi->num_rx_desc)\n\t\t\tvsi->num_rx_desc = ALIGN(I40E_DEFAULT_NUM_DESCRIPTORS,\n\t\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\t\tvsi->num_q_vectors = pf->num_lan_msix;\n\t\telse\n\t\t\tvsi->num_q_vectors = 1;\n\n\t\tbreak;\n\n\tcase I40E_VSI_FDIR:\n\t\tvsi->alloc_queue_pairs = 1;\n\t\tvsi->num_tx_desc = ALIGN(I40E_FDIR_RING_COUNT,\n\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tvsi->num_rx_desc = ALIGN(I40E_FDIR_RING_COUNT,\n\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tvsi->num_q_vectors = pf->num_fdsb_msix;\n\t\tbreak;\n\n\tcase I40E_VSI_VMDQ2:\n\t\tvsi->alloc_queue_pairs = pf->num_vmdq_qps;\n\t\tif (!vsi->num_tx_desc)\n\t\t\tvsi->num_tx_desc = ALIGN(I40E_DEFAULT_NUM_DESCRIPTORS,\n\t\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tif (!vsi->num_rx_desc)\n\t\t\tvsi->num_rx_desc = ALIGN(I40E_DEFAULT_NUM_DESCRIPTORS,\n\t\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tvsi->num_q_vectors = pf->num_vmdq_msix;\n\t\tbreak;\n\n\tcase I40E_VSI_SRIOV:\n\t\tvsi->alloc_queue_pairs = pf->num_vf_qps;\n\t\tif (!vsi->num_tx_desc)\n\t\t\tvsi->num_tx_desc = ALIGN(I40E_DEFAULT_NUM_DESCRIPTORS,\n\t\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tif (!vsi->num_rx_desc)\n\t\t\tvsi->num_rx_desc = ALIGN(I40E_DEFAULT_NUM_DESCRIPTORS,\n\t\t\t\t\t\t I40E_REQ_DESCRIPTOR_MULTIPLE);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENODATA;\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_alloc_arrays - Allocate queue and vector pointer arrays for the vsi\n * @vsi: VSI pointer\n * @alloc_qvectors: a bool to specify if q_vectors need to be allocated.\n *\n * On error: returns error code (negative)\n * On success: returns 0\n **/\nstatic int i40e_vsi_alloc_arrays(struct i40e_vsi *vsi, bool alloc_qvectors)\n{\n\tstruct i40e_ring **next_rings;\n\tint size;\n\tint ret = 0;\n\n\t/* allocate memory for both Tx, XDP Tx and Rx ring pointers */\n\tsize = sizeof(struct i40e_ring *) * vsi->alloc_queue_pairs *\n\t       (i40e_enabled_xdp_vsi(vsi) ? 3 : 2);\n\tvsi->tx_rings = kzalloc(size, GFP_KERNEL);\n\tif (!vsi->tx_rings)\n\t\treturn -ENOMEM;\n\tnext_rings = vsi->tx_rings + vsi->alloc_queue_pairs;\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\tvsi->xdp_rings = next_rings;\n\t\tnext_rings += vsi->alloc_queue_pairs;\n\t}\n\tvsi->rx_rings = next_rings;\n\n\tif (alloc_qvectors) {\n\t\t/* allocate memory for q_vector pointers */\n\t\tsize = sizeof(struct i40e_q_vector *) * vsi->num_q_vectors;\n\t\tvsi->q_vectors = kzalloc(size, GFP_KERNEL);\n\t\tif (!vsi->q_vectors) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_vectors;\n\t\t}\n\t}\n\treturn ret;\n\nerr_vectors:\n\tkfree(vsi->tx_rings);\n\treturn ret;\n}\n\n/**\n * i40e_vsi_mem_alloc - Allocates the next available struct vsi in the PF\n * @pf: board private structure\n * @type: type of VSI\n *\n * On error: returns error code (negative)\n * On success: returns vsi index in PF (positive)\n **/\nstatic int i40e_vsi_mem_alloc(struct i40e_pf *pf, enum i40e_vsi_type type)\n{\n\tint ret = -ENODEV;\n\tstruct i40e_vsi *vsi;\n\tint vsi_idx;\n\tint i;\n\n\t/* Need to protect the allocation of the VSIs at the PF level */\n\tmutex_lock(&pf->switch_mutex);\n\n\t/* VSI list may be fragmented if VSI creation/destruction has\n\t * been happening.  We can afford to do a quick scan to look\n\t * for any free VSIs in the list.\n\t *\n\t * find next empty vsi slot, looping back around if necessary\n\t */\n\ti = pf->next_vsi;\n\twhile (i < pf->num_alloc_vsi && pf->vsi[i])\n\t\ti++;\n\tif (i >= pf->num_alloc_vsi) {\n\t\ti = 0;\n\t\twhile (i < pf->next_vsi && pf->vsi[i])\n\t\t\ti++;\n\t}\n\n\tif (i < pf->num_alloc_vsi && !pf->vsi[i]) {\n\t\tvsi_idx = i;             /* Found one! */\n\t} else {\n\t\tret = -ENODEV;\n\t\tgoto unlock_pf;  /* out of VSI slots! */\n\t}\n\tpf->next_vsi = ++i;\n\n\tvsi = kzalloc(sizeof(*vsi), GFP_KERNEL);\n\tif (!vsi) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock_pf;\n\t}\n\tvsi->type = type;\n\tvsi->back = pf;\n\tset_bit(__I40E_VSI_DOWN, vsi->state);\n\tvsi->flags = 0;\n\tvsi->idx = vsi_idx;\n\tvsi->int_rate_limit = 0;\n\tvsi->rss_table_size = (vsi->type == I40E_VSI_MAIN) ?\n\t\t\t\tpf->rss_table_size : 64;\n\tvsi->netdev_registered = false;\n\tvsi->work_limit = I40E_DEFAULT_IRQ_WORK;\n\thash_init(vsi->mac_filter_hash);\n\tvsi->irqs_ready = false;\n\n\tif (type == I40E_VSI_MAIN) {\n\t\tvsi->af_xdp_zc_qps = bitmap_zalloc(pf->num_lan_qps, GFP_KERNEL);\n\t\tif (!vsi->af_xdp_zc_qps)\n\t\t\tgoto err_rings;\n\t}\n\n\tret = i40e_set_num_rings_in_vsi(vsi);\n\tif (ret)\n\t\tgoto err_rings;\n\n\tret = i40e_vsi_alloc_arrays(vsi, true);\n\tif (ret)\n\t\tgoto err_rings;\n\n\t/* Setup default MSIX irq handler for VSI */\n\ti40e_vsi_setup_irqhandler(vsi, i40e_msix_clean_rings);\n\n\t/* Initialize VSI lock */\n\tspin_lock_init(&vsi->mac_filter_hash_lock);\n\tpf->vsi[vsi_idx] = vsi;\n\tret = vsi_idx;\n\tgoto unlock_pf;\n\nerr_rings:\n\tbitmap_free(vsi->af_xdp_zc_qps);\n\tpf->next_vsi = i - 1;\n\tkfree(vsi);\nunlock_pf:\n\tmutex_unlock(&pf->switch_mutex);\n\treturn ret;\n}\n\n/**\n * i40e_vsi_free_arrays - Free queue and vector pointer arrays for the VSI\n * @vsi: VSI pointer\n * @free_qvectors: a bool to specify if q_vectors need to be freed.\n *\n * On error: returns error code (negative)\n * On success: returns 0\n **/\nstatic void i40e_vsi_free_arrays(struct i40e_vsi *vsi, bool free_qvectors)\n{\n\t/* free the ring and vector containers */\n\tif (free_qvectors) {\n\t\tkfree(vsi->q_vectors);\n\t\tvsi->q_vectors = NULL;\n\t}\n\tkfree(vsi->tx_rings);\n\tvsi->tx_rings = NULL;\n\tvsi->rx_rings = NULL;\n\tvsi->xdp_rings = NULL;\n}\n\n/**\n * i40e_clear_rss_config_user - clear the user configured RSS hash keys\n * and lookup table\n * @vsi: Pointer to VSI structure\n */\nstatic void i40e_clear_rss_config_user(struct i40e_vsi *vsi)\n{\n\tif (!vsi)\n\t\treturn;\n\n\tkfree(vsi->rss_hkey_user);\n\tvsi->rss_hkey_user = NULL;\n\n\tkfree(vsi->rss_lut_user);\n\tvsi->rss_lut_user = NULL;\n}\n\n/**\n * i40e_vsi_clear - Deallocate the VSI provided\n * @vsi: the VSI being un-configured\n **/\nstatic int i40e_vsi_clear(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf;\n\n\tif (!vsi)\n\t\treturn 0;\n\n\tif (!vsi->back)\n\t\tgoto free_vsi;\n\tpf = vsi->back;\n\n\tmutex_lock(&pf->switch_mutex);\n\tif (!pf->vsi[vsi->idx]) {\n\t\tdev_err(&pf->pdev->dev, \"pf->vsi[%d] is NULL, just free vsi[%d](type %d)\\n\",\n\t\t\tvsi->idx, vsi->idx, vsi->type);\n\t\tgoto unlock_vsi;\n\t}\n\n\tif (pf->vsi[vsi->idx] != vsi) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"pf->vsi[%d](type %d) != vsi[%d](type %d): no free!\\n\",\n\t\t\tpf->vsi[vsi->idx]->idx,\n\t\t\tpf->vsi[vsi->idx]->type,\n\t\t\tvsi->idx, vsi->type);\n\t\tgoto unlock_vsi;\n\t}\n\n\t/* updates the PF for this cleared vsi */\n\ti40e_put_lump(pf->qp_pile, vsi->base_queue, vsi->idx);\n\ti40e_put_lump(pf->irq_pile, vsi->base_vector, vsi->idx);\n\n\tbitmap_free(vsi->af_xdp_zc_qps);\n\ti40e_vsi_free_arrays(vsi, true);\n\ti40e_clear_rss_config_user(vsi);\n\n\tpf->vsi[vsi->idx] = NULL;\n\tif (vsi->idx < pf->next_vsi)\n\t\tpf->next_vsi = vsi->idx;\n\nunlock_vsi:\n\tmutex_unlock(&pf->switch_mutex);\nfree_vsi:\n\tkfree(vsi);\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_clear_rings - Deallocates the Rx and Tx rings for the provided VSI\n * @vsi: the VSI being cleaned\n **/\nstatic void i40e_vsi_clear_rings(struct i40e_vsi *vsi)\n{\n\tint i;\n\n\tif (vsi->tx_rings && vsi->tx_rings[0]) {\n\t\tfor (i = 0; i < vsi->alloc_queue_pairs; i++) {\n\t\t\tkfree_rcu(vsi->tx_rings[i], rcu);\n\t\t\tWRITE_ONCE(vsi->tx_rings[i], NULL);\n\t\t\tWRITE_ONCE(vsi->rx_rings[i], NULL);\n\t\t\tif (vsi->xdp_rings)\n\t\t\t\tWRITE_ONCE(vsi->xdp_rings[i], NULL);\n\t\t}\n\t}\n}\n\n/**\n * i40e_alloc_rings - Allocates the Rx and Tx rings for the provided VSI\n * @vsi: the VSI being configured\n **/\nstatic int i40e_alloc_rings(struct i40e_vsi *vsi)\n{\n\tint i, qpv = i40e_enabled_xdp_vsi(vsi) ? 3 : 2;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_ring *ring;\n\n\t/* Set basic values in the rings to be used later during open() */\n\tfor (i = 0; i < vsi->alloc_queue_pairs; i++) {\n\t\t/* allocate space for both Tx and Rx in one shot */\n\t\tring = kcalloc(qpv, sizeof(struct i40e_ring), GFP_KERNEL);\n\t\tif (!ring)\n\t\t\tgoto err_out;\n\n\t\tring->queue_index = i;\n\t\tring->reg_idx = vsi->base_queue + i;\n\t\tring->ring_active = false;\n\t\tring->vsi = vsi;\n\t\tring->netdev = vsi->netdev;\n\t\tring->dev = &pf->pdev->dev;\n\t\tring->count = vsi->num_tx_desc;\n\t\tring->size = 0;\n\t\tring->dcb_tc = 0;\n\t\tif (vsi->back->hw_features & I40E_HW_WB_ON_ITR_CAPABLE)\n\t\t\tring->flags = I40E_TXR_FLAGS_WB_ON_ITR;\n\t\tring->itr_setting = pf->tx_itr_default;\n\t\tWRITE_ONCE(vsi->tx_rings[i], ring++);\n\n\t\tif (!i40e_enabled_xdp_vsi(vsi))\n\t\t\tgoto setup_rx;\n\n\t\tring->queue_index = vsi->alloc_queue_pairs + i;\n\t\tring->reg_idx = vsi->base_queue + ring->queue_index;\n\t\tring->ring_active = false;\n\t\tring->vsi = vsi;\n\t\tring->netdev = NULL;\n\t\tring->dev = &pf->pdev->dev;\n\t\tring->count = vsi->num_tx_desc;\n\t\tring->size = 0;\n\t\tring->dcb_tc = 0;\n\t\tif (vsi->back->hw_features & I40E_HW_WB_ON_ITR_CAPABLE)\n\t\t\tring->flags = I40E_TXR_FLAGS_WB_ON_ITR;\n\t\tset_ring_xdp(ring);\n\t\tring->itr_setting = pf->tx_itr_default;\n\t\tWRITE_ONCE(vsi->xdp_rings[i], ring++);\n\nsetup_rx:\n\t\tring->queue_index = i;\n\t\tring->reg_idx = vsi->base_queue + i;\n\t\tring->ring_active = false;\n\t\tring->vsi = vsi;\n\t\tring->netdev = vsi->netdev;\n\t\tring->dev = &pf->pdev->dev;\n\t\tring->count = vsi->num_rx_desc;\n\t\tring->size = 0;\n\t\tring->dcb_tc = 0;\n\t\tring->itr_setting = pf->rx_itr_default;\n\t\tWRITE_ONCE(vsi->rx_rings[i], ring);\n\t}\n\n\treturn 0;\n\nerr_out:\n\ti40e_vsi_clear_rings(vsi);\n\treturn -ENOMEM;\n}\n\n/**\n * i40e_reserve_msix_vectors - Reserve MSI-X vectors in the kernel\n * @pf: board private structure\n * @vectors: the number of MSI-X vectors to request\n *\n * Returns the number of vectors reserved, or error\n **/\nstatic int i40e_reserve_msix_vectors(struct i40e_pf *pf, int vectors)\n{\n\tvectors = pci_enable_msix_range(pf->pdev, pf->msix_entries,\n\t\t\t\t\tI40E_MIN_MSIX, vectors);\n\tif (vectors < 0) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"MSI-X vector reservation failed: %d\\n\", vectors);\n\t\tvectors = 0;\n\t}\n\n\treturn vectors;\n}\n\n/**\n * i40e_init_msix - Setup the MSIX capability\n * @pf: board private structure\n *\n * Work with the OS to set up the MSIX vectors needed.\n *\n * Returns the number of vectors reserved or negative on failure\n **/\nstatic int i40e_init_msix(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tint cpus, extra_vectors;\n\tint vectors_left;\n\tint v_budget, i;\n\tint v_actual;\n\tint iwarp_requested = 0;\n\n\tif (!(pf->flags & I40E_FLAG_MSIX_ENABLED))\n\t\treturn -ENODEV;\n\n\t/* The number of vectors we'll request will be comprised of:\n\t *   - Add 1 for \"other\" cause for Admin Queue events, etc.\n\t *   - The number of LAN queue pairs\n\t *\t- Queues being used for RSS.\n\t *\t\tWe don't need as many as max_rss_size vectors.\n\t *\t\tuse rss_size instead in the calculation since that\n\t *\t\tis governed by number of cpus in the system.\n\t *\t- assumes symmetric Tx/Rx pairing\n\t *   - The number of VMDq pairs\n\t *   - The CPU count within the NUMA node if iWARP is enabled\n\t * Once we count this up, try the request.\n\t *\n\t * If we can't get what we want, we'll simplify to nearly nothing\n\t * and try again.  If that still fails, we punt.\n\t */\n\tvectors_left = hw->func_caps.num_msix_vectors;\n\tv_budget = 0;\n\n\t/* reserve one vector for miscellaneous handler */\n\tif (vectors_left) {\n\t\tv_budget++;\n\t\tvectors_left--;\n\t}\n\n\t/* reserve some vectors for the main PF traffic queues. Initially we\n\t * only reserve at most 50% of the available vectors, in the case that\n\t * the number of online CPUs is large. This ensures that we can enable\n\t * extra features as well. Once we've enabled the other features, we\n\t * will use any remaining vectors to reach as close as we can to the\n\t * number of online CPUs.\n\t */\n\tcpus = num_online_cpus();\n\tpf->num_lan_msix = min_t(int, cpus, vectors_left / 2);\n\tvectors_left -= pf->num_lan_msix;\n\n\t/* reserve one vector for sideband flow director */\n\tif (pf->flags & I40E_FLAG_FD_SB_ENABLED) {\n\t\tif (vectors_left) {\n\t\t\tpf->num_fdsb_msix = 1;\n\t\t\tv_budget++;\n\t\t\tvectors_left--;\n\t\t} else {\n\t\t\tpf->num_fdsb_msix = 0;\n\t\t}\n\t}\n\n\t/* can we reserve enough for iWARP? */\n\tif (pf->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\tiwarp_requested = pf->num_iwarp_msix;\n\n\t\tif (!vectors_left)\n\t\t\tpf->num_iwarp_msix = 0;\n\t\telse if (vectors_left < pf->num_iwarp_msix)\n\t\t\tpf->num_iwarp_msix = 1;\n\t\tv_budget += pf->num_iwarp_msix;\n\t\tvectors_left -= pf->num_iwarp_msix;\n\t}\n\n\t/* any vectors left over go for VMDq support */\n\tif (pf->flags & I40E_FLAG_VMDQ_ENABLED) {\n\t\tif (!vectors_left) {\n\t\t\tpf->num_vmdq_msix = 0;\n\t\t\tpf->num_vmdq_qps = 0;\n\t\t} else {\n\t\t\tint vmdq_vecs_wanted =\n\t\t\t\tpf->num_vmdq_vsis * pf->num_vmdq_qps;\n\t\t\tint vmdq_vecs =\n\t\t\t\tmin_t(int, vectors_left, vmdq_vecs_wanted);\n\n\t\t\t/* if we're short on vectors for what's desired, we limit\n\t\t\t * the queues per vmdq.  If this is still more than are\n\t\t\t * available, the user will need to change the number of\n\t\t\t * queues/vectors used by the PF later with the ethtool\n\t\t\t * channels command\n\t\t\t */\n\t\t\tif (vectors_left < vmdq_vecs_wanted) {\n\t\t\t\tpf->num_vmdq_qps = 1;\n\t\t\t\tvmdq_vecs_wanted = pf->num_vmdq_vsis;\n\t\t\t\tvmdq_vecs = min_t(int,\n\t\t\t\t\t\t  vectors_left,\n\t\t\t\t\t\t  vmdq_vecs_wanted);\n\t\t\t}\n\t\t\tpf->num_vmdq_msix = pf->num_vmdq_qps;\n\n\t\t\tv_budget += vmdq_vecs;\n\t\t\tvectors_left -= vmdq_vecs;\n\t\t}\n\t}\n\n\t/* On systems with a large number of SMP cores, we previously limited\n\t * the number of vectors for num_lan_msix to be at most 50% of the\n\t * available vectors, to allow for other features. Now, we add back\n\t * the remaining vectors. However, we ensure that the total\n\t * num_lan_msix will not exceed num_online_cpus(). To do this, we\n\t * calculate the number of vectors we can add without going over the\n\t * cap of CPUs. For systems with a small number of CPUs this will be\n\t * zero.\n\t */\n\textra_vectors = min_t(int, cpus - pf->num_lan_msix, vectors_left);\n\tpf->num_lan_msix += extra_vectors;\n\tvectors_left -= extra_vectors;\n\n\tWARN(vectors_left < 0,\n\t     \"Calculation of remaining vectors underflowed. This is an accounting bug when determining total MSI-X vectors.\\n\");\n\n\tv_budget += pf->num_lan_msix;\n\tpf->msix_entries = kcalloc(v_budget, sizeof(struct msix_entry),\n\t\t\t\t   GFP_KERNEL);\n\tif (!pf->msix_entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v_budget; i++)\n\t\tpf->msix_entries[i].entry = i;\n\tv_actual = i40e_reserve_msix_vectors(pf, v_budget);\n\n\tif (v_actual < I40E_MIN_MSIX) {\n\t\tpf->flags &= ~I40E_FLAG_MSIX_ENABLED;\n\t\tkfree(pf->msix_entries);\n\t\tpf->msix_entries = NULL;\n\t\tpci_disable_msix(pf->pdev);\n\t\treturn -ENODEV;\n\n\t} else if (v_actual == I40E_MIN_MSIX) {\n\t\t/* Adjust for minimal MSIX use */\n\t\tpf->num_vmdq_vsis = 0;\n\t\tpf->num_vmdq_qps = 0;\n\t\tpf->num_lan_qps = 1;\n\t\tpf->num_lan_msix = 1;\n\n\t} else if (v_actual != v_budget) {\n\t\t/* If we have limited resources, we will start with no vectors\n\t\t * for the special features and then allocate vectors to some\n\t\t * of these features based on the policy and at the end disable\n\t\t * the features that did not get any vectors.\n\t\t */\n\t\tint vec;\n\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"MSI-X vector limit reached with %d, wanted %d, attempting to redistribute vectors\\n\",\n\t\t\t v_actual, v_budget);\n\t\t/* reserve the misc vector */\n\t\tvec = v_actual - 1;\n\n\t\t/* Scale vector usage down */\n\t\tpf->num_vmdq_msix = 1;    /* force VMDqs to only one vector */\n\t\tpf->num_vmdq_vsis = 1;\n\t\tpf->num_vmdq_qps = 1;\n\n\t\t/* partition out the remaining vectors */\n\t\tswitch (vec) {\n\t\tcase 2:\n\t\t\tpf->num_lan_msix = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (pf->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\t\t\tpf->num_lan_msix = 1;\n\t\t\t\tpf->num_iwarp_msix = 1;\n\t\t\t} else {\n\t\t\t\tpf->num_lan_msix = 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (pf->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\t\t\tpf->num_iwarp_msix = min_t(int, (vec / 3),\n\t\t\t\t\t\t iwarp_requested);\n\t\t\t\tpf->num_vmdq_vsis = min_t(int, (vec / 3),\n\t\t\t\t\t\t  I40E_DEFAULT_NUM_VMDQ_VSI);\n\t\t\t} else {\n\t\t\t\tpf->num_vmdq_vsis = min_t(int, (vec / 2),\n\t\t\t\t\t\t  I40E_DEFAULT_NUM_VMDQ_VSI);\n\t\t\t}\n\t\t\tif (pf->flags & I40E_FLAG_FD_SB_ENABLED) {\n\t\t\t\tpf->num_fdsb_msix = 1;\n\t\t\t\tvec--;\n\t\t\t}\n\t\t\tpf->num_lan_msix = min_t(int,\n\t\t\t       (vec - (pf->num_iwarp_msix + pf->num_vmdq_vsis)),\n\t\t\t\t\t\t\t      pf->num_lan_msix);\n\t\t\tpf->num_lan_qps = pf->num_lan_msix;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((pf->flags & I40E_FLAG_FD_SB_ENABLED) &&\n\t    (pf->num_fdsb_msix == 0)) {\n\t\tdev_info(&pf->pdev->dev, \"Sideband Flowdir disabled, not enough MSI-X vectors\\n\");\n\t\tpf->flags &= ~I40E_FLAG_FD_SB_ENABLED;\n\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\t}\n\tif ((pf->flags & I40E_FLAG_VMDQ_ENABLED) &&\n\t    (pf->num_vmdq_msix == 0)) {\n\t\tdev_info(&pf->pdev->dev, \"VMDq disabled, not enough MSI-X vectors\\n\");\n\t\tpf->flags &= ~I40E_FLAG_VMDQ_ENABLED;\n\t}\n\n\tif ((pf->flags & I40E_FLAG_IWARP_ENABLED) &&\n\t    (pf->num_iwarp_msix == 0)) {\n\t\tdev_info(&pf->pdev->dev, \"IWARP disabled, not enough MSI-X vectors\\n\");\n\t\tpf->flags &= ~I40E_FLAG_IWARP_ENABLED;\n\t}\n\ti40e_debug(&pf->hw, I40E_DEBUG_INIT,\n\t\t   \"MSI-X vector distribution: PF %d, VMDq %d, FDSB %d, iWARP %d\\n\",\n\t\t   pf->num_lan_msix,\n\t\t   pf->num_vmdq_msix * pf->num_vmdq_vsis,\n\t\t   pf->num_fdsb_msix,\n\t\t   pf->num_iwarp_msix);\n\n\treturn v_actual;\n}\n\n/**\n * i40e_vsi_alloc_q_vector - Allocate memory for a single interrupt vector\n * @vsi: the VSI being configured\n * @v_idx: index of the vector in the vsi struct\n *\n * We allocate one q_vector.  If allocation fails we return -ENOMEM.\n **/\nstatic int i40e_vsi_alloc_q_vector(struct i40e_vsi *vsi, int v_idx)\n{\n\tstruct i40e_q_vector *q_vector;\n\n\t/* allocate q_vector */\n\tq_vector = kzalloc(sizeof(struct i40e_q_vector), GFP_KERNEL);\n\tif (!q_vector)\n\t\treturn -ENOMEM;\n\n\tq_vector->vsi = vsi;\n\tq_vector->v_idx = v_idx;\n\tcpumask_copy(&q_vector->affinity_mask, cpu_possible_mask);\n\n\tif (vsi->netdev)\n\t\tnetif_napi_add(vsi->netdev, &q_vector->napi,\n\t\t\t       i40e_napi_poll, NAPI_POLL_WEIGHT);\n\n\t/* tie q_vector and vsi together */\n\tvsi->q_vectors[v_idx] = q_vector;\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_alloc_q_vectors - Allocate memory for interrupt vectors\n * @vsi: the VSI being configured\n *\n * We allocate one q_vector per queue interrupt.  If allocation fails we\n * return -ENOMEM.\n **/\nstatic int i40e_vsi_alloc_q_vectors(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint err, v_idx, num_q_vectors;\n\n\t/* if not MSIX, give the one vector only to the LAN VSI */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\tnum_q_vectors = vsi->num_q_vectors;\n\telse if (vsi == pf->vsi[pf->lan_vsi])\n\t\tnum_q_vectors = 1;\n\telse\n\t\treturn -EINVAL;\n\n\tfor (v_idx = 0; v_idx < num_q_vectors; v_idx++) {\n\t\terr = i40e_vsi_alloc_q_vector(vsi, v_idx);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\twhile (v_idx--)\n\t\ti40e_free_q_vector(vsi, v_idx);\n\n\treturn err;\n}\n\n/**\n * i40e_init_interrupt_scheme - Determine proper interrupt scheme\n * @pf: board private structure to initialize\n **/\nstatic int i40e_init_interrupt_scheme(struct i40e_pf *pf)\n{\n\tint vectors = 0;\n\tssize_t size;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tvectors = i40e_init_msix(pf);\n\t\tif (vectors < 0) {\n\t\t\tpf->flags &= ~(I40E_FLAG_MSIX_ENABLED\t|\n\t\t\t\t       I40E_FLAG_IWARP_ENABLED\t|\n\t\t\t\t       I40E_FLAG_RSS_ENABLED\t|\n\t\t\t\t       I40E_FLAG_DCB_CAPABLE\t|\n\t\t\t\t       I40E_FLAG_DCB_ENABLED\t|\n\t\t\t\t       I40E_FLAG_SRIOV_ENABLED\t|\n\t\t\t\t       I40E_FLAG_FD_SB_ENABLED\t|\n\t\t\t\t       I40E_FLAG_FD_ATR_ENABLED\t|\n\t\t\t\t       I40E_FLAG_VMDQ_ENABLED);\n\t\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\n\t\t\t/* rework the queue expectations without MSIX */\n\t\t\ti40e_determine_queue_usage(pf);\n\t\t}\n\t}\n\n\tif (!(pf->flags & I40E_FLAG_MSIX_ENABLED) &&\n\t    (pf->flags & I40E_FLAG_MSI_ENABLED)) {\n\t\tdev_info(&pf->pdev->dev, \"MSI-X not available, trying MSI\\n\");\n\t\tvectors = pci_enable_msi(pf->pdev);\n\t\tif (vectors < 0) {\n\t\t\tdev_info(&pf->pdev->dev, \"MSI init failed - %d\\n\",\n\t\t\t\t vectors);\n\t\t\tpf->flags &= ~I40E_FLAG_MSI_ENABLED;\n\t\t}\n\t\tvectors = 1;  /* one MSI or Legacy vector */\n\t}\n\n\tif (!(pf->flags & (I40E_FLAG_MSIX_ENABLED | I40E_FLAG_MSI_ENABLED)))\n\t\tdev_info(&pf->pdev->dev, \"MSI-X and MSI not available, falling back to Legacy IRQ\\n\");\n\n\t/* set up vector assignment tracking */\n\tsize = sizeof(struct i40e_lump_tracking) + (sizeof(u16) * vectors);\n\tpf->irq_pile = kzalloc(size, GFP_KERNEL);\n\tif (!pf->irq_pile)\n\t\treturn -ENOMEM;\n\n\tpf->irq_pile->num_entries = vectors;\n\tpf->irq_pile->search_hint = 0;\n\n\t/* track first vector for misc interrupts, ignore return */\n\t(void)i40e_get_lump(pf, pf->irq_pile, 1, I40E_PILE_VALID_BIT - 1);\n\n\treturn 0;\n}\n\n/**\n * i40e_restore_interrupt_scheme - Restore the interrupt scheme\n * @pf: private board data structure\n *\n * Restore the interrupt scheme that was cleared when we suspended the\n * device. This should be called during resume to re-allocate the q_vectors\n * and reacquire IRQs.\n */\nstatic int i40e_restore_interrupt_scheme(struct i40e_pf *pf)\n{\n\tint err, i;\n\n\t/* We cleared the MSI and MSI-X flags when disabling the old interrupt\n\t * scheme. We need to re-enabled them here in order to attempt to\n\t * re-acquire the MSI or MSI-X vectors\n\t */\n\tpf->flags |= (I40E_FLAG_MSIX_ENABLED | I40E_FLAG_MSI_ENABLED);\n\n\terr = i40e_init_interrupt_scheme(pf);\n\tif (err)\n\t\treturn err;\n\n\t/* Now that we've re-acquired IRQs, we need to remap the vectors and\n\t * rings together again.\n\t */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (pf->vsi[i]) {\n\t\t\terr = i40e_vsi_alloc_q_vectors(pf->vsi[i]);\n\t\t\tif (err)\n\t\t\t\tgoto err_unwind;\n\t\t\ti40e_vsi_map_rings_to_vectors(pf->vsi[i]);\n\t\t}\n\t}\n\n\terr = i40e_setup_misc_vector(pf);\n\tif (err)\n\t\tgoto err_unwind;\n\n\tif (pf->flags & I40E_FLAG_IWARP_ENABLED)\n\t\ti40e_client_update_msix_info(pf);\n\n\treturn 0;\n\nerr_unwind:\n\twhile (i--) {\n\t\tif (pf->vsi[i])\n\t\t\ti40e_vsi_free_q_vectors(pf->vsi[i]);\n\t}\n\n\treturn err;\n}\n\n/**\n * i40e_setup_misc_vector_for_recovery_mode - Setup the misc vector to handle\n * non queue events in recovery mode\n * @pf: board private structure\n *\n * This sets up the handler for MSIX 0 or MSI/legacy, which is used to manage\n * the non-queue interrupts, e.g. AdminQ and errors in recovery mode.\n * This is handled differently than in recovery mode since no Tx/Rx resources\n * are being allocated.\n **/\nstatic int i40e_setup_misc_vector_for_recovery_mode(struct i40e_pf *pf)\n{\n\tint err;\n\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\terr = i40e_setup_misc_vector(pf);\n\n\t\tif (err) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"MSI-X misc vector request failed, error %d\\n\",\n\t\t\t\t err);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tu32 flags = pf->flags & I40E_FLAG_MSI_ENABLED ? 0 : IRQF_SHARED;\n\n\t\terr = request_irq(pf->pdev->irq, i40e_intr, flags,\n\t\t\t\t  pf->int_name, pf);\n\n\t\tif (err) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"MSI/legacy misc vector request failed, error %d\\n\",\n\t\t\t\t err);\n\t\t\treturn err;\n\t\t}\n\t\ti40e_enable_misc_int_causes(pf);\n\t\ti40e_irq_dynamic_enable_icr0(pf);\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_setup_misc_vector - Setup the misc vector to handle non queue events\n * @pf: board private structure\n *\n * This sets up the handler for MSIX 0, which is used to manage the\n * non-queue interrupts, e.g. AdminQ and errors.  This is not used\n * when in MSI or Legacy interrupt mode.\n **/\nstatic int i40e_setup_misc_vector(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tint err = 0;\n\n\t/* Only request the IRQ once, the first time through. */\n\tif (!test_and_set_bit(__I40E_MISC_IRQ_REQUESTED, pf->state)) {\n\t\terr = request_irq(pf->msix_entries[0].vector,\n\t\t\t\t  i40e_intr, 0, pf->int_name, pf);\n\t\tif (err) {\n\t\t\tclear_bit(__I40E_MISC_IRQ_REQUESTED, pf->state);\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"request_irq for %s failed: %d\\n\",\n\t\t\t\t pf->int_name, err);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\ti40e_enable_misc_int_causes(pf);\n\n\t/* associate no queues to the misc vector */\n\twr32(hw, I40E_PFINT_LNKLST0, I40E_QUEUE_END_OF_LIST);\n\twr32(hw, I40E_PFINT_ITR0(I40E_RX_ITR), I40E_ITR_8K >> 1);\n\n\ti40e_flush(hw);\n\n\ti40e_irq_dynamic_enable_icr0(pf);\n\n\treturn err;\n}\n\n/**\n * i40e_get_rss_aq - Get RSS keys and lut by using AQ commands\n * @vsi: Pointer to vsi structure\n * @seed: Buffter to store the hash keys\n * @lut: Buffer to store the lookup table entries\n * @lut_size: Size of buffer to store the lookup table entries\n *\n * Return 0 on success, negative on failure\n */\nstatic int i40e_get_rss_aq(struct i40e_vsi *vsi, const u8 *seed,\n\t\t\t   u8 *lut, u16 lut_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tint ret = 0;\n\n\tif (seed) {\n\t\tret = i40e_aq_get_rss_key(hw, vsi->id,\n\t\t\t(struct i40e_aqc_get_set_rss_key_data *)seed);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Cannot get RSS key, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (lut) {\n\t\tbool pf_lut = vsi->type == I40E_VSI_MAIN;\n\n\t\tret = i40e_aq_get_rss_lut(hw, vsi->id, pf_lut, lut, lut_size);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Cannot get RSS lut, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_config_rss_reg - Configure RSS keys and lut by writing registers\n * @vsi: Pointer to vsi structure\n * @seed: RSS hash seed\n * @lut: Lookup table\n * @lut_size: Lookup table size\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int i40e_config_rss_reg(struct i40e_vsi *vsi, const u8 *seed,\n\t\t\t       const u8 *lut, u16 lut_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 vf_id = vsi->vf_id;\n\tu8 i;\n\n\t/* Fill out hash function seed */\n\tif (seed) {\n\t\tu32 *seed_dw = (u32 *)seed;\n\n\t\tif (vsi->type == I40E_VSI_MAIN) {\n\t\t\tfor (i = 0; i <= I40E_PFQF_HKEY_MAX_INDEX; i++)\n\t\t\t\twr32(hw, I40E_PFQF_HKEY(i), seed_dw[i]);\n\t\t} else if (vsi->type == I40E_VSI_SRIOV) {\n\t\t\tfor (i = 0; i <= I40E_VFQF_HKEY1_MAX_INDEX; i++)\n\t\t\t\twr32(hw, I40E_VFQF_HKEY1(i, vf_id), seed_dw[i]);\n\t\t} else {\n\t\t\tdev_err(&pf->pdev->dev, \"Cannot set RSS seed - invalid VSI type\\n\");\n\t\t}\n\t}\n\n\tif (lut) {\n\t\tu32 *lut_dw = (u32 *)lut;\n\n\t\tif (vsi->type == I40E_VSI_MAIN) {\n\t\t\tif (lut_size != I40E_HLUT_ARRAY_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i <= I40E_PFQF_HLUT_MAX_INDEX; i++)\n\t\t\t\twr32(hw, I40E_PFQF_HLUT(i), lut_dw[i]);\n\t\t} else if (vsi->type == I40E_VSI_SRIOV) {\n\t\t\tif (lut_size != I40E_VF_HLUT_ARRAY_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i <= I40E_VFQF_HLUT_MAX_INDEX; i++)\n\t\t\t\twr32(hw, I40E_VFQF_HLUT1(i, vf_id), lut_dw[i]);\n\t\t} else {\n\t\t\tdev_err(&pf->pdev->dev, \"Cannot set RSS LUT - invalid VSI type\\n\");\n\t\t}\n\t}\n\ti40e_flush(hw);\n\n\treturn 0;\n}\n\n/**\n * i40e_get_rss_reg - Get the RSS keys and lut by reading registers\n * @vsi: Pointer to VSI structure\n * @seed: Buffer to store the keys\n * @lut: Buffer to store the lookup table entries\n * @lut_size: Size of buffer to store the lookup table entries\n *\n * Returns 0 on success, negative on failure\n */\nstatic int i40e_get_rss_reg(struct i40e_vsi *vsi, u8 *seed,\n\t\t\t    u8 *lut, u16 lut_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 i;\n\n\tif (seed) {\n\t\tu32 *seed_dw = (u32 *)seed;\n\n\t\tfor (i = 0; i <= I40E_PFQF_HKEY_MAX_INDEX; i++)\n\t\t\tseed_dw[i] = i40e_read_rx_ctl(hw, I40E_PFQF_HKEY(i));\n\t}\n\tif (lut) {\n\t\tu32 *lut_dw = (u32 *)lut;\n\n\t\tif (lut_size != I40E_HLUT_ARRAY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i <= I40E_PFQF_HLUT_MAX_INDEX; i++)\n\t\t\tlut_dw[i] = rd32(hw, I40E_PFQF_HLUT(i));\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_config_rss - Configure RSS keys and lut\n * @vsi: Pointer to VSI structure\n * @seed: RSS hash seed\n * @lut: Lookup table\n * @lut_size: Lookup table size\n *\n * Returns 0 on success, negative on failure\n */\nint i40e_config_rss(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\tif (pf->hw_features & I40E_HW_RSS_AQ_CAPABLE)\n\t\treturn i40e_config_rss_aq(vsi, seed, lut, lut_size);\n\telse\n\t\treturn i40e_config_rss_reg(vsi, seed, lut, lut_size);\n}\n\n/**\n * i40e_get_rss - Get RSS keys and lut\n * @vsi: Pointer to VSI structure\n * @seed: Buffer to store the keys\n * @lut: Buffer to store the lookup table entries\n * @lut_size: Size of buffer to store the lookup table entries\n *\n * Returns 0 on success, negative on failure\n */\nint i40e_get_rss(struct i40e_vsi *vsi, u8 *seed, u8 *lut, u16 lut_size)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\tif (pf->hw_features & I40E_HW_RSS_AQ_CAPABLE)\n\t\treturn i40e_get_rss_aq(vsi, seed, lut, lut_size);\n\telse\n\t\treturn i40e_get_rss_reg(vsi, seed, lut, lut_size);\n}\n\n/**\n * i40e_fill_rss_lut - Fill the RSS lookup table with default values\n * @pf: Pointer to board private structure\n * @lut: Lookup table\n * @rss_table_size: Lookup table size\n * @rss_size: Range of queue number for hashing\n */\nvoid i40e_fill_rss_lut(struct i40e_pf *pf, u8 *lut,\n\t\t       u16 rss_table_size, u16 rss_size)\n{\n\tu16 i;\n\n\tfor (i = 0; i < rss_table_size; i++)\n\t\tlut[i] = i % rss_size;\n}\n\n/**\n * i40e_pf_config_rss - Prepare for RSS if used\n * @pf: board private structure\n **/\nstatic int i40e_pf_config_rss(struct i40e_pf *pf)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tu8 seed[I40E_HKEY_ARRAY_SIZE];\n\tu8 *lut;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 reg_val;\n\tu64 hena;\n\tint ret;\n\n\t/* By default we enable TCP/UDP with IPv4/IPv6 ptypes */\n\thena = (u64)i40e_read_rx_ctl(hw, I40E_PFQF_HENA(0)) |\n\t\t((u64)i40e_read_rx_ctl(hw, I40E_PFQF_HENA(1)) << 32);\n\thena |= i40e_pf_get_default_rss_hena(pf);\n\n\ti40e_write_rx_ctl(hw, I40E_PFQF_HENA(0), (u32)hena);\n\ti40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), (u32)(hena >> 32));\n\n\t/* Determine the RSS table size based on the hardware capabilities */\n\treg_val = i40e_read_rx_ctl(hw, I40E_PFQF_CTL_0);\n\treg_val = (pf->rss_table_size == 512) ?\n\t\t\t(reg_val | I40E_PFQF_CTL_0_HASHLUTSIZE_512) :\n\t\t\t(reg_val & ~I40E_PFQF_CTL_0_HASHLUTSIZE_512);\n\ti40e_write_rx_ctl(hw, I40E_PFQF_CTL_0, reg_val);\n\n\t/* Determine the RSS size of the VSI */\n\tif (!vsi->rss_size) {\n\t\tu16 qcount;\n\t\t/* If the firmware does something weird during VSI init, we\n\t\t * could end up with zero TCs. Check for that to avoid\n\t\t * divide-by-zero. It probably won't pass traffic, but it also\n\t\t * won't panic.\n\t\t */\n\t\tqcount = vsi->num_queue_pairs /\n\t\t\t (vsi->tc_config.numtc ? vsi->tc_config.numtc : 1);\n\t\tvsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);\n\t}\n\tif (!vsi->rss_size)\n\t\treturn -EINVAL;\n\n\tlut = kzalloc(vsi->rss_table_size, GFP_KERNEL);\n\tif (!lut)\n\t\treturn -ENOMEM;\n\n\t/* Use user configured lut if there is one, otherwise use default */\n\tif (vsi->rss_lut_user)\n\t\tmemcpy(lut, vsi->rss_lut_user, vsi->rss_table_size);\n\telse\n\t\ti40e_fill_rss_lut(pf, lut, vsi->rss_table_size, vsi->rss_size);\n\n\t/* Use user configured hash key if there is one, otherwise\n\t * use default.\n\t */\n\tif (vsi->rss_hkey_user)\n\t\tmemcpy(seed, vsi->rss_hkey_user, I40E_HKEY_ARRAY_SIZE);\n\telse\n\t\tnetdev_rss_key_fill((void *)seed, I40E_HKEY_ARRAY_SIZE);\n\tret = i40e_config_rss(vsi, seed, lut, vsi->rss_table_size);\n\tkfree(lut);\n\n\treturn ret;\n}\n\n/**\n * i40e_reconfig_rss_queues - change number of queues for rss and rebuild\n * @pf: board private structure\n * @queue_count: the requested queue count for rss.\n *\n * returns 0 if rss is not enabled, if enabled returns the final rss queue\n * count which may be different from the requested queue count.\n * Note: expects to be called while under rtnl_lock()\n **/\nint i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)\n{\n\tstruct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];\n\tint new_rss_size;\n\n\tif (!(pf->flags & I40E_FLAG_RSS_ENABLED))\n\t\treturn 0;\n\n\tqueue_count = min_t(int, queue_count, num_online_cpus());\n\tnew_rss_size = min_t(int, queue_count, pf->rss_size_max);\n\n\tif (queue_count != vsi->num_queue_pairs) {\n\t\tu16 qcount;\n\n\t\tvsi->req_queue_pairs = queue_count;\n\t\ti40e_prep_for_reset(pf, true);\n\n\t\tpf->alloc_rss_size = new_rss_size;\n\n\t\ti40e_reset_and_rebuild(pf, true, true);\n\n\t\t/* Discard the user configured hash keys and lut, if less\n\t\t * queues are enabled.\n\t\t */\n\t\tif (queue_count < vsi->rss_size) {\n\t\t\ti40e_clear_rss_config_user(vsi);\n\t\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\t\"discard user configured hash keys and lut\\n\");\n\t\t}\n\n\t\t/* Reset vsi->rss_size, as number of enabled queues changed */\n\t\tqcount = vsi->num_queue_pairs / vsi->tc_config.numtc;\n\t\tvsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);\n\n\t\ti40e_pf_config_rss(pf);\n\t}\n\tdev_info(&pf->pdev->dev, \"User requested queue count/HW max RSS count:  %d/%d\\n\",\n\t\t vsi->req_queue_pairs, pf->rss_size_max);\n\treturn pf->alloc_rss_size;\n}\n\n/**\n * i40e_get_partition_bw_setting - Retrieve BW settings for this PF partition\n * @pf: board private structure\n **/\ni40e_status i40e_get_partition_bw_setting(struct i40e_pf *pf)\n{\n\ti40e_status status;\n\tbool min_valid, max_valid;\n\tu32 max_bw, min_bw;\n\n\tstatus = i40e_read_bw_from_alt_ram(&pf->hw, &max_bw, &min_bw,\n\t\t\t\t\t   &min_valid, &max_valid);\n\n\tif (!status) {\n\t\tif (min_valid)\n\t\t\tpf->min_bw = min_bw;\n\t\tif (max_valid)\n\t\t\tpf->max_bw = max_bw;\n\t}\n\n\treturn status;\n}\n\n/**\n * i40e_set_partition_bw_setting - Set BW settings for this PF partition\n * @pf: board private structure\n **/\ni40e_status i40e_set_partition_bw_setting(struct i40e_pf *pf)\n{\n\tstruct i40e_aqc_configure_partition_bw_data bw_data;\n\ti40e_status status;\n\n\t/* Set the valid bit for this PF */\n\tbw_data.pf_valid_bits = cpu_to_le16(BIT(pf->hw.pf_id));\n\tbw_data.max_bw[pf->hw.pf_id] = pf->max_bw & I40E_ALT_BW_VALUE_MASK;\n\tbw_data.min_bw[pf->hw.pf_id] = pf->min_bw & I40E_ALT_BW_VALUE_MASK;\n\n\t/* Set the new bandwidths */\n\tstatus = i40e_aq_configure_partition_bw(&pf->hw, &bw_data, NULL);\n\n\treturn status;\n}\n\n/**\n * i40e_commit_partition_bw_setting - Commit BW settings for this PF partition\n * @pf: board private structure\n **/\ni40e_status i40e_commit_partition_bw_setting(struct i40e_pf *pf)\n{\n\t/* Commit temporary BW setting to permanent NVM image */\n\tenum i40e_admin_queue_err last_aq_status;\n\ti40e_status ret;\n\tu16 nvm_word;\n\n\tif (pf->hw.partition_id != 1) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Commit BW only works on partition 1! This is partition %d\",\n\t\t\t pf->hw.partition_id);\n\t\tret = I40E_NOT_SUPPORTED;\n\t\tgoto bw_commit_out;\n\t}\n\n\t/* Acquire NVM for read access */\n\tret = i40e_acquire_nvm(&pf->hw, I40E_RESOURCE_READ);\n\tlast_aq_status = pf->hw.aq.asq_last_status;\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Cannot acquire NVM for read access, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, last_aq_status));\n\t\tgoto bw_commit_out;\n\t}\n\n\t/* Read word 0x10 of NVM - SW compatibility word 1 */\n\tret = i40e_aq_read_nvm(&pf->hw,\n\t\t\t       I40E_SR_NVM_CONTROL_WORD,\n\t\t\t       0x10, sizeof(nvm_word), &nvm_word,\n\t\t\t       false, NULL);\n\t/* Save off last admin queue command status before releasing\n\t * the NVM\n\t */\n\tlast_aq_status = pf->hw.aq.asq_last_status;\n\ti40e_release_nvm(&pf->hw);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"NVM read error, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, last_aq_status));\n\t\tgoto bw_commit_out;\n\t}\n\n\t/* Wait a bit for NVM release to complete */\n\tmsleep(50);\n\n\t/* Acquire NVM for write access */\n\tret = i40e_acquire_nvm(&pf->hw, I40E_RESOURCE_WRITE);\n\tlast_aq_status = pf->hw.aq.asq_last_status;\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"Cannot acquire NVM for write access, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, last_aq_status));\n\t\tgoto bw_commit_out;\n\t}\n\t/* Write it back out unchanged to initiate update NVM,\n\t * which will force a write of the shadow (alt) RAM to\n\t * the NVM - thus storing the bandwidth values permanently.\n\t */\n\tret = i40e_aq_update_nvm(&pf->hw,\n\t\t\t\t I40E_SR_NVM_CONTROL_WORD,\n\t\t\t\t 0x10, sizeof(nvm_word),\n\t\t\t\t &nvm_word, true, 0, NULL);\n\t/* Save off last admin queue command status before releasing\n\t * the NVM\n\t */\n\tlast_aq_status = pf->hw.aq.asq_last_status;\n\ti40e_release_nvm(&pf->hw);\n\tif (ret)\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"BW settings NOT SAVED, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, last_aq_status));\nbw_commit_out:\n\n\treturn ret;\n}\n\n/**\n * i40e_is_total_port_shutdown_enabled - read NVM and return value\n * if total port shutdown feature is enabled for this PF\n * @pf: board private structure\n **/\nstatic bool i40e_is_total_port_shutdown_enabled(struct i40e_pf *pf)\n{\n#define I40E_TOTAL_PORT_SHUTDOWN_ENABLED\tBIT(4)\n#define I40E_FEATURES_ENABLE_PTR\t\t0x2A\n#define I40E_CURRENT_SETTING_PTR\t\t0x2B\n#define I40E_LINK_BEHAVIOR_WORD_OFFSET\t\t0x2D\n#define I40E_LINK_BEHAVIOR_WORD_LENGTH\t\t0x1\n#define I40E_LINK_BEHAVIOR_OS_FORCED_ENABLED\tBIT(0)\n#define I40E_LINK_BEHAVIOR_PORT_BIT_LENGTH\t4\n\ti40e_status read_status = I40E_SUCCESS;\n\tu16 sr_emp_sr_settings_ptr = 0;\n\tu16 features_enable = 0;\n\tu16 link_behavior = 0;\n\tbool ret = false;\n\n\tread_status = i40e_read_nvm_word(&pf->hw,\n\t\t\t\t\t I40E_SR_EMP_SR_SETTINGS_PTR,\n\t\t\t\t\t &sr_emp_sr_settings_ptr);\n\tif (read_status)\n\t\tgoto err_nvm;\n\tread_status = i40e_read_nvm_word(&pf->hw,\n\t\t\t\t\t sr_emp_sr_settings_ptr +\n\t\t\t\t\t I40E_FEATURES_ENABLE_PTR,\n\t\t\t\t\t &features_enable);\n\tif (read_status)\n\t\tgoto err_nvm;\n\tif (I40E_TOTAL_PORT_SHUTDOWN_ENABLED & features_enable) {\n\t\tread_status = i40e_read_nvm_module_data(&pf->hw,\n\t\t\t\t\t\t\tI40E_SR_EMP_SR_SETTINGS_PTR,\n\t\t\t\t\t\t\tI40E_CURRENT_SETTING_PTR,\n\t\t\t\t\t\t\tI40E_LINK_BEHAVIOR_WORD_OFFSET,\n\t\t\t\t\t\t\tI40E_LINK_BEHAVIOR_WORD_LENGTH,\n\t\t\t\t\t\t\t&link_behavior);\n\t\tif (read_status)\n\t\t\tgoto err_nvm;\n\t\tlink_behavior >>= (pf->hw.port * I40E_LINK_BEHAVIOR_PORT_BIT_LENGTH);\n\t\tret = I40E_LINK_BEHAVIOR_OS_FORCED_ENABLED & link_behavior;\n\t}\n\treturn ret;\n\nerr_nvm:\n\tdev_warn(&pf->pdev->dev,\n\t\t \"total-port-shutdown feature is off due to read nvm error: %s\\n\",\n\t\t i40e_stat_str(&pf->hw, read_status));\n\treturn ret;\n}\n\n/**\n * i40e_sw_init - Initialize general software structures (struct i40e_pf)\n * @pf: board private structure to initialize\n *\n * i40e_sw_init initializes the Adapter private data structure.\n * Fields are initialized based on PCI device information and\n * OS network device settings (MTU size).\n **/\nstatic int i40e_sw_init(struct i40e_pf *pf)\n{\n\tint err = 0;\n\tint size;\n\n\t/* Set default capability flags */\n\tpf->flags = I40E_FLAG_RX_CSUM_ENABLED |\n\t\t    I40E_FLAG_MSI_ENABLED     |\n\t\t    I40E_FLAG_MSIX_ENABLED;\n\n\t/* Set default ITR */\n\tpf->rx_itr_default = I40E_ITR_RX_DEF;\n\tpf->tx_itr_default = I40E_ITR_TX_DEF;\n\n\t/* Depending on PF configurations, it is possible that the RSS\n\t * maximum might end up larger than the available queues\n\t */\n\tpf->rss_size_max = BIT(pf->hw.func_caps.rss_table_entry_width);\n\tpf->alloc_rss_size = 1;\n\tpf->rss_table_size = pf->hw.func_caps.rss_table_size;\n\tpf->rss_size_max = min_t(int, pf->rss_size_max,\n\t\t\t\t pf->hw.func_caps.num_tx_qp);\n\tif (pf->hw.func_caps.rss) {\n\t\tpf->flags |= I40E_FLAG_RSS_ENABLED;\n\t\tpf->alloc_rss_size = min_t(int, pf->rss_size_max,\n\t\t\t\t\t   num_online_cpus());\n\t}\n\n\t/* MFP mode enabled */\n\tif (pf->hw.func_caps.npar_enable || pf->hw.func_caps.flex10_enable) {\n\t\tpf->flags |= I40E_FLAG_MFP_ENABLED;\n\t\tdev_info(&pf->pdev->dev, \"MFP mode Enabled\\n\");\n\t\tif (i40e_get_partition_bw_setting(pf)) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"Could not get partition bw settings\\n\");\n\t\t} else {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Partition BW Min = %8.8x, Max = %8.8x\\n\",\n\t\t\t\t pf->min_bw, pf->max_bw);\n\n\t\t\t/* nudge the Tx scheduler */\n\t\t\ti40e_set_partition_bw_setting(pf);\n\t\t}\n\t}\n\n\tif ((pf->hw.func_caps.fd_filters_guaranteed > 0) ||\n\t    (pf->hw.func_caps.fd_filters_best_effort > 0)) {\n\t\tpf->flags |= I40E_FLAG_FD_ATR_ENABLED;\n\t\tpf->atr_sample_rate = I40E_DEFAULT_ATR_SAMPLE_RATE;\n\t\tif (pf->flags & I40E_FLAG_MFP_ENABLED &&\n\t\t    pf->hw.num_partitions > 1)\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"Flow Director Sideband mode Disabled in MFP mode\\n\");\n\t\telse\n\t\t\tpf->flags |= I40E_FLAG_FD_SB_ENABLED;\n\t\tpf->fdir_pf_filter_count =\n\t\t\t\t pf->hw.func_caps.fd_filters_guaranteed;\n\t\tpf->hw.fdir_shared_filter_count =\n\t\t\t\t pf->hw.func_caps.fd_filters_best_effort;\n\t}\n\n\tif (pf->hw.mac.type == I40E_MAC_X722) {\n\t\tpf->hw_features |= (I40E_HW_RSS_AQ_CAPABLE |\n\t\t\t\t    I40E_HW_128_QP_RSS_CAPABLE |\n\t\t\t\t    I40E_HW_ATR_EVICT_CAPABLE |\n\t\t\t\t    I40E_HW_WB_ON_ITR_CAPABLE |\n\t\t\t\t    I40E_HW_MULTIPLE_TCP_UDP_RSS_PCTYPE |\n\t\t\t\t    I40E_HW_NO_PCI_LINK_CHECK |\n\t\t\t\t    I40E_HW_USE_SET_LLDP_MIB |\n\t\t\t\t    I40E_HW_GENEVE_OFFLOAD_CAPABLE |\n\t\t\t\t    I40E_HW_PTP_L4_CAPABLE |\n\t\t\t\t    I40E_HW_WOL_MC_MAGIC_PKT_WAKE |\n\t\t\t\t    I40E_HW_OUTER_UDP_CSUM_CAPABLE);\n\n#define I40E_FDEVICT_PCTYPE_DEFAULT 0xc03\n\t\tif (rd32(&pf->hw, I40E_GLQF_FDEVICTENA(1)) !=\n\t\t    I40E_FDEVICT_PCTYPE_DEFAULT) {\n\t\t\tdev_warn(&pf->pdev->dev,\n\t\t\t\t \"FD EVICT PCTYPES are not right, disable FD HW EVICT\\n\");\n\t\t\tpf->hw_features &= ~I40E_HW_ATR_EVICT_CAPABLE;\n\t\t}\n\t} else if ((pf->hw.aq.api_maj_ver > 1) ||\n\t\t   ((pf->hw.aq.api_maj_ver == 1) &&\n\t\t    (pf->hw.aq.api_min_ver > 4))) {\n\t\t/* Supported in FW API version higher than 1.4 */\n\t\tpf->hw_features |= I40E_HW_GENEVE_OFFLOAD_CAPABLE;\n\t}\n\n\t/* Enable HW ATR eviction if possible */\n\tif (pf->hw_features & I40E_HW_ATR_EVICT_CAPABLE)\n\t\tpf->flags |= I40E_FLAG_HW_ATR_EVICT_ENABLED;\n\n\tif ((pf->hw.mac.type == I40E_MAC_XL710) &&\n\t    (((pf->hw.aq.fw_maj_ver == 4) && (pf->hw.aq.fw_min_ver < 33)) ||\n\t    (pf->hw.aq.fw_maj_ver < 4))) {\n\t\tpf->hw_features |= I40E_HW_RESTART_AUTONEG;\n\t\t/* No DCB support  for FW < v4.33 */\n\t\tpf->hw_features |= I40E_HW_NO_DCB_SUPPORT;\n\t}\n\n\t/* Disable FW LLDP if FW < v4.3 */\n\tif ((pf->hw.mac.type == I40E_MAC_XL710) &&\n\t    (((pf->hw.aq.fw_maj_ver == 4) && (pf->hw.aq.fw_min_ver < 3)) ||\n\t    (pf->hw.aq.fw_maj_ver < 4)))\n\t\tpf->hw_features |= I40E_HW_STOP_FW_LLDP;\n\n\t/* Use the FW Set LLDP MIB API if FW > v4.40 */\n\tif ((pf->hw.mac.type == I40E_MAC_XL710) &&\n\t    (((pf->hw.aq.fw_maj_ver == 4) && (pf->hw.aq.fw_min_ver >= 40)) ||\n\t    (pf->hw.aq.fw_maj_ver >= 5)))\n\t\tpf->hw_features |= I40E_HW_USE_SET_LLDP_MIB;\n\n\t/* Enable PTP L4 if FW > v6.0 */\n\tif (pf->hw.mac.type == I40E_MAC_XL710 &&\n\t    pf->hw.aq.fw_maj_ver >= 6)\n\t\tpf->hw_features |= I40E_HW_PTP_L4_CAPABLE;\n\n\tif (pf->hw.func_caps.vmdq && num_online_cpus() != 1) {\n\t\tpf->num_vmdq_vsis = I40E_DEFAULT_NUM_VMDQ_VSI;\n\t\tpf->flags |= I40E_FLAG_VMDQ_ENABLED;\n\t\tpf->num_vmdq_qps = i40e_default_queues_per_vmdq(pf);\n\t}\n\n\tif (pf->hw.func_caps.iwarp && num_online_cpus() != 1) {\n\t\tpf->flags |= I40E_FLAG_IWARP_ENABLED;\n\t\t/* IWARP needs one extra vector for CQP just like MISC.*/\n\t\tpf->num_iwarp_msix = (int)num_online_cpus() + 1;\n\t}\n\t/* Stopping FW LLDP engine is supported on XL710 and X722\n\t * starting from FW versions determined in i40e_init_adminq.\n\t * Stopping the FW LLDP engine is not supported on XL710\n\t * if NPAR is functioning so unset this hw flag in this case.\n\t */\n\tif (pf->hw.mac.type == I40E_MAC_XL710 &&\n\t    pf->hw.func_caps.npar_enable &&\n\t    (pf->hw.flags & I40E_HW_FLAG_FW_LLDP_STOPPABLE))\n\t\tpf->hw.flags &= ~I40E_HW_FLAG_FW_LLDP_STOPPABLE;\n\n#ifdef CONFIG_PCI_IOV\n\tif (pf->hw.func_caps.num_vfs && pf->hw.partition_id == 1) {\n\t\tpf->num_vf_qps = I40E_DEFAULT_QUEUES_PER_VF;\n\t\tpf->flags |= I40E_FLAG_SRIOV_ENABLED;\n\t\tpf->num_req_vfs = min_t(int,\n\t\t\t\t\tpf->hw.func_caps.num_vfs,\n\t\t\t\t\tI40E_MAX_VF_COUNT);\n\t}\n#endif /* CONFIG_PCI_IOV */\n\tpf->eeprom_version = 0xDEAD;\n\tpf->lan_veb = I40E_NO_VEB;\n\tpf->lan_vsi = I40E_NO_VSI;\n\n\t/* By default FW has this off for performance reasons */\n\tpf->flags &= ~I40E_FLAG_VEB_STATS_ENABLED;\n\n\t/* set up queue assignment tracking */\n\tsize = sizeof(struct i40e_lump_tracking)\n\t\t+ (sizeof(u16) * pf->hw.func_caps.num_tx_qp);\n\tpf->qp_pile = kzalloc(size, GFP_KERNEL);\n\tif (!pf->qp_pile) {\n\t\terr = -ENOMEM;\n\t\tgoto sw_init_done;\n\t}\n\tpf->qp_pile->num_entries = pf->hw.func_caps.num_tx_qp;\n\tpf->qp_pile->search_hint = 0;\n\n\tpf->tx_timeout_recovery_level = 1;\n\n\tif (pf->hw.mac.type != I40E_MAC_X722 &&\n\t    i40e_is_total_port_shutdown_enabled(pf)) {\n\t\t/* Link down on close must be on when total port shutdown\n\t\t * is enabled for a given port\n\t\t */\n\t\tpf->flags |= (I40E_FLAG_TOTAL_PORT_SHUTDOWN_ENABLED |\n\t\t\t      I40E_FLAG_LINK_DOWN_ON_CLOSE_ENABLED);\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"total-port-shutdown was enabled, link-down-on-close is forced on\\n\");\n\t}\n\tmutex_init(&pf->switch_mutex);\n\nsw_init_done:\n\treturn err;\n}\n\n/**\n * i40e_set_ntuple - set the ntuple feature flag and take action\n * @pf: board private structure to initialize\n * @features: the feature set that the stack is suggesting\n *\n * returns a bool to indicate if reset needs to happen\n **/\nbool i40e_set_ntuple(struct i40e_pf *pf, netdev_features_t features)\n{\n\tbool need_reset = false;\n\n\t/* Check if Flow Director n-tuple support was enabled or disabled.  If\n\t * the state changed, we need to reset.\n\t */\n\tif (features & NETIF_F_NTUPLE) {\n\t\t/* Enable filters and mark for reset */\n\t\tif (!(pf->flags & I40E_FLAG_FD_SB_ENABLED))\n\t\t\tneed_reset = true;\n\t\t/* enable FD_SB only if there is MSI-X vector and no cloud\n\t\t * filters exist\n\t\t */\n\t\tif (pf->num_fdsb_msix > 0 && !pf->num_cloud_filters) {\n\t\t\tpf->flags |= I40E_FLAG_FD_SB_ENABLED;\n\t\t\tpf->flags &= ~I40E_FLAG_FD_SB_INACTIVE;\n\t\t}\n\t} else {\n\t\t/* turn off filters, mark for reset and clear SW filter list */\n\t\tif (pf->flags & I40E_FLAG_FD_SB_ENABLED) {\n\t\t\tneed_reset = true;\n\t\t\ti40e_fdir_filter_exit(pf);\n\t\t}\n\t\tpf->flags &= ~I40E_FLAG_FD_SB_ENABLED;\n\t\tclear_bit(__I40E_FD_SB_AUTO_DISABLED, pf->state);\n\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\n\t\t/* reset fd counters */\n\t\tpf->fd_add_err = 0;\n\t\tpf->fd_atr_cnt = 0;\n\t\t/* if ATR was auto disabled it can be re-enabled. */\n\t\tif (test_and_clear_bit(__I40E_FD_ATR_AUTO_DISABLED, pf->state))\n\t\t\tif ((pf->flags & I40E_FLAG_FD_ATR_ENABLED) &&\n\t\t\t    (I40E_DEBUG_FD & pf->hw.debug_mask))\n\t\t\t\tdev_info(&pf->pdev->dev, \"ATR re-enabled.\\n\");\n\t}\n\treturn need_reset;\n}\n\n/**\n * i40e_clear_rss_lut - clear the rx hash lookup table\n * @vsi: the VSI being configured\n **/\nstatic void i40e_clear_rss_lut(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu16 vf_id = vsi->vf_id;\n\tu8 i;\n\n\tif (vsi->type == I40E_VSI_MAIN) {\n\t\tfor (i = 0; i <= I40E_PFQF_HLUT_MAX_INDEX; i++)\n\t\t\twr32(hw, I40E_PFQF_HLUT(i), 0);\n\t} else if (vsi->type == I40E_VSI_SRIOV) {\n\t\tfor (i = 0; i <= I40E_VFQF_HLUT_MAX_INDEX; i++)\n\t\t\ti40e_write_rx_ctl(hw, I40E_VFQF_HLUT1(i, vf_id), 0);\n\t} else {\n\t\tdev_err(&pf->pdev->dev, \"Cannot set RSS LUT - invalid VSI type\\n\");\n\t}\n}\n\n/**\n * i40e_set_features - set the netdev feature flags\n * @netdev: ptr to the netdev being adjusted\n * @features: the feature set that the stack is suggesting\n * Note: expects to be called while under rtnl_lock()\n **/\nstatic int i40e_set_features(struct net_device *netdev,\n\t\t\t     netdev_features_t features)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tbool need_reset;\n\n\tif (features & NETIF_F_RXHASH && !(netdev->features & NETIF_F_RXHASH))\n\t\ti40e_pf_config_rss(pf);\n\telse if (!(features & NETIF_F_RXHASH) &&\n\t\t netdev->features & NETIF_F_RXHASH)\n\t\ti40e_clear_rss_lut(vsi);\n\n\tif (features & NETIF_F_HW_VLAN_CTAG_RX)\n\t\ti40e_vlan_stripping_enable(vsi);\n\telse\n\t\ti40e_vlan_stripping_disable(vsi);\n\n\tif (!(features & NETIF_F_HW_TC) && pf->num_cloud_filters) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Offloaded tc filters active, can't turn hw_tc_offload off\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(features & NETIF_F_HW_L2FW_DOFFLOAD) && vsi->macvlan_cnt)\n\t\ti40e_del_all_macvlans(vsi);\n\n\tneed_reset = i40e_set_ntuple(pf, features);\n\n\tif (need_reset)\n\t\ti40e_do_reset(pf, I40E_PF_RESET_FLAG, true);\n\n\treturn 0;\n}\n\nstatic int i40e_udp_tunnel_set_port(struct net_device *netdev,\n\t\t\t\t    unsigned int table, unsigned int idx,\n\t\t\t\t    struct udp_tunnel_info *ti)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_hw *hw = &np->vsi->back->hw;\n\tu8 type, filter_index;\n\ti40e_status ret;\n\n\ttype = ti->type == UDP_TUNNEL_TYPE_VXLAN ? I40E_AQC_TUNNEL_TYPE_VXLAN :\n\t\t\t\t\t\t   I40E_AQC_TUNNEL_TYPE_NGE;\n\n\tret = i40e_aq_add_udp_tunnel(hw, ntohs(ti->port), type, &filter_index,\n\t\t\t\t     NULL);\n\tif (ret) {\n\t\tnetdev_info(netdev, \"add UDP port failed, err %s aq_err %s\\n\",\n\t\t\t    i40e_stat_str(hw, ret),\n\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn -EIO;\n\t}\n\n\tudp_tunnel_nic_set_port_priv(netdev, table, idx, filter_index);\n\treturn 0;\n}\n\nstatic int i40e_udp_tunnel_unset_port(struct net_device *netdev,\n\t\t\t\t      unsigned int table, unsigned int idx,\n\t\t\t\t      struct udp_tunnel_info *ti)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_hw *hw = &np->vsi->back->hw;\n\ti40e_status ret;\n\n\tret = i40e_aq_del_udp_tunnel(hw, ti->hw_priv, NULL);\n\tif (ret) {\n\t\tnetdev_info(netdev, \"delete UDP port failed, err %s aq_err %s\\n\",\n\t\t\t    i40e_stat_str(hw, ret),\n\t\t\t    i40e_aq_str(hw, hw->aq.asq_last_status));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int i40e_get_phys_port_id(struct net_device *netdev,\n\t\t\t\t struct netdev_phys_item_id *ppid)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(netdev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\n\tif (!(pf->hw_features & I40E_HW_PORT_ID_VALID))\n\t\treturn -EOPNOTSUPP;\n\n\tppid->id_len = min_t(int, sizeof(hw->mac.port_addr), sizeof(ppid->id));\n\tmemcpy(ppid->id, hw->mac.port_addr, ppid->id_len);\n\n\treturn 0;\n}\n\n/**\n * i40e_ndo_fdb_add - add an entry to the hardware database\n * @ndm: the input from the stack\n * @tb: pointer to array of nladdr (unused)\n * @dev: the net device pointer\n * @addr: the MAC address entry being added\n * @vid: VLAN ID\n * @flags: instructions from stack about fdb operation\n * @extack: netlink extended ack, unused currently\n */\nstatic int i40e_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr, u16 vid,\n\t\t\t    u16 flags,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tstruct i40e_pf *pf = np->vsi->back;\n\tint err = 0;\n\n\tif (!(pf->flags & I40E_FLAG_SRIOV_ENABLED))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vid) {\n\t\tpr_info(\"%s: vlans aren't supported yet for dev_uc|mc_add()\\n\", dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Hardware does not support aging addresses so if a\n\t * ndm_state is given only allow permanent addresses\n\t */\n\tif (ndm->ndm_state && !(ndm->ndm_state & NUD_PERMANENT)) {\n\t\tnetdev_info(dev, \"FDB only supports static addresses\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))\n\t\terr = dev_uc_add_excl(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_add_excl(dev, addr);\n\telse\n\t\terr = -EINVAL;\n\n\t/* Only return duplicate errors if NLM_F_EXCL is set */\n\tif (err == -EEXIST && !(flags & NLM_F_EXCL))\n\t\terr = 0;\n\n\treturn err;\n}\n\n/**\n * i40e_ndo_bridge_setlink - Set the hardware bridge mode\n * @dev: the netdev being configured\n * @nlh: RTNL message\n * @flags: bridge flags\n * @extack: netlink extended ack\n *\n * Inserts a new hardware bridge if not already created and\n * enables the bridging mode requested (VEB or VEPA). If the\n * hardware bridge has already been inserted and the request\n * is to change the mode then that requires a PF reset to\n * allow rebuild of the components with required hardware\n * bridge mode enabled.\n *\n * Note: expects to be called while under rtnl_lock()\n **/\nstatic int i40e_ndo_bridge_setlink(struct net_device *dev,\n\t\t\t\t   struct nlmsghdr *nlh,\n\t\t\t\t   u16 flags,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_veb *veb = NULL;\n\tstruct nlattr *attr, *br_spec;\n\tint i, rem;\n\n\t/* Only for PF VSI for now */\n\tif (vsi->seid != pf->vsi[pf->lan_vsi]->seid)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Find the HW bridge for PF VSI */\n\tfor (i = 0; i < I40E_MAX_VEB && !veb; i++) {\n\t\tif (pf->veb[i] && pf->veb[i]->seid == vsi->uplink_seid)\n\t\t\tveb = pf->veb[i];\n\t}\n\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\n\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t__u16 mode;\n\n\t\tif (nla_type(attr) != IFLA_BRIDGE_MODE)\n\t\t\tcontinue;\n\n\t\tmode = nla_get_u16(attr);\n\t\tif ((mode != BRIDGE_MODE_VEPA) &&\n\t\t    (mode != BRIDGE_MODE_VEB))\n\t\t\treturn -EINVAL;\n\n\t\t/* Insert a new HW bridge */\n\t\tif (!veb) {\n\t\t\tveb = i40e_veb_setup(pf, 0, vsi->uplink_seid, vsi->seid,\n\t\t\t\t\t     vsi->tc_config.enabled_tc);\n\t\t\tif (veb) {\n\t\t\t\tveb->bridge_mode = mode;\n\t\t\t\ti40e_config_bridge_mode(veb);\n\t\t\t} else {\n\t\t\t\t/* No Bridge HW offload available */\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if (mode != veb->bridge_mode) {\n\t\t\t/* Existing HW bridge but different mode needs reset */\n\t\t\tveb->bridge_mode = mode;\n\t\t\t/* TODO: If no VFs or VMDq VSIs, disallow VEB mode */\n\t\t\tif (mode == BRIDGE_MODE_VEB)\n\t\t\t\tpf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\n\t\t\telse\n\t\t\t\tpf->flags &= ~I40E_FLAG_VEB_MODE_ENABLED;\n\t\t\ti40e_do_reset(pf, I40E_PF_RESET_FLAG, true);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_ndo_bridge_getlink - Get the hardware bridge mode\n * @skb: skb buff\n * @pid: process id\n * @seq: RTNL message seq #\n * @dev: the netdev being configured\n * @filter_mask: unused\n * @nlflags: netlink flags passed in\n *\n * Return the mode in which the hardware bridge is operating in\n * i.e VEB or VEPA.\n **/\nstatic int i40e_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   u32 __always_unused filter_mask,\n\t\t\t\t   int nlflags)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_veb *veb = NULL;\n\tint i;\n\n\t/* Only for PF VSI for now */\n\tif (vsi->seid != pf->vsi[pf->lan_vsi]->seid)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Find the HW bridge for the PF VSI */\n\tfor (i = 0; i < I40E_MAX_VEB && !veb; i++) {\n\t\tif (pf->veb[i] && pf->veb[i]->seid == vsi->uplink_seid)\n\t\t\tveb = pf->veb[i];\n\t}\n\n\tif (!veb)\n\t\treturn 0;\n\n\treturn ndo_dflt_bridge_getlink(skb, pid, seq, dev, veb->bridge_mode,\n\t\t\t\t       0, 0, nlflags, filter_mask, NULL);\n}\n\n/**\n * i40e_features_check - Validate encapsulated packet conforms to limits\n * @skb: skb buff\n * @dev: This physical port's netdev\n * @features: Offload features that the stack believes apply\n **/\nstatic netdev_features_t i40e_features_check(struct sk_buff *skb,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n\tsize_t len;\n\n\t/* No point in doing any of this if neither checksum nor GSO are\n\t * being requested for this frame.  We can rule out both by just\n\t * checking for CHECKSUM_PARTIAL\n\t */\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn features;\n\n\t/* We cannot support GSO if the MSS is going to be less than\n\t * 64 bytes.  If it is then we need to drop support for GSO.\n\t */\n\tif (skb_is_gso(skb) && (skb_shinfo(skb)->gso_size < 64))\n\t\tfeatures &= ~NETIF_F_GSO_MASK;\n\n\t/* MACLEN can support at most 63 words */\n\tlen = skb_network_header(skb) - skb->data;\n\tif (len & ~(63 * 2))\n\t\tgoto out_err;\n\n\t/* IPLEN and EIPLEN can support at most 127 dwords */\n\tlen = skb_transport_header(skb) - skb_network_header(skb);\n\tif (len & ~(127 * 4))\n\t\tgoto out_err;\n\n\tif (skb->encapsulation) {\n\t\t/* L4TUNLEN can support 127 words */\n\t\tlen = skb_inner_network_header(skb) - skb_transport_header(skb);\n\t\tif (len & ~(127 * 2))\n\t\t\tgoto out_err;\n\n\t\t/* IPLEN can support at most 127 dwords */\n\t\tlen = skb_inner_transport_header(skb) -\n\t\t      skb_inner_network_header(skb);\n\t\tif (len & ~(127 * 4))\n\t\t\tgoto out_err;\n\t}\n\n\t/* No need to validate L4LEN as TCP is the only protocol with a\n\t * a flexible value and we support all possible values supported\n\t * by TCP, which is at most 15 dwords\n\t */\n\n\treturn features;\nout_err:\n\treturn features & ~(NETIF_F_CSUM_MASK | NETIF_F_GSO_MASK);\n}\n\n/**\n * i40e_xdp_setup - add/remove an XDP program\n * @vsi: VSI to changed\n * @prog: XDP program\n **/\nstatic int i40e_xdp_setup(struct i40e_vsi *vsi,\n\t\t\t  struct bpf_prog *prog)\n{\n\tint frame_size = vsi->netdev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct bpf_prog *old_prog;\n\tbool need_reset;\n\tint i;\n\n\t/* Don't allow frames that span over multiple buffers */\n\tif (frame_size > vsi->rx_buf_len)\n\t\treturn -EINVAL;\n\n\tif (!i40e_enabled_xdp_vsi(vsi) && !prog)\n\t\treturn 0;\n\n\t/* When turning XDP on->off/off->on we reset and rebuild the rings. */\n\tneed_reset = (i40e_enabled_xdp_vsi(vsi) != !!prog);\n\n\tif (need_reset)\n\t\ti40e_prep_for_reset(pf, true);\n\n\told_prog = xchg(&vsi->xdp_prog, prog);\n\n\tif (need_reset) {\n\t\tif (!prog)\n\t\t\t/* Wait until ndo_xsk_wakeup completes. */\n\t\t\tsynchronize_rcu();\n\t\ti40e_reset_and_rebuild(pf, true, true);\n\t}\n\n\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\tWRITE_ONCE(vsi->rx_rings[i]->xdp_prog, vsi->xdp_prog);\n\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\t/* Kick start the NAPI context if there is an AF_XDP socket open\n\t * on that queue id. This so that receiving will start.\n\t */\n\tif (need_reset && prog)\n\t\tfor (i = 0; i < vsi->num_queue_pairs; i++)\n\t\t\tif (vsi->xdp_rings[i]->xsk_pool)\n\t\t\t\t(void)i40e_xsk_wakeup(vsi->netdev, i,\n\t\t\t\t\t\t      XDP_WAKEUP_RX);\n\n\treturn 0;\n}\n\n/**\n * i40e_enter_busy_conf - Enters busy config state\n * @vsi: vsi\n *\n * Returns 0 on success, <0 for failure.\n **/\nstatic int i40e_enter_busy_conf(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint timeout = 50;\n\n\twhile (test_and_set_bit(__I40E_CONFIG_BUSY, pf->state)) {\n\t\ttimeout--;\n\t\tif (!timeout)\n\t\t\treturn -EBUSY;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\n/**\n * i40e_exit_busy_conf - Exits busy config state\n * @vsi: vsi\n **/\nstatic void i40e_exit_busy_conf(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\n\tclear_bit(__I40E_CONFIG_BUSY, pf->state);\n}\n\n/**\n * i40e_queue_pair_reset_stats - Resets all statistics for a queue pair\n * @vsi: vsi\n * @queue_pair: queue pair\n **/\nstatic void i40e_queue_pair_reset_stats(struct i40e_vsi *vsi, int queue_pair)\n{\n\tmemset(&vsi->rx_rings[queue_pair]->rx_stats, 0,\n\t       sizeof(vsi->rx_rings[queue_pair]->rx_stats));\n\tmemset(&vsi->tx_rings[queue_pair]->stats, 0,\n\t       sizeof(vsi->tx_rings[queue_pair]->stats));\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\tmemset(&vsi->xdp_rings[queue_pair]->stats, 0,\n\t\t       sizeof(vsi->xdp_rings[queue_pair]->stats));\n\t}\n}\n\n/**\n * i40e_queue_pair_clean_rings - Cleans all the rings of a queue pair\n * @vsi: vsi\n * @queue_pair: queue pair\n **/\nstatic void i40e_queue_pair_clean_rings(struct i40e_vsi *vsi, int queue_pair)\n{\n\ti40e_clean_tx_ring(vsi->tx_rings[queue_pair]);\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\t/* Make sure that in-progress ndo_xdp_xmit calls are\n\t\t * completed.\n\t\t */\n\t\tsynchronize_rcu();\n\t\ti40e_clean_tx_ring(vsi->xdp_rings[queue_pair]);\n\t}\n\ti40e_clean_rx_ring(vsi->rx_rings[queue_pair]);\n}\n\n/**\n * i40e_queue_pair_toggle_napi - Enables/disables NAPI for a queue pair\n * @vsi: vsi\n * @queue_pair: queue pair\n * @enable: true for enable, false for disable\n **/\nstatic void i40e_queue_pair_toggle_napi(struct i40e_vsi *vsi, int queue_pair,\n\t\t\t\t\tbool enable)\n{\n\tstruct i40e_ring *rxr = vsi->rx_rings[queue_pair];\n\tstruct i40e_q_vector *q_vector = rxr->q_vector;\n\n\tif (!vsi->netdev)\n\t\treturn;\n\n\t/* All rings in a qp belong to the same qvector. */\n\tif (q_vector->rx.ring || q_vector->tx.ring) {\n\t\tif (enable)\n\t\t\tnapi_enable(&q_vector->napi);\n\t\telse\n\t\t\tnapi_disable(&q_vector->napi);\n\t}\n}\n\n/**\n * i40e_queue_pair_toggle_rings - Enables/disables all rings for a queue pair\n * @vsi: vsi\n * @queue_pair: queue pair\n * @enable: true for enable, false for disable\n *\n * Returns 0 on success, <0 on failure.\n **/\nstatic int i40e_queue_pair_toggle_rings(struct i40e_vsi *vsi, int queue_pair,\n\t\t\t\t\tbool enable)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tint pf_q, ret = 0;\n\n\tpf_q = vsi->base_queue + queue_pair;\n\tret = i40e_control_wait_tx_q(vsi->seid, pf, pf_q,\n\t\t\t\t     false /*is xdp*/, enable);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VSI seid %d Tx ring %d %sable timeout\\n\",\n\t\t\t vsi->seid, pf_q, (enable ? \"en\" : \"dis\"));\n\t\treturn ret;\n\t}\n\n\ti40e_control_rx_q(pf, pf_q, enable);\n\tret = i40e_pf_rxq_wait(pf, pf_q, enable);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VSI seid %d Rx ring %d %sable timeout\\n\",\n\t\t\t vsi->seid, pf_q, (enable ? \"en\" : \"dis\"));\n\t\treturn ret;\n\t}\n\n\t/* Due to HW errata, on Rx disable only, the register can\n\t * indicate done before it really is. Needs 50ms to be sure\n\t */\n\tif (!enable)\n\t\tmdelay(50);\n\n\tif (!i40e_enabled_xdp_vsi(vsi))\n\t\treturn ret;\n\n\tret = i40e_control_wait_tx_q(vsi->seid, pf,\n\t\t\t\t     pf_q + vsi->alloc_queue_pairs,\n\t\t\t\t     true /*is xdp*/, enable);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"VSI seid %d XDP Tx ring %d %sable timeout\\n\",\n\t\t\t vsi->seid, pf_q, (enable ? \"en\" : \"dis\"));\n\t}\n\n\treturn ret;\n}\n\n/**\n * i40e_queue_pair_enable_irq - Enables interrupts for a queue pair\n * @vsi: vsi\n * @queue_pair: queue_pair\n **/\nstatic void i40e_queue_pair_enable_irq(struct i40e_vsi *vsi, int queue_pair)\n{\n\tstruct i40e_ring *rxr = vsi->rx_rings[queue_pair];\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\n\t/* All rings in a qp belong to the same qvector. */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED)\n\t\ti40e_irq_dynamic_enable(vsi, rxr->q_vector->v_idx);\n\telse\n\t\ti40e_irq_dynamic_enable_icr0(pf);\n\n\ti40e_flush(hw);\n}\n\n/**\n * i40e_queue_pair_disable_irq - Disables interrupts for a queue pair\n * @vsi: vsi\n * @queue_pair: queue_pair\n **/\nstatic void i40e_queue_pair_disable_irq(struct i40e_vsi *vsi, int queue_pair)\n{\n\tstruct i40e_ring *rxr = vsi->rx_rings[queue_pair];\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\n\t/* For simplicity, instead of removing the qp interrupt causes\n\t * from the interrupt linked list, we simply disable the interrupt, and\n\t * leave the list intact.\n\t *\n\t * All rings in a qp belong to the same qvector.\n\t */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\tu32 intpf = vsi->base_vector + rxr->q_vector->v_idx;\n\n\t\twr32(hw, I40E_PFINT_DYN_CTLN(intpf - 1), 0);\n\t\ti40e_flush(hw);\n\t\tsynchronize_irq(pf->msix_entries[intpf].vector);\n\t} else {\n\t\t/* Legacy and MSI mode - this stops all interrupt handling */\n\t\twr32(hw, I40E_PFINT_ICR0_ENA, 0);\n\t\twr32(hw, I40E_PFINT_DYN_CTL0, 0);\n\t\ti40e_flush(hw);\n\t\tsynchronize_irq(pf->pdev->irq);\n\t}\n}\n\n/**\n * i40e_queue_pair_disable - Disables a queue pair\n * @vsi: vsi\n * @queue_pair: queue pair\n *\n * Returns 0 on success, <0 on failure.\n **/\nint i40e_queue_pair_disable(struct i40e_vsi *vsi, int queue_pair)\n{\n\tint err;\n\n\terr = i40e_enter_busy_conf(vsi);\n\tif (err)\n\t\treturn err;\n\n\ti40e_queue_pair_disable_irq(vsi, queue_pair);\n\terr = i40e_queue_pair_toggle_rings(vsi, queue_pair, false /* off */);\n\ti40e_queue_pair_toggle_napi(vsi, queue_pair, false /* off */);\n\ti40e_queue_pair_clean_rings(vsi, queue_pair);\n\ti40e_queue_pair_reset_stats(vsi, queue_pair);\n\n\treturn err;\n}\n\n/**\n * i40e_queue_pair_enable - Enables a queue pair\n * @vsi: vsi\n * @queue_pair: queue pair\n *\n * Returns 0 on success, <0 on failure.\n **/\nint i40e_queue_pair_enable(struct i40e_vsi *vsi, int queue_pair)\n{\n\tint err;\n\n\terr = i40e_configure_tx_ring(vsi->tx_rings[queue_pair]);\n\tif (err)\n\t\treturn err;\n\n\tif (i40e_enabled_xdp_vsi(vsi)) {\n\t\terr = i40e_configure_tx_ring(vsi->xdp_rings[queue_pair]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = i40e_configure_rx_ring(vsi->rx_rings[queue_pair]);\n\tif (err)\n\t\treturn err;\n\n\terr = i40e_queue_pair_toggle_rings(vsi, queue_pair, true /* on */);\n\ti40e_queue_pair_toggle_napi(vsi, queue_pair, true /* on */);\n\ti40e_queue_pair_enable_irq(vsi, queue_pair);\n\n\ti40e_exit_busy_conf(vsi);\n\n\treturn err;\n}\n\n/**\n * i40e_xdp - implements ndo_bpf for i40e\n * @dev: netdevice\n * @xdp: XDP command\n **/\nstatic int i40e_xdp(struct net_device *dev,\n\t\t    struct netdev_bpf *xdp)\n{\n\tstruct i40e_netdev_priv *np = netdev_priv(dev);\n\tstruct i40e_vsi *vsi = np->vsi;\n\n\tif (vsi->type != I40E_VSI_MAIN)\n\t\treturn -EINVAL;\n\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn i40e_xdp_setup(vsi, xdp->prog);\n\tcase XDP_SETUP_XSK_POOL:\n\t\treturn i40e_xsk_pool_setup(vsi, xdp->xsk.pool,\n\t\t\t\t\t   xdp->xsk.queue_id);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct net_device_ops i40e_netdev_ops = {\n\t.ndo_open\t\t= i40e_open,\n\t.ndo_stop\t\t= i40e_close,\n\t.ndo_start_xmit\t\t= i40e_lan_xmit_frame,\n\t.ndo_get_stats64\t= i40e_get_netdev_stats_struct,\n\t.ndo_set_rx_mode\t= i40e_set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= i40e_set_mac,\n\t.ndo_change_mtu\t\t= i40e_change_mtu,\n\t.ndo_do_ioctl\t\t= i40e_ioctl,\n\t.ndo_tx_timeout\t\t= i40e_tx_timeout,\n\t.ndo_vlan_rx_add_vid\t= i40e_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= i40e_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= i40e_netpoll,\n#endif\n\t.ndo_setup_tc\t\t= __i40e_setup_tc,\n\t.ndo_set_features\t= i40e_set_features,\n\t.ndo_set_vf_mac\t\t= i40e_ndo_set_vf_mac,\n\t.ndo_set_vf_vlan\t= i40e_ndo_set_vf_port_vlan,\n\t.ndo_get_vf_stats\t= i40e_get_vf_stats,\n\t.ndo_set_vf_rate\t= i40e_ndo_set_vf_bw,\n\t.ndo_get_vf_config\t= i40e_ndo_get_vf_config,\n\t.ndo_set_vf_link_state\t= i40e_ndo_set_vf_link_state,\n\t.ndo_set_vf_spoofchk\t= i40e_ndo_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= i40e_ndo_set_vf_trust,\n\t.ndo_udp_tunnel_add\t= udp_tunnel_nic_add_port,\n\t.ndo_udp_tunnel_del\t= udp_tunnel_nic_del_port,\n\t.ndo_get_phys_port_id\t= i40e_get_phys_port_id,\n\t.ndo_fdb_add\t\t= i40e_ndo_fdb_add,\n\t.ndo_features_check\t= i40e_features_check,\n\t.ndo_bridge_getlink\t= i40e_ndo_bridge_getlink,\n\t.ndo_bridge_setlink\t= i40e_ndo_bridge_setlink,\n\t.ndo_bpf\t\t= i40e_xdp,\n\t.ndo_xdp_xmit\t\t= i40e_xdp_xmit,\n\t.ndo_xsk_wakeup\t        = i40e_xsk_wakeup,\n\t.ndo_dfwd_add_station\t= i40e_fwd_add,\n\t.ndo_dfwd_del_station\t= i40e_fwd_del,\n};\n\n/**\n * i40e_config_netdev - Setup the netdev flags\n * @vsi: the VSI being configured\n *\n * Returns 0 on success, negative value on failure\n **/\nstatic int i40e_config_netdev(struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_netdev_priv *np;\n\tstruct net_device *netdev;\n\tu8 broadcast[ETH_ALEN];\n\tu8 mac_addr[ETH_ALEN];\n\tint etherdev_size;\n\tnetdev_features_t hw_enc_features;\n\tnetdev_features_t hw_features;\n\n\tetherdev_size = sizeof(struct i40e_netdev_priv);\n\tnetdev = alloc_etherdev_mq(etherdev_size, vsi->alloc_queue_pairs);\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tvsi->netdev = netdev;\n\tnp = netdev_priv(netdev);\n\tnp->vsi = vsi;\n\n\thw_enc_features = NETIF_F_SG\t\t\t|\n\t\t\t  NETIF_F_IP_CSUM\t\t|\n\t\t\t  NETIF_F_IPV6_CSUM\t\t|\n\t\t\t  NETIF_F_HIGHDMA\t\t|\n\t\t\t  NETIF_F_SOFT_FEATURES\t\t|\n\t\t\t  NETIF_F_TSO\t\t\t|\n\t\t\t  NETIF_F_TSO_ECN\t\t|\n\t\t\t  NETIF_F_TSO6\t\t\t|\n\t\t\t  NETIF_F_GSO_GRE\t\t|\n\t\t\t  NETIF_F_GSO_GRE_CSUM\t\t|\n\t\t\t  NETIF_F_GSO_PARTIAL\t\t|\n\t\t\t  NETIF_F_GSO_IPXIP4\t\t|\n\t\t\t  NETIF_F_GSO_IPXIP6\t\t|\n\t\t\t  NETIF_F_GSO_UDP_TUNNEL\t|\n\t\t\t  NETIF_F_GSO_UDP_TUNNEL_CSUM\t|\n\t\t\t  NETIF_F_GSO_UDP_L4\t\t|\n\t\t\t  NETIF_F_SCTP_CRC\t\t|\n\t\t\t  NETIF_F_RXHASH\t\t|\n\t\t\t  NETIF_F_RXCSUM\t\t|\n\t\t\t  0;\n\n\tif (!(pf->hw_features & I40E_HW_OUTER_UDP_CSUM_CAPABLE))\n\t\tnetdev->gso_partial_features |= NETIF_F_GSO_UDP_TUNNEL_CSUM;\n\n\tnetdev->udp_tunnel_nic_info = &pf->udp_tunnel_nic;\n\n\tnetdev->gso_partial_features |= NETIF_F_GSO_GRE_CSUM;\n\n\tnetdev->hw_enc_features |= hw_enc_features;\n\n\t/* record features VLANs can make use of */\n\tnetdev->vlan_features |= hw_enc_features | NETIF_F_TSO_MANGLEID;\n\n\t/* enable macvlan offloads */\n\tnetdev->hw_features |= NETIF_F_HW_L2FW_DOFFLOAD;\n\n\thw_features = hw_enc_features\t\t|\n\t\t      NETIF_F_HW_VLAN_CTAG_TX\t|\n\t\t      NETIF_F_HW_VLAN_CTAG_RX;\n\n\tif (!(pf->flags & I40E_FLAG_MFP_ENABLED))\n\t\thw_features |= NETIF_F_NTUPLE | NETIF_F_HW_TC;\n\n\tnetdev->hw_features |= hw_features;\n\n\tnetdev->features |= hw_features | NETIF_F_HW_VLAN_CTAG_FILTER;\n\tnetdev->hw_enc_features |= NETIF_F_TSO_MANGLEID;\n\n\tif (vsi->type == I40E_VSI_MAIN) {\n\t\tSET_NETDEV_DEV(netdev, &pf->pdev->dev);\n\t\tether_addr_copy(mac_addr, hw->mac.perm_addr);\n\t\t/* The following steps are necessary for two reasons. First,\n\t\t * some older NVM configurations load a default MAC-VLAN\n\t\t * filter that will accept any tagged packet, and we want to\n\t\t * replace this with a normal filter. Additionally, it is\n\t\t * possible our MAC address was provided by the platform using\n\t\t * Open Firmware or similar.\n\t\t *\n\t\t * Thus, we need to remove the default filter and install one\n\t\t * specific to the MAC address.\n\t\t */\n\t\ti40e_rm_default_mac_filter(vsi, mac_addr);\n\t\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t\ti40e_add_mac_filter(vsi, mac_addr);\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t} else {\n\t\t/* Relate the VSI_VMDQ name to the VSI_MAIN name. Note that we\n\t\t * are still limited by IFNAMSIZ, but we're adding 'v%d\\0' to\n\t\t * the end, which is 4 bytes long, so force truncation of the\n\t\t * original name by IFNAMSIZ - 4\n\t\t */\n\t\tsnprintf(netdev->name, IFNAMSIZ, \"%.*sv%%d\",\n\t\t\t IFNAMSIZ - 4,\n\t\t\t pf->vsi[pf->lan_vsi]->netdev->name);\n\t\teth_random_addr(mac_addr);\n\n\t\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t\ti40e_add_mac_filter(vsi, mac_addr);\n\t\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\t}\n\n\t/* Add the broadcast filter so that we initially will receive\n\t * broadcast packets. Note that when a new VLAN is first added the\n\t * driver will convert all filters marked I40E_VLAN_ANY into VLAN\n\t * specific filters as part of transitioning into \"vlan\" operation.\n\t * When more VLANs are added, the driver will copy each existing MAC\n\t * filter and add it for the new VLAN.\n\t *\n\t * Broadcast filters are handled specially by\n\t * i40e_sync_filters_subtask, as the driver must to set the broadcast\n\t * promiscuous bit instead of adding this directly as a MAC/VLAN\n\t * filter. The subtask will update the correct broadcast promiscuous\n\t * bits as VLANs become active or inactive.\n\t */\n\teth_broadcast_addr(broadcast);\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\ti40e_add_mac_filter(vsi, broadcast);\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\tether_addr_copy(netdev->dev_addr, mac_addr);\n\tether_addr_copy(netdev->perm_addr, mac_addr);\n\n\t/* i40iw_net_event() reads 16 bytes from neigh->primary_key */\n\tnetdev->neigh_priv_len = sizeof(u32) * 4;\n\n\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\tnetdev->priv_flags |= IFF_SUPP_NOFCS;\n\t/* Setup netdev TC information */\n\ti40e_vsi_config_netdev_tc(vsi, vsi->tc_config.enabled_tc);\n\n\tnetdev->netdev_ops = &i40e_netdev_ops;\n\tnetdev->watchdog_timeo = 5 * HZ;\n\ti40e_set_ethtool_ops(netdev);\n\n\t/* MTU range: 68 - 9706 */\n\tnetdev->min_mtu = ETH_MIN_MTU;\n\tnetdev->max_mtu = I40E_MAX_RXBUFFER - I40E_PACKET_HDR_PAD;\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_delete - Delete a VSI from the switch\n * @vsi: the VSI being removed\n *\n * Returns 0 on success, negative value on failure\n **/\nstatic void i40e_vsi_delete(struct i40e_vsi *vsi)\n{\n\t/* remove default VSI is not allowed */\n\tif (vsi == vsi->back->vsi[vsi->back->lan_vsi])\n\t\treturn;\n\n\ti40e_aq_delete_element(&vsi->back->hw, vsi->seid, NULL);\n}\n\n/**\n * i40e_is_vsi_uplink_mode_veb - Check if the VSI's uplink bridge mode is VEB\n * @vsi: the VSI being queried\n *\n * Returns 1 if HW bridge mode is VEB and return 0 in case of VEPA mode\n **/\nint i40e_is_vsi_uplink_mode_veb(struct i40e_vsi *vsi)\n{\n\tstruct i40e_veb *veb;\n\tstruct i40e_pf *pf = vsi->back;\n\n\t/* Uplink is not a bridge so default to VEB */\n\tif (vsi->veb_idx >= I40E_MAX_VEB)\n\t\treturn 1;\n\n\tveb = pf->veb[vsi->veb_idx];\n\tif (!veb) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"There is no veb associated with the bridge\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t/* Uplink is a bridge in VEPA mode */\n\tif (veb->bridge_mode & BRIDGE_MODE_VEPA) {\n\t\treturn 0;\n\t} else {\n\t\t/* Uplink is a bridge in VEB mode */\n\t\treturn 1;\n\t}\n\n\t/* VEPA is now default bridge, so return 0 */\n\treturn 0;\n}\n\n/**\n * i40e_add_vsi - Add a VSI to the switch\n * @vsi: the VSI being configured\n *\n * This initializes a VSI context depending on the VSI type to be added and\n * passes it down to the add_vsi aq command.\n **/\nstatic int i40e_add_vsi(struct i40e_vsi *vsi)\n{\n\tint ret = -ENODEV;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct i40e_hw *hw = &pf->hw;\n\tstruct i40e_vsi_context ctxt;\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\tint bkt;\n\n\tu8 enabled_tc = 0x1; /* TC0 enabled */\n\tint f_count = 0;\n\n\tmemset(&ctxt, 0, sizeof(ctxt));\n\tswitch (vsi->type) {\n\tcase I40E_VSI_MAIN:\n\t\t/* The PF's main VSI is already setup as part of the\n\t\t * device initialization, so we'll not bother with\n\t\t * the add_vsi call, but we will retrieve the current\n\t\t * VSI context.\n\t\t */\n\t\tctxt.seid = pf->main_vsi_seid;\n\t\tctxt.pf_num = pf->hw.pf_id;\n\t\tctxt.vf_num = 0;\n\t\tret = i40e_aq_get_vsi_params(&pf->hw, &ctxt, NULL);\n\t\tctxt.flags = I40E_AQ_VSI_TYPE_PF;\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"couldn't get PF vsi config, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tvsi->info = ctxt.info;\n\t\tvsi->info.valid_sections = 0;\n\n\t\tvsi->seid = ctxt.seid;\n\t\tvsi->id = ctxt.vsi_number;\n\n\t\tenabled_tc = i40e_pf_get_tc_map(pf);\n\n\t\t/* Source pruning is enabled by default, so the flag is\n\t\t * negative logic - if it's set, we need to fiddle with\n\t\t * the VSI to disable source pruning.\n\t\t */\n\t\tif (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED) {\n\t\t\tmemset(&ctxt, 0, sizeof(ctxt));\n\t\t\tctxt.seid = pf->main_vsi_seid;\n\t\t\tctxt.pf_num = pf->hw.pf_id;\n\t\t\tctxt.vf_num = 0;\n\t\t\tctxt.info.valid_sections |=\n\t\t\t\t     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\t\t\tctxt.info.switch_id =\n\t\t\t\t   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_LOCAL_LB);\n\t\t\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"update vsi failed, err %s aq_err %s\\n\",\n\t\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\t/* MFP mode setup queue map and update VSI */\n\t\tif ((pf->flags & I40E_FLAG_MFP_ENABLED) &&\n\t\t    !(pf->hw.func_caps.iscsi)) { /* NIC type PF */\n\t\t\tmemset(&ctxt, 0, sizeof(ctxt));\n\t\t\tctxt.seid = pf->main_vsi_seid;\n\t\t\tctxt.pf_num = pf->hw.pf_id;\n\t\t\tctxt.vf_num = 0;\n\t\t\ti40e_vsi_setup_queue_map(vsi, &ctxt, enabled_tc, false);\n\t\t\tret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"update vsi failed, err %s aq_err %s\\n\",\n\t\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t\t    pf->hw.aq.asq_last_status));\n\t\t\t\tret = -ENOENT;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t/* update the local VSI info queue map */\n\t\t\ti40e_vsi_update_queue_map(vsi, &ctxt);\n\t\t\tvsi->info.valid_sections = 0;\n\t\t} else {\n\t\t\t/* Default/Main VSI is only enabled for TC0\n\t\t\t * reconfigure it to enable all TCs that are\n\t\t\t * available on the port in SFP mode.\n\t\t\t * For MFP case the iSCSI PF would use this\n\t\t\t * flow to enable LAN+iSCSI TC.\n\t\t\t */\n\t\t\tret = i40e_vsi_config_tc(vsi, enabled_tc);\n\t\t\tif (ret) {\n\t\t\t\t/* Single TC condition is not fatal,\n\t\t\t\t * message and continue\n\t\t\t\t */\n\t\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t\t \"failed to configure TCs for main VSI tc_map 0x%08x, err %s aq_err %s\\n\",\n\t\t\t\t\t enabled_tc,\n\t\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t\t    pf->hw.aq.asq_last_status));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase I40E_VSI_FDIR:\n\t\tctxt.pf_num = hw->pf_id;\n\t\tctxt.vf_num = 0;\n\t\tctxt.uplink_seid = vsi->uplink_seid;\n\t\tctxt.connection_type = I40E_AQ_VSI_CONN_TYPE_NORMAL;\n\t\tctxt.flags = I40E_AQ_VSI_TYPE_PF;\n\t\tif ((pf->flags & I40E_FLAG_VEB_MODE_ENABLED) &&\n\t\t    (i40e_is_vsi_uplink_mode_veb(vsi))) {\n\t\t\tctxt.info.valid_sections |=\n\t\t\t     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\t\t\tctxt.info.switch_id =\n\t\t\t   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\n\t\t}\n\t\ti40e_vsi_setup_queue_map(vsi, &ctxt, enabled_tc, true);\n\t\tbreak;\n\n\tcase I40E_VSI_VMDQ2:\n\t\tctxt.pf_num = hw->pf_id;\n\t\tctxt.vf_num = 0;\n\t\tctxt.uplink_seid = vsi->uplink_seid;\n\t\tctxt.connection_type = I40E_AQ_VSI_CONN_TYPE_NORMAL;\n\t\tctxt.flags = I40E_AQ_VSI_TYPE_VMDQ2;\n\n\t\t/* This VSI is connected to VEB so the switch_id\n\t\t * should be set to zero by default.\n\t\t */\n\t\tif (i40e_is_vsi_uplink_mode_veb(vsi)) {\n\t\t\tctxt.info.valid_sections |=\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\t\t\tctxt.info.switch_id =\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\n\t\t}\n\n\t\t/* Setup the VSI tx/rx queue map for TC0 only for now */\n\t\ti40e_vsi_setup_queue_map(vsi, &ctxt, enabled_tc, true);\n\t\tbreak;\n\n\tcase I40E_VSI_SRIOV:\n\t\tctxt.pf_num = hw->pf_id;\n\t\tctxt.vf_num = vsi->vf_id + hw->func_caps.vf_base_id;\n\t\tctxt.uplink_seid = vsi->uplink_seid;\n\t\tctxt.connection_type = I40E_AQ_VSI_CONN_TYPE_NORMAL;\n\t\tctxt.flags = I40E_AQ_VSI_TYPE_VF;\n\n\t\t/* This VSI is connected to VEB so the switch_id\n\t\t * should be set to zero by default.\n\t\t */\n\t\tif (i40e_is_vsi_uplink_mode_veb(vsi)) {\n\t\t\tctxt.info.valid_sections |=\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);\n\t\t\tctxt.info.switch_id =\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_ALLOW_LB);\n\t\t}\n\n\t\tif (vsi->back->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\t\tctxt.info.valid_sections |=\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_QUEUE_OPT_VALID);\n\t\t\tctxt.info.queueing_opt_flags |=\n\t\t\t\t(I40E_AQ_VSI_QUE_OPT_TCP_ENA |\n\t\t\t\t I40E_AQ_VSI_QUE_OPT_RSS_LUT_VSI);\n\t\t}\n\n\t\tctxt.info.valid_sections |= cpu_to_le16(I40E_AQ_VSI_PROP_VLAN_VALID);\n\t\tctxt.info.port_vlan_flags |= I40E_AQ_VSI_PVLAN_MODE_ALL;\n\t\tif (pf->vf[vsi->vf_id].spoofchk) {\n\t\t\tctxt.info.valid_sections |=\n\t\t\t\tcpu_to_le16(I40E_AQ_VSI_PROP_SECURITY_VALID);\n\t\t\tctxt.info.sec_flags |=\n\t\t\t\t(I40E_AQ_VSI_SEC_FLAG_ENABLE_VLAN_CHK |\n\t\t\t\t I40E_AQ_VSI_SEC_FLAG_ENABLE_MAC_CHK);\n\t\t}\n\t\t/* Setup the VSI tx/rx queue map for TC0 only for now */\n\t\ti40e_vsi_setup_queue_map(vsi, &ctxt, enabled_tc, true);\n\t\tbreak;\n\n\tcase I40E_VSI_IWARP:\n\t\t/* send down message to iWARP */\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (vsi->type != I40E_VSI_MAIN) {\n\t\tret = i40e_aq_add_vsi(hw, &ctxt, NULL);\n\t\tif (ret) {\n\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t \"add vsi failed, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\tret = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\t\tvsi->info = ctxt.info;\n\t\tvsi->info.valid_sections = 0;\n\t\tvsi->seid = ctxt.seid;\n\t\tvsi->id = ctxt.vsi_number;\n\t}\n\n\tvsi->active_filters = 0;\n\tclear_bit(__I40E_VSI_OVERFLOW_PROMISC, vsi->state);\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\t/* If macvlan filters already exist, force them to get loaded */\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {\n\t\tf->state = I40E_FILTER_NEW;\n\t\tf_count++;\n\t}\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\tif (f_count) {\n\t\tvsi->flags |= I40E_VSI_FLAG_FILTER_CHANGED;\n\t\tset_bit(__I40E_MACVLAN_SYNC_PENDING, pf->state);\n\t}\n\n\t/* Update VSI BW information */\n\tret = i40e_vsi_get_bw_info(vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get vsi bw info, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\t/* VSI is already added so not tearing that up */\n\t\tret = 0;\n\t}\n\nerr:\n\treturn ret;\n}\n\n/**\n * i40e_vsi_release - Delete a VSI and free its resources\n * @vsi: the VSI being removed\n *\n * Returns 0 on success or < 0 on error\n **/\nint i40e_vsi_release(struct i40e_vsi *vsi)\n{\n\tstruct i40e_mac_filter *f;\n\tstruct hlist_node *h;\n\tstruct i40e_veb *veb = NULL;\n\tstruct i40e_pf *pf;\n\tu16 uplink_seid;\n\tint i, n, bkt;\n\n\tpf = vsi->back;\n\n\t/* release of a VEB-owner or last VSI is not allowed */\n\tif (vsi->flags & I40E_VSI_FLAG_VEB_OWNER) {\n\t\tdev_info(&pf->pdev->dev, \"VSI %d has existing VEB %d\\n\",\n\t\t\t vsi->seid, vsi->uplink_seid);\n\t\treturn -ENODEV;\n\t}\n\tif (vsi == pf->vsi[pf->lan_vsi] &&\n\t    !test_bit(__I40E_DOWN, pf->state)) {\n\t\tdev_info(&pf->pdev->dev, \"Can't remove PF VSI\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tuplink_seid = vsi->uplink_seid;\n\tif (vsi->type != I40E_VSI_SRIOV) {\n\t\tif (vsi->netdev_registered) {\n\t\t\tvsi->netdev_registered = false;\n\t\t\tif (vsi->netdev) {\n\t\t\t\t/* results in a call to i40e_close() */\n\t\t\t\tunregister_netdev(vsi->netdev);\n\t\t\t}\n\t\t} else {\n\t\t\ti40e_vsi_close(vsi);\n\t\t}\n\t\ti40e_vsi_disable_irq(vsi);\n\t}\n\n\tspin_lock_bh(&vsi->mac_filter_hash_lock);\n\n\t/* clear the sync flag on all filters */\n\tif (vsi->netdev) {\n\t\t__dev_uc_unsync(vsi->netdev, NULL);\n\t\t__dev_mc_unsync(vsi->netdev, NULL);\n\t}\n\n\t/* make sure any remaining filters are marked for deletion */\n\thash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist)\n\t\t__i40e_del_filter(vsi, f);\n\n\tspin_unlock_bh(&vsi->mac_filter_hash_lock);\n\n\ti40e_sync_vsi_filters(vsi);\n\n\ti40e_vsi_delete(vsi);\n\ti40e_vsi_free_q_vectors(vsi);\n\tif (vsi->netdev) {\n\t\tfree_netdev(vsi->netdev);\n\t\tvsi->netdev = NULL;\n\t}\n\ti40e_vsi_clear_rings(vsi);\n\ti40e_vsi_clear(vsi);\n\n\t/* If this was the last thing on the VEB, except for the\n\t * controlling VSI, remove the VEB, which puts the controlling\n\t * VSI onto the next level down in the switch.\n\t *\n\t * Well, okay, there's one more exception here: don't remove\n\t * the orphan VEBs yet.  We'll wait for an explicit remove request\n\t * from up the network stack.\n\t */\n\tfor (n = 0, i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (pf->vsi[i] &&\n\t\t    pf->vsi[i]->uplink_seid == uplink_seid &&\n\t\t    (pf->vsi[i]->flags & I40E_VSI_FLAG_VEB_OWNER) == 0) {\n\t\t\tn++;      /* count the VSIs */\n\t\t}\n\t}\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tif (!pf->veb[i])\n\t\t\tcontinue;\n\t\tif (pf->veb[i]->uplink_seid == uplink_seid)\n\t\t\tn++;     /* count the VEBs */\n\t\tif (pf->veb[i]->seid == uplink_seid)\n\t\t\tveb = pf->veb[i];\n\t}\n\tif (n == 0 && veb && veb->uplink_seid != 0)\n\t\ti40e_veb_release(veb);\n\n\treturn 0;\n}\n\n/**\n * i40e_vsi_setup_vectors - Set up the q_vectors for the given VSI\n * @vsi: ptr to the VSI\n *\n * This should only be called after i40e_vsi_mem_alloc() which allocates the\n * corresponding SW VSI structure and initializes num_queue_pairs for the\n * newly allocated VSI.\n *\n * Returns 0 on success or negative on failure\n **/\nstatic int i40e_vsi_setup_vectors(struct i40e_vsi *vsi)\n{\n\tint ret = -ENOENT;\n\tstruct i40e_pf *pf = vsi->back;\n\n\tif (vsi->q_vectors[0]) {\n\t\tdev_info(&pf->pdev->dev, \"VSI %d has existing q_vectors\\n\",\n\t\t\t vsi->seid);\n\t\treturn -EEXIST;\n\t}\n\n\tif (vsi->base_vector) {\n\t\tdev_info(&pf->pdev->dev, \"VSI %d has non-zero base vector %d\\n\",\n\t\t\t vsi->seid, vsi->base_vector);\n\t\treturn -EEXIST;\n\t}\n\n\tret = i40e_vsi_alloc_q_vectors(vsi);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"failed to allocate %d q_vector for VSI %d, ret=%d\\n\",\n\t\t\t vsi->num_q_vectors, vsi->seid, ret);\n\t\tvsi->num_q_vectors = 0;\n\t\tgoto vector_setup_out;\n\t}\n\n\t/* In Legacy mode, we do not have to get any other vector since we\n\t * piggyback on the misc/ICR0 for queue interrupts.\n\t*/\n\tif (!(pf->flags & I40E_FLAG_MSIX_ENABLED))\n\t\treturn ret;\n\tif (vsi->num_q_vectors)\n\t\tvsi->base_vector = i40e_get_lump(pf, pf->irq_pile,\n\t\t\t\t\t\t vsi->num_q_vectors, vsi->idx);\n\tif (vsi->base_vector < 0) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"failed to get tracking for %d vectors for VSI %d, err=%d\\n\",\n\t\t\t vsi->num_q_vectors, vsi->seid, vsi->base_vector);\n\t\ti40e_vsi_free_q_vectors(vsi);\n\t\tret = -ENOENT;\n\t\tgoto vector_setup_out;\n\t}\n\nvector_setup_out:\n\treturn ret;\n}\n\n/**\n * i40e_vsi_reinit_setup - return and reallocate resources for a VSI\n * @vsi: pointer to the vsi.\n *\n * This re-allocates a vsi's queue resources.\n *\n * Returns pointer to the successfully allocated and configured VSI sw struct\n * on success, otherwise returns NULL on failure.\n **/\nstatic struct i40e_vsi *i40e_vsi_reinit_setup(struct i40e_vsi *vsi)\n{\n\tu16 alloc_queue_pairs;\n\tstruct i40e_pf *pf;\n\tu8 enabled_tc;\n\tint ret;\n\n\tif (!vsi)\n\t\treturn NULL;\n\n\tpf = vsi->back;\n\n\ti40e_put_lump(pf->qp_pile, vsi->base_queue, vsi->idx);\n\ti40e_vsi_clear_rings(vsi);\n\n\ti40e_vsi_free_arrays(vsi, false);\n\ti40e_set_num_rings_in_vsi(vsi);\n\tret = i40e_vsi_alloc_arrays(vsi, false);\n\tif (ret)\n\t\tgoto err_vsi;\n\n\talloc_queue_pairs = vsi->alloc_queue_pairs *\n\t\t\t    (i40e_enabled_xdp_vsi(vsi) ? 2 : 1);\n\n\tret = i40e_get_lump(pf, pf->qp_pile, alloc_queue_pairs, vsi->idx);\n\tif (ret < 0) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"failed to get tracking for %d queues for VSI %d err %d\\n\",\n\t\t\t alloc_queue_pairs, vsi->seid, ret);\n\t\tgoto err_vsi;\n\t}\n\tvsi->base_queue = ret;\n\n\t/* Update the FW view of the VSI. Force a reset of TC and queue\n\t * layout configurations.\n\t */\n\tenabled_tc = pf->vsi[pf->lan_vsi]->tc_config.enabled_tc;\n\tpf->vsi[pf->lan_vsi]->tc_config.enabled_tc = 0;\n\tpf->vsi[pf->lan_vsi]->seid = pf->main_vsi_seid;\n\ti40e_vsi_config_tc(pf->vsi[pf->lan_vsi], enabled_tc);\n\tif (vsi->type == I40E_VSI_MAIN)\n\t\ti40e_rm_default_mac_filter(vsi, pf->hw.mac.perm_addr);\n\n\t/* assign it some queues */\n\tret = i40e_alloc_rings(vsi);\n\tif (ret)\n\t\tgoto err_rings;\n\n\t/* map all of the rings to the q_vectors */\n\ti40e_vsi_map_rings_to_vectors(vsi);\n\treturn vsi;\n\nerr_rings:\n\ti40e_vsi_free_q_vectors(vsi);\n\tif (vsi->netdev_registered) {\n\t\tvsi->netdev_registered = false;\n\t\tunregister_netdev(vsi->netdev);\n\t\tfree_netdev(vsi->netdev);\n\t\tvsi->netdev = NULL;\n\t}\n\ti40e_aq_delete_element(&pf->hw, vsi->seid, NULL);\nerr_vsi:\n\ti40e_vsi_clear(vsi);\n\treturn NULL;\n}\n\n/**\n * i40e_vsi_setup - Set up a VSI by a given type\n * @pf: board private structure\n * @type: VSI type\n * @uplink_seid: the switch element to link to\n * @param1: usage depends upon VSI type. For VF types, indicates VF id\n *\n * This allocates the sw VSI structure and its queue resources, then add a VSI\n * to the identified VEB.\n *\n * Returns pointer to the successfully allocated and configure VSI sw struct on\n * success, otherwise returns NULL on failure.\n **/\nstruct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type,\n\t\t\t\tu16 uplink_seid, u32 param1)\n{\n\tstruct i40e_vsi *vsi = NULL;\n\tstruct i40e_veb *veb = NULL;\n\tu16 alloc_queue_pairs;\n\tint ret, i;\n\tint v_idx;\n\n\t/* The requested uplink_seid must be either\n\t *     - the PF's port seid\n\t *              no VEB is needed because this is the PF\n\t *              or this is a Flow Director special case VSI\n\t *     - seid of an existing VEB\n\t *     - seid of a VSI that owns an existing VEB\n\t *     - seid of a VSI that doesn't own a VEB\n\t *              a new VEB is created and the VSI becomes the owner\n\t *     - seid of the PF VSI, which is what creates the first VEB\n\t *              this is a special case of the previous\n\t *\n\t * Find which uplink_seid we were given and create a new VEB if needed\n\t */\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tif (pf->veb[i] && pf->veb[i]->seid == uplink_seid) {\n\t\t\tveb = pf->veb[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!veb && uplink_seid != pf->mac_seid) {\n\n\t\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\t\tif (pf->vsi[i] && pf->vsi[i]->seid == uplink_seid) {\n\t\t\t\tvsi = pf->vsi[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev, \"no such uplink_seid %d\\n\",\n\t\t\t\t uplink_seid);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (vsi->uplink_seid == pf->mac_seid)\n\t\t\tveb = i40e_veb_setup(pf, 0, pf->mac_seid, vsi->seid,\n\t\t\t\t\t     vsi->tc_config.enabled_tc);\n\t\telse if ((vsi->flags & I40E_VSI_FLAG_VEB_OWNER) == 0)\n\t\t\tveb = i40e_veb_setup(pf, 0, vsi->uplink_seid, vsi->seid,\n\t\t\t\t\t     vsi->tc_config.enabled_tc);\n\t\tif (veb) {\n\t\t\tif (vsi->seid != pf->vsi[pf->lan_vsi]->seid) {\n\t\t\t\tdev_info(&vsi->back->pdev->dev,\n\t\t\t\t\t \"New VSI creation error, uplink seid of LAN VSI expected.\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t/* We come up by default in VEPA mode if SRIOV is not\n\t\t\t * already enabled, in which case we can't force VEPA\n\t\t\t * mode.\n\t\t\t */\n\t\t\tif (!(pf->flags & I40E_FLAG_VEB_MODE_ENABLED)) {\n\t\t\t\tveb->bridge_mode = BRIDGE_MODE_VEPA;\n\t\t\t\tpf->flags &= ~I40E_FLAG_VEB_MODE_ENABLED;\n\t\t\t}\n\t\t\ti40e_config_bridge_mode(veb);\n\t\t}\n\t\tfor (i = 0; i < I40E_MAX_VEB && !veb; i++) {\n\t\t\tif (pf->veb[i] && pf->veb[i]->seid == vsi->uplink_seid)\n\t\t\t\tveb = pf->veb[i];\n\t\t}\n\t\tif (!veb) {\n\t\t\tdev_info(&pf->pdev->dev, \"couldn't add VEB\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tvsi->flags |= I40E_VSI_FLAG_VEB_OWNER;\n\t\tuplink_seid = veb->seid;\n\t}\n\n\t/* get vsi sw struct */\n\tv_idx = i40e_vsi_mem_alloc(pf, type);\n\tif (v_idx < 0)\n\t\tgoto err_alloc;\n\tvsi = pf->vsi[v_idx];\n\tif (!vsi)\n\t\tgoto err_alloc;\n\tvsi->type = type;\n\tvsi->veb_idx = (veb ? veb->idx : I40E_NO_VEB);\n\n\tif (type == I40E_VSI_MAIN)\n\t\tpf->lan_vsi = v_idx;\n\telse if (type == I40E_VSI_SRIOV)\n\t\tvsi->vf_id = param1;\n\t/* assign it some queues */\n\talloc_queue_pairs = vsi->alloc_queue_pairs *\n\t\t\t    (i40e_enabled_xdp_vsi(vsi) ? 2 : 1);\n\n\tret = i40e_get_lump(pf, pf->qp_pile, alloc_queue_pairs, vsi->idx);\n\tif (ret < 0) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"failed to get tracking for %d queues for VSI %d err=%d\\n\",\n\t\t\t alloc_queue_pairs, vsi->seid, ret);\n\t\tgoto err_vsi;\n\t}\n\tvsi->base_queue = ret;\n\n\t/* get a VSI from the hardware */\n\tvsi->uplink_seid = uplink_seid;\n\tret = i40e_add_vsi(vsi);\n\tif (ret)\n\t\tgoto err_vsi;\n\n\tswitch (vsi->type) {\n\t/* setup the netdev if needed */\n\tcase I40E_VSI_MAIN:\n\tcase I40E_VSI_VMDQ2:\n\t\tret = i40e_config_netdev(vsi);\n\t\tif (ret)\n\t\t\tgoto err_netdev;\n\t\tret = register_netdev(vsi->netdev);\n\t\tif (ret)\n\t\t\tgoto err_netdev;\n\t\tvsi->netdev_registered = true;\n\t\tnetif_carrier_off(vsi->netdev);\n#ifdef CONFIG_I40E_DCB\n\t\t/* Setup DCB netlink interface */\n\t\ti40e_dcbnl_setup(vsi);\n#endif /* CONFIG_I40E_DCB */\n\t\tfallthrough;\n\tcase I40E_VSI_FDIR:\n\t\t/* set up vectors and rings if needed */\n\t\tret = i40e_vsi_setup_vectors(vsi);\n\t\tif (ret)\n\t\t\tgoto err_msix;\n\n\t\tret = i40e_alloc_rings(vsi);\n\t\tif (ret)\n\t\t\tgoto err_rings;\n\n\t\t/* map all of the rings to the q_vectors */\n\t\ti40e_vsi_map_rings_to_vectors(vsi);\n\n\t\ti40e_vsi_reset_stats(vsi);\n\t\tbreak;\n\tdefault:\n\t\t/* no netdev or rings for the other VSI types */\n\t\tbreak;\n\t}\n\n\tif ((pf->hw_features & I40E_HW_RSS_AQ_CAPABLE) &&\n\t    (vsi->type == I40E_VSI_VMDQ2)) {\n\t\tret = i40e_vsi_config_rss(vsi);\n\t}\n\treturn vsi;\n\nerr_rings:\n\ti40e_vsi_free_q_vectors(vsi);\nerr_msix:\n\tif (vsi->netdev_registered) {\n\t\tvsi->netdev_registered = false;\n\t\tunregister_netdev(vsi->netdev);\n\t\tfree_netdev(vsi->netdev);\n\t\tvsi->netdev = NULL;\n\t}\nerr_netdev:\n\ti40e_aq_delete_element(&pf->hw, vsi->seid, NULL);\nerr_vsi:\n\ti40e_vsi_clear(vsi);\nerr_alloc:\n\treturn NULL;\n}\n\n/**\n * i40e_veb_get_bw_info - Query VEB BW information\n * @veb: the veb to query\n *\n * Query the Tx scheduler BW configuration data for given VEB\n **/\nstatic int i40e_veb_get_bw_info(struct i40e_veb *veb)\n{\n\tstruct i40e_aqc_query_switching_comp_ets_config_resp ets_data;\n\tstruct i40e_aqc_query_switching_comp_bw_config_resp bw_data;\n\tstruct i40e_pf *pf = veb->pf;\n\tstruct i40e_hw *hw = &pf->hw;\n\tu32 tc_bw_max;\n\tint ret = 0;\n\tint i;\n\n\tret = i40e_aq_query_switch_comp_bw_config(hw, veb->seid,\n\t\t\t\t\t\t  &bw_data, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"query veb bw config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, hw->aq.asq_last_status));\n\t\tgoto out;\n\t}\n\n\tret = i40e_aq_query_switch_comp_ets_config(hw, veb->seid,\n\t\t\t\t\t\t   &ets_data, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"query veb bw ets config failed, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, hw->aq.asq_last_status));\n\t\tgoto out;\n\t}\n\n\tveb->bw_limit = le16_to_cpu(ets_data.port_bw_limit);\n\tveb->bw_max_quanta = ets_data.tc_bw_max;\n\tveb->is_abs_credits = bw_data.absolute_credits_enable;\n\tveb->enabled_tc = ets_data.tc_valid_bits;\n\ttc_bw_max = le16_to_cpu(bw_data.tc_bw_max[0]) |\n\t\t    (le16_to_cpu(bw_data.tc_bw_max[1]) << 16);\n\tfor (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {\n\t\tveb->bw_tc_share_credits[i] = bw_data.tc_bw_share_credits[i];\n\t\tveb->bw_tc_limit_credits[i] =\n\t\t\t\t\tle16_to_cpu(bw_data.tc_bw_limits[i]);\n\t\tveb->bw_tc_max_quanta[i] = ((tc_bw_max >> (i*4)) & 0x7);\n\t}\n\nout:\n\treturn ret;\n}\n\n/**\n * i40e_veb_mem_alloc - Allocates the next available struct veb in the PF\n * @pf: board private structure\n *\n * On error: returns error code (negative)\n * On success: returns vsi index in PF (positive)\n **/\nstatic int i40e_veb_mem_alloc(struct i40e_pf *pf)\n{\n\tint ret = -ENOENT;\n\tstruct i40e_veb *veb;\n\tint i;\n\n\t/* Need to protect the allocation of switch elements at the PF level */\n\tmutex_lock(&pf->switch_mutex);\n\n\t/* VEB list may be fragmented if VEB creation/destruction has\n\t * been happening.  We can afford to do a quick scan to look\n\t * for any free slots in the list.\n\t *\n\t * find next empty veb slot, looping back around if necessary\n\t */\n\ti = 0;\n\twhile ((i < I40E_MAX_VEB) && (pf->veb[i] != NULL))\n\t\ti++;\n\tif (i >= I40E_MAX_VEB) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_veb;  /* out of VEB slots! */\n\t}\n\n\tveb = kzalloc(sizeof(*veb), GFP_KERNEL);\n\tif (!veb) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_veb;\n\t}\n\tveb->pf = pf;\n\tveb->idx = i;\n\tveb->enabled_tc = 1;\n\n\tpf->veb[i] = veb;\n\tret = i;\nerr_alloc_veb:\n\tmutex_unlock(&pf->switch_mutex);\n\treturn ret;\n}\n\n/**\n * i40e_switch_branch_release - Delete a branch of the switch tree\n * @branch: where to start deleting\n *\n * This uses recursion to find the tips of the branch to be\n * removed, deleting until we get back to and can delete this VEB.\n **/\nstatic void i40e_switch_branch_release(struct i40e_veb *branch)\n{\n\tstruct i40e_pf *pf = branch->pf;\n\tu16 branch_seid = branch->seid;\n\tu16 veb_idx = branch->idx;\n\tint i;\n\n\t/* release any VEBs on this VEB - RECURSION */\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tif (!pf->veb[i])\n\t\t\tcontinue;\n\t\tif (pf->veb[i]->uplink_seid == branch->seid)\n\t\t\ti40e_switch_branch_release(pf->veb[i]);\n\t}\n\n\t/* Release the VSIs on this VEB, but not the owner VSI.\n\t *\n\t * NOTE: Removing the last VSI on a VEB has the SIDE EFFECT of removing\n\t *       the VEB itself, so don't use (*branch) after this loop.\n\t */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (!pf->vsi[i])\n\t\t\tcontinue;\n\t\tif (pf->vsi[i]->uplink_seid == branch_seid &&\n\t\t   (pf->vsi[i]->flags & I40E_VSI_FLAG_VEB_OWNER) == 0) {\n\t\t\ti40e_vsi_release(pf->vsi[i]);\n\t\t}\n\t}\n\n\t/* There's one corner case where the VEB might not have been\n\t * removed, so double check it here and remove it if needed.\n\t * This case happens if the veb was created from the debugfs\n\t * commands and no VSIs were added to it.\n\t */\n\tif (pf->veb[veb_idx])\n\t\ti40e_veb_release(pf->veb[veb_idx]);\n}\n\n/**\n * i40e_veb_clear - remove veb struct\n * @veb: the veb to remove\n **/\nstatic void i40e_veb_clear(struct i40e_veb *veb)\n{\n\tif (!veb)\n\t\treturn;\n\n\tif (veb->pf) {\n\t\tstruct i40e_pf *pf = veb->pf;\n\n\t\tmutex_lock(&pf->switch_mutex);\n\t\tif (pf->veb[veb->idx] == veb)\n\t\t\tpf->veb[veb->idx] = NULL;\n\t\tmutex_unlock(&pf->switch_mutex);\n\t}\n\n\tkfree(veb);\n}\n\n/**\n * i40e_veb_release - Delete a VEB and free its resources\n * @veb: the VEB being removed\n **/\nvoid i40e_veb_release(struct i40e_veb *veb)\n{\n\tstruct i40e_vsi *vsi = NULL;\n\tstruct i40e_pf *pf;\n\tint i, n = 0;\n\n\tpf = veb->pf;\n\n\t/* find the remaining VSI and check for extras */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (pf->vsi[i] && pf->vsi[i]->uplink_seid == veb->seid) {\n\t\t\tn++;\n\t\t\tvsi = pf->vsi[i];\n\t\t}\n\t}\n\tif (n != 1) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"can't remove VEB %d with %d VSIs left\\n\",\n\t\t\t veb->seid, n);\n\t\treturn;\n\t}\n\n\t/* move the remaining VSI to uplink veb */\n\tvsi->flags &= ~I40E_VSI_FLAG_VEB_OWNER;\n\tif (veb->uplink_seid) {\n\t\tvsi->uplink_seid = veb->uplink_seid;\n\t\tif (veb->uplink_seid == pf->mac_seid)\n\t\t\tvsi->veb_idx = I40E_NO_VEB;\n\t\telse\n\t\t\tvsi->veb_idx = veb->veb_idx;\n\t} else {\n\t\t/* floating VEB */\n\t\tvsi->uplink_seid = pf->vsi[pf->lan_vsi]->uplink_seid;\n\t\tvsi->veb_idx = pf->vsi[pf->lan_vsi]->veb_idx;\n\t}\n\n\ti40e_aq_delete_element(&pf->hw, veb->seid, NULL);\n\ti40e_veb_clear(veb);\n}\n\n/**\n * i40e_add_veb - create the VEB in the switch\n * @veb: the VEB to be instantiated\n * @vsi: the controlling VSI\n **/\nstatic int i40e_add_veb(struct i40e_veb *veb, struct i40e_vsi *vsi)\n{\n\tstruct i40e_pf *pf = veb->pf;\n\tbool enable_stats = !!(pf->flags & I40E_FLAG_VEB_STATS_ENABLED);\n\tint ret;\n\n\tret = i40e_aq_add_veb(&pf->hw, veb->uplink_seid, vsi->seid,\n\t\t\t      veb->enabled_tc, false,\n\t\t\t      &veb->seid, enable_stats, NULL);\n\n\t/* get a VEB from the hardware */\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't add VEB, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EPERM;\n\t}\n\n\t/* get statistics counter */\n\tret = i40e_aq_get_veb_parameters(&pf->hw, veb->seid, NULL, NULL,\n\t\t\t\t\t &veb->stats_idx, NULL, NULL, NULL);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get VEB statistics idx, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn -EPERM;\n\t}\n\tret = i40e_veb_get_bw_info(veb);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't get VEB bw info, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\ti40e_aq_delete_element(&pf->hw, veb->seid, NULL);\n\t\treturn -ENOENT;\n\t}\n\n\tvsi->uplink_seid = veb->seid;\n\tvsi->veb_idx = veb->idx;\n\tvsi->flags |= I40E_VSI_FLAG_VEB_OWNER;\n\n\treturn 0;\n}\n\n/**\n * i40e_veb_setup - Set up a VEB\n * @pf: board private structure\n * @flags: VEB setup flags\n * @uplink_seid: the switch element to link to\n * @vsi_seid: the initial VSI seid\n * @enabled_tc: Enabled TC bit-map\n *\n * This allocates the sw VEB structure and links it into the switch\n * It is possible and legal for this to be a duplicate of an already\n * existing VEB.  It is also possible for both uplink and vsi seids\n * to be zero, in order to create a floating VEB.\n *\n * Returns pointer to the successfully allocated VEB sw struct on\n * success, otherwise returns NULL on failure.\n **/\nstruct i40e_veb *i40e_veb_setup(struct i40e_pf *pf, u16 flags,\n\t\t\t\tu16 uplink_seid, u16 vsi_seid,\n\t\t\t\tu8 enabled_tc)\n{\n\tstruct i40e_veb *veb, *uplink_veb = NULL;\n\tint vsi_idx, veb_idx;\n\tint ret;\n\n\t/* if one seid is 0, the other must be 0 to create a floating relay */\n\tif ((uplink_seid == 0 || vsi_seid == 0) &&\n\t    (uplink_seid + vsi_seid != 0)) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"one, not both seid's are 0: uplink=%d vsi=%d\\n\",\n\t\t\t uplink_seid, vsi_seid);\n\t\treturn NULL;\n\t}\n\n\t/* make sure there is such a vsi and uplink */\n\tfor (vsi_idx = 0; vsi_idx < pf->num_alloc_vsi; vsi_idx++)\n\t\tif (pf->vsi[vsi_idx] && pf->vsi[vsi_idx]->seid == vsi_seid)\n\t\t\tbreak;\n\tif (vsi_idx == pf->num_alloc_vsi && vsi_seid != 0) {\n\t\tdev_info(&pf->pdev->dev, \"vsi seid %d not found\\n\",\n\t\t\t vsi_seid);\n\t\treturn NULL;\n\t}\n\n\tif (uplink_seid && uplink_seid != pf->mac_seid) {\n\t\tfor (veb_idx = 0; veb_idx < I40E_MAX_VEB; veb_idx++) {\n\t\t\tif (pf->veb[veb_idx] &&\n\t\t\t    pf->veb[veb_idx]->seid == uplink_seid) {\n\t\t\t\tuplink_veb = pf->veb[veb_idx];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!uplink_veb) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"uplink seid %d not found\\n\", uplink_seid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* get veb sw struct */\n\tveb_idx = i40e_veb_mem_alloc(pf);\n\tif (veb_idx < 0)\n\t\tgoto err_alloc;\n\tveb = pf->veb[veb_idx];\n\tveb->flags = flags;\n\tveb->uplink_seid = uplink_seid;\n\tveb->veb_idx = (uplink_veb ? uplink_veb->idx : I40E_NO_VEB);\n\tveb->enabled_tc = (enabled_tc ? enabled_tc : 0x1);\n\n\t/* create the VEB in the switch */\n\tret = i40e_add_veb(veb, pf->vsi[vsi_idx]);\n\tif (ret)\n\t\tgoto err_veb;\n\tif (vsi_idx == pf->lan_vsi)\n\t\tpf->lan_veb = veb->idx;\n\n\treturn veb;\n\nerr_veb:\n\ti40e_veb_clear(veb);\nerr_alloc:\n\treturn NULL;\n}\n\n/**\n * i40e_setup_pf_switch_element - set PF vars based on switch type\n * @pf: board private structure\n * @ele: element we are building info from\n * @num_reported: total number of elements\n * @printconfig: should we print the contents\n *\n * helper function to assist in extracting a few useful SEID values.\n **/\nstatic void i40e_setup_pf_switch_element(struct i40e_pf *pf,\n\t\t\t\tstruct i40e_aqc_switch_config_element_resp *ele,\n\t\t\t\tu16 num_reported, bool printconfig)\n{\n\tu16 downlink_seid = le16_to_cpu(ele->downlink_seid);\n\tu16 uplink_seid = le16_to_cpu(ele->uplink_seid);\n\tu8 element_type = ele->element_type;\n\tu16 seid = le16_to_cpu(ele->seid);\n\n\tif (printconfig)\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"type=%d seid=%d uplink=%d downlink=%d\\n\",\n\t\t\t element_type, seid, uplink_seid, downlink_seid);\n\n\tswitch (element_type) {\n\tcase I40E_SWITCH_ELEMENT_TYPE_MAC:\n\t\tpf->mac_seid = seid;\n\t\tbreak;\n\tcase I40E_SWITCH_ELEMENT_TYPE_VEB:\n\t\t/* Main VEB? */\n\t\tif (uplink_seid != pf->mac_seid)\n\t\t\tbreak;\n\t\tif (pf->lan_veb >= I40E_MAX_VEB) {\n\t\t\tint v;\n\n\t\t\t/* find existing or else empty VEB */\n\t\t\tfor (v = 0; v < I40E_MAX_VEB; v++) {\n\t\t\t\tif (pf->veb[v] && (pf->veb[v]->seid == seid)) {\n\t\t\t\t\tpf->lan_veb = v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pf->lan_veb >= I40E_MAX_VEB) {\n\t\t\t\tv = i40e_veb_mem_alloc(pf);\n\t\t\t\tif (v < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tpf->lan_veb = v;\n\t\t\t}\n\t\t}\n\t\tif (pf->lan_veb >= I40E_MAX_VEB)\n\t\t\tbreak;\n\n\t\tpf->veb[pf->lan_veb]->seid = seid;\n\t\tpf->veb[pf->lan_veb]->uplink_seid = pf->mac_seid;\n\t\tpf->veb[pf->lan_veb]->pf = pf;\n\t\tpf->veb[pf->lan_veb]->veb_idx = I40E_NO_VEB;\n\t\tbreak;\n\tcase I40E_SWITCH_ELEMENT_TYPE_VSI:\n\t\tif (num_reported != 1)\n\t\t\tbreak;\n\t\t/* This is immediately after a reset so we can assume this is\n\t\t * the PF's VSI\n\t\t */\n\t\tpf->mac_seid = uplink_seid;\n\t\tpf->pf_seid = downlink_seid;\n\t\tpf->main_vsi_seid = seid;\n\t\tif (printconfig)\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"pf_seid=%d main_vsi_seid=%d\\n\",\n\t\t\t\t pf->pf_seid, pf->main_vsi_seid);\n\t\tbreak;\n\tcase I40E_SWITCH_ELEMENT_TYPE_PF:\n\tcase I40E_SWITCH_ELEMENT_TYPE_VF:\n\tcase I40E_SWITCH_ELEMENT_TYPE_EMP:\n\tcase I40E_SWITCH_ELEMENT_TYPE_BMC:\n\tcase I40E_SWITCH_ELEMENT_TYPE_PE:\n\tcase I40E_SWITCH_ELEMENT_TYPE_PA:\n\t\t/* ignore these for now */\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&pf->pdev->dev, \"unknown element type=%d seid=%d\\n\",\n\t\t\t element_type, seid);\n\t\tbreak;\n\t}\n}\n\n/**\n * i40e_fetch_switch_configuration - Get switch config from firmware\n * @pf: board private structure\n * @printconfig: should we print the contents\n *\n * Get the current switch configuration from the device and\n * extract a few useful SEID values.\n **/\nint i40e_fetch_switch_configuration(struct i40e_pf *pf, bool printconfig)\n{\n\tstruct i40e_aqc_get_switch_config_resp *sw_config;\n\tu16 next_seid = 0;\n\tint ret = 0;\n\tu8 *aq_buf;\n\tint i;\n\n\taq_buf = kzalloc(I40E_AQ_LARGE_BUF, GFP_KERNEL);\n\tif (!aq_buf)\n\t\treturn -ENOMEM;\n\n\tsw_config = (struct i40e_aqc_get_switch_config_resp *)aq_buf;\n\tdo {\n\t\tu16 num_reported, num_total;\n\n\t\tret = i40e_aq_get_switch_config(&pf->hw, sw_config,\n\t\t\t\t\t\tI40E_AQ_LARGE_BUF,\n\t\t\t\t\t\t&next_seid, NULL);\n\t\tif (ret) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"get switch config failed err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\tkfree(aq_buf);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tnum_reported = le16_to_cpu(sw_config->header.num_reported);\n\t\tnum_total = le16_to_cpu(sw_config->header.num_total);\n\n\t\tif (printconfig)\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"header: %d reported %d total\\n\",\n\t\t\t\t num_reported, num_total);\n\n\t\tfor (i = 0; i < num_reported; i++) {\n\t\t\tstruct i40e_aqc_switch_config_element_resp *ele =\n\t\t\t\t&sw_config->element[i];\n\n\t\t\ti40e_setup_pf_switch_element(pf, ele, num_reported,\n\t\t\t\t\t\t     printconfig);\n\t\t}\n\t} while (next_seid != 0);\n\n\tkfree(aq_buf);\n\treturn ret;\n}\n\n/**\n * i40e_setup_pf_switch - Setup the HW switch on startup or after reset\n * @pf: board private structure\n * @reinit: if the Main VSI needs to re-initialized.\n *\n * Returns 0 on success, negative value on failure\n **/\nstatic int i40e_setup_pf_switch(struct i40e_pf *pf, bool reinit)\n{\n\tu16 flags = 0;\n\tint ret;\n\n\t/* find out what's out there already */\n\tret = i40e_fetch_switch_configuration(pf, false);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev,\n\t\t\t \"couldn't fetch switch config, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\t\treturn ret;\n\t}\n\ti40e_pf_reset_stats(pf);\n\n\t/* set the switch config bit for the whole device to\n\t * support limited promisc or true promisc\n\t * when user requests promisc. The default is limited\n\t * promisc.\n\t*/\n\n\tif ((pf->hw.pf_id == 0) &&\n\t    !(pf->flags & I40E_FLAG_TRUE_PROMISC_SUPPORT)) {\n\t\tflags = I40E_AQ_SET_SWITCH_CFG_PROMISC;\n\t\tpf->last_sw_conf_flags = flags;\n\t}\n\n\tif (pf->hw.pf_id == 0) {\n\t\tu16 valid_flags;\n\n\t\tvalid_flags = I40E_AQ_SET_SWITCH_CFG_PROMISC;\n\t\tret = i40e_aq_set_switch_config(&pf->hw, flags, valid_flags, 0,\n\t\t\t\t\t\tNULL);\n\t\tif (ret && pf->hw.aq.asq_last_status != I40E_AQ_RC_ESRCH) {\n\t\t\tdev_info(&pf->pdev->dev,\n\t\t\t\t \"couldn't set switch config bits, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, ret),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t\t\t/* not a fatal problem, just keep going */\n\t\t}\n\t\tpf->last_sw_conf_valid_flags = valid_flags;\n\t}\n\n\t/* first time setup */\n\tif (pf->lan_vsi == I40E_NO_VSI || reinit) {\n\t\tstruct i40e_vsi *vsi = NULL;\n\t\tu16 uplink_seid;\n\n\t\t/* Set up the PF VSI associated with the PF's main VSI\n\t\t * that is already in the HW switch\n\t\t */\n\t\tif (pf->lan_veb < I40E_MAX_VEB && pf->veb[pf->lan_veb])\n\t\t\tuplink_seid = pf->veb[pf->lan_veb]->seid;\n\t\telse\n\t\t\tuplink_seid = pf->mac_seid;\n\t\tif (pf->lan_vsi == I40E_NO_VSI)\n\t\t\tvsi = i40e_vsi_setup(pf, I40E_VSI_MAIN, uplink_seid, 0);\n\t\telse if (reinit)\n\t\t\tvsi = i40e_vsi_reinit_setup(pf->vsi[pf->lan_vsi]);\n\t\tif (!vsi) {\n\t\t\tdev_info(&pf->pdev->dev, \"setup of MAIN VSI failed\\n\");\n\t\t\ti40e_cloud_filter_exit(pf);\n\t\t\ti40e_fdir_teardown(pf);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t} else {\n\t\t/* force a reset of TC and queue layout configurations */\n\t\tu8 enabled_tc = pf->vsi[pf->lan_vsi]->tc_config.enabled_tc;\n\n\t\tpf->vsi[pf->lan_vsi]->tc_config.enabled_tc = 0;\n\t\tpf->vsi[pf->lan_vsi]->seid = pf->main_vsi_seid;\n\t\ti40e_vsi_config_tc(pf->vsi[pf->lan_vsi], enabled_tc);\n\t}\n\ti40e_vlan_stripping_disable(pf->vsi[pf->lan_vsi]);\n\n\ti40e_fdir_sb_setup(pf);\n\n\t/* Setup static PF queue filter control settings */\n\tret = i40e_setup_pf_filter_control(pf);\n\tif (ret) {\n\t\tdev_info(&pf->pdev->dev, \"setup_pf_filter_control failed: %d\\n\",\n\t\t\t ret);\n\t\t/* Failure here should not stop continuing other steps */\n\t}\n\n\t/* enable RSS in the HW, even for only one queue, as the stack can use\n\t * the hash\n\t */\n\tif ((pf->flags & I40E_FLAG_RSS_ENABLED))\n\t\ti40e_pf_config_rss(pf);\n\n\t/* fill in link information and enable LSE reporting */\n\ti40e_link_event(pf);\n\n\t/* Initialize user-specific link properties */\n\tpf->fc_autoneg_status = ((pf->hw.phy.link_info.an_info &\n\t\t\t\t  I40E_AQ_AN_COMPLETED) ? true : false);\n\n\ti40e_ptp_init(pf);\n\n\t/* repopulate tunnel port filters */\n\tudp_tunnel_nic_reset_ntf(pf->vsi[pf->lan_vsi]->netdev);\n\n\treturn ret;\n}\n\n/**\n * i40e_determine_queue_usage - Work out queue distribution\n * @pf: board private structure\n **/\nstatic void i40e_determine_queue_usage(struct i40e_pf *pf)\n{\n\tint queues_left;\n\tint q_max;\n\n\tpf->num_lan_qps = 0;\n\n\t/* Find the max queues to be put into basic use.  We'll always be\n\t * using TC0, whether or not DCB is running, and TC0 will get the\n\t * big RSS set.\n\t */\n\tqueues_left = pf->hw.func_caps.num_tx_qp;\n\n\tif ((queues_left == 1) ||\n\t    !(pf->flags & I40E_FLAG_MSIX_ENABLED)) {\n\t\t/* one qp for PF, no queues for anything else */\n\t\tqueues_left = 0;\n\t\tpf->alloc_rss_size = pf->num_lan_qps = 1;\n\n\t\t/* make sure all the fancies are disabled */\n\t\tpf->flags &= ~(I40E_FLAG_RSS_ENABLED\t|\n\t\t\t       I40E_FLAG_IWARP_ENABLED\t|\n\t\t\t       I40E_FLAG_FD_SB_ENABLED\t|\n\t\t\t       I40E_FLAG_FD_ATR_ENABLED\t|\n\t\t\t       I40E_FLAG_DCB_CAPABLE\t|\n\t\t\t       I40E_FLAG_DCB_ENABLED\t|\n\t\t\t       I40E_FLAG_SRIOV_ENABLED\t|\n\t\t\t       I40E_FLAG_VMDQ_ENABLED);\n\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\t} else if (!(pf->flags & (I40E_FLAG_RSS_ENABLED |\n\t\t\t\t  I40E_FLAG_FD_SB_ENABLED |\n\t\t\t\t  I40E_FLAG_FD_ATR_ENABLED |\n\t\t\t\t  I40E_FLAG_DCB_CAPABLE))) {\n\t\t/* one qp for PF */\n\t\tpf->alloc_rss_size = pf->num_lan_qps = 1;\n\t\tqueues_left -= pf->num_lan_qps;\n\n\t\tpf->flags &= ~(I40E_FLAG_RSS_ENABLED\t|\n\t\t\t       I40E_FLAG_IWARP_ENABLED\t|\n\t\t\t       I40E_FLAG_FD_SB_ENABLED\t|\n\t\t\t       I40E_FLAG_FD_ATR_ENABLED\t|\n\t\t\t       I40E_FLAG_DCB_ENABLED\t|\n\t\t\t       I40E_FLAG_VMDQ_ENABLED);\n\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\t} else {\n\t\t/* Not enough queues for all TCs */\n\t\tif ((pf->flags & I40E_FLAG_DCB_CAPABLE) &&\n\t\t    (queues_left < I40E_MAX_TRAFFIC_CLASS)) {\n\t\t\tpf->flags &= ~(I40E_FLAG_DCB_CAPABLE |\n\t\t\t\t\tI40E_FLAG_DCB_ENABLED);\n\t\t\tdev_info(&pf->pdev->dev, \"not enough queues for DCB. DCB is disabled.\\n\");\n\t\t}\n\n\t\t/* limit lan qps to the smaller of qps, cpus or msix */\n\t\tq_max = max_t(int, pf->rss_size_max, num_online_cpus());\n\t\tq_max = min_t(int, q_max, pf->hw.func_caps.num_tx_qp);\n\t\tq_max = min_t(int, q_max, pf->hw.func_caps.num_msix_vectors);\n\t\tpf->num_lan_qps = q_max;\n\n\t\tqueues_left -= pf->num_lan_qps;\n\t}\n\n\tif (pf->flags & I40E_FLAG_FD_SB_ENABLED) {\n\t\tif (queues_left > 1) {\n\t\t\tqueues_left -= 1; /* save 1 queue for FD */\n\t\t} else {\n\t\t\tpf->flags &= ~I40E_FLAG_FD_SB_ENABLED;\n\t\t\tpf->flags |= I40E_FLAG_FD_SB_INACTIVE;\n\t\t\tdev_info(&pf->pdev->dev, \"not enough queues for Flow Director. Flow Director feature is disabled\\n\");\n\t\t}\n\t}\n\n\tif ((pf->flags & I40E_FLAG_SRIOV_ENABLED) &&\n\t    pf->num_vf_qps && pf->num_req_vfs && queues_left) {\n\t\tpf->num_req_vfs = min_t(int, pf->num_req_vfs,\n\t\t\t\t\t(queues_left / pf->num_vf_qps));\n\t\tqueues_left -= (pf->num_req_vfs * pf->num_vf_qps);\n\t}\n\n\tif ((pf->flags & I40E_FLAG_VMDQ_ENABLED) &&\n\t    pf->num_vmdq_vsis && pf->num_vmdq_qps && queues_left) {\n\t\tpf->num_vmdq_vsis = min_t(int, pf->num_vmdq_vsis,\n\t\t\t\t\t  (queues_left / pf->num_vmdq_qps));\n\t\tqueues_left -= (pf->num_vmdq_vsis * pf->num_vmdq_qps);\n\t}\n\n\tpf->queues_left = queues_left;\n\tdev_dbg(&pf->pdev->dev,\n\t\t\"qs_avail=%d FD SB=%d lan_qs=%d lan_tc0=%d vf=%d*%d vmdq=%d*%d, remaining=%d\\n\",\n\t\tpf->hw.func_caps.num_tx_qp,\n\t\t!!(pf->flags & I40E_FLAG_FD_SB_ENABLED),\n\t\tpf->num_lan_qps, pf->alloc_rss_size, pf->num_req_vfs,\n\t\tpf->num_vf_qps, pf->num_vmdq_vsis, pf->num_vmdq_qps,\n\t\tqueues_left);\n}\n\n/**\n * i40e_setup_pf_filter_control - Setup PF static filter control\n * @pf: PF to be setup\n *\n * i40e_setup_pf_filter_control sets up a PF's initial filter control\n * settings. If PE/FCoE are enabled then it will also set the per PF\n * based filter sizes required for them. It also enables Flow director,\n * ethertype and macvlan type filter settings for the pf.\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int i40e_setup_pf_filter_control(struct i40e_pf *pf)\n{\n\tstruct i40e_filter_control_settings *settings = &pf->filter_settings;\n\n\tsettings->hash_lut_size = I40E_HASH_LUT_SIZE_128;\n\n\t/* Flow Director is enabled */\n\tif (pf->flags & (I40E_FLAG_FD_SB_ENABLED | I40E_FLAG_FD_ATR_ENABLED))\n\t\tsettings->enable_fdir = true;\n\n\t/* Ethtype and MACVLAN filters enabled for PF */\n\tsettings->enable_ethtype = true;\n\tsettings->enable_macvlan = true;\n\n\tif (i40e_set_filter_control(&pf->hw, settings))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n#define INFO_STRING_LEN 255\n#define REMAIN(__x) (INFO_STRING_LEN - (__x))\nstatic void i40e_print_features(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\tchar *buf;\n\tint i;\n\n\tbuf = kmalloc(INFO_STRING_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\ti = snprintf(buf, INFO_STRING_LEN, \"Features: PF-id[%d]\", hw->pf_id);\n#ifdef CONFIG_PCI_IOV\n\ti += scnprintf(&buf[i], REMAIN(i), \" VFs: %d\", pf->num_req_vfs);\n#endif\n\ti += scnprintf(&buf[i], REMAIN(i), \" VSIs: %d QP: %d\",\n\t\t      pf->hw.func_caps.num_vsis,\n\t\t      pf->vsi[pf->lan_vsi]->num_queue_pairs);\n\tif (pf->flags & I40E_FLAG_RSS_ENABLED)\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" RSS\");\n\tif (pf->flags & I40E_FLAG_FD_ATR_ENABLED)\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" FD_ATR\");\n\tif (pf->flags & I40E_FLAG_FD_SB_ENABLED) {\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" FD_SB\");\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" NTUPLE\");\n\t}\n\tif (pf->flags & I40E_FLAG_DCB_CAPABLE)\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" DCB\");\n\ti += scnprintf(&buf[i], REMAIN(i), \" VxLAN\");\n\ti += scnprintf(&buf[i], REMAIN(i), \" Geneve\");\n\tif (pf->flags & I40E_FLAG_PTP)\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" PTP\");\n\tif (pf->flags & I40E_FLAG_VEB_MODE_ENABLED)\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" VEB\");\n\telse\n\t\ti += scnprintf(&buf[i], REMAIN(i), \" VEPA\");\n\n\tdev_info(&pf->pdev->dev, \"%s\\n\", buf);\n\tkfree(buf);\n\tWARN_ON(i > INFO_STRING_LEN);\n}\n\n/**\n * i40e_get_platform_mac_addr - get platform-specific MAC address\n * @pdev: PCI device information struct\n * @pf: board private structure\n *\n * Look up the MAC address for the device. First we'll try\n * eth_platform_get_mac_address, which will check Open Firmware, or arch\n * specific fallback. Otherwise, we'll default to the stored value in\n * firmware.\n **/\nstatic void i40e_get_platform_mac_addr(struct pci_dev *pdev, struct i40e_pf *pf)\n{\n\tif (eth_platform_get_mac_address(&pdev->dev, pf->hw.mac.addr))\n\t\ti40e_get_mac_addr(&pf->hw, pf->hw.mac.addr);\n}\n\n/**\n * i40e_set_fec_in_flags - helper function for setting FEC options in flags\n * @fec_cfg: FEC option to set in flags\n * @flags: ptr to flags in which we set FEC option\n **/\nvoid i40e_set_fec_in_flags(u8 fec_cfg, u32 *flags)\n{\n\tif (fec_cfg & I40E_AQ_SET_FEC_AUTO)\n\t\t*flags |= I40E_FLAG_RS_FEC | I40E_FLAG_BASE_R_FEC;\n\tif ((fec_cfg & I40E_AQ_SET_FEC_REQUEST_RS) ||\n\t    (fec_cfg & I40E_AQ_SET_FEC_ABILITY_RS)) {\n\t\t*flags |= I40E_FLAG_RS_FEC;\n\t\t*flags &= ~I40E_FLAG_BASE_R_FEC;\n\t}\n\tif ((fec_cfg & I40E_AQ_SET_FEC_REQUEST_KR) ||\n\t    (fec_cfg & I40E_AQ_SET_FEC_ABILITY_KR)) {\n\t\t*flags |= I40E_FLAG_BASE_R_FEC;\n\t\t*flags &= ~I40E_FLAG_RS_FEC;\n\t}\n\tif (fec_cfg == 0)\n\t\t*flags &= ~(I40E_FLAG_RS_FEC | I40E_FLAG_BASE_R_FEC);\n}\n\n/**\n * i40e_check_recovery_mode - check if we are running transition firmware\n * @pf: board private structure\n *\n * Check registers indicating the firmware runs in recovery mode. Sets the\n * appropriate driver state.\n *\n * Returns true if the recovery mode was detected, false otherwise\n **/\nstatic bool i40e_check_recovery_mode(struct i40e_pf *pf)\n{\n\tu32 val = rd32(&pf->hw, I40E_GL_FWSTS);\n\n\tif (val & I40E_GL_FWSTS_FWS1B_MASK) {\n\t\tdev_crit(&pf->pdev->dev, \"Firmware recovery mode detected. Limiting functionality.\\n\");\n\t\tdev_crit(&pf->pdev->dev, \"Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode.\\n\");\n\t\tset_bit(__I40E_RECOVERY_MODE, pf->state);\n\n\t\treturn true;\n\t}\n\tif (test_bit(__I40E_RECOVERY_MODE, pf->state))\n\t\tdev_info(&pf->pdev->dev, \"Please do Power-On Reset to initialize adapter in normal mode with full functionality.\\n\");\n\n\treturn false;\n}\n\n/**\n * i40e_pf_loop_reset - perform reset in a loop.\n * @pf: board private structure\n *\n * This function is useful when a NIC is about to enter recovery mode.\n * When a NIC's internal data structures are corrupted the NIC's\n * firmware is going to enter recovery mode.\n * Right after a POR it takes about 7 minutes for firmware to enter\n * recovery mode. Until that time a NIC is in some kind of intermediate\n * state. After that time period the NIC almost surely enters\n * recovery mode. The only way for a driver to detect intermediate\n * state is to issue a series of pf-resets and check a return value.\n * If a PF reset returns success then the firmware could be in recovery\n * mode so the caller of this code needs to check for recovery mode\n * if this function returns success. There is a little chance that\n * firmware will hang in intermediate state forever.\n * Since waiting 7 minutes is quite a lot of time this function waits\n * 10 seconds and then gives up by returning an error.\n *\n * Return 0 on success, negative on failure.\n **/\nstatic i40e_status i40e_pf_loop_reset(struct i40e_pf *pf)\n{\n\t/* wait max 10 seconds for PF reset to succeed */\n\tconst unsigned long time_end = jiffies + 10 * HZ;\n\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret;\n\n\tret = i40e_pf_reset(hw);\n\twhile (ret != I40E_SUCCESS && time_before(jiffies, time_end)) {\n\t\tusleep_range(10000, 20000);\n\t\tret = i40e_pf_reset(hw);\n\t}\n\n\tif (ret == I40E_SUCCESS)\n\t\tpf->pfr_count++;\n\telse\n\t\tdev_info(&pf->pdev->dev, \"PF reset failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\n/**\n * i40e_check_fw_empr - check if FW issued unexpected EMP Reset\n * @pf: board private structure\n *\n * Check FW registers to determine if FW issued unexpected EMP Reset.\n * Every time when unexpected EMP Reset occurs the FW increments\n * a counter of unexpected EMP Resets. When the counter reaches 10\n * the FW should enter the Recovery mode\n *\n * Returns true if FW issued unexpected EMP Reset\n **/\nstatic bool i40e_check_fw_empr(struct i40e_pf *pf)\n{\n\tconst u32 fw_sts = rd32(&pf->hw, I40E_GL_FWSTS) &\n\t\t\t   I40E_GL_FWSTS_FWS1B_MASK;\n\treturn (fw_sts > I40E_GL_FWSTS_FWS1B_EMPR_0) &&\n\t       (fw_sts <= I40E_GL_FWSTS_FWS1B_EMPR_10);\n}\n\n/**\n * i40e_handle_resets - handle EMP resets and PF resets\n * @pf: board private structure\n *\n * Handle both EMP resets and PF resets and conclude whether there are\n * any issues regarding these resets. If there are any issues then\n * generate log entry.\n *\n * Return 0 if NIC is healthy or negative value when there are issues\n * with resets\n **/\nstatic i40e_status i40e_handle_resets(struct i40e_pf *pf)\n{\n\tconst i40e_status pfr = i40e_pf_loop_reset(pf);\n\tconst bool is_empr = i40e_check_fw_empr(pf);\n\n\tif (is_empr || pfr != I40E_SUCCESS)\n\t\tdev_crit(&pf->pdev->dev, \"Entering recovery mode due to repeated FW resets. This may take several minutes. Refer to the Intel(R) Ethernet Adapters and Devices User Guide.\\n\");\n\n\treturn is_empr ? I40E_ERR_RESET_FAILED : pfr;\n}\n\n/**\n * i40e_init_recovery_mode - initialize subsystems needed in recovery mode\n * @pf: board private structure\n * @hw: ptr to the hardware info\n *\n * This function does a minimal setup of all subsystems needed for running\n * recovery mode.\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int i40e_init_recovery_mode(struct i40e_pf *pf, struct i40e_hw *hw)\n{\n\tstruct i40e_vsi *vsi;\n\tint err;\n\tint v_idx;\n\n\tpci_save_state(pf->pdev);\n\n\t/* set up periodic task facility */\n\ttimer_setup(&pf->service_timer, i40e_service_timer, 0);\n\tpf->service_timer_period = HZ;\n\n\tINIT_WORK(&pf->service_task, i40e_service_task);\n\tclear_bit(__I40E_SERVICE_SCHED, pf->state);\n\n\terr = i40e_init_interrupt_scheme(pf);\n\tif (err)\n\t\tgoto err_switch_setup;\n\n\t/* The number of VSIs reported by the FW is the minimum guaranteed\n\t * to us; HW supports far more and we share the remaining pool with\n\t * the other PFs. We allocate space for more than the guarantee with\n\t * the understanding that we might not get them all later.\n\t */\n\tif (pf->hw.func_caps.num_vsis < I40E_MIN_VSI_ALLOC)\n\t\tpf->num_alloc_vsi = I40E_MIN_VSI_ALLOC;\n\telse\n\t\tpf->num_alloc_vsi = pf->hw.func_caps.num_vsis;\n\n\t/* Set up the vsi struct and our local tracking of the MAIN PF vsi. */\n\tpf->vsi = kcalloc(pf->num_alloc_vsi, sizeof(struct i40e_vsi *),\n\t\t\t  GFP_KERNEL);\n\tif (!pf->vsi) {\n\t\terr = -ENOMEM;\n\t\tgoto err_switch_setup;\n\t}\n\n\t/* We allocate one VSI which is needed as absolute minimum\n\t * in order to register the netdev\n\t */\n\tv_idx = i40e_vsi_mem_alloc(pf, I40E_VSI_MAIN);\n\tif (v_idx < 0)\n\t\tgoto err_switch_setup;\n\tpf->lan_vsi = v_idx;\n\tvsi = pf->vsi[v_idx];\n\tif (!vsi)\n\t\tgoto err_switch_setup;\n\tvsi->alloc_queue_pairs = 1;\n\terr = i40e_config_netdev(vsi);\n\tif (err)\n\t\tgoto err_switch_setup;\n\terr = register_netdev(vsi->netdev);\n\tif (err)\n\t\tgoto err_switch_setup;\n\tvsi->netdev_registered = true;\n\ti40e_dbg_pf_init(pf);\n\n\terr = i40e_setup_misc_vector_for_recovery_mode(pf);\n\tif (err)\n\t\tgoto err_switch_setup;\n\n\t/* tell the firmware that we're starting */\n\ti40e_send_version(pf);\n\n\t/* since everything's happy, start the service_task timer */\n\tmod_timer(&pf->service_timer,\n\t\t  round_jiffies(jiffies + pf->service_timer_period));\n\n\treturn 0;\n\nerr_switch_setup:\n\ti40e_reset_interrupt_capability(pf);\n\tdel_timer_sync(&pf->service_timer);\n\ti40e_shutdown_adminq(hw);\n\tiounmap(hw->hw_addr);\n\tpci_disable_pcie_error_reporting(pf->pdev);\n\tpci_release_mem_regions(pf->pdev);\n\tpci_disable_device(pf->pdev);\n\tkfree(pf);\n\n\treturn err;\n}\n\n/**\n * i40e_probe - Device initialization routine\n * @pdev: PCI device information struct\n * @ent: entry in i40e_pci_tbl\n *\n * i40e_probe initializes a PF identified by a pci_dev structure.\n * The OS initialization, configuring of the PF private structure,\n * and a hardware reset occur.\n *\n * Returns 0 on success, negative on failure\n **/\nstatic int i40e_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct i40e_aq_get_phy_abilities_resp abilities;\n\tstruct i40e_pf *pf;\n\tstruct i40e_hw *hw;\n\tstatic u16 pfs_found;\n\tu16 wol_nvm_bits;\n\tu16 link_status;\n\tint err;\n\tu32 val;\n\tu32 i;\n\tu8 set_fc_aq_fail;\n\n\terr = pci_enable_device_mem(pdev);\n\tif (err)\n\t\treturn err;\n\n\t/* set up for high or low dma */\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"DMA configuration failed: 0x%x\\n\", err);\n\t\t\tgoto err_dma;\n\t\t}\n\t}\n\n\t/* set up pci connections */\n\terr = pci_request_mem_regions(pdev, i40e_driver_name);\n\tif (err) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"pci_request_selected_regions failed %d\\n\", err);\n\t\tgoto err_pci_reg;\n\t}\n\n\tpci_enable_pcie_error_reporting(pdev);\n\tpci_set_master(pdev);\n\n\t/* Now that we have a PCI connection, we need to do the\n\t * low level device setup.  This is primarily setting up\n\t * the Admin Queue structures and then querying for the\n\t * device's current profile information.\n\t */\n\tpf = kzalloc(sizeof(*pf), GFP_KERNEL);\n\tif (!pf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pf_alloc;\n\t}\n\tpf->next_vsi = 0;\n\tpf->pdev = pdev;\n\tset_bit(__I40E_DOWN, pf->state);\n\n\thw = &pf->hw;\n\thw->back = pf;\n\n\tpf->ioremap_len = min_t(int, pci_resource_len(pdev, 0),\n\t\t\t\tI40E_MAX_CSR_SPACE);\n\t/* We believe that the highest register to read is\n\t * I40E_GLGEN_STAT_CLEAR, so we check if the BAR size\n\t * is not less than that before mapping to prevent a\n\t * kernel panic.\n\t */\n\tif (pf->ioremap_len < I40E_GLGEN_STAT_CLEAR) {\n\t\tdev_err(&pdev->dev, \"Cannot map registers, bar size 0x%X too small, aborting\\n\",\n\t\t\tpf->ioremap_len);\n\t\terr = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\thw->hw_addr = ioremap(pci_resource_start(pdev, 0), pf->ioremap_len);\n\tif (!hw->hw_addr) {\n\t\terr = -EIO;\n\t\tdev_info(&pdev->dev, \"ioremap(0x%04x, 0x%04x) failed: 0x%x\\n\",\n\t\t\t (unsigned int)pci_resource_start(pdev, 0),\n\t\t\t pf->ioremap_len, err);\n\t\tgoto err_ioremap;\n\t}\n\thw->vendor_id = pdev->vendor;\n\thw->device_id = pdev->device;\n\tpci_read_config_byte(pdev, PCI_REVISION_ID, &hw->revision_id);\n\thw->subsystem_vendor_id = pdev->subsystem_vendor;\n\thw->subsystem_device_id = pdev->subsystem_device;\n\thw->bus.device = PCI_SLOT(pdev->devfn);\n\thw->bus.func = PCI_FUNC(pdev->devfn);\n\thw->bus.bus_id = pdev->bus->number;\n\tpf->instance = pfs_found;\n\n\t/* Select something other than the 802.1ad ethertype for the\n\t * switch to use internally and drop on ingress.\n\t */\n\thw->switch_tag = 0xffff;\n\thw->first_tag = ETH_P_8021AD;\n\thw->second_tag = ETH_P_8021Q;\n\n\tINIT_LIST_HEAD(&pf->l3_flex_pit_list);\n\tINIT_LIST_HEAD(&pf->l4_flex_pit_list);\n\tINIT_LIST_HEAD(&pf->ddp_old_prof);\n\n\t/* set up the locks for the AQ, do this only once in probe\n\t * and destroy them only once in remove\n\t */\n\tmutex_init(&hw->aq.asq_mutex);\n\tmutex_init(&hw->aq.arq_mutex);\n\n\tpf->msg_enable = netif_msg_init(debug,\n\t\t\t\t\tNETIF_MSG_DRV |\n\t\t\t\t\tNETIF_MSG_PROBE |\n\t\t\t\t\tNETIF_MSG_LINK);\n\tif (debug < -1)\n\t\tpf->hw.debug_mask = debug;\n\n\t/* do a special CORER for clearing PXE mode once at init */\n\tif (hw->revision_id == 0 &&\n\t    (rd32(hw, I40E_GLLAN_RCTL_0) & I40E_GLLAN_RCTL_0_PXE_MODE_MASK)) {\n\t\twr32(hw, I40E_GLGEN_RTRIG, I40E_GLGEN_RTRIG_CORER_MASK);\n\t\ti40e_flush(hw);\n\t\tmsleep(200);\n\t\tpf->corer_count++;\n\n\t\ti40e_clear_pxe_mode(hw);\n\t}\n\n\t/* Reset here to make sure all is clean and to define PF 'n' */\n\ti40e_clear_hw(hw);\n\n\terr = i40e_set_mac_type(hw);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"unidentified MAC or BLANK NVM: %d\\n\",\n\t\t\t err);\n\t\tgoto err_pf_reset;\n\t}\n\n\terr = i40e_handle_resets(pf);\n\tif (err)\n\t\tgoto err_pf_reset;\n\n\ti40e_check_recovery_mode(pf);\n\n\thw->aq.num_arq_entries = I40E_AQ_LEN;\n\thw->aq.num_asq_entries = I40E_AQ_LEN;\n\thw->aq.arq_buf_size = I40E_MAX_AQ_BUF_SIZE;\n\thw->aq.asq_buf_size = I40E_MAX_AQ_BUF_SIZE;\n\tpf->adminq_work_limit = I40E_AQ_WORK_LIMIT;\n\n\tsnprintf(pf->int_name, sizeof(pf->int_name) - 1,\n\t\t \"%s-%s:misc\",\n\t\t dev_driver_string(&pf->pdev->dev), dev_name(&pdev->dev));\n\n\terr = i40e_init_shared_code(hw);\n\tif (err) {\n\t\tdev_warn(&pdev->dev, \"unidentified MAC or BLANK NVM: %d\\n\",\n\t\t\t err);\n\t\tgoto err_pf_reset;\n\t}\n\n\t/* set up a default setting for link flow control */\n\tpf->hw.fc.requested_mode = I40E_FC_NONE;\n\n\terr = i40e_init_adminq(hw);\n\tif (err) {\n\t\tif (err == I40E_ERR_FIRMWARE_API_VERSION)\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"The driver for the device stopped because the NVM image v%u.%u is newer than expected v%u.%u. You must install the most recent version of the network driver.\\n\",\n\t\t\t\t hw->aq.api_maj_ver,\n\t\t\t\t hw->aq.api_min_ver,\n\t\t\t\t I40E_FW_API_VERSION_MAJOR,\n\t\t\t\t I40E_FW_MINOR_VERSION(hw));\n\t\telse\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"The driver for the device stopped because the device firmware failed to init. Try updating your NVM image.\\n\");\n\n\t\tgoto err_pf_reset;\n\t}\n\ti40e_get_oem_version(hw);\n\n\t/* provide nvm, fw, api versions, vendor:device id, subsys vendor:device id */\n\tdev_info(&pdev->dev, \"fw %d.%d.%05d api %d.%d nvm %s [%04x:%04x] [%04x:%04x]\\n\",\n\t\t hw->aq.fw_maj_ver, hw->aq.fw_min_ver, hw->aq.fw_build,\n\t\t hw->aq.api_maj_ver, hw->aq.api_min_ver,\n\t\t i40e_nvm_version_str(hw), hw->vendor_id, hw->device_id,\n\t\t hw->subsystem_vendor_id, hw->subsystem_device_id);\n\n\tif (hw->aq.api_maj_ver == I40E_FW_API_VERSION_MAJOR &&\n\t    hw->aq.api_min_ver > I40E_FW_MINOR_VERSION(hw))\n\t\tdev_info(&pdev->dev,\n\t\t\t \"The driver for the device detected a newer version of the NVM image v%u.%u than expected v%u.%u. Please install the most recent version of the network driver.\\n\",\n\t\t\t hw->aq.api_maj_ver,\n\t\t\t hw->aq.api_min_ver,\n\t\t\t I40E_FW_API_VERSION_MAJOR,\n\t\t\t I40E_FW_MINOR_VERSION(hw));\n\telse if (hw->aq.api_maj_ver == 1 && hw->aq.api_min_ver < 4)\n\t\tdev_info(&pdev->dev,\n\t\t\t \"The driver for the device detected an older version of the NVM image v%u.%u than expected v%u.%u. Please update the NVM image.\\n\",\n\t\t\t hw->aq.api_maj_ver,\n\t\t\t hw->aq.api_min_ver,\n\t\t\t I40E_FW_API_VERSION_MAJOR,\n\t\t\t I40E_FW_MINOR_VERSION(hw));\n\n\ti40e_verify_eeprom(pf);\n\n\t/* Rev 0 hardware was never productized */\n\tif (hw->revision_id < 1)\n\t\tdev_warn(&pdev->dev, \"This device is a pre-production adapter/LOM. Please be aware there may be issues with your hardware. If you are experiencing problems please contact your Intel or hardware representative who provided you with this hardware.\\n\");\n\n\ti40e_clear_pxe_mode(hw);\n\n\terr = i40e_get_capabilities(pf, i40e_aqc_opc_list_func_capabilities);\n\tif (err)\n\t\tgoto err_adminq_setup;\n\n\terr = i40e_sw_init(pf);\n\tif (err) {\n\t\tdev_info(&pdev->dev, \"sw_init failed: %d\\n\", err);\n\t\tgoto err_sw_init;\n\t}\n\n\tif (test_bit(__I40E_RECOVERY_MODE, pf->state))\n\t\treturn i40e_init_recovery_mode(pf, hw);\n\n\terr = i40e_init_lan_hmc(hw, hw->func_caps.num_tx_qp,\n\t\t\t\thw->func_caps.num_rx_qp, 0, 0);\n\tif (err) {\n\t\tdev_info(&pdev->dev, \"init_lan_hmc failed: %d\\n\", err);\n\t\tgoto err_init_lan_hmc;\n\t}\n\n\terr = i40e_configure_lan_hmc(hw, I40E_HMC_MODEL_DIRECT_ONLY);\n\tif (err) {\n\t\tdev_info(&pdev->dev, \"configure_lan_hmc failed: %d\\n\", err);\n\t\terr = -ENOENT;\n\t\tgoto err_configure_lan_hmc;\n\t}\n\n\t/* Disable LLDP for NICs that have firmware versions lower than v4.3.\n\t * Ignore error return codes because if it was already disabled via\n\t * hardware settings this will fail\n\t */\n\tif (pf->hw_features & I40E_HW_STOP_FW_LLDP) {\n\t\tdev_info(&pdev->dev, \"Stopping firmware LLDP agent.\\n\");\n\t\ti40e_aq_stop_lldp(hw, true, false, NULL);\n\t}\n\n\t/* allow a platform config to override the HW addr */\n\ti40e_get_platform_mac_addr(pdev, pf);\n\n\tif (!is_valid_ether_addr(hw->mac.addr)) {\n\t\tdev_info(&pdev->dev, \"invalid MAC address %pM\\n\", hw->mac.addr);\n\t\terr = -EIO;\n\t\tgoto err_mac_addr;\n\t}\n\tdev_info(&pdev->dev, \"MAC address: %pM\\n\", hw->mac.addr);\n\tether_addr_copy(hw->mac.perm_addr, hw->mac.addr);\n\ti40e_get_port_mac_addr(hw, hw->mac.port_addr);\n\tif (is_valid_ether_addr(hw->mac.port_addr))\n\t\tpf->hw_features |= I40E_HW_PORT_ID_VALID;\n\n\tpci_set_drvdata(pdev, pf);\n\tpci_save_state(pdev);\n\n\tdev_info(&pdev->dev,\n\t\t (pf->flags & I40E_FLAG_DISABLE_FW_LLDP) ?\n\t\t\t\"FW LLDP is disabled\\n\" :\n\t\t\t\"FW LLDP is enabled\\n\");\n\n\t/* Enable FW to write default DCB config on link-up */\n\ti40e_aq_set_dcb_parameters(hw, true, NULL);\n\n#ifdef CONFIG_I40E_DCB\n\terr = i40e_init_pf_dcb(pf);\n\tif (err) {\n\t\tdev_info(&pdev->dev, \"DCB init failed %d, disabled\\n\", err);\n\t\tpf->flags &= ~(I40E_FLAG_DCB_CAPABLE | I40E_FLAG_DCB_ENABLED);\n\t\t/* Continue without DCB enabled */\n\t}\n#endif /* CONFIG_I40E_DCB */\n\n\t/* set up periodic task facility */\n\ttimer_setup(&pf->service_timer, i40e_service_timer, 0);\n\tpf->service_timer_period = HZ;\n\n\tINIT_WORK(&pf->service_task, i40e_service_task);\n\tclear_bit(__I40E_SERVICE_SCHED, pf->state);\n\n\t/* NVM bit on means WoL disabled for the port */\n\ti40e_read_nvm_word(hw, I40E_SR_NVM_WAKE_ON_LAN, &wol_nvm_bits);\n\tif (BIT (hw->port) & wol_nvm_bits || hw->partition_id != 1)\n\t\tpf->wol_en = false;\n\telse\n\t\tpf->wol_en = true;\n\tdevice_set_wakeup_enable(&pf->pdev->dev, pf->wol_en);\n\n\t/* set up the main switch operations */\n\ti40e_determine_queue_usage(pf);\n\terr = i40e_init_interrupt_scheme(pf);\n\tif (err)\n\t\tgoto err_switch_setup;\n\n\tpf->udp_tunnel_nic.set_port = i40e_udp_tunnel_set_port;\n\tpf->udp_tunnel_nic.unset_port = i40e_udp_tunnel_unset_port;\n\tpf->udp_tunnel_nic.flags = UDP_TUNNEL_NIC_INFO_MAY_SLEEP;\n\tpf->udp_tunnel_nic.shared = &pf->udp_tunnel_shared;\n\tpf->udp_tunnel_nic.tables[0].n_entries = I40E_MAX_PF_UDP_OFFLOAD_PORTS;\n\tpf->udp_tunnel_nic.tables[0].tunnel_types = UDP_TUNNEL_TYPE_VXLAN |\n\t\t\t\t\t\t    UDP_TUNNEL_TYPE_GENEVE;\n\n\t/* The number of VSIs reported by the FW is the minimum guaranteed\n\t * to us; HW supports far more and we share the remaining pool with\n\t * the other PFs. We allocate space for more than the guarantee with\n\t * the understanding that we might not get them all later.\n\t */\n\tif (pf->hw.func_caps.num_vsis < I40E_MIN_VSI_ALLOC)\n\t\tpf->num_alloc_vsi = I40E_MIN_VSI_ALLOC;\n\telse\n\t\tpf->num_alloc_vsi = pf->hw.func_caps.num_vsis;\n\tif (pf->num_alloc_vsi > UDP_TUNNEL_NIC_MAX_SHARING_DEVICES) {\n\t\tdev_warn(&pf->pdev->dev,\n\t\t\t \"limiting the VSI count due to UDP tunnel limitation %d > %d\\n\",\n\t\t\t pf->num_alloc_vsi, UDP_TUNNEL_NIC_MAX_SHARING_DEVICES);\n\t\tpf->num_alloc_vsi = UDP_TUNNEL_NIC_MAX_SHARING_DEVICES;\n\t}\n\n\t/* Set up the *vsi struct and our local tracking of the MAIN PF vsi. */\n\tpf->vsi = kcalloc(pf->num_alloc_vsi, sizeof(struct i40e_vsi *),\n\t\t\t  GFP_KERNEL);\n\tif (!pf->vsi) {\n\t\terr = -ENOMEM;\n\t\tgoto err_switch_setup;\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\t/* prep for VF support */\n\tif ((pf->flags & I40E_FLAG_SRIOV_ENABLED) &&\n\t    (pf->flags & I40E_FLAG_MSIX_ENABLED) &&\n\t    !test_bit(__I40E_BAD_EEPROM, pf->state)) {\n\t\tif (pci_num_vf(pdev))\n\t\t\tpf->flags |= I40E_FLAG_VEB_MODE_ENABLED;\n\t}\n#endif\n\terr = i40e_setup_pf_switch(pf, false);\n\tif (err) {\n\t\tdev_info(&pdev->dev, \"setup_pf_switch failed: %d\\n\", err);\n\t\tgoto err_vsis;\n\t}\n\tINIT_LIST_HEAD(&pf->vsi[pf->lan_vsi]->ch_list);\n\n\t/* Make sure flow control is set according to current settings */\n\terr = i40e_set_fc(hw, &set_fc_aq_fail, true);\n\tif (set_fc_aq_fail & I40E_SET_FC_AQ_FAIL_GET)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Set fc with err %s aq_err %s on get_phy_cap\\n\",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\tif (set_fc_aq_fail & I40E_SET_FC_AQ_FAIL_SET)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Set fc with err %s aq_err %s on set_phy_config\\n\",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\tif (set_fc_aq_fail & I40E_SET_FC_AQ_FAIL_UPDATE)\n\t\tdev_dbg(&pf->pdev->dev,\n\t\t\t\"Set fc with err %s aq_err %s on get_link_info\\n\",\n\t\t\ti40e_stat_str(hw, err),\n\t\t\ti40e_aq_str(hw, hw->aq.asq_last_status));\n\n\t/* if FDIR VSI was set up, start it now */\n\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (pf->vsi[i] && pf->vsi[i]->type == I40E_VSI_FDIR) {\n\t\t\ti40e_vsi_open(pf->vsi[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* The driver only wants link up/down and module qualification\n\t * reports from firmware.  Note the negative logic.\n\t */\n\terr = i40e_aq_set_phy_int_mask(&pf->hw,\n\t\t\t\t       ~(I40E_AQ_EVENT_LINK_UPDOWN |\n\t\t\t\t\t I40E_AQ_EVENT_MEDIA_NA |\n\t\t\t\t\t I40E_AQ_EVENT_MODULE_QUAL_FAIL), NULL);\n\tif (err)\n\t\tdev_info(&pf->pdev->dev, \"set phy mask fail, err %s aq_err %s\\n\",\n\t\t\t i40e_stat_str(&pf->hw, err),\n\t\t\t i40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\n\t/* Reconfigure hardware for allowing smaller MSS in the case\n\t * of TSO, so that we avoid the MDD being fired and causing\n\t * a reset in the case of small MSS+TSO.\n\t */\n\tval = rd32(hw, I40E_REG_MSS);\n\tif ((val & I40E_REG_MSS_MIN_MASK) > I40E_64BYTE_MSS) {\n\t\tval &= ~I40E_REG_MSS_MIN_MASK;\n\t\tval |= I40E_64BYTE_MSS;\n\t\twr32(hw, I40E_REG_MSS, val);\n\t}\n\n\tif (pf->hw_features & I40E_HW_RESTART_AUTONEG) {\n\t\tmsleep(75);\n\t\terr = i40e_aq_set_link_restart_an(&pf->hw, true, NULL);\n\t\tif (err)\n\t\t\tdev_info(&pf->pdev->dev, \"link restart failed, err %s aq_err %s\\n\",\n\t\t\t\t i40e_stat_str(&pf->hw, err),\n\t\t\t\t i40e_aq_str(&pf->hw,\n\t\t\t\t\t     pf->hw.aq.asq_last_status));\n\t}\n\t/* The main driver is (mostly) up and happy. We need to set this state\n\t * before setting up the misc vector or we get a race and the vector\n\t * ends up disabled forever.\n\t */\n\tclear_bit(__I40E_DOWN, pf->state);\n\n\t/* In case of MSIX we are going to setup the misc vector right here\n\t * to handle admin queue events etc. In case of legacy and MSI\n\t * the misc functionality and queue processing is combined in\n\t * the same vector and that gets setup at open.\n\t */\n\tif (pf->flags & I40E_FLAG_MSIX_ENABLED) {\n\t\terr = i40e_setup_misc_vector(pf);\n\t\tif (err) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"setup of misc vector failed: %d\\n\", err);\n\t\t\tgoto err_vsis;\n\t\t}\n\t}\n\n#ifdef CONFIG_PCI_IOV\n\t/* prep for VF support */\n\tif ((pf->flags & I40E_FLAG_SRIOV_ENABLED) &&\n\t    (pf->flags & I40E_FLAG_MSIX_ENABLED) &&\n\t    !test_bit(__I40E_BAD_EEPROM, pf->state)) {\n\t\t/* disable link interrupts for VFs */\n\t\tval = rd32(hw, I40E_PFGEN_PORTMDIO_NUM);\n\t\tval &= ~I40E_PFGEN_PORTMDIO_NUM_VFLINK_STAT_ENA_MASK;\n\t\twr32(hw, I40E_PFGEN_PORTMDIO_NUM, val);\n\t\ti40e_flush(hw);\n\n\t\tif (pci_num_vf(pdev)) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Active VFs found, allocating resources.\\n\");\n\t\t\terr = i40e_alloc_vfs(pf, pci_num_vf(pdev));\n\t\t\tif (err)\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t \"Error %d allocating resources for existing VFs\\n\",\n\t\t\t\t\t err);\n\t\t}\n\t}\n#endif /* CONFIG_PCI_IOV */\n\n\tif (pf->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\tpf->iwarp_base_vector = i40e_get_lump(pf, pf->irq_pile,\n\t\t\t\t\t\t      pf->num_iwarp_msix,\n\t\t\t\t\t\t      I40E_IWARP_IRQ_PILE_ID);\n\t\tif (pf->iwarp_base_vector < 0) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"failed to get tracking for %d vectors for IWARP err=%d\\n\",\n\t\t\t\t pf->num_iwarp_msix, pf->iwarp_base_vector);\n\t\t\tpf->flags &= ~I40E_FLAG_IWARP_ENABLED;\n\t\t}\n\t}\n\n\ti40e_dbg_pf_init(pf);\n\n\t/* tell the firmware that we're starting */\n\ti40e_send_version(pf);\n\n\t/* since everything's happy, start the service_task timer */\n\tmod_timer(&pf->service_timer,\n\t\t  round_jiffies(jiffies + pf->service_timer_period));\n\n\t/* add this PF to client device list and launch a client service task */\n\tif (pf->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\terr = i40e_lan_add_device(pf);\n\t\tif (err)\n\t\t\tdev_info(&pdev->dev, \"Failed to add PF to client API service list: %d\\n\",\n\t\t\t\t err);\n\t}\n\n#define PCI_SPEED_SIZE 8\n#define PCI_WIDTH_SIZE 8\n\t/* Devices on the IOSF bus do not have this information\n\t * and will report PCI Gen 1 x 1 by default so don't bother\n\t * checking them.\n\t */\n\tif (!(pf->hw_features & I40E_HW_NO_PCI_LINK_CHECK)) {\n\t\tchar speed[PCI_SPEED_SIZE] = \"Unknown\";\n\t\tchar width[PCI_WIDTH_SIZE] = \"Unknown\";\n\n\t\t/* Get the negotiated link width and speed from PCI config\n\t\t * space\n\t\t */\n\t\tpcie_capability_read_word(pf->pdev, PCI_EXP_LNKSTA,\n\t\t\t\t\t  &link_status);\n\n\t\ti40e_set_pci_config_data(hw, link_status);\n\n\t\tswitch (hw->bus.speed) {\n\t\tcase i40e_bus_speed_8000:\n\t\t\tstrlcpy(speed, \"8.0\", PCI_SPEED_SIZE); break;\n\t\tcase i40e_bus_speed_5000:\n\t\t\tstrlcpy(speed, \"5.0\", PCI_SPEED_SIZE); break;\n\t\tcase i40e_bus_speed_2500:\n\t\t\tstrlcpy(speed, \"2.5\", PCI_SPEED_SIZE); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tswitch (hw->bus.width) {\n\t\tcase i40e_bus_width_pcie_x8:\n\t\t\tstrlcpy(width, \"8\", PCI_WIDTH_SIZE); break;\n\t\tcase i40e_bus_width_pcie_x4:\n\t\t\tstrlcpy(width, \"4\", PCI_WIDTH_SIZE); break;\n\t\tcase i40e_bus_width_pcie_x2:\n\t\t\tstrlcpy(width, \"2\", PCI_WIDTH_SIZE); break;\n\t\tcase i40e_bus_width_pcie_x1:\n\t\t\tstrlcpy(width, \"1\", PCI_WIDTH_SIZE); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_info(&pdev->dev, \"PCI-Express: Speed %sGT/s Width x%s\\n\",\n\t\t\t speed, width);\n\n\t\tif (hw->bus.width < i40e_bus_width_pcie_x8 ||\n\t\t    hw->bus.speed < i40e_bus_speed_8000) {\n\t\t\tdev_warn(&pdev->dev, \"PCI-Express bandwidth available for this device may be insufficient for optimal performance.\\n\");\n\t\t\tdev_warn(&pdev->dev, \"Please move the device to a different PCI-e link with more lanes and/or higher transfer rate.\\n\");\n\t\t}\n\t}\n\n\t/* get the requested speeds from the fw */\n\terr = i40e_aq_get_phy_capabilities(hw, false, false, &abilities, NULL);\n\tif (err)\n\t\tdev_dbg(&pf->pdev->dev, \"get requested speeds ret =  %s last_status =  %s\\n\",\n\t\t\ti40e_stat_str(&pf->hw, err),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\tpf->hw.phy.link_info.requested_speeds = abilities.link_speed;\n\n\t/* set the FEC config due to the board capabilities */\n\ti40e_set_fec_in_flags(abilities.fec_cfg_curr_mod_ext_info, &pf->flags);\n\n\t/* get the supported phy types from the fw */\n\terr = i40e_aq_get_phy_capabilities(hw, false, true, &abilities, NULL);\n\tif (err)\n\t\tdev_dbg(&pf->pdev->dev, \"get supported phy types ret =  %s last_status =  %s\\n\",\n\t\t\ti40e_stat_str(&pf->hw, err),\n\t\t\ti40e_aq_str(&pf->hw, pf->hw.aq.asq_last_status));\n\n\t/* make sure the MFS hasn't been set lower than the default */\n#define MAX_FRAME_SIZE_DEFAULT 0x2600\n\tval = (rd32(&pf->hw, I40E_PRTGL_SAH) &\n\t       I40E_PRTGL_SAH_MFS_MASK) >> I40E_PRTGL_SAH_MFS_SHIFT;\n\tif (val < MAX_FRAME_SIZE_DEFAULT)\n\t\tdev_warn(&pdev->dev, \"MFS for port %x has been set below the default: %x\\n\",\n\t\t\t i, val);\n\n\t/* Add a filter to drop all Flow control frames from any VSI from being\n\t * transmitted. By doing so we stop a malicious VF from sending out\n\t * PAUSE or PFC frames and potentially controlling traffic for other\n\t * PF/VF VSIs.\n\t * The FW can still send Flow control frames if enabled.\n\t */\n\ti40e_add_filter_to_drop_tx_flow_control_frames(&pf->hw,\n\t\t\t\t\t\t       pf->main_vsi_seid);\n\n\tif ((pf->hw.device_id == I40E_DEV_ID_10G_BASE_T) ||\n\t\t(pf->hw.device_id == I40E_DEV_ID_10G_BASE_T4))\n\t\tpf->hw_features |= I40E_HW_PHY_CONTROLS_LEDS;\n\tif (pf->hw.device_id == I40E_DEV_ID_SFP_I_X722)\n\t\tpf->hw_features |= I40E_HW_HAVE_CRT_RETIMER;\n\t/* print a string summarizing features */\n\ti40e_print_features(pf);\n\n\treturn 0;\n\n\t/* Unwind what we've done if something failed in the setup */\nerr_vsis:\n\tset_bit(__I40E_DOWN, pf->state);\n\ti40e_clear_interrupt_scheme(pf);\n\tkfree(pf->vsi);\nerr_switch_setup:\n\ti40e_reset_interrupt_capability(pf);\n\tdel_timer_sync(&pf->service_timer);\nerr_mac_addr:\nerr_configure_lan_hmc:\n\t(void)i40e_shutdown_lan_hmc(hw);\nerr_init_lan_hmc:\n\tkfree(pf->qp_pile);\nerr_sw_init:\nerr_adminq_setup:\nerr_pf_reset:\n\tiounmap(hw->hw_addr);\nerr_ioremap:\n\tkfree(pf);\nerr_pf_alloc:\n\tpci_disable_pcie_error_reporting(pdev);\n\tpci_release_mem_regions(pdev);\nerr_pci_reg:\nerr_dma:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n/**\n * i40e_remove - Device removal routine\n * @pdev: PCI device information struct\n *\n * i40e_remove is called by the PCI subsystem to alert the driver\n * that is should release a PCI device.  This could be caused by a\n * Hot-Plug event, or because the driver is going to be removed from\n * memory.\n **/\nstatic void i40e_remove(struct pci_dev *pdev)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret_code;\n\tint i;\n\n\ti40e_dbg_pf_exit(pf);\n\n\ti40e_ptp_stop(pf);\n\n\t/* Disable RSS in hw */\n\ti40e_write_rx_ctl(hw, I40E_PFQF_HENA(0), 0);\n\ti40e_write_rx_ctl(hw, I40E_PFQF_HENA(1), 0);\n\n\twhile (test_bit(__I40E_RESET_RECOVERY_PENDING, pf->state))\n\t\tusleep_range(1000, 2000);\n\n\tif (pf->flags & I40E_FLAG_SRIOV_ENABLED) {\n\t\tset_bit(__I40E_VF_RESETS_DISABLED, pf->state);\n\t\ti40e_free_vfs(pf);\n\t\tpf->flags &= ~I40E_FLAG_SRIOV_ENABLED;\n\t}\n\t/* no more scheduling of any task */\n\tset_bit(__I40E_SUSPENDED, pf->state);\n\tset_bit(__I40E_DOWN, pf->state);\n\tif (pf->service_timer.function)\n\t\tdel_timer_sync(&pf->service_timer);\n\tif (pf->service_task.func)\n\t\tcancel_work_sync(&pf->service_task);\n\n\tif (test_bit(__I40E_RECOVERY_MODE, pf->state)) {\n\t\tstruct i40e_vsi *vsi = pf->vsi[0];\n\n\t\t/* We know that we have allocated only one vsi for this PF,\n\t\t * it was just for registering netdevice, so the interface\n\t\t * could be visible in the 'ifconfig' output\n\t\t */\n\t\tunregister_netdev(vsi->netdev);\n\t\tfree_netdev(vsi->netdev);\n\n\t\tgoto unmap;\n\t}\n\n\t/* Client close must be called explicitly here because the timer\n\t * has been stopped.\n\t */\n\ti40e_notify_client_of_netdev_close(pf->vsi[pf->lan_vsi], false);\n\n\ti40e_fdir_teardown(pf);\n\n\t/* If there is a switch structure or any orphans, remove them.\n\t * This will leave only the PF's VSI remaining.\n\t */\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tif (!pf->veb[i])\n\t\t\tcontinue;\n\n\t\tif (pf->veb[i]->uplink_seid == pf->mac_seid ||\n\t\t    pf->veb[i]->uplink_seid == 0)\n\t\t\ti40e_switch_branch_release(pf->veb[i]);\n\t}\n\n\t/* Now we can shutdown the PF's VSI, just before we kill\n\t * adminq and hmc.\n\t */\n\tif (pf->vsi[pf->lan_vsi])\n\t\ti40e_vsi_release(pf->vsi[pf->lan_vsi]);\n\n\ti40e_cloud_filter_exit(pf);\n\n\t/* remove attached clients */\n\tif (pf->flags & I40E_FLAG_IWARP_ENABLED) {\n\t\tret_code = i40e_lan_del_device(pf);\n\t\tif (ret_code)\n\t\t\tdev_warn(&pdev->dev, \"Failed to delete client device: %d\\n\",\n\t\t\t\t ret_code);\n\t}\n\n\t/* shutdown and destroy the HMC */\n\tif (hw->hmc.hmc_obj) {\n\t\tret_code = i40e_shutdown_lan_hmc(hw);\n\t\tif (ret_code)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Failed to destroy the HMC resources: %d\\n\",\n\t\t\t\t ret_code);\n\t}\n\nunmap:\n\t/* Free MSI/legacy interrupt 0 when in recovery mode. */\n\tif (test_bit(__I40E_RECOVERY_MODE, pf->state) &&\n\t    !(pf->flags & I40E_FLAG_MSIX_ENABLED))\n\t\tfree_irq(pf->pdev->irq, pf);\n\n\t/* shutdown the adminq */\n\ti40e_shutdown_adminq(hw);\n\n\t/* destroy the locks only once, here */\n\tmutex_destroy(&hw->aq.arq_mutex);\n\tmutex_destroy(&hw->aq.asq_mutex);\n\n\t/* Clear all dynamic memory lists of rings, q_vectors, and VSIs */\n\trtnl_lock();\n\ti40e_clear_interrupt_scheme(pf);\n\tfor (i = 0; i < pf->num_alloc_vsi; i++) {\n\t\tif (pf->vsi[i]) {\n\t\t\tif (!test_bit(__I40E_RECOVERY_MODE, pf->state))\n\t\t\t\ti40e_vsi_clear_rings(pf->vsi[i]);\n\t\t\ti40e_vsi_clear(pf->vsi[i]);\n\t\t\tpf->vsi[i] = NULL;\n\t\t}\n\t}\n\trtnl_unlock();\n\n\tfor (i = 0; i < I40E_MAX_VEB; i++) {\n\t\tkfree(pf->veb[i]);\n\t\tpf->veb[i] = NULL;\n\t}\n\n\tkfree(pf->qp_pile);\n\tkfree(pf->vsi);\n\n\tiounmap(hw->hw_addr);\n\tkfree(pf);\n\tpci_release_mem_regions(pdev);\n\n\tpci_disable_pcie_error_reporting(pdev);\n\tpci_disable_device(pdev);\n}\n\n/**\n * i40e_pci_error_detected - warning that something funky happened in PCI land\n * @pdev: PCI device information struct\n * @error: the type of PCI error\n *\n * Called to warn that something happened and the error handling steps\n * are in progress.  Allows the driver to quiesce things, be ready for\n * remediation.\n **/\nstatic pci_ers_result_t i40e_pci_error_detected(struct pci_dev *pdev,\n\t\t\t\t\t\tpci_channel_state_t error)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\n\tdev_info(&pdev->dev, \"%s: error %d\\n\", __func__, error);\n\n\tif (!pf) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Cannot recover - error happened during device probe\\n\");\n\t\treturn PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\t/* shutdown all operations */\n\tif (!test_bit(__I40E_SUSPENDED, pf->state))\n\t\ti40e_prep_for_reset(pf, false);\n\n\t/* Request a slot reset */\n\treturn PCI_ERS_RESULT_NEED_RESET;\n}\n\n/**\n * i40e_pci_error_slot_reset - a PCI slot reset just happened\n * @pdev: PCI device information struct\n *\n * Called to find if the driver can work with the device now that\n * the pci slot has been reset.  If a basic connection seems good\n * (registers are readable and have sane content) then return a\n * happy little PCI_ERS_RESULT_xxx.\n **/\nstatic pci_ers_result_t i40e_pci_error_slot_reset(struct pci_dev *pdev)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\tpci_ers_result_t result;\n\tu32 reg;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\tif (pci_enable_device_mem(pdev)) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Cannot re-enable PCI device after reset.\\n\");\n\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t} else {\n\t\tpci_set_master(pdev);\n\t\tpci_restore_state(pdev);\n\t\tpci_save_state(pdev);\n\t\tpci_wake_from_d3(pdev, false);\n\n\t\treg = rd32(&pf->hw, I40E_GLGEN_RTRIG);\n\t\tif (reg == 0)\n\t\t\tresult = PCI_ERS_RESULT_RECOVERED;\n\t\telse\n\t\t\tresult = PCI_ERS_RESULT_DISCONNECT;\n\t}\n\n\treturn result;\n}\n\n/**\n * i40e_pci_error_reset_prepare - prepare device driver for pci reset\n * @pdev: PCI device information struct\n */\nstatic void i40e_pci_error_reset_prepare(struct pci_dev *pdev)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\n\ti40e_prep_for_reset(pf, false);\n}\n\n/**\n * i40e_pci_error_reset_done - pci reset done, device driver reset can begin\n * @pdev: PCI device information struct\n */\nstatic void i40e_pci_error_reset_done(struct pci_dev *pdev)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\n\ti40e_reset_and_rebuild(pf, false, false);\n}\n\n/**\n * i40e_pci_error_resume - restart operations after PCI error recovery\n * @pdev: PCI device information struct\n *\n * Called to allow the driver to bring things back up after PCI error\n * and/or reset recovery has finished.\n **/\nstatic void i40e_pci_error_resume(struct pci_dev *pdev)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\tif (test_bit(__I40E_SUSPENDED, pf->state))\n\t\treturn;\n\n\ti40e_handle_reset_warning(pf, false);\n}\n\n/**\n * i40e_enable_mc_magic_wake - enable multicast magic packet wake up\n * using the mac_address_write admin q function\n * @pf: pointer to i40e_pf struct\n **/\nstatic void i40e_enable_mc_magic_wake(struct i40e_pf *pf)\n{\n\tstruct i40e_hw *hw = &pf->hw;\n\ti40e_status ret;\n\tu8 mac_addr[6];\n\tu16 flags = 0;\n\n\t/* Get current MAC address in case it's an LAA */\n\tif (pf->vsi[pf->lan_vsi] && pf->vsi[pf->lan_vsi]->netdev) {\n\t\tether_addr_copy(mac_addr,\n\t\t\t\tpf->vsi[pf->lan_vsi]->netdev->dev_addr);\n\t} else {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to retrieve MAC address; using default\\n\");\n\t\tether_addr_copy(mac_addr, hw->mac.addr);\n\t}\n\n\t/* The FW expects the mac address write cmd to first be called with\n\t * one of these flags before calling it again with the multicast\n\t * enable flags.\n\t */\n\tflags = I40E_AQC_WRITE_TYPE_LAA_WOL;\n\n\tif (hw->func_caps.flex10_enable && hw->partition_id != 1)\n\t\tflags = I40E_AQC_WRITE_TYPE_LAA_ONLY;\n\n\tret = i40e_aq_mac_address_write(hw, flags, mac_addr, NULL);\n\tif (ret) {\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to update MAC address registers; cannot enable Multicast Magic packet wake up\");\n\t\treturn;\n\t}\n\n\tflags = I40E_AQC_MC_MAG_EN\n\t\t\t| I40E_AQC_WOL_PRESERVE_ON_PFR\n\t\t\t| I40E_AQC_WRITE_TYPE_UPDATE_MC_MAG;\n\tret = i40e_aq_mac_address_write(hw, flags, mac_addr, NULL);\n\tif (ret)\n\t\tdev_err(&pf->pdev->dev,\n\t\t\t\"Failed to enable Multicast Magic Packet wake up\\n\");\n}\n\n/**\n * i40e_shutdown - PCI callback for shutting down\n * @pdev: PCI device information struct\n **/\nstatic void i40e_shutdown(struct pci_dev *pdev)\n{\n\tstruct i40e_pf *pf = pci_get_drvdata(pdev);\n\tstruct i40e_hw *hw = &pf->hw;\n\n\tset_bit(__I40E_SUSPENDED, pf->state);\n\tset_bit(__I40E_DOWN, pf->state);\n\n\tdel_timer_sync(&pf->service_timer);\n\tcancel_work_sync(&pf->service_task);\n\ti40e_cloud_filter_exit(pf);\n\ti40e_fdir_teardown(pf);\n\n\t/* Client close must be called explicitly here because the timer\n\t * has been stopped.\n\t */\n\ti40e_notify_client_of_netdev_close(pf->vsi[pf->lan_vsi], false);\n\n\tif (pf->wol_en && (pf->hw_features & I40E_HW_WOL_MC_MAGIC_PKT_WAKE))\n\t\ti40e_enable_mc_magic_wake(pf);\n\n\ti40e_prep_for_reset(pf, false);\n\n\twr32(hw, I40E_PFPM_APM,\n\t     (pf->wol_en ? I40E_PFPM_APM_APME_MASK : 0));\n\twr32(hw, I40E_PFPM_WUFC,\n\t     (pf->wol_en ? I40E_PFPM_WUFC_MAG_MASK : 0));\n\n\t/* Free MSI/legacy interrupt 0 when in recovery mode. */\n\tif (test_bit(__I40E_RECOVERY_MODE, pf->state) &&\n\t    !(pf->flags & I40E_FLAG_MSIX_ENABLED))\n\t\tfree_irq(pf->pdev->irq, pf);\n\n\t/* Since we're going to destroy queues during the\n\t * i40e_clear_interrupt_scheme() we should hold the RTNL lock for this\n\t * whole section\n\t */\n\trtnl_lock();\n\ti40e_clear_interrupt_scheme(pf);\n\trtnl_unlock();\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, pf->wol_en);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\n/**\n * i40e_suspend - PM callback for moving to D3\n * @dev: generic device information structure\n **/\nstatic int __maybe_unused i40e_suspend(struct device *dev)\n{\n\tstruct i40e_pf *pf = dev_get_drvdata(dev);\n\tstruct i40e_hw *hw = &pf->hw;\n\n\t/* If we're already suspended, then there is nothing to do */\n\tif (test_and_set_bit(__I40E_SUSPENDED, pf->state))\n\t\treturn 0;\n\n\tset_bit(__I40E_DOWN, pf->state);\n\n\t/* Ensure service task will not be running */\n\tdel_timer_sync(&pf->service_timer);\n\tcancel_work_sync(&pf->service_task);\n\n\t/* Client close must be called explicitly here because the timer\n\t * has been stopped.\n\t */\n\ti40e_notify_client_of_netdev_close(pf->vsi[pf->lan_vsi], false);\n\n\tif (pf->wol_en && (pf->hw_features & I40E_HW_WOL_MC_MAGIC_PKT_WAKE))\n\t\ti40e_enable_mc_magic_wake(pf);\n\n\t/* Since we're going to destroy queues during the\n\t * i40e_clear_interrupt_scheme() we should hold the RTNL lock for this\n\t * whole section\n\t */\n\trtnl_lock();\n\n\ti40e_prep_for_reset(pf, true);\n\n\twr32(hw, I40E_PFPM_APM, (pf->wol_en ? I40E_PFPM_APM_APME_MASK : 0));\n\twr32(hw, I40E_PFPM_WUFC, (pf->wol_en ? I40E_PFPM_WUFC_MAG_MASK : 0));\n\n\t/* Clear the interrupt scheme and release our IRQs so that the system\n\t * can safely hibernate even when there are a large number of CPUs.\n\t * Otherwise hibernation might fail when mapping all the vectors back\n\t * to CPU0.\n\t */\n\ti40e_clear_interrupt_scheme(pf);\n\n\trtnl_unlock();\n\n\treturn 0;\n}\n\n/**\n * i40e_resume - PM callback for waking up from D3\n * @dev: generic device information structure\n **/\nstatic int __maybe_unused i40e_resume(struct device *dev)\n{\n\tstruct i40e_pf *pf = dev_get_drvdata(dev);\n\tint err;\n\n\t/* If we're not suspended, then there is nothing to do */\n\tif (!test_bit(__I40E_SUSPENDED, pf->state))\n\t\treturn 0;\n\n\t/* We need to hold the RTNL lock prior to restoring interrupt schemes,\n\t * since we're going to be restoring queues\n\t */\n\trtnl_lock();\n\n\t/* We cleared the interrupt scheme when we suspended, so we need to\n\t * restore it now to resume device functionality.\n\t */\n\terr = i40e_restore_interrupt_scheme(pf);\n\tif (err) {\n\t\tdev_err(dev, \"Cannot restore interrupt scheme: %d\\n\",\n\t\t\terr);\n\t}\n\n\tclear_bit(__I40E_DOWN, pf->state);\n\ti40e_reset_and_rebuild(pf, false, true);\n\n\trtnl_unlock();\n\n\t/* Clear suspended state last after everything is recovered */\n\tclear_bit(__I40E_SUSPENDED, pf->state);\n\n\t/* Restart the service task */\n\tmod_timer(&pf->service_timer,\n\t\t  round_jiffies(jiffies + pf->service_timer_period));\n\n\treturn 0;\n}\n\nstatic const struct pci_error_handlers i40e_err_handler = {\n\t.error_detected = i40e_pci_error_detected,\n\t.slot_reset = i40e_pci_error_slot_reset,\n\t.reset_prepare = i40e_pci_error_reset_prepare,\n\t.reset_done = i40e_pci_error_reset_done,\n\t.resume = i40e_pci_error_resume,\n};\n\nstatic SIMPLE_DEV_PM_OPS(i40e_pm_ops, i40e_suspend, i40e_resume);\n\nstatic struct pci_driver i40e_driver = {\n\t.name     = i40e_driver_name,\n\t.id_table = i40e_pci_tbl,\n\t.probe    = i40e_probe,\n\t.remove   = i40e_remove,\n\t.driver   = {\n\t\t.pm = &i40e_pm_ops,\n\t},\n\t.shutdown = i40e_shutdown,\n\t.err_handler = &i40e_err_handler,\n\t.sriov_configure = i40e_pci_sriov_configure,\n};\n\n/**\n * i40e_init_module - Driver registration routine\n *\n * i40e_init_module is the first routine called when the driver is\n * loaded. All it does is register with the PCI subsystem.\n **/\nstatic int __init i40e_init_module(void)\n{\n\tpr_info(\"%s: %s\\n\", i40e_driver_name, i40e_driver_string);\n\tpr_info(\"%s: %s\\n\", i40e_driver_name, i40e_copyright);\n\n\t/* There is no need to throttle the number of active tasks because\n\t * each device limits its own task using a state bit for scheduling\n\t * the service task, and the device tasks do not interfere with each\n\t * other, so we don't set a max task limit. We must set WQ_MEM_RECLAIM\n\t * since we need to be able to guarantee forward progress even under\n\t * memory pressure.\n\t */\n\ti40e_wq = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0, i40e_driver_name);\n\tif (!i40e_wq) {\n\t\tpr_err(\"%s: Failed to create workqueue\\n\", i40e_driver_name);\n\t\treturn -ENOMEM;\n\t}\n\n\ti40e_dbg_init();\n\treturn pci_register_driver(&i40e_driver);\n}\nmodule_init(i40e_init_module);\n\n/**\n * i40e_exit_module - Driver exit cleanup routine\n *\n * i40e_exit_module is called just before the driver is removed\n * from memory.\n **/\nstatic void __exit i40e_exit_module(void)\n{\n\tpci_unregister_driver(&i40e_driver);\n\tdestroy_workqueue(i40e_wq);\n\ti40e_dbg_exit();\n}\nmodule_exit(i40e_exit_module);\n"}}, "reports": [{"events": [{"location": {"col": 35, "file": 0, "line": 7138}, "message": "ERROR: invalid reference to the index variable of the iterator on line 7105"}], "macros": [], "notes": [], "path": "/src/drivers/net/ethernet/intel/i40e/i40e_main.c", "reportHash": "10772b650abdba83369adecb8eab2ebb", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
