<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/src/drivers/tty/serial/8250/8250_core.c", "content": "// SPDX-License-Identifier: GPL-2.0+\n/*\n *  Universal/legacy driver for 8250/16550-type serial ports\n *\n *  Based on drivers/char/serial.c, by Linus Torvalds, Theodore Ts'o.\n *\n *  Copyright (C) 2001 Russell King.\n *\n *  Supports: ISA-compatible 8250/16550 ports\n *\t      PNP 8250/16550 ports\n *\t      early_serial_setup() ports\n *\t      userspace-configurable \"phantom\" ports\n *\t      \"serial8250\" platform devices\n *\t      serial8250_register_8250_port() ports\n */\n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/sysrq.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/tty.h>\n#include <linux/ratelimit.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/serial_8250.h>\n#include <linux/nmi.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/pm_runtime.h>\n#include <linux/io.h>\n#ifdef CONFIG_SPARC\n#include <linux/sunserialcore.h>\n#endif\n\n#include <asm/irq.h>\n\n#include \"8250.h\"\n\n/*\n * Configuration:\n *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option\n *                is unsafe when used on edge-triggered interrupts.\n */\nstatic unsigned int share_irqs = SERIAL8250_SHARE_IRQS;\n\nstatic unsigned int nr_uarts = CONFIG_SERIAL_8250_RUNTIME_UARTS;\n\nstatic struct uart_driver serial8250_reg;\n\nstatic unsigned int skip_txen_test; /* force skip of txen test at init time */\n\n#define PASS_LIMIT\t512\n\n#include <asm/serial.h>\n/*\n * SERIAL_PORT_DFNS tells us about built-in ports that have no\n * standard enumeration mechanism.   Platforms that can find all\n * serial ports via mechanisms like ACPI or PCI need not supply it.\n */\n#ifndef SERIAL_PORT_DFNS\n#define SERIAL_PORT_DFNS\n#endif\n\nstatic const struct old_serial_port old_serial_port[] = {\n\tSERIAL_PORT_DFNS /* defined in asm/serial.h */\n};\n\n#define UART_NR\tCONFIG_SERIAL_8250_NR_UARTS\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\n#define PORT_RSA_MAX 4\nstatic unsigned long probe_rsa[PORT_RSA_MAX];\nstatic unsigned int probe_rsa_count;\n#endif /* CONFIG_SERIAL_8250_RSA  */\n\nstruct irq_info {\n\tstruct\t\t\thlist_node node;\n\tint\t\t\tirq;\n\tspinlock_t\t\tlock;\t/* Protects list not the hash */\n\tstruct list_head\t*head;\n};\n\n#define NR_IRQ_HASH\t\t32\t/* Can be adjusted later */\nstatic struct hlist_head irq_lists[NR_IRQ_HASH];\nstatic DEFINE_MUTEX(hash_mutex);\t/* Used to walk the hash */\n\n/*\n * This is the serial driver's interrupt routine.\n *\n * Arjan thinks the old way was overly complex, so it got simplified.\n * Alan disagrees, saying that need the complexity to handle the weird\n * nature of ISA shared interrupts.  (This is a special exception.)\n *\n * In order to handle ISA shared interrupts properly, we need to check\n * that all ports have been serviced, and therefore the ISA interrupt\n * line has been de-asserted.\n *\n * This means we need to loop through all ports. checking that they\n * don't have an interrupt pending.\n */\nstatic irqreturn_t serial8250_interrupt(int irq, void *dev_id)\n{\n\tstruct irq_info *i = dev_id;\n\tstruct list_head *l, *end = NULL;\n\tint pass_counter = 0, handled = 0;\n\n\tpr_debug(\"%s(%d): start\\n\", __func__, irq);\n\n\tspin_lock(&i->lock);\n\n\tl = i->head;\n\tdo {\n\t\tstruct uart_8250_port *up;\n\t\tstruct uart_port *port;\n\n\t\tup = list_entry(l, struct uart_8250_port, list);\n\t\tport = &up->port;\n\n\t\tif (port->handle_irq(port)) {\n\t\t\thandled = 1;\n\t\t\tend = NULL;\n\t\t} else if (end == NULL)\n\t\t\tend = l;\n\n\t\tl = l->next;\n\n\t\tif (l == i->head && pass_counter++ > PASS_LIMIT)\n\t\t\tbreak;\n\t} while (l != end);\n\n\tspin_unlock(&i->lock);\n\n\tpr_debug(\"%s(%d): end\\n\", __func__, irq);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n/*\n * To support ISA shared interrupts, we need to have one interrupt\n * handler that ensures that the IRQ line has been deasserted\n * before returning.  Failing to do this will result in the IRQ\n * line being stuck active, and, since ISA irqs are edge triggered,\n * no more IRQs will be seen.\n */\nstatic void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)\n{\n\tspin_lock_irq(&i->lock);\n\n\tif (!list_empty(i->head)) {\n\t\tif (i->head == &up->list)\n\t\t\ti->head = i->head->next;\n\t\tlist_del(&up->list);\n\t} else {\n\t\tBUG_ON(i->head != &up->list);\n\t\ti->head = NULL;\n\t}\n\tspin_unlock_irq(&i->lock);\n\t/* List empty so throw away the hash node */\n\tif (i->head == NULL) {\n\t\thlist_del(&i->node);\n\t\tkfree(i);\n\t}\n}\n\nstatic int serial_link_irq_chain(struct uart_8250_port *up)\n{\n\tstruct hlist_head *h;\n\tstruct hlist_node *n;\n\tstruct irq_info *i;\n\tint ret;\n\n\tmutex_lock(&hash_mutex);\n\n\th = &irq_lists[up->port.irq % NR_IRQ_HASH];\n\n\thlist_for_each(n, h) {\n\t\ti = hlist_entry(n, struct irq_info, node);\n\t\tif (i->irq == up->port.irq)\n\t\t\tbreak;\n\t}\n\n\tif (n == NULL) {\n\t\ti = kzalloc(sizeof(struct irq_info), GFP_KERNEL);\n\t\tif (i == NULL) {\n\t\t\tmutex_unlock(&hash_mutex);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tspin_lock_init(&i->lock);\n\t\ti->irq = up->port.irq;\n\t\thlist_add_head(&i->node, h);\n\t}\n\tmutex_unlock(&hash_mutex);\n\n\tspin_lock_irq(&i->lock);\n\n\tif (i->head) {\n\t\tlist_add(&up->list, i->head);\n\t\tspin_unlock_irq(&i->lock);\n\n\t\tret = 0;\n\t} else {\n\t\tINIT_LIST_HEAD(&up->list);\n\t\ti->head = &up->list;\n\t\tspin_unlock_irq(&i->lock);\n\t\tret = request_irq(up->port.irq, serial8250_interrupt,\n\t\t\t\t  up->port.irqflags, up->port.name, i);\n\t\tif (ret < 0)\n\t\t\tserial_do_unlink(i, up);\n\t}\n\n\treturn ret;\n}\n\nstatic void serial_unlink_irq_chain(struct uart_8250_port *up)\n{\n\t/*\n\t * yes, some broken gcc emit \"warning: 'i' may be used uninitialized\"\n\t * but no, we are not going to take a patch that assigns NULL below.\n\t */\n\tstruct irq_info *i;\n\tstruct hlist_node *n;\n\tstruct hlist_head *h;\n\n\tmutex_lock(&hash_mutex);\n\n\th = &irq_lists[up->port.irq % NR_IRQ_HASH];\n\n\thlist_for_each(n, h) {\n\t\ti = hlist_entry(n, struct irq_info, node);\n\t\tif (i->irq == up->port.irq)\n\t\t\tbreak;\n\t}\n\n\tBUG_ON(n == NULL);\n\tBUG_ON(i->head == NULL);\n\n\tif (list_empty(i->head))\n\t\tfree_irq(up->port.irq, i);\n\n\tserial_do_unlink(i, up);\n\tmutex_unlock(&hash_mutex);\n}\n\n/*\n * This function is used to handle ports that do not have an\n * interrupt.  This doesn't work very well for 16450's, but gives\n * barely passable results for a 16550A.  (Although at the expense\n * of much CPU overhead).\n */\nstatic void serial8250_timeout(struct timer_list *t)\n{\n\tstruct uart_8250_port *up = from_timer(up, t, timer);\n\n\tup->port.handle_irq(&up->port);\n\tmod_timer(&up->timer, jiffies + uart_poll_timeout(&up->port));\n}\n\nstatic void serial8250_backup_timeout(struct timer_list *t)\n{\n\tstruct uart_8250_port *up = from_timer(up, t, timer);\n\tunsigned int iir, ier = 0, lsr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&up->port.lock, flags);\n\n\t/*\n\t * Must disable interrupts or else we risk racing with the interrupt\n\t * based handler.\n\t */\n\tif (up->port.irq) {\n\t\tier = serial_in(up, UART_IER);\n\t\tserial_out(up, UART_IER, 0);\n\t}\n\n\tiir = serial_in(up, UART_IIR);\n\n\t/*\n\t * This should be a safe test for anyone who doesn't trust the\n\t * IIR bits on their UART, but it's specifically designed for\n\t * the \"Diva\" UART used on the management processor on many HP\n\t * ia64 and parisc boxes.\n\t */\n\tlsr = serial_in(up, UART_LSR);\n\tup->lsr_saved_flags |= lsr & LSR_SAVE_FLAGS;\n\tif ((iir & UART_IIR_NO_INT) && (up->ier & UART_IER_THRI) &&\n\t    (!uart_circ_empty(&up->port.state->xmit) || up->port.x_char) &&\n\t    (lsr & UART_LSR_THRE)) {\n\t\tiir &= ~(UART_IIR_ID | UART_IIR_NO_INT);\n\t\tiir |= UART_IIR_THRI;\n\t}\n\n\tif (!(iir & UART_IIR_NO_INT))\n\t\tserial8250_tx_chars(up);\n\n\tif (up->port.irq)\n\t\tserial_out(up, UART_IER, ier);\n\n\tspin_unlock_irqrestore(&up->port.lock, flags);\n\n\t/* Standard timer interval plus 0.2s to keep the port running */\n\tmod_timer(&up->timer,\n\t\tjiffies + uart_poll_timeout(&up->port) + HZ / 5);\n}\n\nstatic int univ8250_setup_irq(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\tint retval = 0;\n\n\t/*\n\t * The above check will only give an accurate result the first time\n\t * the port is opened so this value needs to be preserved.\n\t */\n\tif (up->bugs & UART_BUG_THRE) {\n\t\tpr_debug(\"%s - using backup timer\\n\", port->name);\n\n\t\tup->timer.function = serial8250_backup_timeout;\n\t\tmod_timer(&up->timer, jiffies +\n\t\t\t  uart_poll_timeout(port) + HZ / 5);\n\t}\n\n\t/*\n\t * If the \"interrupt\" for this port doesn't correspond with any\n\t * hardware interrupt, we use a timer-based system.  The original\n\t * driver used to do this with IRQ0.\n\t */\n\tif (!port->irq) {\n\t\tmod_timer(&up->timer, jiffies + uart_poll_timeout(port));\n\t} else\n\t\tretval = serial_link_irq_chain(up);\n\n\treturn retval;\n}\n\nstatic void univ8250_release_irq(struct uart_8250_port *up)\n{\n\tstruct uart_port *port = &up->port;\n\n\tdel_timer_sync(&up->timer);\n\tup->timer.function = serial8250_timeout;\n\tif (port->irq)\n\t\tserial_unlink_irq_chain(up);\n}\n\n#ifdef CONFIG_SERIAL_8250_RSA\nstatic int serial8250_request_rsa_resource(struct uart_8250_port *up)\n{\n\tunsigned long start = UART_RSA_BASE << up->port.regshift;\n\tunsigned int size = 8 << up->port.regshift;\n\tstruct uart_port *port = &up->port;\n\tint ret = -EINVAL;\n\n\tswitch (port->iotype) {\n\tcase UPIO_HUB6:\n\tcase UPIO_PORT:\n\t\tstart += port->iobase;\n\t\tif (request_region(start, size, \"serial-rsa\"))\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void serial8250_release_rsa_resource(struct uart_8250_port *up)\n{\n\tunsigned long offset = UART_RSA_BASE << up->port.regshift;\n\tunsigned int size = 8 << up->port.regshift;\n\tstruct uart_port *port = &up->port;\n\n\tswitch (port->iotype) {\n\tcase UPIO_HUB6:\n\tcase UPIO_PORT:\n\t\trelease_region(port->iobase + offset, size);\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic const struct uart_ops *base_ops;\nstatic struct uart_ops univ8250_port_ops;\n\nstatic const struct uart_8250_ops univ8250_driver_ops = {\n\t.setup_irq\t= univ8250_setup_irq,\n\t.release_irq\t= univ8250_release_irq,\n};\n\nstatic struct uart_8250_port serial8250_ports[UART_NR];\n\n/**\n * serial8250_get_port - retrieve struct uart_8250_port\n * @line: serial line number\n *\n * This function retrieves struct uart_8250_port for the specific line.\n * This struct *must* *not* be used to perform a 8250 or serial core operation\n * which is not accessible otherwise. Its only purpose is to make the struct\n * accessible to the runtime-pm callbacks for context suspend/restore.\n * The lock assumption made here is none because runtime-pm suspend/resume\n * callbacks should not be invoked if there is any operation performed on the\n * port.\n */\nstruct uart_8250_port *serial8250_get_port(int line)\n{\n\treturn &serial8250_ports[line];\n}\nEXPORT_SYMBOL_GPL(serial8250_get_port);\n\nstatic void (*serial8250_isa_config)(int port, struct uart_port *up,\n\tu32 *capabilities);\n\nvoid serial8250_set_isa_configurator(\n\tvoid (*v)(int port, struct uart_port *up, u32 *capabilities))\n{\n\tserial8250_isa_config = v;\n}\nEXPORT_SYMBOL(serial8250_set_isa_configurator);\n\n#ifdef CONFIG_SERIAL_8250_RSA\n\nstatic void univ8250_config_port(struct uart_port *port, int flags)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tup->probe &= ~UART_PROBE_RSA;\n\tif (port->type == PORT_RSA) {\n\t\tif (serial8250_request_rsa_resource(up) == 0)\n\t\t\tup->probe |= UART_PROBE_RSA;\n\t} else if (flags & UART_CONFIG_TYPE) {\n\t\tint i;\n\n\t\tfor (i = 0; i < probe_rsa_count; i++) {\n\t\t\tif (probe_rsa[i] == up->port.iobase) {\n\t\t\t\tif (serial8250_request_rsa_resource(up) == 0)\n\t\t\t\t\tup->probe |= UART_PROBE_RSA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tbase_ops->config_port(port, flags);\n\n\tif (port->type != PORT_RSA && up->probe & UART_PROBE_RSA)\n\t\tserial8250_release_rsa_resource(up);\n}\n\nstatic int univ8250_request_port(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\tint ret;\n\n\tret = base_ops->request_port(port);\n\tif (ret == 0 && port->type == PORT_RSA) {\n\t\tret = serial8250_request_rsa_resource(up);\n\t\tif (ret < 0)\n\t\t\tbase_ops->release_port(port);\n\t}\n\n\treturn ret;\n}\n\nstatic void univ8250_release_port(struct uart_port *port)\n{\n\tstruct uart_8250_port *up = up_to_u8250p(port);\n\n\tif (port->type == PORT_RSA)\n\t\tserial8250_release_rsa_resource(up);\n\tbase_ops->release_port(port);\n}\n\nstatic void univ8250_rsa_support(struct uart_ops *ops)\n{\n\tops->config_port  = univ8250_config_port;\n\tops->request_port = univ8250_request_port;\n\tops->release_port = univ8250_release_port;\n}\n\n#else\n#define univ8250_rsa_support(x)\t\tdo { } while (0)\n#endif /* CONFIG_SERIAL_8250_RSA */\n\nstatic inline void serial8250_apply_quirks(struct uart_8250_port *up)\n{\n\tup->port.quirks |= skip_txen_test ? UPQ_NO_TXEN_TEST : 0;\n}\n\nstatic void __init serial8250_isa_init_ports(void)\n{\n\tstruct uart_8250_port *up;\n\tstatic int first = 1;\n\tint i, irqflag = 0;\n\n\tif (!first)\n\t\treturn;\n\tfirst = 0;\n\n\tif (nr_uarts > UART_NR)\n\t\tnr_uarts = UART_NR;\n\n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\t\tstruct uart_port *port = &up->port;\n\n\t\tport->line = i;\n\t\tserial8250_init_port(up);\n\t\tif (!base_ops)\n\t\t\tbase_ops = port->ops;\n\t\tport->ops = &univ8250_port_ops;\n\n\t\ttimer_setup(&up->timer, serial8250_timeout, 0);\n\n\t\tup->ops = &univ8250_driver_ops;\n\n\t\t/*\n\t\t * ALPHA_KLUDGE_MCR needs to be killed.\n\t\t */\n\t\tup->mcr_mask = ~ALPHA_KLUDGE_MCR;\n\t\tup->mcr_force = ALPHA_KLUDGE_MCR;\n\t\tserial8250_set_defaults(up);\n\t}\n\n\t/* chain base port ops to support Remote Supervisor Adapter */\n\tuniv8250_port_ops = *base_ops;\n\tuniv8250_rsa_support(&univ8250_port_ops);\n\n\tif (share_irqs)\n\t\tirqflag = IRQF_SHARED;\n\n\tfor (i = 0, up = serial8250_ports;\n\t     i < ARRAY_SIZE(old_serial_port) && i < nr_uarts;\n\t     i++, up++) {\n\t\tstruct uart_port *port = &up->port;\n\n\t\tport->iobase   = old_serial_port[i].port;\n\t\tport->irq      = irq_canonicalize(old_serial_port[i].irq);\n\t\tport->irqflags = 0;\n\t\tport->uartclk  = old_serial_port[i].baud_base * 16;\n\t\tport->flags    = old_serial_port[i].flags;\n\t\tport->hub6     = 0;\n\t\tport->membase  = old_serial_port[i].iomem_base;\n\t\tport->iotype   = old_serial_port[i].io_type;\n\t\tport->regshift = old_serial_port[i].iomem_reg_shift;\n\n\t\tport->irqflags |= irqflag;\n\t\tif (serial8250_isa_config != NULL)\n\t\t\tserial8250_isa_config(i, &up->port, &up->capabilities);\n\t}\n}\n\nstatic void __init\nserial8250_register_ports(struct uart_driver *drv, struct device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.type == PORT_8250_CIR)\n\t\t\tcontinue;\n\n\t\tif (up->port.dev)\n\t\t\tcontinue;\n\n\t\tup->port.dev = dev;\n\n\t\tserial8250_apply_quirks(up);\n\t\tuart_add_one_port(drv, &up->port);\n\t}\n}\n\n#ifdef CONFIG_SERIAL_8250_CONSOLE\n\nstatic void univ8250_console_write(struct console *co, const char *s,\n\t\t\t\t   unsigned int count)\n{\n\tstruct uart_8250_port *up = &serial8250_ports[co->index];\n\n\tserial8250_console_write(up, s, count);\n}\n\nstatic int univ8250_console_setup(struct console *co, char *options)\n{\n\tstruct uart_port *port;\n\tint retval;\n\n\t/*\n\t * Check whether an invalid uart number has been specified, and\n\t * if so, search for the first available port that does have\n\t * console support.\n\t */\n\tif (co->index >= nr_uarts)\n\t\tco->index = 0;\n\tport = &serial8250_ports[co->index].port;\n\t/* link port to console */\n\tport->cons = co;\n\n\tretval = serial8250_console_setup(port, options, false);\n\tif (retval != 0)\n\t\tport->cons = NULL;\n\treturn retval;\n}\n\nstatic int univ8250_console_exit(struct console *co)\n{\n\tstruct uart_port *port;\n\n\tport = &serial8250_ports[co->index].port;\n\treturn serial8250_console_exit(port);\n}\n\n/**\n *\tuniv8250_console_match - non-standard console matching\n *\t@co:\t  registering console\n *\t@name:\t  name from console command line\n *\t@idx:\t  index from console command line\n *\t@options: ptr to option string from console command line\n *\n *\tOnly attempts to match console command lines of the form:\n *\t    console=uart[8250],io|mmio|mmio16|mmio32,<addr>[,<options>]\n *\t    console=uart[8250],0x<addr>[,<options>]\n *\tThis form is used to register an initial earlycon boot console and\n *\treplace it with the serial8250_console at 8250 driver init.\n *\n *\tPerforms console setup for a match (as required by interface)\n *\tIf no <options> are specified, then assume the h/w is already setup.\n *\n *\tReturns 0 if console matches; otherwise non-zero to use default matching\n */\nstatic int univ8250_console_match(struct console *co, char *name, int idx,\n\t\t\t\t  char *options)\n{\n\tchar match[] = \"uart\";\t/* 8250-specific earlycon name */\n\tunsigned char iotype;\n\tresource_size_t addr;\n\tint i;\n\n\tif (strncmp(name, match, 4) != 0)\n\t\treturn -ENODEV;\n\n\tif (uart_parse_earlycon(options, &iotype, &addr, &options))\n\t\treturn -ENODEV;\n\n\t/* try to match the port specified on the command line */\n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_port *port = &serial8250_ports[i].port;\n\n\t\tif (port->iotype != iotype)\n\t\t\tcontinue;\n\t\tif ((iotype == UPIO_MEM || iotype == UPIO_MEM16 ||\n\t\t     iotype == UPIO_MEM32 || iotype == UPIO_MEM32BE)\n\t\t    && (port->mapbase != addr))\n\t\t\tcontinue;\n\t\tif (iotype == UPIO_PORT && port->iobase != addr)\n\t\t\tcontinue;\n\n\t\tco->index = i;\n\t\tport->cons = co;\n\t\treturn serial8250_console_setup(port, options, true);\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic struct console univ8250_console = {\n\t.name\t\t= \"ttyS\",\n\t.write\t\t= univ8250_console_write,\n\t.device\t\t= uart_console_device,\n\t.setup\t\t= univ8250_console_setup,\n\t.exit\t\t= univ8250_console_exit,\n\t.match\t\t= univ8250_console_match,\n\t.flags\t\t= CON_PRINTBUFFER | CON_ANYTIME,\n\t.index\t\t= -1,\n\t.data\t\t= &serial8250_reg,\n};\n\nstatic int __init univ8250_console_init(void)\n{\n\tif (nr_uarts == 0)\n\t\treturn -ENODEV;\n\n\tserial8250_isa_init_ports();\n\tregister_console(&univ8250_console);\n\treturn 0;\n}\nconsole_initcall(univ8250_console_init);\n\n#define SERIAL8250_CONSOLE\t(&univ8250_console)\n#else\n#define SERIAL8250_CONSOLE\tNULL\n#endif\n\nstatic struct uart_driver serial8250_reg = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.driver_name\t\t= \"serial\",\n\t.dev_name\t\t= \"ttyS\",\n\t.major\t\t\t= TTY_MAJOR,\n\t.minor\t\t\t= 64,\n\t.cons\t\t\t= SERIAL8250_CONSOLE,\n};\n\n/*\n * early_serial_setup - early registration for 8250 ports\n *\n * Setup an 8250 port structure prior to console initialisation.  Use\n * after console initialisation will cause undefined behaviour.\n */\nint __init early_serial_setup(struct uart_port *port)\n{\n\tstruct uart_port *p;\n\n\tif (port->line >= ARRAY_SIZE(serial8250_ports) || nr_uarts == 0)\n\t\treturn -ENODEV;\n\n\tserial8250_isa_init_ports();\n\tp = &serial8250_ports[port->line].port;\n\tp->iobase       = port->iobase;\n\tp->membase      = port->membase;\n\tp->irq          = port->irq;\n\tp->irqflags     = port->irqflags;\n\tp->uartclk      = port->uartclk;\n\tp->fifosize     = port->fifosize;\n\tp->regshift     = port->regshift;\n\tp->iotype       = port->iotype;\n\tp->flags        = port->flags;\n\tp->mapbase      = port->mapbase;\n\tp->mapsize      = port->mapsize;\n\tp->private_data = port->private_data;\n\tp->type\t\t= port->type;\n\tp->line\t\t= port->line;\n\n\tserial8250_set_defaults(up_to_u8250p(p));\n\n\tif (port->serial_in)\n\t\tp->serial_in = port->serial_in;\n\tif (port->serial_out)\n\t\tp->serial_out = port->serial_out;\n\tif (port->handle_irq)\n\t\tp->handle_irq = port->handle_irq;\n\n\treturn 0;\n}\n\n/**\n *\tserial8250_suspend_port - suspend one serial port\n *\t@line:  serial line number\n *\n *\tSuspend one serial port.\n */\nvoid serial8250_suspend_port(int line)\n{\n\tstruct uart_8250_port *up = &serial8250_ports[line];\n\tstruct uart_port *port = &up->port;\n\n\tif (!console_suspend_enabled && uart_console(port) &&\n\t    port->type != PORT_8250) {\n\t\tunsigned char canary = 0xa5;\n\t\tserial_out(up, UART_SCR, canary);\n\t\tif (serial_in(up, UART_SCR) == canary)\n\t\t\tup->canary = canary;\n\t}\n\n\tuart_suspend_port(&serial8250_reg, port);\n}\nEXPORT_SYMBOL(serial8250_suspend_port);\n\n/**\n *\tserial8250_resume_port - resume one serial port\n *\t@line:  serial line number\n *\n *\tResume one serial port.\n */\nvoid serial8250_resume_port(int line)\n{\n\tstruct uart_8250_port *up = &serial8250_ports[line];\n\tstruct uart_port *port = &up->port;\n\n\tup->canary = 0;\n\n\tif (up->capabilities & UART_NATSEMI) {\n\t\t/* Ensure it's still in high speed mode */\n\t\tserial_port_out(port, UART_LCR, 0xE0);\n\n\t\tns16550a_goto_highspeed(up);\n\n\t\tserial_port_out(port, UART_LCR, 0);\n\t\tport->uartclk = 921600*16;\n\t}\n\tuart_resume_port(&serial8250_reg, port);\n}\nEXPORT_SYMBOL(serial8250_resume_port);\n\n/*\n * Register a set of serial devices attached to a platform device.  The\n * list is terminated with a zero flags entry, which means we expect\n * all entries to have at least UPF_BOOT_AUTOCONF set.\n */\nstatic int serial8250_probe(struct platform_device *dev)\n{\n\tstruct plat_serial8250_port *p = dev_get_platdata(&dev->dev);\n\tstruct uart_8250_port uart;\n\tint ret, i, irqflag = 0;\n\n\tmemset(&uart, 0, sizeof(uart));\n\n\tif (share_irqs)\n\t\tirqflag = IRQF_SHARED;\n\n\tfor (i = 0; p && p->flags != 0; p++, i++) {\n\t\tuart.port.iobase\t= p->iobase;\n\t\tuart.port.membase\t= p->membase;\n\t\tuart.port.irq\t\t= p->irq;\n\t\tuart.port.irqflags\t= p->irqflags;\n\t\tuart.port.uartclk\t= p->uartclk;\n\t\tuart.port.regshift\t= p->regshift;\n\t\tuart.port.iotype\t= p->iotype;\n\t\tuart.port.flags\t\t= p->flags;\n\t\tuart.port.mapbase\t= p->mapbase;\n\t\tuart.port.hub6\t\t= p->hub6;\n\t\tuart.port.has_sysrq\t= p->has_sysrq;\n\t\tuart.port.private_data\t= p->private_data;\n\t\tuart.port.type\t\t= p->type;\n\t\tuart.port.serial_in\t= p->serial_in;\n\t\tuart.port.serial_out\t= p->serial_out;\n\t\tuart.port.handle_irq\t= p->handle_irq;\n\t\tuart.port.handle_break\t= p->handle_break;\n\t\tuart.port.set_termios\t= p->set_termios;\n\t\tuart.port.set_ldisc\t= p->set_ldisc;\n\t\tuart.port.get_mctrl\t= p->get_mctrl;\n\t\tuart.port.pm\t\t= p->pm;\n\t\tuart.port.dev\t\t= &dev->dev;\n\t\tuart.port.irqflags\t|= irqflag;\n\t\tret = serial8250_register_8250_port(&uart);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->dev, \"unable to register port at index %d \"\n\t\t\t\t\"(IO%lx MEM%llx IRQ%d): %d\\n\", i,\n\t\t\t\tp->iobase, (unsigned long long)p->mapbase,\n\t\t\t\tp->irq, ret);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Remove serial ports registered against a platform device.\n */\nstatic int serial8250_remove(struct platform_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_uarts; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.dev == &dev->dev)\n\t\t\tserial8250_unregister_port(i);\n\t}\n\treturn 0;\n}\n\nstatic int serial8250_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\n\t\t\tuart_suspend_port(&serial8250_reg, &up->port);\n\t}\n\n\treturn 0;\n}\n\nstatic int serial8250_resume(struct platform_device *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct uart_8250_port *up = &serial8250_ports[i];\n\n\t\tif (up->port.type != PORT_UNKNOWN && up->port.dev == &dev->dev)\n\t\t\tserial8250_resume_port(i);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver serial8250_isa_driver = {\n\t.probe\t\t= serial8250_probe,\n\t.remove\t\t= serial8250_remove,\n\t.suspend\t= serial8250_suspend,\n\t.resume\t\t= serial8250_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"serial8250\",\n\t},\n};\n\n/*\n * This \"device\" covers _all_ ISA 8250-compatible serial devices listed\n * in the table in include/asm/serial.h\n */\nstatic struct platform_device *serial8250_isa_devs;\n\n/*\n * serial8250_register_8250_port and serial8250_unregister_port allows for\n * 16x50 serial ports to be configured at run-time, to support PCMCIA\n * modems and PCI multiport cards.\n */\nstatic DEFINE_MUTEX(serial_mutex);\n\nstatic struct uart_8250_port *serial8250_find_match_or_unused(struct uart_port *port)\n{\n\tint i;\n\n\t/*\n\t * First, find a port entry which matches.\n\t */\n\tfor (i = 0; i < nr_uarts; i++)\n\t\tif (uart_match_port(&serial8250_ports[i].port, port))\n\t\t\treturn &serial8250_ports[i];\n\n\t/* try line number first if still available */\n\ti = port->line;\n\tif (i < nr_uarts && serial8250_ports[i].port.type == PORT_UNKNOWN &&\n\t\t\tserial8250_ports[i].port.iobase == 0)\n\t\treturn &serial8250_ports[i];\n\t/*\n\t * We didn't find a matching entry, so look for the first\n\t * free entry.  We look for one which hasn't been previously\n\t * used (indicated by zero iobase).\n\t */\n\tfor (i = 0; i < nr_uarts; i++)\n\t\tif (serial8250_ports[i].port.type == PORT_UNKNOWN &&\n\t\t    serial8250_ports[i].port.iobase == 0)\n\t\t\treturn &serial8250_ports[i];\n\n\t/*\n\t * That also failed.  Last resort is to find any entry which\n\t * doesn't have a real port associated with it.\n\t */\n\tfor (i = 0; i < nr_uarts; i++)\n\t\tif (serial8250_ports[i].port.type == PORT_UNKNOWN)\n\t\t\treturn &serial8250_ports[i];\n\n\treturn NULL;\n}\n\nstatic void serial_8250_overrun_backoff_work(struct work_struct *work)\n{\n\tstruct uart_8250_port *up =\n\t    container_of(to_delayed_work(work), struct uart_8250_port,\n\t\t\t overrun_backoff);\n\tstruct uart_port *port = &up->port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tup->ier |= UART_IER_RLSI | UART_IER_RDI;\n\tup->port.read_status_mask |= UART_LSR_DR;\n\tserial_out(up, UART_IER, up->ier);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n/**\n *\tserial8250_register_8250_port - register a serial port\n *\t@up: serial port template\n *\n *\tConfigure the serial port specified by the request. If the\n *\tport exists and is in use, it is hung up and unregistered\n *\tfirst.\n *\n *\tThe port is then probed and if necessary the IRQ is autodetected\n *\tIf this fails an error is returned.\n *\n *\tOn success the port is ready to use and the line number is returned.\n */\nint serial8250_register_8250_port(struct uart_8250_port *up)\n{\n\tstruct uart_8250_port *uart;\n\tint ret = -ENOSPC;\n\n\tif (up->port.uartclk == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&serial_mutex);\n\n\tuart = serial8250_find_match_or_unused(&up->port);\n\tif (uart && uart->port.type != PORT_8250_CIR) {\n\t\tstruct mctrl_gpios *gpios;\n\n\t\tif (uart->port.dev)\n\t\t\tuart_remove_one_port(&serial8250_reg, &uart->port);\n\n\t\tuart->port.iobase       = up->port.iobase;\n\t\tuart->port.membase      = up->port.membase;\n\t\tuart->port.irq          = up->port.irq;\n\t\tuart->port.irqflags     = up->port.irqflags;\n\t\tuart->port.uartclk      = up->port.uartclk;\n\t\tuart->port.fifosize     = up->port.fifosize;\n\t\tuart->port.regshift     = up->port.regshift;\n\t\tuart->port.iotype       = up->port.iotype;\n\t\tuart->port.flags        = up->port.flags | UPF_BOOT_AUTOCONF;\n\t\tuart->bugs\t\t= up->bugs;\n\t\tuart->port.mapbase      = up->port.mapbase;\n\t\tuart->port.mapsize      = up->port.mapsize;\n\t\tuart->port.private_data = up->port.private_data;\n\t\tuart->tx_loadsz\t\t= up->tx_loadsz;\n\t\tuart->capabilities\t= up->capabilities;\n\t\tuart->port.throttle\t= up->port.throttle;\n\t\tuart->port.unthrottle\t= up->port.unthrottle;\n\t\tuart->port.rs485_config\t= up->port.rs485_config;\n\t\tuart->port.rs485\t= up->port.rs485;\n\t\tuart->rs485_start_tx\t= up->rs485_start_tx;\n\t\tuart->rs485_stop_tx\t= up->rs485_stop_tx;\n\t\tuart->dma\t\t= up->dma;\n\n\t\t/* Take tx_loadsz from fifosize if it wasn't set separately */\n\t\tif (uart->port.fifosize && !uart->tx_loadsz)\n\t\t\tuart->tx_loadsz = uart->port.fifosize;\n\n\t\tif (up->port.dev) {\n\t\t\tuart->port.dev = up->port.dev;\n\t\t\tret = uart_get_rs485_mode(&uart->port);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (up->port.flags & UPF_FIXED_TYPE)\n\t\t\tuart->port.type = up->port.type;\n\n\t\t/*\n\t\t * Only call mctrl_gpio_init(), if the device has no ACPI\n\t\t * companion device\n\t\t */\n\t\tif (!has_acpi_companion(uart->port.dev)) {\n\t\t\tgpios = mctrl_gpio_init(&uart->port, 0);\n\t\t\tif (IS_ERR(gpios)) {\n\t\t\t\tret = PTR_ERR(gpios);\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tuart->gpios = gpios;\n\t\t\t}\n\t\t}\n\n\t\tserial8250_set_defaults(uart);\n\n\t\t/* Possibly override default I/O functions.  */\n\t\tif (up->port.serial_in)\n\t\t\tuart->port.serial_in = up->port.serial_in;\n\t\tif (up->port.serial_out)\n\t\t\tuart->port.serial_out = up->port.serial_out;\n\t\tif (up->port.handle_irq)\n\t\t\tuart->port.handle_irq = up->port.handle_irq;\n\t\t/*  Possibly override set_termios call */\n\t\tif (up->port.set_termios)\n\t\t\tuart->port.set_termios = up->port.set_termios;\n\t\tif (up->port.set_ldisc)\n\t\t\tuart->port.set_ldisc = up->port.set_ldisc;\n\t\tif (up->port.get_mctrl)\n\t\t\tuart->port.get_mctrl = up->port.get_mctrl;\n\t\tif (up->port.set_mctrl)\n\t\t\tuart->port.set_mctrl = up->port.set_mctrl;\n\t\tif (up->port.get_divisor)\n\t\t\tuart->port.get_divisor = up->port.get_divisor;\n\t\tif (up->port.set_divisor)\n\t\t\tuart->port.set_divisor = up->port.set_divisor;\n\t\tif (up->port.startup)\n\t\t\tuart->port.startup = up->port.startup;\n\t\tif (up->port.shutdown)\n\t\t\tuart->port.shutdown = up->port.shutdown;\n\t\tif (up->port.pm)\n\t\t\tuart->port.pm = up->port.pm;\n\t\tif (up->port.handle_break)\n\t\t\tuart->port.handle_break = up->port.handle_break;\n\t\tif (up->dl_read)\n\t\t\tuart->dl_read = up->dl_read;\n\t\tif (up->dl_write)\n\t\t\tuart->dl_write = up->dl_write;\n\n\t\tif (uart->port.type != PORT_8250_CIR) {\n\t\t\tif (serial8250_isa_config != NULL)\n\t\t\t\tserial8250_isa_config(0, &uart->port,\n\t\t\t\t\t\t&uart->capabilities);\n\n\t\t\tserial8250_apply_quirks(uart);\n\t\t\tret = uart_add_one_port(&serial8250_reg,\n\t\t\t\t\t\t&uart->port);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tret = uart->port.line;\n\t\t} else {\n\t\t\tdev_info(uart->port.dev,\n\t\t\t\t\"skipping CIR port at 0x%lx / 0x%llx, IRQ %d\\n\",\n\t\t\t\tuart->port.iobase,\n\t\t\t\t(unsigned long long)uart->port.mapbase,\n\t\t\t\tuart->port.irq);\n\n\t\t\tret = 0;\n\t\t}\n\n\t\t/* Initialise interrupt backoff work if required */\n\t\tif (up->overrun_backoff_time_ms > 0) {\n\t\t\tuart->overrun_backoff_time_ms =\n\t\t\t\tup->overrun_backoff_time_ms;\n\t\t\tINIT_DELAYED_WORK(&uart->overrun_backoff,\n\t\t\t\t\tserial_8250_overrun_backoff_work);\n\t\t} else {\n\t\t\tuart->overrun_backoff_time_ms = 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&serial_mutex);\n\n\treturn ret;\n\nerr:\n\tuart->port.dev = NULL;\n\tmutex_unlock(&serial_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL(serial8250_register_8250_port);\n\n/**\n *\tserial8250_unregister_port - remove a 16x50 serial port at runtime\n *\t@line: serial line number\n *\n *\tRemove one serial port.  This may not be called from interrupt\n *\tcontext.  We hand the port back to the our control.\n */\nvoid serial8250_unregister_port(int line)\n{\n\tstruct uart_8250_port *uart = &serial8250_ports[line];\n\n\tmutex_lock(&serial_mutex);\n\n\tif (uart->em485) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&uart->port.lock, flags);\n\t\tserial8250_em485_destroy(uart);\n\t\tspin_unlock_irqrestore(&uart->port.lock, flags);\n\t}\n\n\tuart_remove_one_port(&serial8250_reg, &uart->port);\n\tif (serial8250_isa_devs) {\n\t\tuart->port.flags &= ~UPF_BOOT_AUTOCONF;\n\t\tuart->port.type = PORT_UNKNOWN;\n\t\tuart->port.dev = &serial8250_isa_devs->dev;\n\t\tuart->capabilities = 0;\n\t\tserial8250_apply_quirks(uart);\n\t\tuart_add_one_port(&serial8250_reg, &uart->port);\n\t} else {\n\t\tuart->port.dev = NULL;\n\t}\n\tmutex_unlock(&serial_mutex);\n}\nEXPORT_SYMBOL(serial8250_unregister_port);\n\nstatic int __init serial8250_init(void)\n{\n\tint ret;\n\n\tif (nr_uarts == 0)\n\t\treturn -ENODEV;\n\n\tserial8250_isa_init_ports();\n\n\tpr_info(\"Serial: 8250/16550 driver, %d ports, IRQ sharing %sabled\\n\",\n\t\tnr_uarts, share_irqs ? \"en\" : \"dis\");\n\n#ifdef CONFIG_SPARC\n\tret = sunserial_register_minors(&serial8250_reg, UART_NR);\n#else\n\tserial8250_reg.nr = UART_NR;\n\tret = uart_register_driver(&serial8250_reg);\n#endif\n\tif (ret)\n\t\tgoto out;\n\n\tret = serial8250_pnp_init();\n\tif (ret)\n\t\tgoto unreg_uart_drv;\n\n\tserial8250_isa_devs = platform_device_alloc(\"serial8250\",\n\t\t\t\t\t\t    PLAT8250_DEV_LEGACY);\n\tif (!serial8250_isa_devs) {\n\t\tret = -ENOMEM;\n\t\tgoto unreg_pnp;\n\t}\n\n\tret = platform_device_add(serial8250_isa_devs);\n\tif (ret)\n\t\tgoto put_dev;\n\n\tserial8250_register_ports(&serial8250_reg, &serial8250_isa_devs->dev);\n\n\tret = platform_driver_register(&serial8250_isa_driver);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tplatform_device_del(serial8250_isa_devs);\nput_dev:\n\tplatform_device_put(serial8250_isa_devs);\nunreg_pnp:\n\tserial8250_pnp_exit();\nunreg_uart_drv:\n#ifdef CONFIG_SPARC\n\tsunserial_unregister_minors(&serial8250_reg, UART_NR);\n#else\n\tuart_unregister_driver(&serial8250_reg);\n#endif\nout:\n\treturn ret;\n}\n\nstatic void __exit serial8250_exit(void)\n{\n\tstruct platform_device *isa_dev = serial8250_isa_devs;\n\n\t/*\n\t * This tells serial8250_unregister_port() not to re-register\n\t * the ports (thereby making serial8250_isa_driver permanently\n\t * in use.)\n\t */\n\tserial8250_isa_devs = NULL;\n\n\tplatform_driver_unregister(&serial8250_isa_driver);\n\tplatform_device_unregister(isa_dev);\n\n\tserial8250_pnp_exit();\n\n#ifdef CONFIG_SPARC\n\tsunserial_unregister_minors(&serial8250_reg, UART_NR);\n#else\n\tuart_unregister_driver(&serial8250_reg);\n#endif\n}\n\nmodule_init(serial8250_init);\nmodule_exit(serial8250_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Generic 8250/16x50 serial driver\");\n\nmodule_param_hw(share_irqs, uint, other, 0644);\nMODULE_PARM_DESC(share_irqs, \"Share IRQs with other non-8250/16x50 devices (unsafe)\");\n\nmodule_param(nr_uarts, uint, 0644);\nMODULE_PARM_DESC(nr_uarts, \"Maximum number of UARTs supported. (1-\" __MODULE_STRING(CONFIG_SERIAL_8250_NR_UARTS) \")\");\n\nmodule_param(skip_txen_test, uint, 0644);\nMODULE_PARM_DESC(skip_txen_test, \"Skip checking for the TXEN bug at init time\");\n\n#ifdef CONFIG_SERIAL_8250_RSA\nmodule_param_hw_array(probe_rsa, ulong, ioport, &probe_rsa_count, 0444);\nMODULE_PARM_DESC(probe_rsa, \"Probe I/O ports for RSA\");\n#endif\nMODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);\n\n#ifdef CONFIG_SERIAL_8250_DEPRECATED_OPTIONS\n#ifndef MODULE\n/* This module was renamed to 8250_core in 3.7.  Keep the old \"8250\" name\n * working as well for the module options so we don't break people.  We\n * need to keep the names identical and the convenient macros will happily\n * refuse to let us do that by failing the build with redefinition errors\n * of global variables.  So we stick them inside a dummy function to avoid\n * those conflicts.  The options still get parsed, and the redefined\n * MODULE_PARAM_PREFIX lets us keep the \"8250.\" syntax alive.\n *\n * This is hacky.  I'm sorry.\n */\nstatic void __used s8250_options(void)\n{\n#undef MODULE_PARAM_PREFIX\n#define MODULE_PARAM_PREFIX \"8250_core.\"\n\n\tmodule_param_cb(share_irqs, &param_ops_uint, &share_irqs, 0644);\n\tmodule_param_cb(nr_uarts, &param_ops_uint, &nr_uarts, 0644);\n\tmodule_param_cb(skip_txen_test, &param_ops_uint, &skip_txen_test, 0644);\n#ifdef CONFIG_SERIAL_8250_RSA\n\t__module_param_call(MODULE_PARAM_PREFIX, probe_rsa,\n\t\t&param_array_ops, .arr = &__param_arr_probe_rsa,\n\t\t0444, -1, 0);\n#endif\n}\n#else\nMODULE_ALIAS(\"8250_core\");\n#endif\n#endif\n"}, "0": {"id": 0, "path": "/src/include/linux/acpi.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * acpi.h - ACPI Interface\n *\n * Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>\n */\n\n#ifndef _LINUX_ACPI_H\n#define _LINUX_ACPI_H\n\n#include <linux/errno.h>\n#include <linux/ioport.h>\t/* for struct resource */\n#include <linux/irqdomain.h>\n#include <linux/resource_ext.h>\n#include <linux/device.h>\n#include <linux/property.h>\n#include <linux/uuid.h>\n\n#ifndef _LINUX\n#define _LINUX\n#endif\n#include <acpi/acpi.h>\n\n#ifdef\tCONFIG_ACPI\n\n#include <linux/list.h>\n#include <linux/mod_devicetable.h>\n#include <linux/dynamic_debug.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <acpi/acpi_bus.h>\n#include <acpi/acpi_drivers.h>\n#include <acpi/acpi_numa.h>\n#include <acpi/acpi_io.h>\n#include <asm/acpi.h>\n\nstatic inline acpi_handle acpi_device_handle(struct acpi_device *adev)\n{\n\treturn adev ? adev->handle : NULL;\n}\n\n#define ACPI_COMPANION(dev)\t\tto_acpi_device_node((dev)->fwnode)\n#define ACPI_COMPANION_SET(dev, adev)\tset_primary_fwnode(dev, (adev) ? \\\n\tacpi_fwnode_handle(adev) : NULL)\n#define ACPI_HANDLE(dev)\t\tacpi_device_handle(ACPI_COMPANION(dev))\n#define ACPI_HANDLE_FWNODE(fwnode)\t\\\n\t\t\t\tacpi_device_handle(to_acpi_device_node(fwnode))\n\nstatic inline struct fwnode_handle *acpi_alloc_fwnode_static(void)\n{\n\tstruct fwnode_handle *fwnode;\n\n\tfwnode = kzalloc(sizeof(struct fwnode_handle), GFP_KERNEL);\n\tif (!fwnode)\n\t\treturn NULL;\n\n\tfwnode_init(fwnode, &acpi_static_fwnode_ops);\n\n\treturn fwnode;\n}\n\nstatic inline void acpi_free_fwnode_static(struct fwnode_handle *fwnode)\n{\n\tif (WARN_ON(!is_acpi_static_node(fwnode)))\n\t\treturn;\n\n\tkfree(fwnode);\n}\n\n/**\n * ACPI_DEVICE_CLASS - macro used to describe an ACPI device with\n * the PCI-defined class-code information\n *\n * @_cls : the class, subclass, prog-if triple for this device\n * @_msk : the class mask for this device\n *\n * This macro is used to create a struct acpi_device_id that matches a\n * specific PCI class. The .id and .driver_data fields will be left\n * initialized with the default value.\n */\n#define ACPI_DEVICE_CLASS(_cls, _msk)\t.cls = (_cls), .cls_msk = (_msk),\n\nstatic inline bool has_acpi_companion(struct device *dev)\n{\n\treturn is_acpi_device_node(dev->fwnode);\n}\n\nstatic inline void acpi_preset_companion(struct device *dev,\n\t\t\t\t\t struct acpi_device *parent, u64 addr)\n{\n\tACPI_COMPANION_SET(dev, acpi_find_child_device(parent, addr, false));\n}\n\nstatic inline const char *acpi_dev_name(struct acpi_device *adev)\n{\n\treturn dev_name(&adev->dev);\n}\n\nstruct device *acpi_get_first_physical_node(struct acpi_device *adev);\n\nenum acpi_irq_model_id {\n\tACPI_IRQ_MODEL_PIC = 0,\n\tACPI_IRQ_MODEL_IOAPIC,\n\tACPI_IRQ_MODEL_IOSAPIC,\n\tACPI_IRQ_MODEL_PLATFORM,\n\tACPI_IRQ_MODEL_GIC,\n\tACPI_IRQ_MODEL_COUNT\n};\n\nextern enum acpi_irq_model_id\tacpi_irq_model;\n\nenum acpi_interrupt_id {\n\tACPI_INTERRUPT_PMI\t= 1,\n\tACPI_INTERRUPT_INIT,\n\tACPI_INTERRUPT_CPEI,\n\tACPI_INTERRUPT_COUNT\n};\n\n#define\tACPI_SPACE_MEM\t\t0\n\nenum acpi_address_range_id {\n\tACPI_ADDRESS_RANGE_MEMORY = 1,\n\tACPI_ADDRESS_RANGE_RESERVED = 2,\n\tACPI_ADDRESS_RANGE_ACPI = 3,\n\tACPI_ADDRESS_RANGE_NVS\t= 4,\n\tACPI_ADDRESS_RANGE_COUNT\n};\n\n\n/* Table Handlers */\nunion acpi_subtable_headers {\n\tstruct acpi_subtable_header common;\n\tstruct acpi_hmat_structure hmat;\n};\n\ntypedef int (*acpi_tbl_table_handler)(struct acpi_table_header *table);\n\ntypedef int (*acpi_tbl_entry_handler)(union acpi_subtable_headers *header,\n\t\t\t\t      const unsigned long end);\n\n/* Debugger support */\n\nstruct acpi_debugger_ops {\n\tint (*create_thread)(acpi_osd_exec_callback function, void *context);\n\tssize_t (*write_log)(const char *msg);\n\tssize_t (*read_cmd)(char *buffer, size_t length);\n\tint (*wait_command_ready)(bool single_step, char *buffer, size_t length);\n\tint (*notify_command_complete)(void);\n};\n\nstruct acpi_debugger {\n\tconst struct acpi_debugger_ops *ops;\n\tstruct module *owner;\n\tstruct mutex lock;\n};\n\n#ifdef CONFIG_ACPI_DEBUGGER\nint __init acpi_debugger_init(void);\nint acpi_register_debugger(struct module *owner,\n\t\t\t   const struct acpi_debugger_ops *ops);\nvoid acpi_unregister_debugger(const struct acpi_debugger_ops *ops);\nint acpi_debugger_create_thread(acpi_osd_exec_callback function, void *context);\nssize_t acpi_debugger_write_log(const char *msg);\nssize_t acpi_debugger_read_cmd(char *buffer, size_t buffer_length);\nint acpi_debugger_wait_command_ready(void);\nint acpi_debugger_notify_command_complete(void);\n#else\nstatic inline int acpi_debugger_init(void)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_register_debugger(struct module *owner,\n\t\t\t\t\t const struct acpi_debugger_ops *ops)\n{\n\treturn -ENODEV;\n}\n\nstatic inline void acpi_unregister_debugger(const struct acpi_debugger_ops *ops)\n{\n}\n\nstatic inline int acpi_debugger_create_thread(acpi_osd_exec_callback function,\n\t\t\t\t\t      void *context)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_write_log(const char *msg)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_read_cmd(char *buffer, u32 buffer_length)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_wait_command_ready(void)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_debugger_notify_command_complete(void)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#define BAD_MADT_ENTRY(entry, end) (\t\t\t\t\t    \\\n\t\t(!entry) || (unsigned long)entry + sizeof(*entry) > end ||  \\\n\t\t((struct acpi_subtable_header *)entry)->length < sizeof(*entry))\n\nstruct acpi_subtable_proc {\n\tint id;\n\tacpi_tbl_entry_handler handler;\n\tint count;\n};\n\nvoid __iomem *__acpi_map_table(unsigned long phys, unsigned long size);\nvoid __acpi_unmap_table(void __iomem *map, unsigned long size);\nint early_acpi_boot_init(void);\nint acpi_boot_init (void);\nvoid acpi_boot_table_init (void);\nint acpi_mps_check (void);\nint acpi_numa_init (void);\n\nint acpi_table_init (void);\nint acpi_table_parse(char *id, acpi_tbl_table_handler handler);\nint __init acpi_table_parse_entries(char *id, unsigned long table_size,\n\t\t\t      int entry_id,\n\t\t\t      acpi_tbl_entry_handler handler,\n\t\t\t      unsigned int max_entries);\nint __init acpi_table_parse_entries_array(char *id, unsigned long table_size,\n\t\t\t      struct acpi_subtable_proc *proc, int proc_num,\n\t\t\t      unsigned int max_entries);\nint acpi_table_parse_madt(enum acpi_madt_type id,\n\t\t\t  acpi_tbl_entry_handler handler,\n\t\t\t  unsigned int max_entries);\nint acpi_parse_mcfg (struct acpi_table_header *header);\nvoid acpi_table_print_madt_entry (struct acpi_subtable_header *madt);\n\n/* the following numa functions are architecture-dependent */\nvoid acpi_numa_slit_init (struct acpi_table_slit *slit);\n\n#if defined(CONFIG_X86) || defined(CONFIG_IA64)\nvoid acpi_numa_processor_affinity_init (struct acpi_srat_cpu_affinity *pa);\n#else\nstatic inline void\nacpi_numa_processor_affinity_init(struct acpi_srat_cpu_affinity *pa) { }\n#endif\n\nvoid acpi_numa_x2apic_affinity_init(struct acpi_srat_x2apic_cpu_affinity *pa);\n\n#ifdef CONFIG_ARM64\nvoid acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa);\n#else\nstatic inline void\nacpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa) { }\n#endif\n\nint acpi_numa_memory_affinity_init (struct acpi_srat_mem_affinity *ma);\n\n#ifndef PHYS_CPUID_INVALID\ntypedef u32 phys_cpuid_t;\n#define PHYS_CPUID_INVALID (phys_cpuid_t)(-1)\n#endif\n\nstatic inline bool invalid_logical_cpuid(u32 cpuid)\n{\n\treturn (int)cpuid < 0;\n}\n\nstatic inline bool invalid_phys_cpuid(phys_cpuid_t phys_id)\n{\n\treturn phys_id == PHYS_CPUID_INVALID;\n}\n\n/* Validate the processor object's proc_id */\nbool acpi_duplicate_processor_id(int proc_id);\n/* Processor _CTS control */\nstruct acpi_processor_power;\n\n#ifdef CONFIG_ACPI_PROCESSOR_CSTATE\nbool acpi_processor_claim_cst_control(void);\nint acpi_processor_evaluate_cst(acpi_handle handle, u32 cpu,\n\t\t\t\tstruct acpi_processor_power *info);\n#else\nstatic inline bool acpi_processor_claim_cst_control(void) { return false; }\nstatic inline int acpi_processor_evaluate_cst(acpi_handle handle, u32 cpu,\n\t\t\t\t\t      struct acpi_processor_power *info)\n{\n\treturn -ENODEV;\n}\n#endif\n\n#ifdef CONFIG_ACPI_HOTPLUG_CPU\n/* Arch dependent functions for cpu hotplug support */\nint acpi_map_cpu(acpi_handle handle, phys_cpuid_t physid, u32 acpi_id,\n\t\t int *pcpu);\nint acpi_unmap_cpu(int cpu);\n#endif /* CONFIG_ACPI_HOTPLUG_CPU */\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\nint acpi_get_ioapic_id(acpi_handle handle, u32 gsi_base, u64 *phys_addr);\n#endif\n\nint acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base);\nint acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base);\nint acpi_ioapic_registered(acpi_handle handle, u32 gsi_base);\nvoid acpi_irq_stats_init(void);\nextern u32 acpi_irq_handled;\nextern u32 acpi_irq_not_handled;\nextern unsigned int acpi_sci_irq;\nextern bool acpi_no_s5;\n#define INVALID_ACPI_IRQ\t((unsigned)-1)\nstatic inline bool acpi_sci_irq_valid(void)\n{\n\treturn acpi_sci_irq != INVALID_ACPI_IRQ;\n}\n\nextern int sbf_port;\nextern unsigned long acpi_realmode_flags;\n\nint acpi_register_gsi (struct device *dev, u32 gsi, int triggering, int polarity);\nint acpi_gsi_to_irq (u32 gsi, unsigned int *irq);\nint acpi_isa_irq_to_gsi (unsigned isa_irq, u32 *gsi);\n\nvoid acpi_set_irq_model(enum acpi_irq_model_id model,\n\t\t\tstruct fwnode_handle *fwnode);\n\nstruct irq_domain *acpi_irq_create_hierarchy(unsigned int flags,\n\t\t\t\t\t     unsigned int size,\n\t\t\t\t\t     struct fwnode_handle *fwnode,\n\t\t\t\t\t     const struct irq_domain_ops *ops,\n\t\t\t\t\t     void *host_data);\n\n#ifdef CONFIG_X86_IO_APIC\nextern int acpi_get_override_irq(u32 gsi, int *trigger, int *polarity);\n#else\nstatic inline int acpi_get_override_irq(u32 gsi, int *trigger, int *polarity)\n{\n\treturn -1;\n}\n#endif\n/*\n * This function undoes the effect of one call to acpi_register_gsi().\n * If this matches the last registration, any IRQ resources for gsi\n * are freed.\n */\nvoid acpi_unregister_gsi (u32 gsi);\n\nstruct pci_dev;\n\nint acpi_pci_irq_enable (struct pci_dev *dev);\nvoid acpi_penalize_isa_irq(int irq, int active);\nbool acpi_isa_irq_available(int irq);\n#ifdef CONFIG_PCI\nvoid acpi_penalize_sci_irq(int irq, int trigger, int polarity);\n#else\nstatic inline void acpi_penalize_sci_irq(int irq, int trigger,\n\t\t\t\t\tint polarity)\n{\n}\n#endif\nvoid acpi_pci_irq_disable (struct pci_dev *dev);\n\nextern int ec_read(u8 addr, u8 *val);\nextern int ec_write(u8 addr, u8 val);\nextern int ec_transaction(u8 command,\n                          const u8 *wdata, unsigned wdata_len,\n                          u8 *rdata, unsigned rdata_len);\nextern acpi_handle ec_get_handle(void);\n\nextern bool acpi_is_pnp_device(struct acpi_device *);\n\n#if defined(CONFIG_ACPI_WMI) || defined(CONFIG_ACPI_WMI_MODULE)\n\ntypedef void (*wmi_notify_handler) (u32 value, void *context);\n\nextern acpi_status wmi_evaluate_method(const char *guid, u8 instance,\n\t\t\t\t\tu32 method_id,\n\t\t\t\t\tconst struct acpi_buffer *in,\n\t\t\t\t\tstruct acpi_buffer *out);\nextern acpi_status wmi_query_block(const char *guid, u8 instance,\n\t\t\t\t\tstruct acpi_buffer *out);\nextern acpi_status wmi_set_block(const char *guid, u8 instance,\n\t\t\t\t\tconst struct acpi_buffer *in);\nextern acpi_status wmi_install_notify_handler(const char *guid,\n\t\t\t\t\twmi_notify_handler handler, void *data);\nextern acpi_status wmi_remove_notify_handler(const char *guid);\nextern acpi_status wmi_get_event_data(u32 event, struct acpi_buffer *out);\nextern bool wmi_has_guid(const char *guid);\nextern char *wmi_get_acpi_device_uid(const char *guid);\n\n#endif\t/* CONFIG_ACPI_WMI */\n\n#define ACPI_VIDEO_OUTPUT_SWITCHING\t\t\t0x0001\n#define ACPI_VIDEO_DEVICE_POSTING\t\t\t0x0002\n#define ACPI_VIDEO_ROM_AVAILABLE\t\t\t0x0004\n#define ACPI_VIDEO_BACKLIGHT\t\t\t\t0x0008\n#define ACPI_VIDEO_BACKLIGHT_FORCE_VENDOR\t\t0x0010\n#define ACPI_VIDEO_BACKLIGHT_FORCE_VIDEO\t\t0x0020\n#define ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VENDOR\t0x0040\n#define ACPI_VIDEO_OUTPUT_SWITCHING_FORCE_VIDEO\t\t0x0080\n#define ACPI_VIDEO_BACKLIGHT_DMI_VENDOR\t\t\t0x0100\n#define ACPI_VIDEO_BACKLIGHT_DMI_VIDEO\t\t\t0x0200\n#define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VENDOR\t\t0x0400\n#define ACPI_VIDEO_OUTPUT_SWITCHING_DMI_VIDEO\t\t0x0800\n\nextern char acpi_video_backlight_string[];\nextern long acpi_is_video_device(acpi_handle handle);\nextern int acpi_blacklisted(void);\nextern void acpi_osi_setup(char *str);\nextern bool acpi_osi_is_win8(void);\n\n#ifdef CONFIG_ACPI_NUMA\nint acpi_map_pxm_to_node(int pxm);\nint acpi_get_node(acpi_handle handle);\n\n/**\n * pxm_to_online_node - Map proximity ID to online node\n * @pxm: ACPI proximity ID\n *\n * This is similar to pxm_to_node(), but always returns an online\n * node.  When the mapped node from a given proximity ID is offline, it\n * looks up the node distance table and returns the nearest online node.\n *\n * ACPI device drivers, which are called after the NUMA initialization has\n * completed in the kernel, can call this interface to obtain their device\n * NUMA topology from ACPI tables.  Such drivers do not have to deal with\n * offline nodes.  A node may be offline when SRAT memory entry does not exist,\n * or NUMA is disabled, ex. \"numa=off\" on x86.\n */\nstatic inline int pxm_to_online_node(int pxm)\n{\n\tint node = pxm_to_node(pxm);\n\n\treturn numa_map_to_online_node(node);\n}\n#else\nstatic inline int pxm_to_online_node(int pxm)\n{\n\treturn 0;\n}\nstatic inline int acpi_map_pxm_to_node(int pxm)\n{\n\treturn 0;\n}\nstatic inline int acpi_get_node(acpi_handle handle)\n{\n\treturn 0;\n}\n#endif\nextern int acpi_paddr_to_node(u64 start_addr, u64 size);\n\nextern int pnpacpi_disabled;\n\n#define PXM_INVAL\t(-1)\n\nbool acpi_dev_resource_memory(struct acpi_resource *ares, struct resource *res);\nbool acpi_dev_resource_io(struct acpi_resource *ares, struct resource *res);\nbool acpi_dev_resource_address_space(struct acpi_resource *ares,\n\t\t\t\t     struct resource_win *win);\nbool acpi_dev_resource_ext_address_space(struct acpi_resource *ares,\n\t\t\t\t\t struct resource_win *win);\nunsigned long acpi_dev_irq_flags(u8 triggering, u8 polarity, u8 shareable);\nunsigned int acpi_dev_get_irq_type(int triggering, int polarity);\nbool acpi_dev_resource_interrupt(struct acpi_resource *ares, int index,\n\t\t\t\t struct resource *res);\n\nvoid acpi_dev_free_resource_list(struct list_head *list);\nint acpi_dev_get_resources(struct acpi_device *adev, struct list_head *list,\n\t\t\t   int (*preproc)(struct acpi_resource *, void *),\n\t\t\t   void *preproc_data);\nint acpi_dev_get_dma_resources(struct acpi_device *adev,\n\t\t\t       struct list_head *list);\nint acpi_dev_filter_resource_type(struct acpi_resource *ares,\n\t\t\t\t  unsigned long types);\n\nstatic inline int acpi_dev_filter_resource_type_cb(struct acpi_resource *ares,\n\t\t\t\t\t\t   void *arg)\n{\n\treturn acpi_dev_filter_resource_type(ares, (unsigned long)arg);\n}\n\nstruct acpi_device *acpi_resource_consumer(struct resource *res);\n\nint acpi_check_resource_conflict(const struct resource *res);\n\nint acpi_check_region(resource_size_t start, resource_size_t n,\n\t\t      const char *name);\n\nacpi_status acpi_release_memory(acpi_handle handle, struct resource *res,\n\t\t\t\tu32 level);\n\nint acpi_resources_are_enforced(void);\n\n#ifdef CONFIG_HIBERNATION\nvoid __init acpi_no_s4_hw_signature(void);\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nvoid __init acpi_old_suspend_ordering(void);\nvoid __init acpi_nvs_nosave(void);\nvoid __init acpi_nvs_nosave_s3(void);\nvoid __init acpi_sleep_no_blacklist(void);\n#endif /* CONFIG_PM_SLEEP */\n\nint acpi_register_wakeup_handler(\n\tint wake_irq, bool (*wakeup)(void *context), void *context);\nvoid acpi_unregister_wakeup_handler(\n\tbool (*wakeup)(void *context), void *context);\n\nstruct acpi_osc_context {\n\tchar *uuid_str;\t\t\t/* UUID string */\n\tint rev;\n\tstruct acpi_buffer cap;\t\t/* list of DWORD capabilities */\n\tstruct acpi_buffer ret;\t\t/* free by caller if success */\n};\n\nacpi_status acpi_run_osc(acpi_handle handle, struct acpi_osc_context *context);\n\n/* Indexes into _OSC Capabilities Buffer (DWORDs 2 & 3 are device-specific) */\n#define OSC_QUERY_DWORD\t\t\t\t0\t/* DWORD 1 */\n#define OSC_SUPPORT_DWORD\t\t\t1\t/* DWORD 2 */\n#define OSC_CONTROL_DWORD\t\t\t2\t/* DWORD 3 */\n\n/* _OSC Capabilities DWORD 1: Query/Control and Error Returns (generic) */\n#define OSC_QUERY_ENABLE\t\t\t0x00000001  /* input */\n#define OSC_REQUEST_ERROR\t\t\t0x00000002  /* return */\n#define OSC_INVALID_UUID_ERROR\t\t\t0x00000004  /* return */\n#define OSC_INVALID_REVISION_ERROR\t\t0x00000008  /* return */\n#define OSC_CAPABILITIES_MASK_ERROR\t\t0x00000010  /* return */\n\n/* Platform-Wide Capabilities _OSC: Capabilities DWORD 2: Support Field */\n#define OSC_SB_PAD_SUPPORT\t\t\t0x00000001\n#define OSC_SB_PPC_OST_SUPPORT\t\t\t0x00000002\n#define OSC_SB_PR3_SUPPORT\t\t\t0x00000004\n#define OSC_SB_HOTPLUG_OST_SUPPORT\t\t0x00000008\n#define OSC_SB_APEI_SUPPORT\t\t\t0x00000010\n#define OSC_SB_CPC_SUPPORT\t\t\t0x00000020\n#define OSC_SB_CPCV2_SUPPORT\t\t\t0x00000040\n#define OSC_SB_PCLPI_SUPPORT\t\t\t0x00000080\n#define OSC_SB_OSLPI_SUPPORT\t\t\t0x00000100\n#define OSC_SB_CPC_DIVERSE_HIGH_SUPPORT\t\t0x00001000\n#define OSC_SB_GENERIC_INITIATOR_SUPPORT\t0x00002000\n\nextern bool osc_sb_apei_support_acked;\nextern bool osc_pc_lpi_support_confirmed;\n\n/* PCI Host Bridge _OSC: Capabilities DWORD 2: Support Field */\n#define OSC_PCI_EXT_CONFIG_SUPPORT\t\t0x00000001\n#define OSC_PCI_ASPM_SUPPORT\t\t\t0x00000002\n#define OSC_PCI_CLOCK_PM_SUPPORT\t\t0x00000004\n#define OSC_PCI_SEGMENT_GROUPS_SUPPORT\t\t0x00000008\n#define OSC_PCI_MSI_SUPPORT\t\t\t0x00000010\n#define OSC_PCI_EDR_SUPPORT\t\t\t0x00000080\n#define OSC_PCI_HPX_TYPE_3_SUPPORT\t\t0x00000100\n#define OSC_PCI_SUPPORT_MASKS\t\t\t0x0000019f\n\n/* PCI Host Bridge _OSC: Capabilities DWORD 3: Control Field */\n#define OSC_PCI_EXPRESS_NATIVE_HP_CONTROL\t0x00000001\n#define OSC_PCI_SHPC_NATIVE_HP_CONTROL\t\t0x00000002\n#define OSC_PCI_EXPRESS_PME_CONTROL\t\t0x00000004\n#define OSC_PCI_EXPRESS_AER_CONTROL\t\t0x00000008\n#define OSC_PCI_EXPRESS_CAPABILITY_CONTROL\t0x00000010\n#define OSC_PCI_EXPRESS_LTR_CONTROL\t\t0x00000020\n#define OSC_PCI_EXPRESS_DPC_CONTROL\t\t0x00000080\n#define OSC_PCI_CONTROL_MASKS\t\t\t0x000000bf\n\n#define ACPI_GSB_ACCESS_ATTRIB_QUICK\t\t0x00000002\n#define ACPI_GSB_ACCESS_ATTRIB_SEND_RCV         0x00000004\n#define ACPI_GSB_ACCESS_ATTRIB_BYTE\t\t0x00000006\n#define ACPI_GSB_ACCESS_ATTRIB_WORD\t\t0x00000008\n#define ACPI_GSB_ACCESS_ATTRIB_BLOCK\t\t0x0000000A\n#define ACPI_GSB_ACCESS_ATTRIB_MULTIBYTE\t0x0000000B\n#define ACPI_GSB_ACCESS_ATTRIB_WORD_CALL\t0x0000000C\n#define ACPI_GSB_ACCESS_ATTRIB_BLOCK_CALL\t0x0000000D\n#define ACPI_GSB_ACCESS_ATTRIB_RAW_BYTES\t0x0000000E\n#define ACPI_GSB_ACCESS_ATTRIB_RAW_PROCESS\t0x0000000F\n\n/* Enable _OST when all relevant hotplug operations are enabled */\n#if defined(CONFIG_ACPI_HOTPLUG_CPU) &&\t\t\t\\\n\tdefined(CONFIG_ACPI_HOTPLUG_MEMORY) &&\t\t\\\n\tdefined(CONFIG_ACPI_CONTAINER)\n#define ACPI_HOTPLUG_OST\n#endif\n\n/* _OST Source Event Code (OSPM Action) */\n#define ACPI_OST_EC_OSPM_SHUTDOWN\t\t0x100\n#define ACPI_OST_EC_OSPM_EJECT\t\t\t0x103\n#define ACPI_OST_EC_OSPM_INSERTION\t\t0x200\n\n/* _OST General Processing Status Code */\n#define ACPI_OST_SC_SUCCESS\t\t\t0x0\n#define ACPI_OST_SC_NON_SPECIFIC_FAILURE\t0x1\n#define ACPI_OST_SC_UNRECOGNIZED_NOTIFY\t\t0x2\n\n/* _OST OS Shutdown Processing (0x100) Status Code */\n#define ACPI_OST_SC_OS_SHUTDOWN_DENIED\t\t0x80\n#define ACPI_OST_SC_OS_SHUTDOWN_IN_PROGRESS\t0x81\n#define ACPI_OST_SC_OS_SHUTDOWN_COMPLETED\t0x82\n#define ACPI_OST_SC_OS_SHUTDOWN_NOT_SUPPORTED\t0x83\n\n/* _OST Ejection Request (0x3, 0x103) Status Code */\n#define ACPI_OST_SC_EJECT_NOT_SUPPORTED\t\t0x80\n#define ACPI_OST_SC_DEVICE_IN_USE\t\t0x81\n#define ACPI_OST_SC_DEVICE_BUSY\t\t\t0x82\n#define ACPI_OST_SC_EJECT_DEPENDENCY_BUSY\t0x83\n#define ACPI_OST_SC_EJECT_IN_PROGRESS\t\t0x84\n\n/* _OST Insertion Request (0x200) Status Code */\n#define ACPI_OST_SC_INSERT_IN_PROGRESS\t\t0x80\n#define ACPI_OST_SC_DRIVER_LOAD_FAILURE\t\t0x81\n#define ACPI_OST_SC_INSERT_NOT_SUPPORTED\t0x82\n\nenum acpi_predicate {\n\tall_versions,\n\tless_than_or_equal,\n\tequal,\n\tgreater_than_or_equal,\n};\n\n/* Table must be terminted by a NULL entry */\nstruct acpi_platform_list {\n\tchar\toem_id[ACPI_OEM_ID_SIZE+1];\n\tchar\toem_table_id[ACPI_OEM_TABLE_ID_SIZE+1];\n\tu32\toem_revision;\n\tchar\t*table;\n\tenum acpi_predicate pred;\n\tchar\t*reason;\n\tu32\tdata;\n};\nint acpi_match_platform_list(const struct acpi_platform_list *plat);\n\nextern void acpi_early_init(void);\nextern void acpi_subsystem_init(void);\nextern void arch_post_acpi_subsys_init(void);\n\nextern int acpi_nvs_register(__u64 start, __u64 size);\n\nextern int acpi_nvs_for_each_region(int (*func)(__u64, __u64, void *),\n\t\t\t\t    void *data);\n\nconst struct acpi_device_id *acpi_match_device(const struct acpi_device_id *ids,\n\t\t\t\t\t       const struct device *dev);\n\nconst void *acpi_device_get_match_data(const struct device *dev);\nextern bool acpi_driver_match_device(struct device *dev,\n\t\t\t\t     const struct device_driver *drv);\nint acpi_device_uevent_modalias(struct device *, struct kobj_uevent_env *);\nint acpi_device_modalias(struct device *, char *, int);\nvoid acpi_walk_dep_device_list(acpi_handle handle);\n\nstruct platform_device *acpi_create_platform_device(struct acpi_device *,\n\t\t\t\t\t\t    struct property_entry *);\n#define ACPI_PTR(_ptr)\t(_ptr)\n\nstatic inline void acpi_device_set_enumerated(struct acpi_device *adev)\n{\n\tadev->flags.visited = true;\n}\n\nstatic inline void acpi_device_clear_enumerated(struct acpi_device *adev)\n{\n\tadev->flags.visited = false;\n}\n\nenum acpi_reconfig_event  {\n\tACPI_RECONFIG_DEVICE_ADD = 0,\n\tACPI_RECONFIG_DEVICE_REMOVE,\n};\n\nint acpi_reconfig_notifier_register(struct notifier_block *nb);\nint acpi_reconfig_notifier_unregister(struct notifier_block *nb);\n\n#ifdef CONFIG_ACPI_GTDT\nint acpi_gtdt_init(struct acpi_table_header *table, int *platform_timer_count);\nint acpi_gtdt_map_ppi(int type);\nbool acpi_gtdt_c3stop(int type);\nint acpi_arch_timer_mem_init(struct arch_timer_mem *timer_mem, int *timer_count);\n#endif\n\n#ifndef ACPI_HAVE_ARCH_SET_ROOT_POINTER\nstatic inline void acpi_arch_set_root_pointer(u64 addr)\n{\n}\n#endif\n\n#ifndef ACPI_HAVE_ARCH_GET_ROOT_POINTER\nstatic inline u64 acpi_arch_get_root_pointer(void)\n{\n\treturn 0;\n}\n#endif\n\n#else\t/* !CONFIG_ACPI */\n\n#define acpi_disabled 1\n\n#define ACPI_COMPANION(dev)\t\t(NULL)\n#define ACPI_COMPANION_SET(dev, adev)\tdo { } while (0)\n#define ACPI_HANDLE(dev)\t\t(NULL)\n#define ACPI_HANDLE_FWNODE(fwnode)\t(NULL)\n#define ACPI_DEVICE_CLASS(_cls, _msk)\t.cls = (0), .cls_msk = (0),\n\n#include <acpi/acpi_numa.h>\n\nstruct fwnode_handle;\n\nstatic inline bool acpi_dev_found(const char *hid)\n{\n\treturn false;\n}\n\nstatic inline bool acpi_dev_present(const char *hid, const char *uid, s64 hrv)\n{\n\treturn false;\n}\n\nstruct acpi_device;\n\nstatic inline bool\nacpi_dev_hid_uid_match(struct acpi_device *adev, const char *hid2, const char *uid2)\n{\n\treturn false;\n}\n\nstatic inline struct acpi_device *\nacpi_dev_get_first_match_dev(const char *hid, const char *uid, s64 hrv)\n{\n\treturn NULL;\n}\n\nstatic inline void acpi_dev_put(struct acpi_device *adev) {}\n\nstatic inline bool is_acpi_node(struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline bool is_acpi_device_node(struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline struct acpi_device *to_acpi_device_node(struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline bool is_acpi_data_node(struct fwnode_handle *fwnode)\n{\n\treturn false;\n}\n\nstatic inline struct acpi_data_node *to_acpi_data_node(struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_data_node_match(struct fwnode_handle *fwnode,\n\t\t\t\t\tconst char *name)\n{\n\treturn false;\n}\n\nstatic inline struct fwnode_handle *acpi_fwnode_handle(struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline bool has_acpi_companion(struct device *dev)\n{\n\treturn false;\n}\n\nstatic inline void acpi_preset_companion(struct device *dev,\n\t\t\t\t\t struct acpi_device *parent, u64 addr)\n{\n}\n\nstatic inline const char *acpi_dev_name(struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline struct device *acpi_get_first_physical_node(struct acpi_device *adev)\n{\n\treturn NULL;\n}\n\nstatic inline void acpi_early_init(void) { }\nstatic inline void acpi_subsystem_init(void) { }\n\nstatic inline int early_acpi_boot_init(void)\n{\n\treturn 0;\n}\nstatic inline int acpi_boot_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void acpi_boot_table_init(void)\n{\n\treturn;\n}\n\nstatic inline int acpi_mps_check(void)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_check_resource_conflict(struct resource *res)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_check_region(resource_size_t start, resource_size_t n,\n\t\t\t\t    const char *name)\n{\n\treturn 0;\n}\n\nstruct acpi_table_header;\nstatic inline int acpi_table_parse(char *id,\n\t\t\t\tint (*handler)(struct acpi_table_header *))\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_nvs_register(__u64 start, __u64 size)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_nvs_for_each_region(int (*func)(__u64, __u64, void *),\n\t\t\t\t\t   void *data)\n{\n\treturn 0;\n}\n\nstruct acpi_device_id;\n\nstatic inline const struct acpi_device_id *acpi_match_device(\n\tconst struct acpi_device_id *ids, const struct device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline const void *acpi_device_get_match_data(const struct device *dev)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_driver_match_device(struct device *dev,\n\t\t\t\t\t    const struct device_driver *drv)\n{\n\treturn false;\n}\n\nstatic inline union acpi_object *acpi_evaluate_dsm(acpi_handle handle,\n\t\t\t\t\t\t   const guid_t *guid,\n\t\t\t\t\t\t   u64 rev, u64 func,\n\t\t\t\t\t\t   union acpi_object *argv4)\n{\n\treturn NULL;\n}\n\nstatic inline int acpi_device_uevent_modalias(struct device *dev,\n\t\t\t\tstruct kobj_uevent_env *env)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_device_modalias(struct device *dev,\n\t\t\t\tchar *buf, int size)\n{\n\treturn -ENODEV;\n}\n\nstatic inline struct platform_device *\nacpi_create_platform_device(struct acpi_device *adev,\n\t\t\t    struct property_entry *properties)\n{\n\treturn NULL;\n}\n\nstatic inline bool acpi_dma_supported(struct acpi_device *adev)\n{\n\treturn false;\n}\n\nstatic inline enum dev_dma_attr acpi_get_dma_attr(struct acpi_device *adev)\n{\n\treturn DEV_DMA_NOT_SUPPORTED;\n}\n\nstatic inline int acpi_dma_get_range(struct device *dev, u64 *dma_addr,\n\t\t\t\t     u64 *offset, u64 *size)\n{\n\treturn -ENODEV;\n}\n\nstatic inline int acpi_dma_configure(struct device *dev,\n\t\t\t\t     enum dev_dma_attr attr)\n{\n\treturn 0;\n}\n\nstatic inline int acpi_dma_configure_id(struct device *dev,\n\t\t\t\t\tenum dev_dma_attr attr,\n\t\t\t\t\tconst u32 *input_id)\n{\n\treturn 0;\n}\n\n#define ACPI_PTR(_ptr)\t(NULL)\n\nstatic inline void acpi_device_set_enumerated(struct acpi_device *adev)\n{\n}\n\nstatic inline void acpi_device_clear_enumerated(struct acpi_device *adev)\n{\n}\n\nstatic inline int acpi_reconfig_notifier_register(struct notifier_block *nb)\n{\n\treturn -EINVAL;\n}\n\nstatic inline int acpi_reconfig_notifier_unregister(struct notifier_block *nb)\n{\n\treturn -EINVAL;\n}\n\nstatic inline struct acpi_device *acpi_resource_consumer(struct resource *res)\n{\n\treturn NULL;\n}\n\n#endif\t/* !CONFIG_ACPI */\n\n#ifdef CONFIG_ACPI_HOTPLUG_IOAPIC\nint acpi_ioapic_add(acpi_handle root);\n#else\nstatic inline int acpi_ioapic_add(acpi_handle root) { return 0; }\n#endif\n\n#ifdef CONFIG_ACPI\nvoid acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl,  u32 pm1b_ctrl));\n\nacpi_status acpi_os_prepare_sleep(u8 sleep_state,\n\t\t\t\t  u32 pm1a_control, u32 pm1b_control);\n\nvoid acpi_os_set_prepare_extended_sleep(int (*func)(u8 sleep_state,\n\t\t\t\t        u32 val_a,  u32 val_b));\n\nacpi_status acpi_os_prepare_extended_sleep(u8 sleep_state,\n\t\t\t\t\t   u32 val_a, u32 val_b);\n\n#ifndef CONFIG_IA64\nvoid arch_reserve_mem_area(acpi_physical_address addr, size_t size);\n#else\nstatic inline void arch_reserve_mem_area(acpi_physical_address addr,\n\t\t\t\t\t  size_t size)\n{\n}\n#endif /* CONFIG_X86 */\n#else\n#define acpi_os_set_prepare_sleep(func, pm1a_ctrl, pm1b_ctrl) do { } while (0)\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PM)\nint acpi_dev_suspend(struct device *dev, bool wakeup);\nint acpi_dev_resume(struct device *dev);\nint acpi_subsys_runtime_suspend(struct device *dev);\nint acpi_subsys_runtime_resume(struct device *dev);\nint acpi_dev_pm_attach(struct device *dev, bool power_on);\n#else\nstatic inline int acpi_subsys_runtime_suspend(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_runtime_resume(struct device *dev) { return 0; }\nstatic inline int acpi_dev_pm_attach(struct device *dev, bool power_on)\n{\n\treturn 0;\n}\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_PM_SLEEP)\nint acpi_subsys_prepare(struct device *dev);\nvoid acpi_subsys_complete(struct device *dev);\nint acpi_subsys_suspend_late(struct device *dev);\nint acpi_subsys_suspend_noirq(struct device *dev);\nint acpi_subsys_suspend(struct device *dev);\nint acpi_subsys_freeze(struct device *dev);\nint acpi_subsys_poweroff(struct device *dev);\nvoid acpi_ec_mark_gpe_for_wake(void);\nvoid acpi_ec_set_gpe_wake_mask(u8 action);\n#else\nstatic inline int acpi_subsys_prepare(struct device *dev) { return 0; }\nstatic inline void acpi_subsys_complete(struct device *dev) {}\nstatic inline int acpi_subsys_suspend_late(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_suspend_noirq(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_suspend(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_freeze(struct device *dev) { return 0; }\nstatic inline int acpi_subsys_poweroff(struct device *dev) { return 0; }\nstatic inline void acpi_ec_mark_gpe_for_wake(void) {}\nstatic inline void acpi_ec_set_gpe_wake_mask(u8 action) {}\n#endif\n\n#ifdef CONFIG_ACPI\n__printf(3, 4)\nvoid acpi_handle_printk(const char *level, acpi_handle handle,\n\t\t\tconst char *fmt, ...);\n#else\t/* !CONFIG_ACPI */\nstatic inline __printf(3, 4) void\nacpi_handle_printk(const char *level, void *handle, const char *fmt, ...) {}\n#endif\t/* !CONFIG_ACPI */\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_DYNAMIC_DEBUG)\n__printf(3, 4)\nvoid __acpi_handle_debug(struct _ddebug *descriptor, acpi_handle handle, const char *fmt, ...);\n#endif\n\n/*\n * acpi_handle_<level>: Print message with ACPI prefix and object path\n *\n * These interfaces acquire the global namespace mutex to obtain an object\n * path.  In interrupt context, it shows the object path as <n/a>.\n */\n#define acpi_handle_emerg(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_EMERG, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_alert(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_ALERT, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_crit(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_CRIT, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_err(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_ERR, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_warn(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_WARNING, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_notice(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_NOTICE, handle, fmt, ##__VA_ARGS__)\n#define acpi_handle_info(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_INFO, handle, fmt, ##__VA_ARGS__)\n\n#if defined(DEBUG)\n#define acpi_handle_debug(handle, fmt, ...)\t\t\t\t\\\n\tacpi_handle_printk(KERN_DEBUG, handle, fmt, ##__VA_ARGS__)\n#else\n#if defined(CONFIG_DYNAMIC_DEBUG)\n#define acpi_handle_debug(handle, fmt, ...)\t\t\t\t\\\n\t_dynamic_func_call(fmt, __acpi_handle_debug,\t\t\t\\\n\t\t\t   handle, pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define acpi_handle_debug(handle, fmt, ...)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\tacpi_handle_printk(KERN_DEBUG, handle, fmt, ##__VA_ARGS__); \\\n\t0;\t\t\t\t\t\t\t\t\\\n})\n#endif\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_GPIOLIB)\nbool acpi_gpio_get_irq_resource(struct acpi_resource *ares,\n\t\t\t\tstruct acpi_resource_gpio **agpio);\nint acpi_dev_gpio_irq_get(struct acpi_device *adev, int index);\n#else\nstatic inline bool acpi_gpio_get_irq_resource(struct acpi_resource *ares,\n\t\t\t\t\t      struct acpi_resource_gpio **agpio)\n{\n\treturn false;\n}\nstatic inline int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)\n{\n\treturn -ENXIO;\n}\n#endif\n\n/* Device properties */\n\n#ifdef CONFIG_ACPI\nint acpi_dev_get_property(const struct acpi_device *adev, const char *name,\n\t\t\t  acpi_object_type type, const union acpi_object **obj);\nint __acpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name, size_t index, size_t num_args,\n\t\t\t\tstruct fwnode_reference_args *args);\n\nstatic inline int acpi_node_get_property_reference(\n\t\t\t\tconst struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name, size_t index,\n\t\t\t\tstruct fwnode_reference_args *args)\n{\n\treturn __acpi_node_get_property_reference(fwnode, name, index,\n\t\tNR_FWNODE_REFERENCE_ARGS, args);\n}\n\nstatic inline bool acpi_dev_has_props(const struct acpi_device *adev)\n{\n\treturn !list_empty(&adev->data.properties);\n}\n\nstruct acpi_device_properties *\nacpi_data_add_props(struct acpi_device_data *data, const guid_t *guid,\n\t\t    const union acpi_object *properties);\n\nint acpi_node_prop_get(const struct fwnode_handle *fwnode, const char *propname,\n\t\t       void **valptr);\nint acpi_dev_prop_read_single(struct acpi_device *adev,\n\t\t\t      const char *propname, enum dev_prop_type proptype,\n\t\t\t      void *val);\nint acpi_node_prop_read(const struct fwnode_handle *fwnode,\n\t\t\tconst char *propname, enum dev_prop_type proptype,\n\t\t\tvoid *val, size_t nval);\nint acpi_dev_prop_read(const struct acpi_device *adev, const char *propname,\n\t\t       enum dev_prop_type proptype, void *val, size_t nval);\n\nstruct fwnode_handle *acpi_get_next_subnode(const struct fwnode_handle *fwnode,\n\t\t\t\t\t    struct fwnode_handle *child);\nstruct fwnode_handle *acpi_node_get_parent(const struct fwnode_handle *fwnode);\n\nstruct acpi_probe_entry;\ntypedef bool (*acpi_probe_entry_validate_subtbl)(struct acpi_subtable_header *,\n\t\t\t\t\t\t struct acpi_probe_entry *);\n\n#define ACPI_TABLE_ID_LEN\t5\n\n/**\n * struct acpi_probe_entry - boot-time probing entry\n * @id:\t\t\tACPI table name\n * @type:\t\tOptional subtable type to match\n *\t\t\t(if @id contains subtables)\n * @subtable_valid:\tOptional callback to check the validity of\n *\t\t\tthe subtable\n * @probe_table:\tCallback to the driver being probed when table\n *\t\t\tmatch is successful\n * @probe_subtbl:\tCallback to the driver being probed when table and\n *\t\t\tsubtable match (and optional callback is successful)\n * @driver_data:\tSideband data provided back to the driver\n */\nstruct acpi_probe_entry {\n\t__u8 id[ACPI_TABLE_ID_LEN];\n\t__u8 type;\n\tacpi_probe_entry_validate_subtbl subtable_valid;\n\tunion {\n\t\tacpi_tbl_table_handler probe_table;\n\t\tacpi_tbl_entry_handler probe_subtbl;\n\t};\n\tkernel_ulong_t driver_data;\n};\n\n#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable,\t\\\n\t\t\t\t valid, data, fn)\t\t\t\\\n\tstatic const struct acpi_probe_entry __acpi_probe_##name\t\\\n\t\t__used __section(\"__\" #table \"_acpi_probe_table\") = {\t\\\n\t\t\t.id = table_id,\t\t\t\t\t\\\n\t\t\t.type = subtable,\t\t\t\t\\\n\t\t\t.subtable_valid = valid,\t\t\t\\\n\t\t\t.probe_table = fn,\t\t\t\t\\\n\t\t\t.driver_data = data,\t\t\t\t\\\n\t\t}\n\n#define ACPI_DECLARE_SUBTABLE_PROBE_ENTRY(table, name, table_id,\t\\\n\t\t\t\t\t  subtable, valid, data, fn)\t\\\n\tstatic const struct acpi_probe_entry __acpi_probe_##name\t\\\n\t\t__used __section(\"__\" #table \"_acpi_probe_table\") = {\t\\\n\t\t\t.id = table_id,\t\t\t\t\t\\\n\t\t\t.type = subtable,\t\t\t\t\\\n\t\t\t.subtable_valid = valid,\t\t\t\\\n\t\t\t.probe_subtbl = fn,\t\t\t\t\\\n\t\t\t.driver_data = data,\t\t\t\t\\\n\t\t}\n\n#define ACPI_PROBE_TABLE(name)\t\t__##name##_acpi_probe_table\n#define ACPI_PROBE_TABLE_END(name)\t__##name##_acpi_probe_table_end\n\nint __acpi_probe_device_table(struct acpi_probe_entry *start, int nr);\n\n#define acpi_probe_device_table(t)\t\t\t\t\t\\\n\t({ \t\t\t\t\t\t\t\t\\\n\t\textern struct acpi_probe_entry ACPI_PROBE_TABLE(t),\t\\\n\t\t\t                       ACPI_PROBE_TABLE_END(t);\t\\\n\t\t__acpi_probe_device_table(&ACPI_PROBE_TABLE(t),\t\t\\\n\t\t\t\t\t  (&ACPI_PROBE_TABLE_END(t) -\t\\\n\t\t\t\t\t   &ACPI_PROBE_TABLE(t)));\t\\\n\t})\n#else\nstatic inline int acpi_dev_get_property(struct acpi_device *adev,\n\t\t\t\t\tconst char *name, acpi_object_type type,\n\t\t\t\t\tconst union acpi_object **obj)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int\n__acpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *name, size_t index, size_t num_args,\n\t\t\t\tstruct fwnode_reference_args *args)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int\nacpi_node_get_property_reference(const struct fwnode_handle *fwnode,\n\t\t\t\t const char *name, size_t index,\n\t\t\t\t struct fwnode_reference_args *args)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int acpi_node_prop_get(const struct fwnode_handle *fwnode,\n\t\t\t\t     const char *propname,\n\t\t\t\t     void **valptr)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int acpi_dev_prop_read_single(const struct acpi_device *adev,\n\t\t\t\t\t    const char *propname,\n\t\t\t\t\t    enum dev_prop_type proptype,\n\t\t\t\t\t    void *val)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int acpi_node_prop_read(const struct fwnode_handle *fwnode,\n\t\t\t\t      const char *propname,\n\t\t\t\t      enum dev_prop_type proptype,\n\t\t\t\t      void *val, size_t nval)\n{\n\treturn -ENXIO;\n}\n\nstatic inline int acpi_dev_prop_read(const struct acpi_device *adev,\n\t\t\t\t     const char *propname,\n\t\t\t\t     enum dev_prop_type proptype,\n\t\t\t\t     void *val, size_t nval)\n{\n\treturn -ENXIO;\n}\n\nstatic inline struct fwnode_handle *\nacpi_get_next_subnode(const struct fwnode_handle *fwnode,\n\t\t      struct fwnode_handle *child)\n{\n\treturn NULL;\n}\n\nstatic inline struct fwnode_handle *\nacpi_node_get_parent(const struct fwnode_handle *fwnode)\n{\n\treturn NULL;\n}\n\nstatic inline struct fwnode_handle *\nacpi_graph_get_next_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t     struct fwnode_handle *prev)\n{\n\treturn ERR_PTR(-ENXIO);\n}\n\nstatic inline int\nacpi_graph_get_remote_endpoint(const struct fwnode_handle *fwnode,\n\t\t\t       struct fwnode_handle **remote,\n\t\t\t       struct fwnode_handle **port,\n\t\t\t       struct fwnode_handle **endpoint)\n{\n\treturn -ENXIO;\n}\n\n#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable, valid, data, fn) \\\n\tstatic const void * __acpi_table_##name[]\t\t\t\\\n\t\t__attribute__((unused))\t\t\t\t\t\\\n\t\t = { (void *) table_id,\t\t\t\t\t\\\n\t\t     (void *) subtable,\t\t\t\t\t\\\n\t\t     (void *) valid,\t\t\t\t\t\\\n\t\t     (void *) fn,\t\t\t\t\t\\\n\t\t     (void *) data }\n\n#define acpi_probe_device_table(t)\t({ int __r = 0; __r;})\n#endif\n\n#ifdef CONFIG_ACPI_TABLE_UPGRADE\nvoid acpi_table_upgrade(void);\n#else\nstatic inline void acpi_table_upgrade(void) { }\n#endif\n\n#if defined(CONFIG_ACPI) && defined(CONFIG_ACPI_WATCHDOG)\nextern bool acpi_has_watchdog(void);\n#else\nstatic inline bool acpi_has_watchdog(void) { return false; }\n#endif\n\n#ifdef CONFIG_ACPI_SPCR_TABLE\nextern bool qdf2400_e44_present;\nint acpi_parse_spcr(bool enable_earlycon, bool enable_console);\n#else\nstatic inline int acpi_parse_spcr(bool enable_earlycon, bool enable_console)\n{\n\treturn 0;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_ACPI_GENERIC_GSI)\nint acpi_irq_get(acpi_handle handle, unsigned int index, struct resource *res);\n#else\nstatic inline\nint acpi_irq_get(acpi_handle handle, unsigned int index, struct resource *res)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#ifdef CONFIG_ACPI_LPIT\nint lpit_read_residency_count_address(u64 *address);\n#else\nstatic inline int lpit_read_residency_count_address(u64 *address)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#ifdef CONFIG_ACPI_PPTT\nint acpi_pptt_cpu_is_thread(unsigned int cpu);\nint find_acpi_cpu_topology(unsigned int cpu, int level);\nint find_acpi_cpu_topology_package(unsigned int cpu);\nint find_acpi_cpu_topology_hetero_id(unsigned int cpu);\nint find_acpi_cpu_cache_topology(unsigned int cpu, int level);\n#else\nstatic inline int acpi_pptt_cpu_is_thread(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology(unsigned int cpu, int level)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology_package(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_topology_hetero_id(unsigned int cpu)\n{\n\treturn -EINVAL;\n}\nstatic inline int find_acpi_cpu_cache_topology(unsigned int cpu, int level)\n{\n\treturn -EINVAL;\n}\n#endif\n\n#ifdef CONFIG_ACPI\nextern int acpi_platform_notify(struct device *dev, enum kobject_action action);\n#else\nstatic inline int\nacpi_platform_notify(struct device *dev, enum kobject_action action)\n{\n\treturn 0;\n}\n#endif\n\n#endif\t/*_LINUX_ACPI_H*/\n"}, "2": {"id": 2, "path": "/src/drivers/i2c/i2c-core-base.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Linux I2C core\n *\n * Copyright (C) 1995-99 Simon G. Vogl\n *   With some changes from Ky\u00f6sti M\u00e4lkki <kmalkki@cc.hut.fi>\n *   Mux support by Rodolfo Giometti <giometti@enneenne.com> and\n *   Michael Lawnick <michael.lawnick.ext@nsn.com>\n *\n * Copyright (C) 2013-2017 Wolfram Sang <wsa@kernel.org>\n */\n\n#define pr_fmt(fmt) \"i2c-core: \" fmt\n\n#include <dt-bindings/i2c/i2c.h>\n#include <linux/acpi.h>\n#include <linux/clk/clk-conf.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/i2c-smbus.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/irqflags.h>\n#include <linux/jump_label.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/property.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n\n#include \"i2c-core.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/i2c.h>\n\n#define I2C_ADDR_OFFSET_TEN_BIT\t0xa000\n#define I2C_ADDR_OFFSET_SLAVE\t0x1000\n\n#define I2C_ADDR_7BITS_MAX\t0x77\n#define I2C_ADDR_7BITS_COUNT\t(I2C_ADDR_7BITS_MAX + 1)\n\n#define I2C_ADDR_DEVICE_ID\t0x7c\n\n/*\n * core_lock protects i2c_adapter_idr, and guarantees that device detection,\n * deletion of detected devices are serialized\n */\nstatic DEFINE_MUTEX(core_lock);\nstatic DEFINE_IDR(i2c_adapter_idr);\n\nstatic int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);\n\nstatic DEFINE_STATIC_KEY_FALSE(i2c_trace_msg_key);\nstatic bool is_registered;\n\nint i2c_transfer_trace_reg(void)\n{\n\tstatic_branch_inc(&i2c_trace_msg_key);\n\treturn 0;\n}\n\nvoid i2c_transfer_trace_unreg(void)\n{\n\tstatic_branch_dec(&i2c_trace_msg_key);\n}\n\nconst struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,\n\t\t\t\t\t\tconst struct i2c_client *client)\n{\n\tif (!(id && client))\n\t\treturn NULL;\n\n\twhile (id->name[0]) {\n\t\tif (strcmp(client->name, id->name) == 0)\n\t\t\treturn id;\n\t\tid++;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(i2c_match_id);\n\nstatic int i2c_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tstruct i2c_driver\t*driver;\n\n\n\t/* Attempt an OF style match */\n\tif (i2c_of_match_device(drv->of_match_table, client))\n\t\treturn 1;\n\n\t/* Then ACPI style match */\n\tif (acpi_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tdriver = to_i2c_driver(drv);\n\n\t/* Finally an I2C match */\n\tif (i2c_match_id(driver->id_table, client))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint rc;\n\n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\trc = acpi_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn add_uevent_var(env, \"MODALIAS=%s%s\", I2C_MODULE_PREFIX, client->name);\n}\n\n/* i2c bus recovery routines */\nstatic int get_scl_gpio_value(struct i2c_adapter *adap)\n{\n\treturn gpiod_get_value_cansleep(adap->bus_recovery_info->scl_gpiod);\n}\n\nstatic void set_scl_gpio_value(struct i2c_adapter *adap, int val)\n{\n\tgpiod_set_value_cansleep(adap->bus_recovery_info->scl_gpiod, val);\n}\n\nstatic int get_sda_gpio_value(struct i2c_adapter *adap)\n{\n\treturn gpiod_get_value_cansleep(adap->bus_recovery_info->sda_gpiod);\n}\n\nstatic void set_sda_gpio_value(struct i2c_adapter *adap, int val)\n{\n\tgpiod_set_value_cansleep(adap->bus_recovery_info->sda_gpiod, val);\n}\n\nstatic int i2c_generic_bus_free(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tint ret = -EOPNOTSUPP;\n\n\tif (bri->get_bus_free)\n\t\tret = bri->get_bus_free(adap);\n\telse if (bri->get_sda)\n\t\tret = bri->get_sda(adap);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret ? 0 : -EBUSY;\n}\n\n/*\n * We are generating clock pulses. ndelay() determines durating of clk pulses.\n * We will generate clock with rate 100 KHz and so duration of both clock levels\n * is: delay in ns = (10^6 / 100) / 2\n */\n#define RECOVERY_NDELAY\t\t5000\n#define RECOVERY_CLK_CNT\t9\n\nint i2c_generic_scl_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tint i = 0, scl = 1, ret = 0;\n\n\tif (bri->prepare_recovery)\n\t\tbri->prepare_recovery(adap);\n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_gpio);\n\n\t/*\n\t * If we can set SDA, we will always create a STOP to ensure additional\n\t * pulses will do no harm. This is achieved by letting SDA follow SCL\n\t * half a cycle later. Check the 'incomplete_write_byte' fault injector\n\t * for details. Note that we must honour tsu:sto, 4us, but lets use 5us\n\t * here for simplicity.\n\t */\n\tbri->set_scl(adap, scl);\n\tndelay(RECOVERY_NDELAY);\n\tif (bri->set_sda)\n\t\tbri->set_sda(adap, scl);\n\tndelay(RECOVERY_NDELAY / 2);\n\n\t/*\n\t * By this time SCL is high, as we need to give 9 falling-rising edges\n\t */\n\twhile (i++ < RECOVERY_CLK_CNT * 2) {\n\t\tif (scl) {\n\t\t\t/* SCL shouldn't be low here */\n\t\t\tif (!bri->get_scl(adap)) {\n\t\t\t\tdev_err(&adap->dev,\n\t\t\t\t\t\"SCL is stuck low, exit recovery\\n\");\n\t\t\t\tret = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tscl = !scl;\n\t\tbri->set_scl(adap, scl);\n\t\t/* Creating STOP again, see above */\n\t\tif (scl)  {\n\t\t\t/* Honour minimum tsu:sto */\n\t\t\tndelay(RECOVERY_NDELAY);\n\t\t} else {\n\t\t\t/* Honour minimum tf and thd:dat */\n\t\t\tndelay(RECOVERY_NDELAY / 2);\n\t\t}\n\t\tif (bri->set_sda)\n\t\t\tbri->set_sda(adap, scl);\n\t\tndelay(RECOVERY_NDELAY / 2);\n\n\t\tif (scl) {\n\t\t\tret = i2c_generic_bus_free(adap);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If we can't check bus status, assume recovery worked */\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\n\tif (bri->unprepare_recovery)\n\t\tbri->unprepare_recovery(adap);\n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_default);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);\n\nint i2c_recover_bus(struct i2c_adapter *adap)\n{\n\tif (!adap->bus_recovery_info)\n\t\treturn -EOPNOTSUPP;\n\n\tdev_dbg(&adap->dev, \"Trying i2c bus recovery\\n\");\n\treturn adap->bus_recovery_info->recover_bus(adap);\n}\nEXPORT_SYMBOL_GPL(i2c_recover_bus);\n\nstatic void i2c_gpio_init_pinctrl_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tstruct device *dev = &adap->dev;\n\tstruct pinctrl *p = bri->pinctrl;\n\n\t/*\n\t * we can't change states without pinctrl, so remove the states if\n\t * populated\n\t */\n\tif (!p) {\n\t\tbri->pins_default = NULL;\n\t\tbri->pins_gpio = NULL;\n\t\treturn;\n\t}\n\n\tif (!bri->pins_default) {\n\t\tbri->pins_default = pinctrl_lookup_state(p,\n\t\t\t\t\t\t\t PINCTRL_STATE_DEFAULT);\n\t\tif (IS_ERR(bri->pins_default)) {\n\t\t\tdev_dbg(dev, PINCTRL_STATE_DEFAULT \" state not found for GPIO recovery\\n\");\n\t\t\tbri->pins_default = NULL;\n\t\t}\n\t}\n\tif (!bri->pins_gpio) {\n\t\tbri->pins_gpio = pinctrl_lookup_state(p, \"gpio\");\n\t\tif (IS_ERR(bri->pins_gpio))\n\t\t\tbri->pins_gpio = pinctrl_lookup_state(p, \"recovery\");\n\n\t\tif (IS_ERR(bri->pins_gpio)) {\n\t\t\tdev_dbg(dev, \"no gpio or recovery state found for GPIO recovery\\n\");\n\t\t\tbri->pins_gpio = NULL;\n\t\t}\n\t}\n\n\t/* for pinctrl state changes, we need all the information */\n\tif (bri->pins_default && bri->pins_gpio) {\n\t\tdev_info(dev, \"using pinctrl states for GPIO recovery\");\n\t} else {\n\t\tbri->pinctrl = NULL;\n\t\tbri->pins_default = NULL;\n\t\tbri->pins_gpio = NULL;\n\t}\n}\n\nstatic int i2c_gpio_init_generic_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tstruct device *dev = &adap->dev;\n\tstruct gpio_desc *gpiod;\n\tint ret = 0;\n\n\t/*\n\t * don't touch the recovery information if the driver is not using\n\t * generic SCL recovery\n\t */\n\tif (bri->recover_bus && bri->recover_bus != i2c_generic_scl_recovery)\n\t\treturn 0;\n\n\t/*\n\t * pins might be taken as GPIO, so we should inform pinctrl about\n\t * this and move the state to GPIO\n\t */\n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_gpio);\n\n\t/*\n\t * if there is incomplete or no recovery information, see if generic\n\t * GPIO recovery is available\n\t */\n\tif (!bri->scl_gpiod) {\n\t\tgpiod = devm_gpiod_get(dev, \"scl\", GPIOD_OUT_HIGH_OPEN_DRAIN);\n\t\tif (PTR_ERR(gpiod) == -EPROBE_DEFER) {\n\t\t\tret  = -EPROBE_DEFER;\n\t\t\tgoto cleanup_pinctrl_state;\n\t\t}\n\t\tif (!IS_ERR(gpiod)) {\n\t\t\tbri->scl_gpiod = gpiod;\n\t\t\tbri->recover_bus = i2c_generic_scl_recovery;\n\t\t\tdev_info(dev, \"using generic GPIOs for recovery\\n\");\n\t\t}\n\t}\n\n\t/* SDA GPIOD line is optional, so we care about DEFER only */\n\tif (!bri->sda_gpiod) {\n\t\t/*\n\t\t * We have SCL. Pull SCL low and wait a bit so that SDA glitches\n\t\t * have no effect.\n\t\t */\n\t\tgpiod_direction_output(bri->scl_gpiod, 0);\n\t\tudelay(10);\n\t\tgpiod = devm_gpiod_get(dev, \"sda\", GPIOD_IN);\n\n\t\t/* Wait a bit in case of a SDA glitch, and then release SCL. */\n\t\tudelay(10);\n\t\tgpiod_direction_output(bri->scl_gpiod, 1);\n\n\t\tif (PTR_ERR(gpiod) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto cleanup_pinctrl_state;\n\t\t}\n\t\tif (!IS_ERR(gpiod))\n\t\t\tbri->sda_gpiod = gpiod;\n\t}\n\ncleanup_pinctrl_state:\n\t/* change the state of the pins back to their default state */\n\tif (bri->pinctrl)\n\t\tpinctrl_select_state(bri->pinctrl, bri->pins_default);\n\n\treturn ret;\n}\n\nstatic int i2c_gpio_init_recovery(struct i2c_adapter *adap)\n{\n\ti2c_gpio_init_pinctrl_recovery(adap);\n\treturn i2c_gpio_init_generic_recovery(adap);\n}\n\nstatic int i2c_init_recovery(struct i2c_adapter *adap)\n{\n\tstruct i2c_bus_recovery_info *bri = adap->bus_recovery_info;\n\tchar *err_str;\n\n\tif (!bri)\n\t\treturn 0;\n\n\tif (i2c_gpio_init_recovery(adap) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (!bri->recover_bus) {\n\t\terr_str = \"no recover_bus() found\";\n\t\tgoto err;\n\t}\n\n\tif (bri->scl_gpiod && bri->recover_bus == i2c_generic_scl_recovery) {\n\t\tbri->get_scl = get_scl_gpio_value;\n\t\tbri->set_scl = set_scl_gpio_value;\n\t\tif (bri->sda_gpiod) {\n\t\t\tbri->get_sda = get_sda_gpio_value;\n\t\t\t/* FIXME: add proper flag instead of '0' once available */\n\t\t\tif (gpiod_get_direction(bri->sda_gpiod) == 0)\n\t\t\t\tbri->set_sda = set_sda_gpio_value;\n\t\t}\n\t} else if (bri->recover_bus == i2c_generic_scl_recovery) {\n\t\t/* Generic SCL recovery */\n\t\tif (!bri->set_scl || !bri->get_scl) {\n\t\t\terr_str = \"no {get|set}_scl() found\";\n\t\t\tgoto err;\n\t\t}\n\t\tif (!bri->set_sda && !bri->get_sda) {\n\t\t\terr_str = \"either get_sda() or set_sda() needed\";\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n err:\n\tdev_err(&adap->dev, \"Not using recovery: %s\\n\", err_str);\n\tadap->bus_recovery_info = NULL;\n\n\treturn -EINVAL;\n}\n\nstatic int i2c_smbus_host_notify_to_irq(const struct i2c_client *client)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tunsigned int irq;\n\n\tif (!adap->host_notify_domain)\n\t\treturn -ENXIO;\n\n\tif (client->flags & I2C_CLIENT_TEN)\n\t\treturn -EINVAL;\n\n\tirq = irq_create_mapping(adap->host_notify_domain, client->addr);\n\n\treturn irq > 0 ? irq : -ENXIO;\n}\n\nstatic int i2c_device_probe(struct device *dev)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tstruct i2c_driver\t*driver;\n\tint status;\n\n\tif (!client)\n\t\treturn 0;\n\n\tclient->irq = client->init_irq;\n\n\tif (!client->irq) {\n\t\tint irq = -ENOENT;\n\n\t\tif (client->flags & I2C_CLIENT_HOST_NOTIFY) {\n\t\t\tdev_dbg(dev, \"Using Host Notify IRQ\\n\");\n\t\t\t/* Keep adapter active when Host Notify is required */\n\t\t\tpm_runtime_get_sync(&client->adapter->dev);\n\t\t\tirq = i2c_smbus_host_notify_to_irq(client);\n\t\t} else if (dev->of_node) {\n\t\t\tirq = of_irq_get_byname(dev->of_node, \"irq\");\n\t\t\tif (irq == -EINVAL || irq == -ENODATA)\n\t\t\t\tirq = of_irq_get(dev->of_node, 0);\n\t\t} else if (ACPI_COMPANION(dev)) {\n\t\t\tirq = i2c_acpi_get_irq(client);\n\t\t}\n\t\tif (irq == -EPROBE_DEFER) {\n\t\t\tstatus = irq;\n\t\t\tgoto put_sync_adapter;\n\t\t}\n\n\t\tif (irq < 0)\n\t\t\tirq = 0;\n\n\t\tclient->irq = irq;\n\t}\n\n\tdriver = to_i2c_driver(dev->driver);\n\n\t/*\n\t * An I2C ID table is not mandatory, if and only if, a suitable OF\n\t * or ACPI ID table is supplied for the probing device.\n\t */\n\tif (!driver->id_table &&\n\t    !acpi_driver_match_device(dev, dev->driver) &&\n\t    !i2c_of_match_device(dev->driver->of_match_table, client)) {\n\t\tstatus = -ENODEV;\n\t\tgoto put_sync_adapter;\n\t}\n\n\tif (client->flags & I2C_CLIENT_WAKE) {\n\t\tint wakeirq;\n\n\t\twakeirq = of_irq_get_byname(dev->of_node, \"wakeup\");\n\t\tif (wakeirq == -EPROBE_DEFER) {\n\t\t\tstatus = wakeirq;\n\t\t\tgoto put_sync_adapter;\n\t\t}\n\n\t\tdevice_init_wakeup(&client->dev, true);\n\n\t\tif (wakeirq > 0 && wakeirq != client->irq)\n\t\t\tstatus = dev_pm_set_dedicated_wake_irq(dev, wakeirq);\n\t\telse if (client->irq > 0)\n\t\t\tstatus = dev_pm_set_wake_irq(dev, client->irq);\n\t\telse\n\t\t\tstatus = 0;\n\n\t\tif (status)\n\t\t\tdev_warn(&client->dev, \"failed to set up wakeup irq\\n\");\n\t}\n\n\tdev_dbg(dev, \"probe\\n\");\n\n\tstatus = of_clk_set_defaults(dev->of_node, false);\n\tif (status < 0)\n\t\tgoto err_clear_wakeup_irq;\n\n\tstatus = dev_pm_domain_attach(&client->dev, true);\n\tif (status)\n\t\tgoto err_clear_wakeup_irq;\n\n\t/*\n\t * When there are no more users of probe(),\n\t * rename probe_new to probe.\n\t */\n\tif (driver->probe_new)\n\t\tstatus = driver->probe_new(client);\n\telse if (driver->probe)\n\t\tstatus = driver->probe(client,\n\t\t\t\t       i2c_match_id(driver->id_table, client));\n\telse\n\t\tstatus = -EINVAL;\n\n\tif (status)\n\t\tgoto err_detach_pm_domain;\n\n\treturn 0;\n\nerr_detach_pm_domain:\n\tdev_pm_domain_detach(&client->dev, true);\nerr_clear_wakeup_irq:\n\tdev_pm_clear_wake_irq(&client->dev);\n\tdevice_init_wakeup(&client->dev, false);\nput_sync_adapter:\n\tif (client->flags & I2C_CLIENT_HOST_NOTIFY)\n\t\tpm_runtime_put_sync(&client->adapter->dev);\n\n\treturn status;\n}\n\nstatic int i2c_device_remove(struct device *dev)\n{\n\tstruct i2c_client\t*client = to_i2c_client(dev);\n\tstruct i2c_driver\t*driver;\n\n\tdriver = to_i2c_driver(dev->driver);\n\tif (driver->remove) {\n\t\tint status;\n\n\t\tdev_dbg(dev, \"remove\\n\");\n\n\t\tstatus = driver->remove(client);\n\t\tif (status)\n\t\t\tdev_warn(dev, \"remove failed (%pe), will be ignored\\n\", ERR_PTR(status));\n\t}\n\n\tdev_pm_domain_detach(&client->dev, true);\n\n\tdev_pm_clear_wake_irq(&client->dev);\n\tdevice_init_wakeup(&client->dev, false);\n\n\tclient->irq = 0;\n\tif (client->flags & I2C_CLIENT_HOST_NOTIFY)\n\t\tpm_runtime_put(&client->adapter->dev);\n\n\t/* return always 0 because there is WIP to make remove-functions void */\n\treturn 0;\n}\n\nstatic void i2c_device_shutdown(struct device *dev)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\tstruct i2c_driver *driver;\n\n\tif (!client || !dev->driver)\n\t\treturn;\n\tdriver = to_i2c_driver(dev->driver);\n\tif (driver->shutdown)\n\t\tdriver->shutdown(client);\n}\n\nstatic void i2c_client_dev_release(struct device *dev)\n{\n\tkfree(to_i2c_client(dev));\n}\n\nstatic ssize_t\nname_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", dev->type == &i2c_client_type ?\n\t\t       to_i2c_client(dev)->name : to_i2c_adapter(dev)->name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t\nmodalias_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tint len;\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\tlen = acpi_device_modalias(dev, buf, PAGE_SIZE -1);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\treturn sprintf(buf, \"%s%s\\n\", I2C_MODULE_PREFIX, client->name);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *i2c_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t/* modalias helps coldplug:  modprobe $(cat .../modalias) */\n\t&dev_attr_modalias.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(i2c_dev);\n\nstruct bus_type i2c_bus_type = {\n\t.name\t\t= \"i2c\",\n\t.match\t\t= i2c_device_match,\n\t.probe\t\t= i2c_device_probe,\n\t.remove\t\t= i2c_device_remove,\n\t.shutdown\t= i2c_device_shutdown,\n};\nEXPORT_SYMBOL_GPL(i2c_bus_type);\n\nstruct device_type i2c_client_type = {\n\t.groups\t\t= i2c_dev_groups,\n\t.uevent\t\t= i2c_device_uevent,\n\t.release\t= i2c_client_dev_release,\n};\nEXPORT_SYMBOL_GPL(i2c_client_type);\n\n\n/**\n * i2c_verify_client - return parameter as i2c_client, or NULL\n * @dev: device, probably from some driver model iterator\n *\n * When traversing the driver model tree, perhaps using driver model\n * iterators like @device_for_each_child(), you can't assume very much\n * about the nodes you find.  Use this function to avoid oopses caused\n * by wrongly treating some non-I2C device as an i2c_client.\n */\nstruct i2c_client *i2c_verify_client(struct device *dev)\n{\n\treturn (dev->type == &i2c_client_type)\n\t\t\t? to_i2c_client(dev)\n\t\t\t: NULL;\n}\nEXPORT_SYMBOL(i2c_verify_client);\n\n\n/* Return a unique address which takes the flags of the client into account */\nstatic unsigned short i2c_encode_flags_to_addr(struct i2c_client *client)\n{\n\tunsigned short addr = client->addr;\n\n\t/* For some client flags, add an arbitrary offset to avoid collisions */\n\tif (client->flags & I2C_CLIENT_TEN)\n\t\taddr |= I2C_ADDR_OFFSET_TEN_BIT;\n\n\tif (client->flags & I2C_CLIENT_SLAVE)\n\t\taddr |= I2C_ADDR_OFFSET_SLAVE;\n\n\treturn addr;\n}\n\n/* This is a permissive address validity check, I2C address map constraints\n * are purposely not enforced, except for the general call address. */\nstatic int i2c_check_addr_validity(unsigned int addr, unsigned short flags)\n{\n\tif (flags & I2C_CLIENT_TEN) {\n\t\t/* 10-bit address, all values are valid */\n\t\tif (addr > 0x3ff)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t/* 7-bit address, reject the general call address */\n\t\tif (addr == 0x00 || addr > 0x7f)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n/* And this is a strict address validity check, used when probing. If a\n * device uses a reserved address, then it shouldn't be probed. 7-bit\n * addressing is assumed, 10-bit address devices are rare and should be\n * explicitly enumerated. */\nint i2c_check_7bit_addr_validity_strict(unsigned short addr)\n{\n\t/*\n\t * Reserved addresses per I2C specification:\n\t *  0x00       General call address / START byte\n\t *  0x01       CBUS address\n\t *  0x02       Reserved for different bus format\n\t *  0x03       Reserved for future purposes\n\t *  0x04-0x07  Hs-mode master code\n\t *  0x78-0x7b  10-bit slave addressing\n\t *  0x7c-0x7f  Reserved for future purposes\n\t */\n\tif (addr < 0x08 || addr > 0x77)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int __i2c_check_addr_busy(struct device *dev, void *addrp)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tint\t\t\taddr = *(int *)addrp;\n\n\tif (client && i2c_encode_flags_to_addr(client) == addr)\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n/* walk up mux tree */\nstatic int i2c_check_mux_parents(struct i2c_adapter *adapter, int addr)\n{\n\tstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\n\tint result;\n\n\tresult = device_for_each_child(&adapter->dev, &addr,\n\t\t\t\t\t__i2c_check_addr_busy);\n\n\tif (!result && parent)\n\t\tresult = i2c_check_mux_parents(parent, addr);\n\n\treturn result;\n}\n\n/* recurse down mux tree */\nstatic int i2c_check_mux_children(struct device *dev, void *addrp)\n{\n\tint result;\n\n\tif (dev->type == &i2c_adapter_type)\n\t\tresult = device_for_each_child(dev, addrp,\n\t\t\t\t\t\ti2c_check_mux_children);\n\telse\n\t\tresult = __i2c_check_addr_busy(dev, addrp);\n\n\treturn result;\n}\n\nstatic int i2c_check_addr_busy(struct i2c_adapter *adapter, int addr)\n{\n\tstruct i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);\n\tint result = 0;\n\n\tif (parent)\n\t\tresult = i2c_check_mux_parents(parent, addr);\n\n\tif (!result)\n\t\tresult = device_for_each_child(&adapter->dev, &addr,\n\t\t\t\t\t\ti2c_check_mux_children);\n\n\treturn result;\n}\n\n/**\n * i2c_adapter_lock_bus - Get exclusive access to an I2C bus segment\n * @adapter: Target I2C bus segment\n * @flags: I2C_LOCK_ROOT_ADAPTER locks the root i2c adapter, I2C_LOCK_SEGMENT\n *\tlocks only this branch in the adapter tree\n */\nstatic void i2c_adapter_lock_bus(struct i2c_adapter *adapter,\n\t\t\t\t unsigned int flags)\n{\n\trt_mutex_lock_nested(&adapter->bus_lock, i2c_adapter_depth(adapter));\n}\n\n/**\n * i2c_adapter_trylock_bus - Try to get exclusive access to an I2C bus segment\n * @adapter: Target I2C bus segment\n * @flags: I2C_LOCK_ROOT_ADAPTER trylocks the root i2c adapter, I2C_LOCK_SEGMENT\n *\ttrylocks only this branch in the adapter tree\n */\nstatic int i2c_adapter_trylock_bus(struct i2c_adapter *adapter,\n\t\t\t\t   unsigned int flags)\n{\n\treturn rt_mutex_trylock(&adapter->bus_lock);\n}\n\n/**\n * i2c_adapter_unlock_bus - Release exclusive access to an I2C bus segment\n * @adapter: Target I2C bus segment\n * @flags: I2C_LOCK_ROOT_ADAPTER unlocks the root i2c adapter, I2C_LOCK_SEGMENT\n *\tunlocks only this branch in the adapter tree\n */\nstatic void i2c_adapter_unlock_bus(struct i2c_adapter *adapter,\n\t\t\t\t   unsigned int flags)\n{\n\trt_mutex_unlock(&adapter->bus_lock);\n}\n\nstatic void i2c_dev_set_name(struct i2c_adapter *adap,\n\t\t\t     struct i2c_client *client,\n\t\t\t     struct i2c_board_info const *info)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&client->dev);\n\n\tif (info && info->dev_name) {\n\t\tdev_set_name(&client->dev, \"i2c-%s\", info->dev_name);\n\t\treturn;\n\t}\n\n\tif (adev) {\n\t\tdev_set_name(&client->dev, \"i2c-%s\", acpi_dev_name(adev));\n\t\treturn;\n\t}\n\n\tdev_set_name(&client->dev, \"%d-%04x\", i2c_adapter_id(adap),\n\t\t     i2c_encode_flags_to_addr(client));\n}\n\nint i2c_dev_irq_from_resources(const struct resource *resources,\n\t\t\t       unsigned int num_resources)\n{\n\tstruct irq_data *irqd;\n\tint i;\n\n\tfor (i = 0; i < num_resources; i++) {\n\t\tconst struct resource *r = &resources[i];\n\n\t\tif (resource_type(r) != IORESOURCE_IRQ)\n\t\t\tcontinue;\n\n\t\tif (r->flags & IORESOURCE_BITS) {\n\t\t\tirqd = irq_get_irq_data(r->start);\n\t\t\tif (!irqd)\n\t\t\t\tbreak;\n\n\t\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t\t}\n\n\t\treturn r->start;\n\t}\n\n\treturn 0;\n}\n\n/**\n * i2c_new_client_device - instantiate an i2c device\n * @adap: the adapter managing the device\n * @info: describes one I2C device; bus_num is ignored\n * Context: can sleep\n *\n * Create an i2c device. Binding is handled through driver model\n * probe()/remove() methods.  A driver may be bound to this device when we\n * return from this function, or any later moment (e.g. maybe hotplugging will\n * load the driver module).  This call is not appropriate for use by mainboard\n * initialization logic, which usually runs during an arch_initcall() long\n * before any i2c_adapter could exist.\n *\n * This returns the new i2c client, which may be saved for later use with\n * i2c_unregister_device(); or an ERR_PTR to describe the error.\n */\nstruct i2c_client *\ni2c_new_client_device(struct i2c_adapter *adap, struct i2c_board_info const *info)\n{\n\tstruct i2c_client\t*client;\n\tint\t\t\tstatus;\n\n\tclient = kzalloc(sizeof *client, GFP_KERNEL);\n\tif (!client)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclient->adapter = adap;\n\n\tclient->dev.platform_data = info->platform_data;\n\tclient->flags = info->flags;\n\tclient->addr = info->addr;\n\n\tclient->init_irq = info->irq;\n\tif (!client->init_irq)\n\t\tclient->init_irq = i2c_dev_irq_from_resources(info->resources,\n\t\t\t\t\t\t\t info->num_resources);\n\n\tstrlcpy(client->name, info->type, sizeof(client->name));\n\n\tstatus = i2c_check_addr_validity(client->addr, client->flags);\n\tif (status) {\n\t\tdev_err(&adap->dev, \"Invalid %d-bit I2C address 0x%02hx\\n\",\n\t\t\tclient->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);\n\t\tgoto out_err_silent;\n\t}\n\n\t/* Check for address business */\n\tstatus = i2c_check_addr_busy(adap, i2c_encode_flags_to_addr(client));\n\tif (status)\n\t\tgoto out_err;\n\n\tclient->dev.parent = &client->adapter->dev;\n\tclient->dev.bus = &i2c_bus_type;\n\tclient->dev.type = &i2c_client_type;\n\tclient->dev.of_node = of_node_get(info->of_node);\n\tclient->dev.fwnode = info->fwnode;\n\n\ti2c_dev_set_name(adap, client, info);\n\n\tif (info->properties) {\n\t\tstatus = device_add_properties(&client->dev, info->properties);\n\t\tif (status) {\n\t\t\tdev_err(&adap->dev,\n\t\t\t\t\"Failed to add properties to client %s: %d\\n\",\n\t\t\t\tclient->name, status);\n\t\t\tgoto out_err_put_of_node;\n\t\t}\n\t}\n\n\tstatus = device_register(&client->dev);\n\tif (status)\n\t\tgoto out_free_props;\n\n\tdev_dbg(&adap->dev, \"client [%s] registered with bus id %s\\n\",\n\t\tclient->name, dev_name(&client->dev));\n\n\treturn client;\n\nout_free_props:\n\tif (info->properties)\n\t\tdevice_remove_properties(&client->dev);\nout_err_put_of_node:\n\tof_node_put(info->of_node);\nout_err:\n\tdev_err(&adap->dev,\n\t\t\"Failed to register i2c client %s at 0x%02x (%d)\\n\",\n\t\tclient->name, client->addr, status);\nout_err_silent:\n\tkfree(client);\n\treturn ERR_PTR(status);\n}\nEXPORT_SYMBOL_GPL(i2c_new_client_device);\n\n/**\n * i2c_unregister_device - reverse effect of i2c_new_*_device()\n * @client: value returned from i2c_new_*_device()\n * Context: can sleep\n */\nvoid i2c_unregister_device(struct i2c_client *client)\n{\n\tif (IS_ERR_OR_NULL(client))\n\t\treturn;\n\n\tif (client->dev.of_node) {\n\t\tof_node_clear_flag(client->dev.of_node, OF_POPULATED);\n\t\tof_node_put(client->dev.of_node);\n\t}\n\n\tif (ACPI_COMPANION(&client->dev))\n\t\tacpi_device_clear_enumerated(ACPI_COMPANION(&client->dev));\n\tdevice_unregister(&client->dev);\n}\nEXPORT_SYMBOL_GPL(i2c_unregister_device);\n\n\nstatic const struct i2c_device_id dummy_id[] = {\n\t{ \"dummy\", 0 },\n\t{ },\n};\n\nstatic int dummy_probe(struct i2c_client *client,\n\t\t       const struct i2c_device_id *id)\n{\n\treturn 0;\n}\n\nstatic int dummy_remove(struct i2c_client *client)\n{\n\treturn 0;\n}\n\nstatic struct i2c_driver dummy_driver = {\n\t.driver.name\t= \"dummy\",\n\t.probe\t\t= dummy_probe,\n\t.remove\t\t= dummy_remove,\n\t.id_table\t= dummy_id,\n};\n\n/**\n * i2c_new_dummy_device - return a new i2c device bound to a dummy driver\n * @adapter: the adapter managing the device\n * @address: seven bit address to be used\n * Context: can sleep\n *\n * This returns an I2C client bound to the \"dummy\" driver, intended for use\n * with devices that consume multiple addresses.  Examples of such chips\n * include various EEPROMS (like 24c04 and 24c08 models).\n *\n * These dummy devices have two main uses.  First, most I2C and SMBus calls\n * except i2c_transfer() need a client handle; the dummy will be that handle.\n * And second, this prevents the specified address from being bound to a\n * different driver.\n *\n * This returns the new i2c client, which should be saved for later use with\n * i2c_unregister_device(); or an ERR_PTR to describe the error.\n */\nstruct i2c_client *i2c_new_dummy_device(struct i2c_adapter *adapter, u16 address)\n{\n\tstruct i2c_board_info info = {\n\t\tI2C_BOARD_INFO(\"dummy\", address),\n\t};\n\n\treturn i2c_new_client_device(adapter, &info);\n}\nEXPORT_SYMBOL_GPL(i2c_new_dummy_device);\n\nstruct i2c_dummy_devres {\n\tstruct i2c_client *client;\n};\n\nstatic void devm_i2c_release_dummy(struct device *dev, void *res)\n{\n\tstruct i2c_dummy_devres *this = res;\n\n\ti2c_unregister_device(this->client);\n}\n\n/**\n * devm_i2c_new_dummy_device - return a new i2c device bound to a dummy driver\n * @dev: device the managed resource is bound to\n * @adapter: the adapter managing the device\n * @address: seven bit address to be used\n * Context: can sleep\n *\n * This is the device-managed version of @i2c_new_dummy_device. It returns the\n * new i2c client or an ERR_PTR in case of an error.\n */\nstruct i2c_client *devm_i2c_new_dummy_device(struct device *dev,\n\t\t\t\t\t     struct i2c_adapter *adapter,\n\t\t\t\t\t     u16 address)\n{\n\tstruct i2c_dummy_devres *dr;\n\tstruct i2c_client *client;\n\n\tdr = devres_alloc(devm_i2c_release_dummy, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclient = i2c_new_dummy_device(adapter, address);\n\tif (IS_ERR(client)) {\n\t\tdevres_free(dr);\n\t} else {\n\t\tdr->client = client;\n\t\tdevres_add(dev, dr);\n\t}\n\n\treturn client;\n}\nEXPORT_SYMBOL_GPL(devm_i2c_new_dummy_device);\n\n/**\n * i2c_new_ancillary_device - Helper to get the instantiated secondary address\n * and create the associated device\n * @client: Handle to the primary client\n * @name: Handle to specify which secondary address to get\n * @default_addr: Used as a fallback if no secondary address was specified\n * Context: can sleep\n *\n * I2C clients can be composed of multiple I2C slaves bound together in a single\n * component. The I2C client driver then binds to the master I2C slave and needs\n * to create I2C dummy clients to communicate with all the other slaves.\n *\n * This function creates and returns an I2C dummy client whose I2C address is\n * retrieved from the platform firmware based on the given slave name. If no\n * address is specified by the firmware default_addr is used.\n *\n * On DT-based platforms the address is retrieved from the \"reg\" property entry\n * cell whose \"reg-names\" value matches the slave name.\n *\n * This returns the new i2c client, which should be saved for later use with\n * i2c_unregister_device(); or an ERR_PTR to describe the error.\n */\nstruct i2c_client *i2c_new_ancillary_device(struct i2c_client *client,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tu16 default_addr)\n{\n\tstruct device_node *np = client->dev.of_node;\n\tu32 addr = default_addr;\n\tint i;\n\n\tif (np) {\n\t\ti = of_property_match_string(np, \"reg-names\", name);\n\t\tif (i >= 0)\n\t\t\tof_property_read_u32_index(np, \"reg\", i, &addr);\n\t}\n\n\tdev_dbg(&client->adapter->dev, \"Address for %s : 0x%x\\n\", name, addr);\n\treturn i2c_new_dummy_device(client->adapter, addr);\n}\nEXPORT_SYMBOL_GPL(i2c_new_ancillary_device);\n\n/* ------------------------------------------------------------------------- */\n\n/* I2C bus adapters -- one roots each I2C or SMBUS segment */\n\nstatic void i2c_adapter_dev_release(struct device *dev)\n{\n\tstruct i2c_adapter *adap = to_i2c_adapter(dev);\n\tcomplete(&adap->dev_released);\n}\n\nunsigned int i2c_adapter_depth(struct i2c_adapter *adapter)\n{\n\tunsigned int depth = 0;\n\n\twhile ((adapter = i2c_parent_is_i2c_adapter(adapter)))\n\t\tdepth++;\n\n\tWARN_ONCE(depth >= MAX_LOCKDEP_SUBCLASSES,\n\t\t  \"adapter depth exceeds lockdep subclass limit\\n\");\n\n\treturn depth;\n}\nEXPORT_SYMBOL_GPL(i2c_adapter_depth);\n\n/*\n * Let users instantiate I2C devices through sysfs. This can be used when\n * platform initialization code doesn't contain the proper data for\n * whatever reason. Also useful for drivers that do device detection and\n * detection fails, either because the device uses an unexpected address,\n * or this is a compatible device with different ID register values.\n *\n * Parameter checking may look overzealous, but we really don't want\n * the user to provide incorrect parameters.\n */\nstatic ssize_t\nnew_device_store(struct device *dev, struct device_attribute *attr,\n\t\t const char *buf, size_t count)\n{\n\tstruct i2c_adapter *adap = to_i2c_adapter(dev);\n\tstruct i2c_board_info info;\n\tstruct i2c_client *client;\n\tchar *blank, end;\n\tint res;\n\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\n\tblank = strchr(buf, ' ');\n\tif (!blank) {\n\t\tdev_err(dev, \"%s: Missing parameters\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (blank - buf > I2C_NAME_SIZE - 1) {\n\t\tdev_err(dev, \"%s: Invalid device name\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(info.type, buf, blank - buf);\n\n\t/* Parse remaining parameters, reject extra parameters */\n\tres = sscanf(++blank, \"%hi%c\", &info.addr, &end);\n\tif (res < 1) {\n\t\tdev_err(dev, \"%s: Can't parse I2C address\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (res > 1  && end != '\\n') {\n\t\tdev_err(dev, \"%s: Extra parameters\\n\", \"new_device\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((info.addr & I2C_ADDR_OFFSET_TEN_BIT) == I2C_ADDR_OFFSET_TEN_BIT) {\n\t\tinfo.addr &= ~I2C_ADDR_OFFSET_TEN_BIT;\n\t\tinfo.flags |= I2C_CLIENT_TEN;\n\t}\n\n\tif (info.addr & I2C_ADDR_OFFSET_SLAVE) {\n\t\tinfo.addr &= ~I2C_ADDR_OFFSET_SLAVE;\n\t\tinfo.flags |= I2C_CLIENT_SLAVE;\n\t}\n\n\tclient = i2c_new_client_device(adap, &info);\n\tif (IS_ERR(client))\n\t\treturn PTR_ERR(client);\n\n\t/* Keep track of the added device */\n\tmutex_lock(&adap->userspace_clients_lock);\n\tlist_add_tail(&client->detected, &adap->userspace_clients);\n\tmutex_unlock(&adap->userspace_clients_lock);\n\tdev_info(dev, \"%s: Instantiated device %s at 0x%02hx\\n\", \"new_device\",\n\t\t info.type, info.addr);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(new_device);\n\n/*\n * And of course let the users delete the devices they instantiated, if\n * they got it wrong. This interface can only be used to delete devices\n * instantiated by i2c_sysfs_new_device above. This guarantees that we\n * don't delete devices to which some kernel code still has references.\n *\n * Parameter checking may look overzealous, but we really don't want\n * the user to delete the wrong device.\n */\nstatic ssize_t\ndelete_device_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t count)\n{\n\tstruct i2c_adapter *adap = to_i2c_adapter(dev);\n\tstruct i2c_client *client, *next;\n\tunsigned short addr;\n\tchar end;\n\tint res;\n\n\t/* Parse parameters, reject extra parameters */\n\tres = sscanf(buf, \"%hi%c\", &addr, &end);\n\tif (res < 1) {\n\t\tdev_err(dev, \"%s: Can't parse I2C address\\n\", \"delete_device\");\n\t\treturn -EINVAL;\n\t}\n\tif (res > 1  && end != '\\n') {\n\t\tdev_err(dev, \"%s: Extra parameters\\n\", \"delete_device\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* Make sure the device was added through sysfs */\n\tres = -ENOENT;\n\tmutex_lock_nested(&adap->userspace_clients_lock,\n\t\t\t  i2c_adapter_depth(adap));\n\tlist_for_each_entry_safe(client, next, &adap->userspace_clients,\n\t\t\t\t detected) {\n\t\tif (i2c_encode_flags_to_addr(client) == addr) {\n\t\t\tdev_info(dev, \"%s: Deleting device %s at 0x%02hx\\n\",\n\t\t\t\t \"delete_device\", client->name, client->addr);\n\n\t\t\tlist_del(&client->detected);\n\t\t\ti2c_unregister_device(client);\n\t\t\tres = count;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&adap->userspace_clients_lock);\n\n\tif (res < 0)\n\t\tdev_err(dev, \"%s: Can't find device in list\\n\",\n\t\t\t\"delete_device\");\n\treturn res;\n}\nstatic DEVICE_ATTR_IGNORE_LOCKDEP(delete_device, S_IWUSR, NULL,\n\t\t\t\t  delete_device_store);\n\nstatic struct attribute *i2c_adapter_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_new_device.attr,\n\t&dev_attr_delete_device.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(i2c_adapter);\n\nstruct device_type i2c_adapter_type = {\n\t.groups\t\t= i2c_adapter_groups,\n\t.release\t= i2c_adapter_dev_release,\n};\nEXPORT_SYMBOL_GPL(i2c_adapter_type);\n\n/**\n * i2c_verify_adapter - return parameter as i2c_adapter or NULL\n * @dev: device, probably from some driver model iterator\n *\n * When traversing the driver model tree, perhaps using driver model\n * iterators like @device_for_each_child(), you can't assume very much\n * about the nodes you find.  Use this function to avoid oopses caused\n * by wrongly treating some non-I2C device as an i2c_adapter.\n */\nstruct i2c_adapter *i2c_verify_adapter(struct device *dev)\n{\n\treturn (dev->type == &i2c_adapter_type)\n\t\t\t? to_i2c_adapter(dev)\n\t\t\t: NULL;\n}\nEXPORT_SYMBOL(i2c_verify_adapter);\n\n#ifdef CONFIG_I2C_COMPAT\nstatic struct class_compat *i2c_adapter_compat_class;\n#endif\n\nstatic void i2c_scan_static_board_info(struct i2c_adapter *adapter)\n{\n\tstruct i2c_devinfo\t*devinfo;\n\n\tdown_read(&__i2c_board_lock);\n\tlist_for_each_entry(devinfo, &__i2c_board_list, list) {\n\t\tif (devinfo->busnum == adapter->nr &&\n\t\t    IS_ERR(i2c_new_client_device(adapter, &devinfo->board_info)))\n\t\t\tdev_err(&adapter->dev,\n\t\t\t\t\"Can't create device at 0x%02x\\n\",\n\t\t\t\tdevinfo->board_info.addr);\n\t}\n\tup_read(&__i2c_board_lock);\n}\n\nstatic int i2c_do_add_adapter(struct i2c_driver *driver,\n\t\t\t      struct i2c_adapter *adap)\n{\n\t/* Detect supported devices on that bus, and instantiate them */\n\ti2c_detect(adap, driver);\n\n\treturn 0;\n}\n\nstatic int __process_new_adapter(struct device_driver *d, void *data)\n{\n\treturn i2c_do_add_adapter(to_i2c_driver(d), data);\n}\n\nstatic const struct i2c_lock_operations i2c_adapter_lock_ops = {\n\t.lock_bus =    i2c_adapter_lock_bus,\n\t.trylock_bus = i2c_adapter_trylock_bus,\n\t.unlock_bus =  i2c_adapter_unlock_bus,\n};\n\nstatic void i2c_host_notify_irq_teardown(struct i2c_adapter *adap)\n{\n\tstruct irq_domain *domain = adap->host_notify_domain;\n\tirq_hw_number_t hwirq;\n\n\tif (!domain)\n\t\treturn;\n\n\tfor (hwirq = 0 ; hwirq < I2C_ADDR_7BITS_COUNT ; hwirq++)\n\t\tirq_dispose_mapping(irq_find_mapping(domain, hwirq));\n\n\tirq_domain_remove(domain);\n\tadap->host_notify_domain = NULL;\n}\n\nstatic int i2c_host_notify_irq_map(struct irq_domain *h,\n\t\t\t\t\t  unsigned int virq,\n\t\t\t\t\t  irq_hw_number_t hw_irq_num)\n{\n\tirq_set_chip_and_handler(virq, &dummy_irq_chip, handle_simple_irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops i2c_host_notify_irq_ops = {\n\t.map = i2c_host_notify_irq_map,\n};\n\nstatic int i2c_setup_host_notify_irq_domain(struct i2c_adapter *adap)\n{\n\tstruct irq_domain *domain;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_HOST_NOTIFY))\n\t\treturn 0;\n\n\tdomain = irq_domain_create_linear(adap->dev.parent->fwnode,\n\t\t\t\t\t  I2C_ADDR_7BITS_COUNT,\n\t\t\t\t\t  &i2c_host_notify_irq_ops, adap);\n\tif (!domain)\n\t\treturn -ENOMEM;\n\n\tadap->host_notify_domain = domain;\n\n\treturn 0;\n}\n\n/**\n * i2c_handle_smbus_host_notify - Forward a Host Notify event to the correct\n * I2C client.\n * @adap: the adapter\n * @addr: the I2C address of the notifying device\n * Context: can't sleep\n *\n * Helper function to be called from an I2C bus driver's interrupt\n * handler. It will schedule the Host Notify IRQ.\n */\nint i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr)\n{\n\tint irq;\n\n\tif (!adap)\n\t\treturn -EINVAL;\n\n\tirq = irq_find_mapping(adap->host_notify_domain, addr);\n\tif (irq <= 0)\n\t\treturn -ENXIO;\n\n\tgeneric_handle_irq(irq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i2c_handle_smbus_host_notify);\n\nstatic int i2c_register_adapter(struct i2c_adapter *adap)\n{\n\tint res = -EINVAL;\n\n\t/* Can't register until after driver model init */\n\tif (WARN_ON(!is_registered)) {\n\t\tres = -EAGAIN;\n\t\tgoto out_list;\n\t}\n\n\t/* Sanity checks */\n\tif (WARN(!adap->name[0], \"i2c adapter has no name\"))\n\t\tgoto out_list;\n\n\tif (!adap->algo) {\n\t\tpr_err(\"adapter '%s': no algo supplied!\\n\", adap->name);\n\t\tgoto out_list;\n\t}\n\n\tif (!adap->lock_ops)\n\t\tadap->lock_ops = &i2c_adapter_lock_ops;\n\n\tadap->locked_flags = 0;\n\trt_mutex_init(&adap->bus_lock);\n\trt_mutex_init(&adap->mux_lock);\n\tmutex_init(&adap->userspace_clients_lock);\n\tINIT_LIST_HEAD(&adap->userspace_clients);\n\n\t/* Set default timeout to 1 second if not already set */\n\tif (adap->timeout == 0)\n\t\tadap->timeout = HZ;\n\n\t/* register soft irqs for Host Notify */\n\tres = i2c_setup_host_notify_irq_domain(adap);\n\tif (res) {\n\t\tpr_err(\"adapter '%s': can't create Host Notify IRQs (%d)\\n\",\n\t\t       adap->name, res);\n\t\tgoto out_list;\n\t}\n\n\tdev_set_name(&adap->dev, \"i2c-%d\", adap->nr);\n\tadap->dev.bus = &i2c_bus_type;\n\tadap->dev.type = &i2c_adapter_type;\n\tres = device_register(&adap->dev);\n\tif (res) {\n\t\tpr_err(\"adapter '%s': can't register device (%d)\\n\", adap->name, res);\n\t\tgoto out_list;\n\t}\n\n\tres = of_i2c_setup_smbus_alert(adap);\n\tif (res)\n\t\tgoto out_reg;\n\n\tpm_runtime_no_callbacks(&adap->dev);\n\tpm_suspend_ignore_children(&adap->dev, true);\n\tpm_runtime_enable(&adap->dev);\n\n\tres = i2c_init_recovery(adap);\n\tif (res == -EPROBE_DEFER)\n\t\tgoto out_reg;\n\n\tdev_dbg(&adap->dev, \"adapter [%s] registered\\n\", adap->name);\n\n#ifdef CONFIG_I2C_COMPAT\n\tres = class_compat_create_link(i2c_adapter_compat_class, &adap->dev,\n\t\t\t\t       adap->dev.parent);\n\tif (res)\n\t\tdev_warn(&adap->dev,\n\t\t\t \"Failed to create compatibility class link\\n\");\n#endif\n\n\t/* create pre-declared device nodes */\n\tof_i2c_register_devices(adap);\n\ti2c_acpi_install_space_handler(adap);\n\ti2c_acpi_register_devices(adap);\n\n\tif (adap->nr < __i2c_first_dynamic_bus_num)\n\t\ti2c_scan_static_board_info(adap);\n\n\t/* Notify drivers */\n\tmutex_lock(&core_lock);\n\tbus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);\n\tmutex_unlock(&core_lock);\n\n\treturn 0;\n\nout_reg:\n\tinit_completion(&adap->dev_released);\n\tdevice_unregister(&adap->dev);\n\twait_for_completion(&adap->dev_released);\nout_list:\n\tmutex_lock(&core_lock);\n\tidr_remove(&i2c_adapter_idr, adap->nr);\n\tmutex_unlock(&core_lock);\n\treturn res;\n}\n\n/**\n * __i2c_add_numbered_adapter - i2c_add_numbered_adapter where nr is never -1\n * @adap: the adapter to register (with adap->nr initialized)\n * Context: can sleep\n *\n * See i2c_add_numbered_adapter() for details.\n */\nstatic int __i2c_add_numbered_adapter(struct i2c_adapter *adap)\n{\n\tint id;\n\n\tmutex_lock(&core_lock);\n\tid = idr_alloc(&i2c_adapter_idr, adap, adap->nr, adap->nr + 1, GFP_KERNEL);\n\tmutex_unlock(&core_lock);\n\tif (WARN(id < 0, \"couldn't get idr\"))\n\t\treturn id == -ENOSPC ? -EBUSY : id;\n\n\treturn i2c_register_adapter(adap);\n}\n\n/**\n * i2c_add_adapter - declare i2c adapter, use dynamic bus number\n * @adapter: the adapter to add\n * Context: can sleep\n *\n * This routine is used to declare an I2C adapter when its bus number\n * doesn't matter or when its bus number is specified by an dt alias.\n * Examples of bases when the bus number doesn't matter: I2C adapters\n * dynamically added by USB links or PCI plugin cards.\n *\n * When this returns zero, a new bus number was allocated and stored\n * in adap->nr, and the specified adapter became available for clients.\n * Otherwise, a negative errno value is returned.\n */\nint i2c_add_adapter(struct i2c_adapter *adapter)\n{\n\tstruct device *dev = &adapter->dev;\n\tint id;\n\n\tif (dev->of_node) {\n\t\tid = of_alias_get_id(dev->of_node, \"i2c\");\n\t\tif (id >= 0) {\n\t\t\tadapter->nr = id;\n\t\t\treturn __i2c_add_numbered_adapter(adapter);\n\t\t}\n\t}\n\n\tmutex_lock(&core_lock);\n\tid = idr_alloc(&i2c_adapter_idr, adapter,\n\t\t       __i2c_first_dynamic_bus_num, 0, GFP_KERNEL);\n\tmutex_unlock(&core_lock);\n\tif (WARN(id < 0, \"couldn't get idr\"))\n\t\treturn id;\n\n\tadapter->nr = id;\n\n\treturn i2c_register_adapter(adapter);\n}\nEXPORT_SYMBOL(i2c_add_adapter);\n\n/**\n * i2c_add_numbered_adapter - declare i2c adapter, use static bus number\n * @adap: the adapter to register (with adap->nr initialized)\n * Context: can sleep\n *\n * This routine is used to declare an I2C adapter when its bus number\n * matters.  For example, use it for I2C adapters from system-on-chip CPUs,\n * or otherwise built in to the system's mainboard, and where i2c_board_info\n * is used to properly configure I2C devices.\n *\n * If the requested bus number is set to -1, then this function will behave\n * identically to i2c_add_adapter, and will dynamically assign a bus number.\n *\n * If no devices have pre-been declared for this bus, then be sure to\n * register the adapter before any dynamically allocated ones.  Otherwise\n * the required bus ID may not be available.\n *\n * When this returns zero, the specified adapter became available for\n * clients using the bus number provided in adap->nr.  Also, the table\n * of I2C devices pre-declared using i2c_register_board_info() is scanned,\n * and the appropriate driver model device nodes are created.  Otherwise, a\n * negative errno value is returned.\n */\nint i2c_add_numbered_adapter(struct i2c_adapter *adap)\n{\n\tif (adap->nr == -1) /* -1 means dynamically assign bus id */\n\t\treturn i2c_add_adapter(adap);\n\n\treturn __i2c_add_numbered_adapter(adap);\n}\nEXPORT_SYMBOL_GPL(i2c_add_numbered_adapter);\n\nstatic void i2c_do_del_adapter(struct i2c_driver *driver,\n\t\t\t      struct i2c_adapter *adapter)\n{\n\tstruct i2c_client *client, *_n;\n\n\t/* Remove the devices we created ourselves as the result of hardware\n\t * probing (using a driver's detect method) */\n\tlist_for_each_entry_safe(client, _n, &driver->clients, detected) {\n\t\tif (client->adapter == adapter) {\n\t\t\tdev_dbg(&adapter->dev, \"Removing %s at 0x%x\\n\",\n\t\t\t\tclient->name, client->addr);\n\t\t\tlist_del(&client->detected);\n\t\t\ti2c_unregister_device(client);\n\t\t}\n\t}\n}\n\nstatic int __unregister_client(struct device *dev, void *dummy)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\tif (client && strcmp(client->name, \"dummy\"))\n\t\ti2c_unregister_device(client);\n\treturn 0;\n}\n\nstatic int __unregister_dummy(struct device *dev, void *dummy)\n{\n\tstruct i2c_client *client = i2c_verify_client(dev);\n\ti2c_unregister_device(client);\n\treturn 0;\n}\n\nstatic int __process_removed_adapter(struct device_driver *d, void *data)\n{\n\ti2c_do_del_adapter(to_i2c_driver(d), data);\n\treturn 0;\n}\n\n/**\n * i2c_del_adapter - unregister I2C adapter\n * @adap: the adapter being unregistered\n * Context: can sleep\n *\n * This unregisters an I2C adapter which was previously registered\n * by @i2c_add_adapter or @i2c_add_numbered_adapter.\n */\nvoid i2c_del_adapter(struct i2c_adapter *adap)\n{\n\tstruct i2c_adapter *found;\n\tstruct i2c_client *client, *next;\n\n\t/* First make sure that this adapter was ever added */\n\tmutex_lock(&core_lock);\n\tfound = idr_find(&i2c_adapter_idr, adap->nr);\n\tmutex_unlock(&core_lock);\n\tif (found != adap) {\n\t\tpr_debug(\"attempting to delete unregistered adapter [%s]\\n\", adap->name);\n\t\treturn;\n\t}\n\n\ti2c_acpi_remove_space_handler(adap);\n\t/* Tell drivers about this removal */\n\tmutex_lock(&core_lock);\n\tbus_for_each_drv(&i2c_bus_type, NULL, adap,\n\t\t\t       __process_removed_adapter);\n\tmutex_unlock(&core_lock);\n\n\t/* Remove devices instantiated from sysfs */\n\tmutex_lock_nested(&adap->userspace_clients_lock,\n\t\t\t  i2c_adapter_depth(adap));\n\tlist_for_each_entry_safe(client, next, &adap->userspace_clients,\n\t\t\t\t detected) {\n\t\tdev_dbg(&adap->dev, \"Removing %s at 0x%x\\n\", client->name,\n\t\t\tclient->addr);\n\t\tlist_del(&client->detected);\n\t\ti2c_unregister_device(client);\n\t}\n\tmutex_unlock(&adap->userspace_clients_lock);\n\n\t/* Detach any active clients. This can't fail, thus we do not\n\t * check the returned value. This is a two-pass process, because\n\t * we can't remove the dummy devices during the first pass: they\n\t * could have been instantiated by real devices wishing to clean\n\t * them up properly, so we give them a chance to do that first. */\n\tdevice_for_each_child(&adap->dev, NULL, __unregister_client);\n\tdevice_for_each_child(&adap->dev, NULL, __unregister_dummy);\n\n#ifdef CONFIG_I2C_COMPAT\n\tclass_compat_remove_link(i2c_adapter_compat_class, &adap->dev,\n\t\t\t\t adap->dev.parent);\n#endif\n\n\t/* device name is gone after device_unregister */\n\tdev_dbg(&adap->dev, \"adapter [%s] unregistered\\n\", adap->name);\n\n\tpm_runtime_disable(&adap->dev);\n\n\ti2c_host_notify_irq_teardown(adap);\n\n\t/* wait until all references to the device are gone\n\t *\n\t * FIXME: This is old code and should ideally be replaced by an\n\t * alternative which results in decoupling the lifetime of the struct\n\t * device from the i2c_adapter, like spi or netdev do. Any solution\n\t * should be thoroughly tested with DEBUG_KOBJECT_RELEASE enabled!\n\t */\n\tinit_completion(&adap->dev_released);\n\tdevice_unregister(&adap->dev);\n\twait_for_completion(&adap->dev_released);\n\n\t/* free bus id */\n\tmutex_lock(&core_lock);\n\tidr_remove(&i2c_adapter_idr, adap->nr);\n\tmutex_unlock(&core_lock);\n\n\t/* Clear the device structure in case this adapter is ever going to be\n\t   added again */\n\tmemset(&adap->dev, 0, sizeof(adap->dev));\n}\nEXPORT_SYMBOL(i2c_del_adapter);\n\nstatic void i2c_parse_timing(struct device *dev, char *prop_name, u32 *cur_val_p,\n\t\t\t    u32 def_val, bool use_def)\n{\n\tint ret;\n\n\tret = device_property_read_u32(dev, prop_name, cur_val_p);\n\tif (ret && use_def)\n\t\t*cur_val_p = def_val;\n\n\tdev_dbg(dev, \"%s: %u\\n\", prop_name, *cur_val_p);\n}\n\n/**\n * i2c_parse_fw_timings - get I2C related timing parameters from firmware\n * @dev: The device to scan for I2C timing properties\n * @t: the i2c_timings struct to be filled with values\n * @use_defaults: bool to use sane defaults derived from the I2C specification\n *\t\t  when properties are not found, otherwise don't update\n *\n * Scan the device for the generic I2C properties describing timing parameters\n * for the signal and fill the given struct with the results. If a property was\n * not found and use_defaults was true, then maximum timings are assumed which\n * are derived from the I2C specification. If use_defaults is not used, the\n * results will be as before, so drivers can apply their own defaults before\n * calling this helper. The latter is mainly intended for avoiding regressions\n * of existing drivers which want to switch to this function. New drivers\n * almost always should use the defaults.\n */\nvoid i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_defaults)\n{\n\tbool u = use_defaults;\n\tu32 d;\n\n\ti2c_parse_timing(dev, \"clock-frequency\", &t->bus_freq_hz,\n\t\t\t I2C_MAX_STANDARD_MODE_FREQ, u);\n\n\td = t->bus_freq_hz <= I2C_MAX_STANDARD_MODE_FREQ ? 1000 :\n\t    t->bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ ? 300 : 120;\n\ti2c_parse_timing(dev, \"i2c-scl-rising-time-ns\", &t->scl_rise_ns, d, u);\n\n\td = t->bus_freq_hz <= I2C_MAX_FAST_MODE_FREQ ? 300 : 120;\n\ti2c_parse_timing(dev, \"i2c-scl-falling-time-ns\", &t->scl_fall_ns, d, u);\n\n\ti2c_parse_timing(dev, \"i2c-scl-internal-delay-ns\",\n\t\t\t &t->scl_int_delay_ns, 0, u);\n\ti2c_parse_timing(dev, \"i2c-sda-falling-time-ns\", &t->sda_fall_ns,\n\t\t\t t->scl_fall_ns, u);\n\ti2c_parse_timing(dev, \"i2c-sda-hold-time-ns\", &t->sda_hold_ns, 0, u);\n\ti2c_parse_timing(dev, \"i2c-digital-filter-width-ns\",\n\t\t\t &t->digital_filter_width_ns, 0, u);\n\ti2c_parse_timing(dev, \"i2c-analog-filter-cutoff-frequency\",\n\t\t\t &t->analog_filter_cutoff_freq_hz, 0, u);\n}\nEXPORT_SYMBOL_GPL(i2c_parse_fw_timings);\n\n/* ------------------------------------------------------------------------- */\n\nint i2c_for_each_dev(void *data, int (*fn)(struct device *dev, void *data))\n{\n\tint res;\n\n\tmutex_lock(&core_lock);\n\tres = bus_for_each_dev(&i2c_bus_type, NULL, data, fn);\n\tmutex_unlock(&core_lock);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(i2c_for_each_dev);\n\nstatic int __process_new_driver(struct device *dev, void *data)\n{\n\tif (dev->type != &i2c_adapter_type)\n\t\treturn 0;\n\treturn i2c_do_add_adapter(data, to_i2c_adapter(dev));\n}\n\n/*\n * An i2c_driver is used with one or more i2c_client (device) nodes to access\n * i2c slave chips, on a bus instance associated with some i2c_adapter.\n */\n\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver)\n{\n\tint res;\n\n\t/* Can't register until after driver model init */\n\tif (WARN_ON(!is_registered))\n\t\treturn -EAGAIN;\n\n\t/* add the driver to the list of i2c drivers in the driver core */\n\tdriver->driver.owner = owner;\n\tdriver->driver.bus = &i2c_bus_type;\n\tINIT_LIST_HEAD(&driver->clients);\n\n\t/* When registration returns, the driver core\n\t * will have called probe() for all matching-but-unbound devices.\n\t */\n\tres = driver_register(&driver->driver);\n\tif (res)\n\t\treturn res;\n\n\tpr_debug(\"driver [%s] registered\\n\", driver->driver.name);\n\n\t/* Walk the adapters that are already present */\n\ti2c_for_each_dev(driver, __process_new_driver);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(i2c_register_driver);\n\nstatic int __process_removed_driver(struct device *dev, void *data)\n{\n\tif (dev->type == &i2c_adapter_type)\n\t\ti2c_do_del_adapter(data, to_i2c_adapter(dev));\n\treturn 0;\n}\n\n/**\n * i2c_del_driver - unregister I2C driver\n * @driver: the driver being unregistered\n * Context: can sleep\n */\nvoid i2c_del_driver(struct i2c_driver *driver)\n{\n\ti2c_for_each_dev(driver, __process_removed_driver);\n\n\tdriver_unregister(&driver->driver);\n\tpr_debug(\"driver [%s] unregistered\\n\", driver->driver.name);\n}\nEXPORT_SYMBOL(i2c_del_driver);\n\n/* ------------------------------------------------------------------------- */\n\nstruct i2c_cmd_arg {\n\tunsigned\tcmd;\n\tvoid\t\t*arg;\n};\n\nstatic int i2c_cmd(struct device *dev, void *_arg)\n{\n\tstruct i2c_client\t*client = i2c_verify_client(dev);\n\tstruct i2c_cmd_arg\t*arg = _arg;\n\tstruct i2c_driver\t*driver;\n\n\tif (!client || !client->dev.driver)\n\t\treturn 0;\n\n\tdriver = to_i2c_driver(client->dev.driver);\n\tif (driver->command)\n\t\tdriver->command(client, arg->cmd, arg->arg);\n\treturn 0;\n}\n\nvoid i2c_clients_command(struct i2c_adapter *adap, unsigned int cmd, void *arg)\n{\n\tstruct i2c_cmd_arg\tcmd_arg;\n\n\tcmd_arg.cmd = cmd;\n\tcmd_arg.arg = arg;\n\tdevice_for_each_child(&adap->dev, &cmd_arg, i2c_cmd);\n}\nEXPORT_SYMBOL(i2c_clients_command);\n\nstatic int __init i2c_init(void)\n{\n\tint retval;\n\n\tretval = of_alias_get_highest_id(\"i2c\");\n\n\tdown_write(&__i2c_board_lock);\n\tif (retval >= __i2c_first_dynamic_bus_num)\n\t\t__i2c_first_dynamic_bus_num = retval + 1;\n\tup_write(&__i2c_board_lock);\n\n\tretval = bus_register(&i2c_bus_type);\n\tif (retval)\n\t\treturn retval;\n\n\tis_registered = true;\n\n#ifdef CONFIG_I2C_COMPAT\n\ti2c_adapter_compat_class = class_compat_register(\"i2c-adapter\");\n\tif (!i2c_adapter_compat_class) {\n\t\tretval = -ENOMEM;\n\t\tgoto bus_err;\n\t}\n#endif\n\tretval = i2c_add_driver(&dummy_driver);\n\tif (retval)\n\t\tgoto class_err;\n\n\tif (IS_ENABLED(CONFIG_OF_DYNAMIC))\n\t\tWARN_ON(of_reconfig_notifier_register(&i2c_of_notifier));\n\tif (IS_ENABLED(CONFIG_ACPI))\n\t\tWARN_ON(acpi_reconfig_notifier_register(&i2c_acpi_notifier));\n\n\treturn 0;\n\nclass_err:\n#ifdef CONFIG_I2C_COMPAT\n\tclass_compat_unregister(i2c_adapter_compat_class);\nbus_err:\n#endif\n\tis_registered = false;\n\tbus_unregister(&i2c_bus_type);\n\treturn retval;\n}\n\nstatic void __exit i2c_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_ACPI))\n\t\tWARN_ON(acpi_reconfig_notifier_unregister(&i2c_acpi_notifier));\n\tif (IS_ENABLED(CONFIG_OF_DYNAMIC))\n\t\tWARN_ON(of_reconfig_notifier_unregister(&i2c_of_notifier));\n\ti2c_del_driver(&dummy_driver);\n#ifdef CONFIG_I2C_COMPAT\n\tclass_compat_unregister(i2c_adapter_compat_class);\n#endif\n\tbus_unregister(&i2c_bus_type);\n\ttracepoint_synchronize_unregister();\n}\n\n/* We must initialize early, because some subsystems register i2c drivers\n * in subsys_initcall() code, but are linked (and initialized) before i2c.\n */\npostcore_initcall(i2c_init);\nmodule_exit(i2c_exit);\n\n/* ----------------------------------------------------\n * the functional interface to the i2c busses.\n * ----------------------------------------------------\n */\n\n/* Check if val is exceeding the quirk IFF quirk is non 0 */\n#define i2c_quirk_exceeded(val, quirk) ((quirk) && ((val) > (quirk)))\n\nstatic int i2c_quirk_error(struct i2c_adapter *adap, struct i2c_msg *msg, char *err_msg)\n{\n\tdev_err_ratelimited(&adap->dev, \"adapter quirk: %s (addr 0x%04x, size %u, %s)\\n\",\n\t\t\t    err_msg, msg->addr, msg->len,\n\t\t\t    msg->flags & I2C_M_RD ? \"read\" : \"write\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic int i2c_check_for_quirks(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tconst struct i2c_adapter_quirks *q = adap->quirks;\n\tint max_num = q->max_num_msgs, i;\n\tbool do_len_check = true;\n\n\tif (q->flags & I2C_AQ_COMB) {\n\t\tmax_num = 2;\n\n\t\t/* special checks for combined messages */\n\t\tif (num == 2) {\n\t\t\tif (q->flags & I2C_AQ_COMB_WRITE_FIRST && msgs[0].flags & I2C_M_RD)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[0], \"1st comb msg must be write\");\n\n\t\t\tif (q->flags & I2C_AQ_COMB_READ_SECOND && !(msgs[1].flags & I2C_M_RD))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[1], \"2nd comb msg must be read\");\n\n\t\t\tif (q->flags & I2C_AQ_COMB_SAME_ADDR && msgs[0].addr != msgs[1].addr)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[0], \"comb msg only to same addr\");\n\n\t\t\tif (i2c_quirk_exceeded(msgs[0].len, q->max_comb_1st_msg_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[0], \"msg too long\");\n\n\t\t\tif (i2c_quirk_exceeded(msgs[1].len, q->max_comb_2nd_msg_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[1], \"msg too long\");\n\n\t\t\tdo_len_check = false;\n\t\t}\n\t}\n\n\tif (i2c_quirk_exceeded(num, max_num))\n\t\treturn i2c_quirk_error(adap, &msgs[0], \"too many messages\");\n\n\tfor (i = 0; i < num; i++) {\n\t\tu16 len = msgs[i].len;\n\n\t\tif (msgs[i].flags & I2C_M_RD) {\n\t\t\tif (do_len_check && i2c_quirk_exceeded(len, q->max_read_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"msg too long\");\n\n\t\t\tif (q->flags & I2C_AQ_NO_ZERO_LEN_READ && len == 0)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"no zero length\");\n\t\t} else {\n\t\t\tif (do_len_check && i2c_quirk_exceeded(len, q->max_write_len))\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"msg too long\");\n\n\t\t\tif (q->flags & I2C_AQ_NO_ZERO_LEN_WRITE && len == 0)\n\t\t\t\treturn i2c_quirk_error(adap, &msgs[i], \"no zero length\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * __i2c_transfer - unlocked flavor of i2c_transfer\n * @adap: Handle to I2C bus\n * @msgs: One or more messages to execute before STOP is issued to\n *\tterminate the operation; each message begins with a START.\n * @num: Number of messages to be executed.\n *\n * Returns negative errno, else the number of messages executed.\n *\n * Adapter lock must be held when calling this function. No debug logging\n * takes place. adap->algo->master_xfer existence isn't checked.\n */\nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tunsigned long orig_jiffies;\n\tint ret, try;\n\n\tif (WARN_ON(!msgs || num < 1))\n\t\treturn -EINVAL;\n\n\tret = __i2c_check_suspended(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adap->quirks && i2c_check_for_quirks(adap, msgs, num))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets\n\t * enabled.  This is an efficient way of keeping the for-loop from\n\t * being executed when not needed.\n\t */\n\tif (static_branch_unlikely(&i2c_trace_msg_key)) {\n\t\tint i;\n\t\tfor (i = 0; i < num; i++)\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\ttrace_i2c_read(adap, &msgs[i], i);\n\t\t\telse\n\t\t\t\ttrace_i2c_write(adap, &msgs[i], i);\n\t}\n\n\t/* Retry automatically on arbitration loss */\n\torig_jiffies = jiffies;\n\tfor (ret = 0, try = 0; try <= adap->retries; try++) {\n\t\tif (i2c_in_atomic_xfer_mode() && adap->algo->master_xfer_atomic)\n\t\t\tret = adap->algo->master_xfer_atomic(adap, msgs, num);\n\t\telse\n\t\t\tret = adap->algo->master_xfer(adap, msgs, num);\n\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, orig_jiffies + adap->timeout))\n\t\t\tbreak;\n\t}\n\n\tif (static_branch_unlikely(&i2c_trace_msg_key)) {\n\t\tint i;\n\t\tfor (i = 0; i < ret; i++)\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\ttrace_i2c_reply(adap, &msgs[i], i);\n\t\ttrace_i2c_result(adap, num, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__i2c_transfer);\n\n/**\n * i2c_transfer - execute a single or combined I2C message\n * @adap: Handle to I2C bus\n * @msgs: One or more messages to execute before STOP is issued to\n *\tterminate the operation; each message begins with a START.\n * @num: Number of messages to be executed.\n *\n * Returns negative errno, else the number of messages executed.\n *\n * Note that there is no requirement that each message be sent to\n * the same slave address, although that is the most common model.\n */\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tint ret;\n\n\tif (!adap->algo->master_xfer) {\n\t\tdev_dbg(&adap->dev, \"I2C level transfers not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* REVISIT the fault reporting model here is weak:\n\t *\n\t *  - When we get an error after receiving N bytes from a slave,\n\t *    there is no way to report \"N\".\n\t *\n\t *  - When we get a NAK after transmitting N bytes to a slave,\n\t *    there is no way to report \"N\" ... or to let the master\n\t *    continue executing the rest of this combined message, if\n\t *    that's the appropriate response.\n\t *\n\t *  - When for example \"num\" is two and we successfully complete\n\t *    the first message but get an error part way through the\n\t *    second, it's unclear whether that should be reported as\n\t *    one (discarding status on the second message) or errno\n\t *    (discarding status on the first one).\n\t */\n\tret = __i2c_lock_bus_helper(adap);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __i2c_transfer(adap, msgs, num);\n\ti2c_unlock_bus(adap, I2C_LOCK_SEGMENT);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(i2c_transfer);\n\n/**\n * i2c_transfer_buffer_flags - issue a single I2C message transferring data\n *\t\t\t       to/from a buffer\n * @client: Handle to slave device\n * @buf: Where the data is stored\n * @count: How many bytes to transfer, must be less than 64k since msg.len is u16\n * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads\n *\n * Returns negative errno, or else the number of bytes transferred.\n */\nint i2c_transfer_buffer_flags(const struct i2c_client *client, char *buf,\n\t\t\t      int count, u16 flags)\n{\n\tint ret;\n\tstruct i2c_msg msg = {\n\t\t.addr = client->addr,\n\t\t.flags = flags | (client->flags & I2C_M_TEN),\n\t\t.len = count,\n\t\t.buf = buf,\n\t};\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\n\t/*\n\t * If everything went ok (i.e. 1 msg transferred), return #bytes\n\t * transferred, else error code.\n\t */\n\treturn (ret == 1) ? count : ret;\n}\nEXPORT_SYMBOL(i2c_transfer_buffer_flags);\n\n/**\n * i2c_get_device_id - get manufacturer, part id and die revision of a device\n * @client: The device to query\n * @id: The queried information\n *\n * Returns negative errno on error, zero on success.\n */\nint i2c_get_device_id(const struct i2c_client *client,\n\t\t      struct i2c_device_identity *id)\n{\n\tstruct i2c_adapter *adap = client->adapter;\n\tunion i2c_smbus_data raw_id;\n\tint ret;\n\n\tif (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_I2C_BLOCK))\n\t\treturn -EOPNOTSUPP;\n\n\traw_id.block[0] = 3;\n\tret = i2c_smbus_xfer(adap, I2C_ADDR_DEVICE_ID, 0,\n\t\t\t     I2C_SMBUS_READ, client->addr << 1,\n\t\t\t     I2C_SMBUS_I2C_BLOCK_DATA, &raw_id);\n\tif (ret)\n\t\treturn ret;\n\n\tid->manufacturer_id = (raw_id.block[1] << 4) | (raw_id.block[2] >> 4);\n\tid->part_id = ((raw_id.block[2] & 0xf) << 5) | (raw_id.block[3] >> 3);\n\tid->die_revision = raw_id.block[3] & 0x7;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i2c_get_device_id);\n\n/* ----------------------------------------------------\n * the i2c address scanning function\n * Will not work for 10-bit addresses!\n * ----------------------------------------------------\n */\n\n/*\n * Legacy default probe function, mostly relevant for SMBus. The default\n * probe method is a quick write, but it is known to corrupt the 24RF08\n * EEPROMs due to a state machine bug, and could also irreversibly\n * write-protect some EEPROMs, so for address ranges 0x30-0x37 and 0x50-0x5f,\n * we use a short byte read instead. Also, some bus drivers don't implement\n * quick write, so we fallback to a byte read in that case too.\n * On x86, there is another special case for FSC hardware monitoring chips,\n * which want regular byte reads (address 0x73.) Fortunately, these are the\n * only known chips using this I2C address on PC hardware.\n * Returns 1 if probe succeeded, 0 if not.\n */\nstatic int i2c_default_probe(struct i2c_adapter *adap, unsigned short addr)\n{\n\tint err;\n\tunion i2c_smbus_data dummy;\n\n#ifdef CONFIG_X86\n\tif (addr == 0x73 && (adap->class & I2C_CLASS_HWMON)\n\t && i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))\n\t\terr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\n\t\t\t\t     I2C_SMBUS_BYTE_DATA, &dummy);\n\telse\n#endif\n\tif (!((addr & ~0x07) == 0x30 || (addr & ~0x0f) == 0x50)\n\t && i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))\n\t\terr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_WRITE, 0,\n\t\t\t\t     I2C_SMBUS_QUICK, NULL);\n\telse if (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))\n\t\terr = i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\n\t\t\t\t     I2C_SMBUS_BYTE, &dummy);\n\telse {\n\t\tdev_warn(&adap->dev, \"No suitable probing method supported for address 0x%02X\\n\",\n\t\t\t addr);\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err >= 0;\n}\n\nstatic int i2c_detect_address(struct i2c_client *temp_client,\n\t\t\t      struct i2c_driver *driver)\n{\n\tstruct i2c_board_info info;\n\tstruct i2c_adapter *adapter = temp_client->adapter;\n\tint addr = temp_client->addr;\n\tint err;\n\n\t/* Make sure the address is valid */\n\terr = i2c_check_7bit_addr_validity_strict(addr);\n\tif (err) {\n\t\tdev_warn(&adapter->dev, \"Invalid probe address 0x%02x\\n\",\n\t\t\t addr);\n\t\treturn err;\n\t}\n\n\t/* Skip if already in use (7 bit, no need to encode flags) */\n\tif (i2c_check_addr_busy(adapter, addr))\n\t\treturn 0;\n\n\t/* Make sure there is something at this address */\n\tif (!i2c_default_probe(adapter, addr))\n\t\treturn 0;\n\n\t/* Finally call the custom detection function */\n\tmemset(&info, 0, sizeof(struct i2c_board_info));\n\tinfo.addr = addr;\n\terr = driver->detect(temp_client, &info);\n\tif (err) {\n\t\t/* -ENODEV is returned if the detection fails. We catch it\n\t\t   here as this isn't an error. */\n\t\treturn err == -ENODEV ? 0 : err;\n\t}\n\n\t/* Consistency check */\n\tif (info.type[0] == '\\0') {\n\t\tdev_err(&adapter->dev,\n\t\t\t\"%s detection function provided no name for 0x%x\\n\",\n\t\t\tdriver->driver.name, addr);\n\t} else {\n\t\tstruct i2c_client *client;\n\n\t\t/* Detection succeeded, instantiate the device */\n\t\tif (adapter->class & I2C_CLASS_DEPRECATED)\n\t\t\tdev_warn(&adapter->dev,\n\t\t\t\t\"This adapter will soon drop class based instantiation of devices. \"\n\t\t\t\t\"Please make sure client 0x%02x gets instantiated by other means. \"\n\t\t\t\t\"Check 'Documentation/i2c/instantiating-devices.rst' for details.\\n\",\n\t\t\t\tinfo.addr);\n\n\t\tdev_dbg(&adapter->dev, \"Creating %s at 0x%02x\\n\",\n\t\t\tinfo.type, info.addr);\n\t\tclient = i2c_new_client_device(adapter, &info);\n\t\tif (!IS_ERR(client))\n\t\t\tlist_add_tail(&client->detected, &driver->clients);\n\t\telse\n\t\t\tdev_err(&adapter->dev, \"Failed creating %s at 0x%02x\\n\",\n\t\t\t\tinfo.type, info.addr);\n\t}\n\treturn 0;\n}\n\nstatic int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver)\n{\n\tconst unsigned short *address_list;\n\tstruct i2c_client *temp_client;\n\tint i, err = 0;\n\n\taddress_list = driver->address_list;\n\tif (!driver->detect || !address_list)\n\t\treturn 0;\n\n\t/* Warn that the adapter lost class based instantiation */\n\tif (adapter->class == I2C_CLASS_DEPRECATED) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"This adapter dropped support for I2C classes and won't auto-detect %s devices anymore. \"\n\t\t\t\"If you need it, check 'Documentation/i2c/instantiating-devices.rst' for alternatives.\\n\",\n\t\t\tdriver->driver.name);\n\t\treturn 0;\n\t}\n\n\t/* Stop here if the classes do not match */\n\tif (!(adapter->class & driver->class))\n\t\treturn 0;\n\n\t/* Set up a temporary client to help detect callback */\n\ttemp_client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);\n\tif (!temp_client)\n\t\treturn -ENOMEM;\n\ttemp_client->adapter = adapter;\n\n\tfor (i = 0; address_list[i] != I2C_CLIENT_END; i += 1) {\n\t\tdev_dbg(&adapter->dev,\n\t\t\t\"found normal entry for adapter %d, addr 0x%02x\\n\",\n\t\t\ti2c_adapter_id(adapter), address_list[i]);\n\t\ttemp_client->addr = address_list[i];\n\t\terr = i2c_detect_address(temp_client, driver);\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\n\tkfree(temp_client);\n\treturn err;\n}\n\nint i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr)\n{\n\treturn i2c_smbus_xfer(adap, addr, 0, I2C_SMBUS_READ, 0,\n\t\t\t      I2C_SMBUS_QUICK, NULL) >= 0;\n}\nEXPORT_SYMBOL_GPL(i2c_probe_func_quick_read);\n\nstruct i2c_client *\ni2c_new_scanned_device(struct i2c_adapter *adap,\n\t\t       struct i2c_board_info *info,\n\t\t       unsigned short const *addr_list,\n\t\t       int (*probe)(struct i2c_adapter *adap, unsigned short addr))\n{\n\tint i;\n\n\tif (!probe)\n\t\tprobe = i2c_default_probe;\n\n\tfor (i = 0; addr_list[i] != I2C_CLIENT_END; i++) {\n\t\t/* Check address validity */\n\t\tif (i2c_check_7bit_addr_validity_strict(addr_list[i]) < 0) {\n\t\t\tdev_warn(&adap->dev, \"Invalid 7-bit address 0x%02x\\n\",\n\t\t\t\t addr_list[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check address availability (7 bit, no need to encode flags) */\n\t\tif (i2c_check_addr_busy(adap, addr_list[i])) {\n\t\t\tdev_dbg(&adap->dev,\n\t\t\t\t\"Address 0x%02x already in use, not probing\\n\",\n\t\t\t\taddr_list[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Test address responsiveness */\n\t\tif (probe(adap, addr_list[i]))\n\t\t\tbreak;\n\t}\n\n\tif (addr_list[i] == I2C_CLIENT_END) {\n\t\tdev_dbg(&adap->dev, \"Probing failed, no device found\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tinfo->addr = addr_list[i];\n\treturn i2c_new_client_device(adap, info);\n}\nEXPORT_SYMBOL_GPL(i2c_new_scanned_device);\n\nstruct i2c_adapter *i2c_get_adapter(int nr)\n{\n\tstruct i2c_adapter *adapter;\n\n\tmutex_lock(&core_lock);\n\tadapter = idr_find(&i2c_adapter_idr, nr);\n\tif (!adapter)\n\t\tgoto exit;\n\n\tif (try_module_get(adapter->owner))\n\t\tget_device(&adapter->dev);\n\telse\n\t\tadapter = NULL;\n\n exit:\n\tmutex_unlock(&core_lock);\n\treturn adapter;\n}\nEXPORT_SYMBOL(i2c_get_adapter);\n\nvoid i2c_put_adapter(struct i2c_adapter *adap)\n{\n\tif (!adap)\n\t\treturn;\n\n\tput_device(&adap->dev);\n\tmodule_put(adap->owner);\n}\nEXPORT_SYMBOL(i2c_put_adapter);\n\n/**\n * i2c_get_dma_safe_msg_buf() - get a DMA safe buffer for the given i2c_msg\n * @msg: the message to be checked\n * @threshold: the minimum number of bytes for which using DMA makes sense.\n *\t       Should at least be 1.\n *\n * Return: NULL if a DMA safe buffer was not obtained. Use msg->buf with PIO.\n *\t   Or a valid pointer to be used with DMA. After use, release it by\n *\t   calling i2c_put_dma_safe_msg_buf().\n *\n * This function must only be called from process context!\n */\nu8 *i2c_get_dma_safe_msg_buf(struct i2c_msg *msg, unsigned int threshold)\n{\n\t/* also skip 0-length msgs for bogus thresholds of 0 */\n\tif (!threshold)\n\t\tpr_debug(\"DMA buffer for addr=0x%02x with length 0 is bogus\\n\",\n\t\t\t msg->addr);\n\tif (msg->len < threshold || msg->len == 0)\n\t\treturn NULL;\n\n\tif (msg->flags & I2C_M_DMA_SAFE)\n\t\treturn msg->buf;\n\n\tpr_debug(\"using bounce buffer for addr=0x%02x, len=%d\\n\",\n\t\t msg->addr, msg->len);\n\n\tif (msg->flags & I2C_M_RD)\n\t\treturn kzalloc(msg->len, GFP_KERNEL);\n\telse\n\t\treturn kmemdup(msg->buf, msg->len, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(i2c_get_dma_safe_msg_buf);\n\n/**\n * i2c_put_dma_safe_msg_buf - release DMA safe buffer and sync with i2c_msg\n * @buf: the buffer obtained from i2c_get_dma_safe_msg_buf(). May be NULL.\n * @msg: the message which the buffer corresponds to\n * @xferred: bool saying if the message was transferred\n */\nvoid i2c_put_dma_safe_msg_buf(u8 *buf, struct i2c_msg *msg, bool xferred)\n{\n\tif (!buf || buf == msg->buf)\n\t\treturn;\n\n\tif (xferred && msg->flags & I2C_M_RD)\n\t\tmemcpy(msg->buf, buf, msg->len);\n\n\tkfree(buf);\n}\nEXPORT_SYMBOL_GPL(i2c_put_dma_safe_msg_buf);\n\nMODULE_AUTHOR(\"Simon G. Vogl <simon@tk.uni-linz.ac.at>\");\nMODULE_DESCRIPTION(\"I2C-Bus main module\");\nMODULE_LICENSE(\"GPL\");\n"}, "3": {"id": 3, "path": "/src/include/linux/i2c.h", "content": "/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * i2c.h - definitions for the Linux i2c bus interface\n * Copyright (C) 1995-2000 Simon G. Vogl\n * Copyright (C) 2013-2019 Wolfram Sang <wsa@kernel.org>\n *\n * With some changes from Ky\u00f6sti M\u00e4lkki <kmalkki@cc.hut.fi> and\n * Frodo Looijaard <frodol@dds.nl>\n */\n#ifndef _LINUX_I2C_H\n#define _LINUX_I2C_H\n\n#include <linux/acpi.h>\t\t/* for acpi_handle */\n#include <linux/mod_devicetable.h>\n#include <linux/device.h>\t/* for struct device */\n#include <linux/sched.h>\t/* for completion */\n#include <linux/mutex.h>\n#include <linux/rtmutex.h>\n#include <linux/irqdomain.h>\t\t/* for Host Notify IRQ */\n#include <linux/of.h>\t\t/* for struct device_node */\n#include <linux/swab.h>\t\t/* for swab16 */\n#include <uapi/linux/i2c.h>\n\nextern struct bus_type i2c_bus_type;\nextern struct device_type i2c_adapter_type;\nextern struct device_type i2c_client_type;\n\n/* --- General options ------------------------------------------------\t*/\n\nstruct i2c_msg;\nstruct i2c_algorithm;\nstruct i2c_adapter;\nstruct i2c_client;\nstruct i2c_driver;\nstruct i2c_device_identity;\nunion i2c_smbus_data;\nstruct i2c_board_info;\nenum i2c_slave_event;\ntypedef int (*i2c_slave_cb_t)(struct i2c_client *client,\n\t\t\t      enum i2c_slave_event event, u8 *val);\n\n/* I2C Frequency Modes */\n#define I2C_MAX_STANDARD_MODE_FREQ\t100000\n#define I2C_MAX_FAST_MODE_FREQ\t\t400000\n#define I2C_MAX_FAST_MODE_PLUS_FREQ\t1000000\n#define I2C_MAX_TURBO_MODE_FREQ\t\t1400000\n#define I2C_MAX_HIGH_SPEED_MODE_FREQ\t3400000\n#define I2C_MAX_ULTRA_FAST_MODE_FREQ\t5000000\n\nstruct module;\nstruct property_entry;\n\n#if IS_ENABLED(CONFIG_I2C)\n/*\n * The master routines are the ones normally used to transmit data to devices\n * on a bus (or read from them). Apart from two basic transfer functions to\n * transmit one message at a time, a more complex version can be used to\n * transmit an arbitrary number of messages without interruption.\n * @count must be less than 64k since msg.len is u16.\n */\nint i2c_transfer_buffer_flags(const struct i2c_client *client,\n\t\t\t      char *buf, int count, u16 flags);\n\n/**\n * i2c_master_recv - issue a single I2C message in master receive mode\n * @client: Handle to slave device\n * @buf: Where to store data read from slave\n * @count: How many bytes to read, must be less than 64k since msg.len is u16\n *\n * Returns negative errno, or else the number of bytes read.\n */\nstatic inline int i2c_master_recv(const struct i2c_client *client,\n\t\t\t\t  char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);\n};\n\n/**\n * i2c_master_recv_dmasafe - issue a single I2C message in master receive mode\n *\t\t\t     using a DMA safe buffer\n * @client: Handle to slave device\n * @buf: Where to store data read from slave, must be safe to use with DMA\n * @count: How many bytes to read, must be less than 64k since msg.len is u16\n *\n * Returns negative errno, or else the number of bytes read.\n */\nstatic inline int i2c_master_recv_dmasafe(const struct i2c_client *client,\n\t\t\t\t\t  char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, buf, count,\n\t\t\t\t\t I2C_M_RD | I2C_M_DMA_SAFE);\n};\n\n/**\n * i2c_master_send - issue a single I2C message in master transmit mode\n * @client: Handle to slave device\n * @buf: Data that will be written to the slave\n * @count: How many bytes to write, must be less than 64k since msg.len is u16\n *\n * Returns negative errno, or else the number of bytes written.\n */\nstatic inline int i2c_master_send(const struct i2c_client *client,\n\t\t\t\t  const char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, (char *)buf, count, 0);\n};\n\n/**\n * i2c_master_send_dmasafe - issue a single I2C message in master transmit mode\n *\t\t\t     using a DMA safe buffer\n * @client: Handle to slave device\n * @buf: Data that will be written to the slave, must be safe to use with DMA\n * @count: How many bytes to write, must be less than 64k since msg.len is u16\n *\n * Returns negative errno, or else the number of bytes written.\n */\nstatic inline int i2c_master_send_dmasafe(const struct i2c_client *client,\n\t\t\t\t\t  const char *buf, int count)\n{\n\treturn i2c_transfer_buffer_flags(client, (char *)buf, count,\n\t\t\t\t\t I2C_M_DMA_SAFE);\n};\n\n/* Transfer num messages.\n */\nint i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);\n/* Unlocked flavor */\nint __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);\n\n/* This is the very generalized SMBus access routine. You probably do not\n   want to use this, though; one of the functions below may be much easier,\n   and probably just as fast.\n   Note that we use i2c_adapter here, because you do not need a specific\n   smbus adapter to call this function. */\ns32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t   unsigned short flags, char read_write, u8 command,\n\t\t   int protocol, union i2c_smbus_data *data);\n\n/* Unlocked flavor */\ns32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,\n\t\t     unsigned short flags, char read_write, u8 command,\n\t\t     int protocol, union i2c_smbus_data *data);\n\n/* Now follow the 'nice' access routines. These also document the calling\n   conventions of i2c_smbus_xfer. */\n\ns32 i2c_smbus_read_byte(const struct i2c_client *client);\ns32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value);\ns32 i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command);\ns32 i2c_smbus_write_byte_data(const struct i2c_client *client,\n\t\t\t      u8 command, u8 value);\ns32 i2c_smbus_read_word_data(const struct i2c_client *client, u8 command);\ns32 i2c_smbus_write_word_data(const struct i2c_client *client,\n\t\t\t      u8 command, u16 value);\n\nstatic inline s32\ni2c_smbus_read_word_swapped(const struct i2c_client *client, u8 command)\n{\n\ts32 value = i2c_smbus_read_word_data(client, command);\n\n\treturn (value < 0) ? value : swab16(value);\n}\n\nstatic inline s32\ni2c_smbus_write_word_swapped(const struct i2c_client *client,\n\t\t\t     u8 command, u16 value)\n{\n\treturn i2c_smbus_write_word_data(client, command, swab16(value));\n}\n\n/* Returns the number of read bytes */\ns32 i2c_smbus_read_block_data(const struct i2c_client *client,\n\t\t\t      u8 command, u8 *values);\ns32 i2c_smbus_write_block_data(const struct i2c_client *client,\n\t\t\t       u8 command, u8 length, const u8 *values);\n/* Returns the number of read bytes */\ns32 i2c_smbus_read_i2c_block_data(const struct i2c_client *client,\n\t\t\t\t  u8 command, u8 length, u8 *values);\ns32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client,\n\t\t\t\t   u8 command, u8 length, const u8 *values);\ns32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,\n\t\t\t\t\t      u8 command, u8 length,\n\t\t\t\t\t      u8 *values);\nint i2c_get_device_id(const struct i2c_client *client,\n\t\t      struct i2c_device_identity *id);\n#endif /* I2C */\n\n/**\n * struct i2c_device_identity - i2c client device identification\n * @manufacturer_id: 0 - 4095, database maintained by NXP\n * @part_id: 0 - 511, according to manufacturer\n * @die_revision: 0 - 7, according to manufacturer\n */\nstruct i2c_device_identity {\n\tu16 manufacturer_id;\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS                0\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_1              1\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_2              2\n#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_3              3\n#define I2C_DEVICE_ID_RAMTRON_INTERNATIONAL             4\n#define I2C_DEVICE_ID_ANALOG_DEVICES                    5\n#define I2C_DEVICE_ID_STMICROELECTRONICS                6\n#define I2C_DEVICE_ID_ON_SEMICONDUCTOR                  7\n#define I2C_DEVICE_ID_SPRINTEK_CORPORATION              8\n#define I2C_DEVICE_ID_ESPROS_PHOTONICS_AG               9\n#define I2C_DEVICE_ID_FUJITSU_SEMICONDUCTOR            10\n#define I2C_DEVICE_ID_FLIR                             11\n#define I2C_DEVICE_ID_O2MICRO                          12\n#define I2C_DEVICE_ID_ATMEL                            13\n#define I2C_DEVICE_ID_NONE                         0xffff\n\tu16 part_id;\n\tu8 die_revision;\n};\n\nenum i2c_alert_protocol {\n\tI2C_PROTOCOL_SMBUS_ALERT,\n\tI2C_PROTOCOL_SMBUS_HOST_NOTIFY,\n};\n\n/**\n * struct i2c_driver - represent an I2C device driver\n * @class: What kind of i2c device we instantiate (for detect)\n * @probe: Callback for device binding - soon to be deprecated\n * @probe_new: New callback for device binding\n * @remove: Callback for device unbinding\n * @shutdown: Callback for device shutdown\n * @alert: Alert callback, for example for the SMBus alert protocol\n * @command: Callback for bus-wide signaling (optional)\n * @driver: Device driver model driver\n * @id_table: List of I2C devices supported by this driver\n * @detect: Callback for device detection\n * @address_list: The I2C addresses to probe (for detect)\n * @clients: List of detected clients we created (for i2c-core use only)\n *\n * The driver.owner field should be set to the module owner of this driver.\n * The driver.name field should be set to the name of this driver.\n *\n * For automatic device detection, both @detect and @address_list must\n * be defined. @class should also be set, otherwise only devices forced\n * with module parameters will be created. The detect function must\n * fill at least the name field of the i2c_board_info structure it is\n * handed upon successful detection, and possibly also the flags field.\n *\n * If @detect is missing, the driver will still work fine for enumerated\n * devices. Detected devices simply won't be supported. This is expected\n * for the many I2C/SMBus devices which can't be detected reliably, and\n * the ones which can always be enumerated in practice.\n *\n * The i2c_client structure which is handed to the @detect callback is\n * not a real i2c_client. It is initialized just enough so that you can\n * call i2c_smbus_read_byte_data and friends on it. Don't do anything\n * else with it. In particular, calling dev_dbg and friends on it is\n * not allowed.\n */\nstruct i2c_driver {\n\tunsigned int class;\n\n\t/* Standard driver model interfaces */\n\tint (*probe)(struct i2c_client *client, const struct i2c_device_id *id);\n\tint (*remove)(struct i2c_client *client);\n\n\t/* New driver model interface to aid the seamless removal of the\n\t * current probe()'s, more commonly unused than used second parameter.\n\t */\n\tint (*probe_new)(struct i2c_client *client);\n\n\t/* driver model interfaces that don't relate to enumeration  */\n\tvoid (*shutdown)(struct i2c_client *client);\n\n\t/* Alert callback, for example for the SMBus alert protocol.\n\t * The format and meaning of the data value depends on the protocol.\n\t * For the SMBus alert protocol, there is a single bit of data passed\n\t * as the alert response's low bit (\"event flag\").\n\t * For the SMBus Host Notify protocol, the data corresponds to the\n\t * 16-bit payload data reported by the slave device acting as master.\n\t */\n\tvoid (*alert)(struct i2c_client *client, enum i2c_alert_protocol protocol,\n\t\t      unsigned int data);\n\n\t/* a ioctl like command that can be used to perform specific functions\n\t * with the device.\n\t */\n\tint (*command)(struct i2c_client *client, unsigned int cmd, void *arg);\n\n\tstruct device_driver driver;\n\tconst struct i2c_device_id *id_table;\n\n\t/* Device detection callback for automatic device creation */\n\tint (*detect)(struct i2c_client *client, struct i2c_board_info *info);\n\tconst unsigned short *address_list;\n\tstruct list_head clients;\n};\n#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)\n\n/**\n * struct i2c_client - represent an I2C slave device\n * @flags: see I2C_CLIENT_* for possible flags\n * @addr: Address used on the I2C bus connected to the parent adapter.\n * @name: Indicates the type of the device, usually a chip name that's\n *\tgeneric enough to hide second-sourcing and compatible revisions.\n * @adapter: manages the bus segment hosting this I2C device\n * @dev: Driver model device node for the slave.\n * @init_irq: IRQ that was set at initialization\n * @irq: indicates the IRQ generated by this device (if any)\n * @detected: member of an i2c_driver.clients list or i2c-core's\n *\tuserspace_devices list\n * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter\n *\tcalls it to pass on slave events to the slave driver.\n *\n * An i2c_client identifies a single device (i.e. chip) connected to an\n * i2c bus. The behaviour exposed to Linux is defined by the driver\n * managing the device.\n */\nstruct i2c_client {\n\tunsigned short flags;\t\t/* div., see below\t\t*/\n#define I2C_CLIENT_PEC\t\t0x04\t/* Use Packet Error Checking */\n#define I2C_CLIENT_TEN\t\t0x10\t/* we have a ten bit chip address */\n\t\t\t\t\t/* Must equal I2C_M_TEN below */\n#define I2C_CLIENT_SLAVE\t0x20\t/* we are the slave */\n#define I2C_CLIENT_HOST_NOTIFY\t0x40\t/* We want to use I2C host notify */\n#define I2C_CLIENT_WAKE\t\t0x80\t/* for board_info; true iff can wake */\n#define I2C_CLIENT_SCCB\t\t0x9000\t/* Use Omnivision SCCB protocol */\n\t\t\t\t\t/* Must match I2C_M_STOP|IGNORE_NAK */\n\n\tunsigned short addr;\t\t/* chip address - NOTE: 7bit\t*/\n\t\t\t\t\t/* addresses are stored in the\t*/\n\t\t\t\t\t/* _LOWER_ 7 bits\t\t*/\n\tchar name[I2C_NAME_SIZE];\n\tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/\n\tstruct device dev;\t\t/* the device structure\t\t*/\n\tint init_irq;\t\t\t/* irq set at initialization\t*/\n\tint irq;\t\t\t/* irq issued by device\t\t*/\n\tstruct list_head detected;\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\ti2c_slave_cb_t slave_cb;\t/* callback for slave mode\t*/\n#endif\n};\n#define to_i2c_client(d) container_of(d, struct i2c_client, dev)\n\nstruct i2c_client *i2c_verify_client(struct device *dev);\nstruct i2c_adapter *i2c_verify_adapter(struct device *dev);\nconst struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,\n\t\t\t\t\t const struct i2c_client *client);\n\nstatic inline struct i2c_client *kobj_to_i2c_client(struct kobject *kobj)\n{\n\tstruct device * const dev = kobj_to_dev(kobj);\n\treturn to_i2c_client(dev);\n}\n\nstatic inline void *i2c_get_clientdata(const struct i2c_client *client)\n{\n\treturn dev_get_drvdata(&client->dev);\n}\n\nstatic inline void i2c_set_clientdata(struct i2c_client *client, void *data)\n{\n\tdev_set_drvdata(&client->dev, data);\n}\n\n/* I2C slave support */\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\nenum i2c_slave_event {\n\tI2C_SLAVE_READ_REQUESTED,\n\tI2C_SLAVE_WRITE_REQUESTED,\n\tI2C_SLAVE_READ_PROCESSED,\n\tI2C_SLAVE_WRITE_RECEIVED,\n\tI2C_SLAVE_STOP,\n};\n\nint i2c_slave_register(struct i2c_client *client, i2c_slave_cb_t slave_cb);\nint i2c_slave_unregister(struct i2c_client *client);\nbool i2c_detect_slave_mode(struct device *dev);\n\nstatic inline int i2c_slave_event(struct i2c_client *client,\n\t\t\t\t  enum i2c_slave_event event, u8 *val)\n{\n\treturn client->slave_cb(client, event, val);\n}\n#else\nstatic inline bool i2c_detect_slave_mode(struct device *dev) { return false; }\n#endif\n\n/**\n * struct i2c_board_info - template for device creation\n * @type: chip type, to initialize i2c_client.name\n * @flags: to initialize i2c_client.flags\n * @addr: stored in i2c_client.addr\n * @dev_name: Overrides the default <busnr>-<addr> dev_name if set\n * @platform_data: stored in i2c_client.dev.platform_data\n * @of_node: pointer to OpenFirmware device node\n * @fwnode: device node supplied by the platform firmware\n * @properties: additional device properties for the device\n * @resources: resources associated with the device\n * @num_resources: number of resources in the @resources array\n * @irq: stored in i2c_client.irq\n *\n * I2C doesn't actually support hardware probing, although controllers and\n * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there's\n * a device at a given address.  Drivers commonly need more information than\n * that, such as chip type, configuration, associated IRQ, and so on.\n *\n * i2c_board_info is used to build tables of information listing I2C devices\n * that are present.  This information is used to grow the driver model tree.\n * For mainboards this is done statically using i2c_register_board_info();\n * bus numbers identify adapters that aren't yet available.  For add-on boards,\n * i2c_new_client_device() does this dynamically with the adapter already known.\n */\nstruct i2c_board_info {\n\tchar\t\ttype[I2C_NAME_SIZE];\n\tunsigned short\tflags;\n\tunsigned short\taddr;\n\tconst char\t*dev_name;\n\tvoid\t\t*platform_data;\n\tstruct device_node *of_node;\n\tstruct fwnode_handle *fwnode;\n\tconst struct property_entry *properties;\n\tconst struct resource *resources;\n\tunsigned int\tnum_resources;\n\tint\t\tirq;\n};\n\n/**\n * I2C_BOARD_INFO - macro used to list an i2c device and its address\n * @dev_type: identifies the device type\n * @dev_addr: the device's address on the bus.\n *\n * This macro initializes essential fields of a struct i2c_board_info,\n * declaring what has been provided on a particular board.  Optional\n * fields (such as associated irq, or device-specific platform_data)\n * are provided using conventional syntax.\n */\n#define I2C_BOARD_INFO(dev_type, dev_addr) \\\n\t.type = dev_type, .addr = (dev_addr)\n\n\n#if IS_ENABLED(CONFIG_I2C)\n/*\n * Add-on boards should register/unregister their devices; e.g. a board\n * with integrated I2C, a config eeprom, sensors, and a codec that's\n * used in conjunction with the primary hardware.\n */\nstruct i2c_client *\ni2c_new_client_device(struct i2c_adapter *adap, struct i2c_board_info const *info);\n\n/* If you don't know the exact address of an I2C device, use this variant\n * instead, which can probe for device presence in a list of possible\n * addresses. The \"probe\" callback function is optional. If it is provided,\n * it must return 1 on successful probe, 0 otherwise. If it is not provided,\n * a default probing method is used.\n */\nstruct i2c_client *\ni2c_new_scanned_device(struct i2c_adapter *adap,\n\t\t       struct i2c_board_info *info,\n\t\t       unsigned short const *addr_list,\n\t\t       int (*probe)(struct i2c_adapter *adap, unsigned short addr));\n\n/* Common custom probe functions */\nint i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr);\n\nstruct i2c_client *\ni2c_new_dummy_device(struct i2c_adapter *adapter, u16 address);\n\nstruct i2c_client *\ndevm_i2c_new_dummy_device(struct device *dev, struct i2c_adapter *adap, u16 address);\n\nstruct i2c_client *\ni2c_new_ancillary_device(struct i2c_client *client,\n\t\t\t const char *name,\n\t\t\t u16 default_addr);\n\nvoid i2c_unregister_device(struct i2c_client *client);\n#endif /* I2C */\n\n/* Mainboard arch_initcall() code should register all its I2C devices.\n * This is done at arch_initcall time, before declaring any i2c adapters.\n * Modules for add-on boards must use other calls.\n */\n#ifdef CONFIG_I2C_BOARDINFO\nint\ni2c_register_board_info(int busnum, struct i2c_board_info const *info,\n\t\t\tunsigned n);\n#else\nstatic inline int\ni2c_register_board_info(int busnum, struct i2c_board_info const *info,\n\t\t\tunsigned n)\n{\n\treturn 0;\n}\n#endif /* I2C_BOARDINFO */\n\n/**\n * struct i2c_algorithm - represent I2C transfer method\n * @master_xfer: Issue a set of i2c transactions to the given I2C adapter\n *   defined by the msgs array, with num messages available to transfer via\n *   the adapter specified by adap.\n * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context\n *   so e.g. PMICs can be accessed very late before shutdown. Optional.\n * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this\n *   is not present, then the bus layer will try and convert the SMBus calls\n *   into I2C transfers instead.\n * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context\n *   so e.g. PMICs can be accessed very late before shutdown. Optional.\n * @functionality: Return the flags that this algorithm/adapter pair supports\n *   from the ``I2C_FUNC_*`` flags.\n * @reg_slave: Register given client to I2C slave mode of this adapter\n * @unreg_slave: Unregister given client from I2C slave mode of this adapter\n *\n * The following structs are for those who like to implement new bus drivers:\n * i2c_algorithm is the interface to a class of hardware solutions which can\n * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584\n * to name two of the most common.\n *\n * The return codes from the ``master_xfer{_atomic}`` fields should indicate the\n * type of error code that occurred during the transfer, as documented in the\n * Kernel Documentation file Documentation/i2c/fault-codes.rst.\n */\nstruct i2c_algorithm {\n\t/*\n\t * If an adapter algorithm can't do I2C-level access, set master_xfer\n\t * to NULL. If an adapter algorithm can do SMBus access, set\n\t * smbus_xfer. If set to NULL, the SMBus protocol is simulated\n\t * using common I2C messages.\n\t *\n\t * master_xfer should return the number of messages successfully\n\t * processed, or a negative value on error\n\t */\n\tint (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,\n\t\t\t   int num);\n\tint (*master_xfer_atomic)(struct i2c_adapter *adap,\n\t\t\t\t   struct i2c_msg *msgs, int num);\n\tint (*smbus_xfer)(struct i2c_adapter *adap, u16 addr,\n\t\t\t  unsigned short flags, char read_write,\n\t\t\t  u8 command, int size, union i2c_smbus_data *data);\n\tint (*smbus_xfer_atomic)(struct i2c_adapter *adap, u16 addr,\n\t\t\t\t unsigned short flags, char read_write,\n\t\t\t\t u8 command, int size, union i2c_smbus_data *data);\n\n\t/* To determine what the adapter supports */\n\tu32 (*functionality)(struct i2c_adapter *adap);\n\n#if IS_ENABLED(CONFIG_I2C_SLAVE)\n\tint (*reg_slave)(struct i2c_client *client);\n\tint (*unreg_slave)(struct i2c_client *client);\n#endif\n};\n\n/**\n * struct i2c_lock_operations - represent I2C locking operations\n * @lock_bus: Get exclusive access to an I2C bus segment\n * @trylock_bus: Try to get exclusive access to an I2C bus segment\n * @unlock_bus: Release exclusive access to an I2C bus segment\n *\n * The main operations are wrapped by i2c_lock_bus and i2c_unlock_bus.\n */\nstruct i2c_lock_operations {\n\tvoid (*lock_bus)(struct i2c_adapter *adapter, unsigned int flags);\n\tint (*trylock_bus)(struct i2c_adapter *adapter, unsigned int flags);\n\tvoid (*unlock_bus)(struct i2c_adapter *adapter, unsigned int flags);\n};\n\n/**\n * struct i2c_timings - I2C timing information\n * @bus_freq_hz: the bus frequency in Hz\n * @scl_rise_ns: time SCL signal takes to rise in ns; t(r) in the I2C specification\n * @scl_fall_ns: time SCL signal takes to fall in ns; t(f) in the I2C specification\n * @scl_int_delay_ns: time IP core additionally needs to setup SCL in ns\n * @sda_fall_ns: time SDA signal takes to fall in ns; t(f) in the I2C specification\n * @sda_hold_ns: time IP core additionally needs to hold SDA in ns\n * @digital_filter_width_ns: width in ns of spikes on i2c lines that the IP core\n *\tdigital filter can filter out\n * @analog_filter_cutoff_freq_hz: threshold frequency for the low pass IP core\n *\tanalog filter\n */\nstruct i2c_timings {\n\tu32 bus_freq_hz;\n\tu32 scl_rise_ns;\n\tu32 scl_fall_ns;\n\tu32 scl_int_delay_ns;\n\tu32 sda_fall_ns;\n\tu32 sda_hold_ns;\n\tu32 digital_filter_width_ns;\n\tu32 analog_filter_cutoff_freq_hz;\n};\n\n/**\n * struct i2c_bus_recovery_info - I2C bus recovery information\n * @recover_bus: Recover routine. Either pass driver's recover_bus() routine, or\n *\ti2c_generic_scl_recovery().\n * @get_scl: This gets current value of SCL line. Mandatory for generic SCL\n *      recovery. Populated internally for generic GPIO recovery.\n * @set_scl: This sets/clears the SCL line. Mandatory for generic SCL recovery.\n *      Populated internally for generic GPIO recovery.\n * @get_sda: This gets current value of SDA line. This or set_sda() is mandatory\n *\tfor generic SCL recovery. Populated internally, if sda_gpio is a valid\n *\tGPIO, for generic GPIO recovery.\n * @set_sda: This sets/clears the SDA line. This or get_sda() is mandatory for\n *\tgeneric SCL recovery. Populated internally, if sda_gpio is a valid GPIO,\n *\tfor generic GPIO recovery.\n * @get_bus_free: Returns the bus free state as seen from the IP core in case it\n *\thas a more complex internal logic than just reading SDA. Optional.\n * @prepare_recovery: This will be called before starting recovery. Platform may\n *\tconfigure padmux here for SDA/SCL line or something else they want.\n * @unprepare_recovery: This will be called after completing recovery. Platform\n *\tmay configure padmux here for SDA/SCL line or something else they want.\n * @scl_gpiod: gpiod of the SCL line. Only required for GPIO recovery.\n * @sda_gpiod: gpiod of the SDA line. Only required for GPIO recovery.\n * @pinctrl: pinctrl used by GPIO recovery to change the state of the I2C pins.\n *      Optional.\n * @pins_default: default pinctrl state of SCL/SDA lines, when they are assigned\n *      to the I2C bus. Optional. Populated internally for GPIO recovery, if\n *      state with the name PINCTRL_STATE_DEFAULT is found and pinctrl is valid.\n * @pins_gpio: recovery pinctrl state of SCL/SDA lines, when they are used as\n *      GPIOs. Optional. Populated internally for GPIO recovery, if this state\n *      is called \"gpio\" or \"recovery\" and pinctrl is valid.\n */\nstruct i2c_bus_recovery_info {\n\tint (*recover_bus)(struct i2c_adapter *adap);\n\n\tint (*get_scl)(struct i2c_adapter *adap);\n\tvoid (*set_scl)(struct i2c_adapter *adap, int val);\n\tint (*get_sda)(struct i2c_adapter *adap);\n\tvoid (*set_sda)(struct i2c_adapter *adap, int val);\n\tint (*get_bus_free)(struct i2c_adapter *adap);\n\n\tvoid (*prepare_recovery)(struct i2c_adapter *adap);\n\tvoid (*unprepare_recovery)(struct i2c_adapter *adap);\n\n\t/* gpio recovery */\n\tstruct gpio_desc *scl_gpiod;\n\tstruct gpio_desc *sda_gpiod;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_default;\n\tstruct pinctrl_state *pins_gpio;\n};\n\nint i2c_recover_bus(struct i2c_adapter *adap);\n\n/* Generic recovery routines */\nint i2c_generic_scl_recovery(struct i2c_adapter *adap);\n\n/**\n * struct i2c_adapter_quirks - describe flaws of an i2c adapter\n * @flags: see I2C_AQ_* for possible flags and read below\n * @max_num_msgs: maximum number of messages per transfer\n * @max_write_len: maximum length of a write message\n * @max_read_len: maximum length of a read message\n * @max_comb_1st_msg_len: maximum length of the first msg in a combined message\n * @max_comb_2nd_msg_len: maximum length of the second msg in a combined message\n *\n * Note about combined messages: Some I2C controllers can only send one message\n * per transfer, plus something called combined message or write-then-read.\n * This is (usually) a small write message followed by a read message and\n * barely enough to access register based devices like EEPROMs. There is a flag\n * to support this mode. It implies max_num_msg = 2 and does the length checks\n * with max_comb_*_len because combined message mode usually has its own\n * limitations. Because of HW implementations, some controllers can actually do\n * write-then-anything or other variants. To support that, write-then-read has\n * been broken out into smaller bits like write-first and read-second which can\n * be combined as needed.\n */\n\nstruct i2c_adapter_quirks {\n\tu64 flags;\n\tint max_num_msgs;\n\tu16 max_write_len;\n\tu16 max_read_len;\n\tu16 max_comb_1st_msg_len;\n\tu16 max_comb_2nd_msg_len;\n};\n\n/* enforce max_num_msgs = 2 and use max_comb_*_len for length checks */\n#define I2C_AQ_COMB\t\t\tBIT(0)\n/* first combined message must be write */\n#define I2C_AQ_COMB_WRITE_FIRST\t\tBIT(1)\n/* second combined message must be read */\n#define I2C_AQ_COMB_READ_SECOND\t\tBIT(2)\n/* both combined messages must have the same target address */\n#define I2C_AQ_COMB_SAME_ADDR\t\tBIT(3)\n/* convenience macro for typical write-then read case */\n#define I2C_AQ_COMB_WRITE_THEN_READ\t(I2C_AQ_COMB | I2C_AQ_COMB_WRITE_FIRST | \\\n\t\t\t\t\t I2C_AQ_COMB_READ_SECOND | I2C_AQ_COMB_SAME_ADDR)\n/* clock stretching is not supported */\n#define I2C_AQ_NO_CLK_STRETCH\t\tBIT(4)\n/* message cannot have length of 0 */\n#define I2C_AQ_NO_ZERO_LEN_READ\t\tBIT(5)\n#define I2C_AQ_NO_ZERO_LEN_WRITE\tBIT(6)\n#define I2C_AQ_NO_ZERO_LEN\t\t(I2C_AQ_NO_ZERO_LEN_READ | I2C_AQ_NO_ZERO_LEN_WRITE)\n\n/*\n * i2c_adapter is the structure used to identify a physical i2c bus along\n * with the access algorithms necessary to access it.\n */\nstruct i2c_adapter {\n\tstruct module *owner;\n\tunsigned int class;\t\t  /* classes to allow probing for */\n\tconst struct i2c_algorithm *algo; /* the algorithm to access the bus */\n\tvoid *algo_data;\n\n\t/* data fields that are valid for all devices\t*/\n\tconst struct i2c_lock_operations *lock_ops;\n\tstruct rt_mutex bus_lock;\n\tstruct rt_mutex mux_lock;\n\n\tint timeout;\t\t\t/* in jiffies */\n\tint retries;\n\tstruct device dev;\t\t/* the adapter device */\n\tunsigned long locked_flags;\t/* owned by the I2C core */\n#define I2C_ALF_IS_SUSPENDED\t\t0\n#define I2C_ALF_SUSPEND_REPORTED\t1\n\n\tint nr;\n\tchar name[48];\n\tstruct completion dev_released;\n\n\tstruct mutex userspace_clients_lock;\n\tstruct list_head userspace_clients;\n\n\tstruct i2c_bus_recovery_info *bus_recovery_info;\n\tconst struct i2c_adapter_quirks *quirks;\n\n\tstruct irq_domain *host_notify_domain;\n};\n#define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)\n\nstatic inline void *i2c_get_adapdata(const struct i2c_adapter *adap)\n{\n\treturn dev_get_drvdata(&adap->dev);\n}\n\nstatic inline void i2c_set_adapdata(struct i2c_adapter *adap, void *data)\n{\n\tdev_set_drvdata(&adap->dev, data);\n}\n\nstatic inline struct i2c_adapter *\ni2c_parent_is_i2c_adapter(const struct i2c_adapter *adapter)\n{\n#if IS_ENABLED(CONFIG_I2C_MUX)\n\tstruct device *parent = adapter->dev.parent;\n\n\tif (parent != NULL && parent->type == &i2c_adapter_type)\n\t\treturn to_i2c_adapter(parent);\n\telse\n#endif\n\t\treturn NULL;\n}\n\nint i2c_for_each_dev(void *data, int (*fn)(struct device *dev, void *data));\n\n/* Adapter locking functions, exported for shared pin cases */\n#define I2C_LOCK_ROOT_ADAPTER BIT(0)\n#define I2C_LOCK_SEGMENT      BIT(1)\n\n/**\n * i2c_lock_bus - Get exclusive access to an I2C bus segment\n * @adapter: Target I2C bus segment\n * @flags: I2C_LOCK_ROOT_ADAPTER locks the root i2c adapter, I2C_LOCK_SEGMENT\n *\tlocks only this branch in the adapter tree\n */\nstatic inline void\ni2c_lock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tadapter->lock_ops->lock_bus(adapter, flags);\n}\n\n/**\n * i2c_trylock_bus - Try to get exclusive access to an I2C bus segment\n * @adapter: Target I2C bus segment\n * @flags: I2C_LOCK_ROOT_ADAPTER tries to locks the root i2c adapter,\n *\tI2C_LOCK_SEGMENT tries to lock only this branch in the adapter tree\n *\n * Return: true if the I2C bus segment is locked, false otherwise\n */\nstatic inline int\ni2c_trylock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\treturn adapter->lock_ops->trylock_bus(adapter, flags);\n}\n\n/**\n * i2c_unlock_bus - Release exclusive access to an I2C bus segment\n * @adapter: Target I2C bus segment\n * @flags: I2C_LOCK_ROOT_ADAPTER unlocks the root i2c adapter, I2C_LOCK_SEGMENT\n *\tunlocks only this branch in the adapter tree\n */\nstatic inline void\ni2c_unlock_bus(struct i2c_adapter *adapter, unsigned int flags)\n{\n\tadapter->lock_ops->unlock_bus(adapter, flags);\n}\n\n/**\n * i2c_mark_adapter_suspended - Report suspended state of the adapter to the core\n * @adap: Adapter to mark as suspended\n *\n * When using this helper to mark an adapter as suspended, the core will reject\n * further transfers to this adapter. The usage of this helper is optional but\n * recommended for devices having distinct handlers for system suspend and\n * runtime suspend. More complex devices are free to implement custom solutions\n * to reject transfers when suspended.\n */\nstatic inline void i2c_mark_adapter_suspended(struct i2c_adapter *adap)\n{\n\ti2c_lock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n\tset_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags);\n\ti2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n}\n\n/**\n * i2c_mark_adapter_resumed - Report resumed state of the adapter to the core\n * @adap: Adapter to mark as resumed\n *\n * When using this helper to mark an adapter as resumed, the core will allow\n * further transfers to this adapter. See also further notes to\n * @i2c_mark_adapter_suspended().\n */\nstatic inline void i2c_mark_adapter_resumed(struct i2c_adapter *adap)\n{\n\ti2c_lock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n\tclear_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags);\n\ti2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);\n}\n\n/* i2c adapter classes (bitmask) */\n#define I2C_CLASS_HWMON\t\t(1<<0)\t/* lm_sensors, ... */\n#define I2C_CLASS_DDC\t\t(1<<3)\t/* DDC bus on graphics adapters */\n#define I2C_CLASS_SPD\t\t(1<<7)\t/* Memory modules */\n/* Warn users that the adapter doesn't support classes anymore */\n#define I2C_CLASS_DEPRECATED\t(1<<8)\n\n/* Internal numbers to terminate lists */\n#define I2C_CLIENT_END\t\t0xfffeU\n\n/* Construct an I2C_CLIENT_END-terminated array of i2c addresses */\n#define I2C_ADDRS(addr, addrs...) \\\n\t((const unsigned short []){ addr, ## addrs, I2C_CLIENT_END })\n\n\n/* ----- functions exported by i2c.o */\n\n/* administration...\n */\n#if IS_ENABLED(CONFIG_I2C)\nint i2c_add_adapter(struct i2c_adapter *adap);\nvoid i2c_del_adapter(struct i2c_adapter *adap);\nint i2c_add_numbered_adapter(struct i2c_adapter *adap);\n\nint i2c_register_driver(struct module *owner, struct i2c_driver *driver);\nvoid i2c_del_driver(struct i2c_driver *driver);\n\n/* use a define to avoid include chaining to get THIS_MODULE */\n#define i2c_add_driver(driver) \\\n\ti2c_register_driver(THIS_MODULE, driver)\n\nstatic inline bool i2c_client_has_driver(struct i2c_client *client)\n{\n\treturn !IS_ERR_OR_NULL(client) && client->dev.driver;\n}\n\n/* call the i2c_client->command() of all attached clients with\n * the given arguments */\nvoid i2c_clients_command(struct i2c_adapter *adap,\n\t\t\t unsigned int cmd, void *arg);\n\nstruct i2c_adapter *i2c_get_adapter(int nr);\nvoid i2c_put_adapter(struct i2c_adapter *adap);\nunsigned int i2c_adapter_depth(struct i2c_adapter *adapter);\n\nvoid i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_defaults);\n\n/* Return the functionality mask */\nstatic inline u32 i2c_get_functionality(struct i2c_adapter *adap)\n{\n\treturn adap->algo->functionality(adap);\n}\n\n/* Return 1 if adapter supports everything we need, 0 if not. */\nstatic inline int i2c_check_functionality(struct i2c_adapter *adap, u32 func)\n{\n\treturn (func & i2c_get_functionality(adap)) == func;\n}\n\n/**\n * i2c_check_quirks() - Function for checking the quirk flags in an i2c adapter\n * @adap: i2c adapter\n * @quirks: quirk flags\n *\n * Return: true if the adapter has all the specified quirk flags, false if not\n */\nstatic inline bool i2c_check_quirks(struct i2c_adapter *adap, u64 quirks)\n{\n\tif (!adap->quirks)\n\t\treturn false;\n\treturn (adap->quirks->flags & quirks) == quirks;\n}\n\n/* Return the adapter number for a specific adapter */\nstatic inline int i2c_adapter_id(struct i2c_adapter *adap)\n{\n\treturn adap->nr;\n}\n\nstatic inline u8 i2c_8bit_addr_from_msg(const struct i2c_msg *msg)\n{\n\treturn (msg->addr << 1) | (msg->flags & I2C_M_RD ? 1 : 0);\n}\n\nu8 *i2c_get_dma_safe_msg_buf(struct i2c_msg *msg, unsigned int threshold);\nvoid i2c_put_dma_safe_msg_buf(u8 *buf, struct i2c_msg *msg, bool xferred);\n\nint i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr);\n/**\n * module_i2c_driver() - Helper macro for registering a modular I2C driver\n * @__i2c_driver: i2c_driver struct\n *\n * Helper macro for I2C drivers which do not do anything special in module\n * init/exit. This eliminates a lot of boilerplate. Each module may only\n * use this macro once, and calling it replaces module_init() and module_exit()\n */\n#define module_i2c_driver(__i2c_driver) \\\n\tmodule_driver(__i2c_driver, i2c_add_driver, \\\n\t\t\ti2c_del_driver)\n\n/**\n * builtin_i2c_driver() - Helper macro for registering a builtin I2C driver\n * @__i2c_driver: i2c_driver struct\n *\n * Helper macro for I2C drivers which do not do anything special in their\n * init. This eliminates a lot of boilerplate. Each driver may only\n * use this macro once, and calling it replaces device_initcall().\n */\n#define builtin_i2c_driver(__i2c_driver) \\\n\tbuiltin_driver(__i2c_driver, i2c_add_driver)\n\n#endif /* I2C */\n\n#if IS_ENABLED(CONFIG_OF)\n/* must call put_device() when done with returned i2c_client device */\nstruct i2c_client *of_find_i2c_device_by_node(struct device_node *node);\n\n/* must call put_device() when done with returned i2c_adapter device */\nstruct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node);\n\n/* must call i2c_put_adapter() when done with returned i2c_adapter device */\nstruct i2c_adapter *of_get_i2c_adapter_by_node(struct device_node *node);\n\nconst struct of_device_id\n*i2c_of_match_device(const struct of_device_id *matches,\n\t\t     struct i2c_client *client);\n\nint of_i2c_get_board_info(struct device *dev, struct device_node *node,\n\t\t\t  struct i2c_board_info *info);\n\n#else\n\nstatic inline struct i2c_client *of_find_i2c_device_by_node(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline struct i2c_adapter *of_find_i2c_adapter_by_node(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline struct i2c_adapter *of_get_i2c_adapter_by_node(struct device_node *node)\n{\n\treturn NULL;\n}\n\nstatic inline const struct of_device_id\n*i2c_of_match_device(const struct of_device_id *matches,\n\t\t     struct i2c_client *client)\n{\n\treturn NULL;\n}\n\nstatic inline int of_i2c_get_board_info(struct device *dev,\n\t\t\t\t\tstruct device_node *node,\n\t\t\t\t\tstruct i2c_board_info *info)\n{\n\treturn -ENOTSUPP;\n}\n\n#endif /* CONFIG_OF */\n\nstruct acpi_resource;\nstruct acpi_resource_i2c_serialbus;\n\n#if IS_ENABLED(CONFIG_ACPI)\nbool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,\n\t\t\t       struct acpi_resource_i2c_serialbus **i2c);\nu32 i2c_acpi_find_bus_speed(struct device *dev);\nstruct i2c_client *i2c_acpi_new_device(struct device *dev, int index,\n\t\t\t\t       struct i2c_board_info *info);\nstruct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle);\n#else\nstatic inline bool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,\n\t\t\t\t\t     struct acpi_resource_i2c_serialbus **i2c)\n{\n\treturn false;\n}\nstatic inline u32 i2c_acpi_find_bus_speed(struct device *dev)\n{\n\treturn 0;\n}\nstatic inline struct i2c_client *i2c_acpi_new_device(struct device *dev,\n\t\t\t\t\tint index, struct i2c_board_info *info)\n{\n\treturn ERR_PTR(-ENODEV);\n}\nstatic inline struct i2c_adapter *i2c_acpi_find_adapter_by_handle(acpi_handle handle)\n{\n\treturn NULL;\n}\n#endif /* CONFIG_ACPI */\n\n#endif /* _LINUX_I2C_H */\n"}, "4": {"id": 4, "path": "/src/include/linux/kernel.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_KERNEL_H\n#define _LINUX_KERNEL_H\n\n#include <stdarg.h>\n#include <linux/limits.h>\n#include <linux/linkage.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/bitops.h>\n#include <linux/log2.h>\n#include <linux/math.h>\n#include <linux/minmax.h>\n#include <linux/typecheck.h>\n#include <linux/printk.h>\n#include <linux/build_bug.h>\n\n#include <asm/byteorder.h>\n\n#include <uapi/linux/kernel.h>\n\n#define STACK_MAGIC\t0xdeadbeef\n\n/**\n * REPEAT_BYTE - repeat the value @x multiple times as an unsigned long value\n * @x: value to repeat\n *\n * NOTE: @x is not checked for > 0xff; larger values produce odd results.\n */\n#define REPEAT_BYTE(x)\t((~0ul / 0xff) * (x))\n\n/* @a is a power of 2 value */\n#define ALIGN(x, a)\t\t__ALIGN_KERNEL((x), (a))\n#define ALIGN_DOWN(x, a)\t__ALIGN_KERNEL((x) - ((a) - 1), (a))\n#define __ALIGN_MASK(x, mask)\t__ALIGN_KERNEL_MASK((x), (mask))\n#define PTR_ALIGN(p, a)\t\t((typeof(p))ALIGN((unsigned long)(p), (a)))\n#define PTR_ALIGN_DOWN(p, a)\t((typeof(p))ALIGN_DOWN((unsigned long)(p), (a)))\n#define IS_ALIGNED(x, a)\t\t(((x) & ((typeof(x))(a) - 1)) == 0)\n\n/* generic data direction definitions */\n#define READ\t\t\t0\n#define WRITE\t\t\t1\n\n/**\n * ARRAY_SIZE - get the number of elements in array @arr\n * @arr: array to be sized\n */\n#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))\n\n#define u64_to_user_ptr(x) (\t\t\\\n{\t\t\t\t\t\\\n\ttypecheck(u64, (x));\t\t\\\n\t(void __user *)(uintptr_t)(x);\t\\\n}\t\t\t\t\t\\\n)\n\n#define typeof_member(T, m)\ttypeof(((T*)0)->m)\n\n#define _RET_IP_\t\t(unsigned long)__builtin_return_address(0)\n#define _THIS_IP_  ({ __label__ __here; __here: (unsigned long)&&__here; })\n\n/**\n * upper_32_bits - return bits 32-63 of a number\n * @n: the number we're accessing\n *\n * A basic shift-right of a 64- or 32-bit quantity.  Use this to suppress\n * the \"right shift count >= width of type\" warning when that quantity is\n * 32-bits.\n */\n#define upper_32_bits(n) ((u32)(((n) >> 16) >> 16))\n\n/**\n * lower_32_bits - return bits 0-31 of a number\n * @n: the number we're accessing\n */\n#define lower_32_bits(n) ((u32)((n) & 0xffffffff))\n\nstruct completion;\nstruct pt_regs;\nstruct user;\n\n#ifdef CONFIG_PREEMPT_VOLUNTARY\nextern int _cond_resched(void);\n# define might_resched() _cond_resched()\n#else\n# define might_resched() do { } while (0)\n#endif\n\n#ifdef CONFIG_DEBUG_ATOMIC_SLEEP\nextern void ___might_sleep(const char *file, int line, int preempt_offset);\nextern void __might_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_sleep(const char *file, int line, int preempt_offset);\nextern void __cant_migrate(const char *file, int line);\n\n/**\n * might_sleep - annotation for functions that can sleep\n *\n * this macro will print a stack trace if it is executed in an atomic\n * context (spinlock, irq-handler, ...). Additional sections where blocking is\n * not allowed can be annotated with non_block_start() and non_block_end()\n * pairs.\n *\n * This is a useful debugging help to be able to catch problems early and not\n * be bitten later when the calling function happens to sleep when it is not\n * supposed to.\n */\n# define might_sleep() \\\n\tdo { __might_sleep(__FILE__, __LINE__, 0); might_resched(); } while (0)\n/**\n * cant_sleep - annotation for functions that cannot sleep\n *\n * this macro will print a stack trace if it is executed with preemption enabled\n */\n# define cant_sleep() \\\n\tdo { __cant_sleep(__FILE__, __LINE__, 0); } while (0)\n# define sched_annotate_sleep()\t(current->task_state_change = 0)\n\n/**\n * cant_migrate - annotation for functions that cannot migrate\n *\n * Will print a stack trace if executed in code which is migratable\n */\n# define cant_migrate()\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (IS_ENABLED(CONFIG_SMP))\t\t\t\t\\\n\t\t\t__cant_migrate(__FILE__, __LINE__);\t\t\\\n\t} while (0)\n\n/**\n * non_block_start - annotate the start of section where sleeping is prohibited\n *\n * This is on behalf of the oom reaper, specifically when it is calling the mmu\n * notifiers. The problem is that if the notifier were to block on, for example,\n * mutex_lock() and if the process which holds that mutex were to perform a\n * sleeping memory allocation, the oom reaper is now blocked on completion of\n * that memory allocation. Other blocking calls like wait_event() pose similar\n * issues.\n */\n# define non_block_start() (current->non_block_count++)\n/**\n * non_block_end - annotate the end of section where sleeping is prohibited\n *\n * Closes a section opened by non_block_start().\n */\n# define non_block_end() WARN_ON(current->non_block_count-- == 0)\n#else\n  static inline void ___might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n  static inline void __might_sleep(const char *file, int line,\n\t\t\t\t   int preempt_offset) { }\n# define might_sleep() do { might_resched(); } while (0)\n# define cant_sleep() do { } while (0)\n# define cant_migrate()\t\tdo { } while (0)\n# define sched_annotate_sleep() do { } while (0)\n# define non_block_start() do { } while (0)\n# define non_block_end() do { } while (0)\n#endif\n\n#define might_sleep_if(cond) do { if (cond) might_sleep(); } while (0)\n\n#if defined(CONFIG_MMU) && \\\n\t(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))\n#define might_fault() __might_fault(__FILE__, __LINE__)\nvoid __might_fault(const char *file, int line);\n#else\nstatic inline void might_fault(void) { }\n#endif\n\nextern struct atomic_notifier_head panic_notifier_list;\nextern long (*panic_blink)(int state);\n__printf(1, 2)\nvoid panic(const char *fmt, ...) __noreturn __cold;\nvoid nmi_panic(struct pt_regs *regs, const char *msg);\nextern void oops_enter(void);\nextern void oops_exit(void);\nextern bool oops_may_print(void);\nvoid do_exit(long error_code) __noreturn;\nvoid complete_and_exit(struct completion *, long) __noreturn;\n\n/* Internal, do not use. */\nint __must_check _kstrtoul(const char *s, unsigned int base, unsigned long *res);\nint __must_check _kstrtol(const char *s, unsigned int base, long *res);\n\nint __must_check kstrtoull(const char *s, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll(const char *s, unsigned int base, long long *res);\n\n/**\n * kstrtoul - convert a string to an unsigned long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign, but not a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtoul(). Return code must be checked.\n*/\nstatic inline int __must_check kstrtoul(const char *s, unsigned int base, unsigned long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(unsigned long, unsigned long long) = 0.\n\t */\n\tif (sizeof(unsigned long) == sizeof(unsigned long long) &&\n\t    __alignof__(unsigned long) == __alignof__(unsigned long long))\n\t\treturn kstrtoull(s, base, (unsigned long long *)res);\n\telse\n\t\treturn _kstrtoul(s, base, res);\n}\n\n/**\n * kstrtol - convert a string to a long\n * @s: The start of the string. The string must be null-terminated, and may also\n *  include a single newline before its terminating null. The first character\n *  may also be a plus sign or a minus sign.\n * @base: The number base to use. The maximum supported base is 16. If base is\n *  given as 0, then the base of the string is automatically detected with the\n *  conventional semantics - If it begins with 0x the number will be parsed as a\n *  hexadecimal (case insensitive), if it otherwise begins with 0, it will be\n *  parsed as an octal number. Otherwise it will be parsed as a decimal.\n * @res: Where to write the result of the conversion on success.\n *\n * Returns 0 on success, -ERANGE on overflow and -EINVAL on parsing error.\n * Preferred over simple_strtol(). Return code must be checked.\n */\nstatic inline int __must_check kstrtol(const char *s, unsigned int base, long *res)\n{\n\t/*\n\t * We want to shortcut function call, but\n\t * __builtin_types_compatible_p(long, long long) = 0.\n\t */\n\tif (sizeof(long) == sizeof(long long) &&\n\t    __alignof__(long) == __alignof__(long long))\n\t\treturn kstrtoll(s, base, (long long *)res);\n\telse\n\t\treturn _kstrtol(s, base, res);\n}\n\nint __must_check kstrtouint(const char *s, unsigned int base, unsigned int *res);\nint __must_check kstrtoint(const char *s, unsigned int base, int *res);\n\nstatic inline int __must_check kstrtou64(const char *s, unsigned int base, u64 *res)\n{\n\treturn kstrtoull(s, base, res);\n}\n\nstatic inline int __must_check kstrtos64(const char *s, unsigned int base, s64 *res)\n{\n\treturn kstrtoll(s, base, res);\n}\n\nstatic inline int __must_check kstrtou32(const char *s, unsigned int base, u32 *res)\n{\n\treturn kstrtouint(s, base, res);\n}\n\nstatic inline int __must_check kstrtos32(const char *s, unsigned int base, s32 *res)\n{\n\treturn kstrtoint(s, base, res);\n}\n\nint __must_check kstrtou16(const char *s, unsigned int base, u16 *res);\nint __must_check kstrtos16(const char *s, unsigned int base, s16 *res);\nint __must_check kstrtou8(const char *s, unsigned int base, u8 *res);\nint __must_check kstrtos8(const char *s, unsigned int base, s8 *res);\nint __must_check kstrtobool(const char *s, bool *res);\n\nint __must_check kstrtoull_from_user(const char __user *s, size_t count, unsigned int base, unsigned long long *res);\nint __must_check kstrtoll_from_user(const char __user *s, size_t count, unsigned int base, long long *res);\nint __must_check kstrtoul_from_user(const char __user *s, size_t count, unsigned int base, unsigned long *res);\nint __must_check kstrtol_from_user(const char __user *s, size_t count, unsigned int base, long *res);\nint __must_check kstrtouint_from_user(const char __user *s, size_t count, unsigned int base, unsigned int *res);\nint __must_check kstrtoint_from_user(const char __user *s, size_t count, unsigned int base, int *res);\nint __must_check kstrtou16_from_user(const char __user *s, size_t count, unsigned int base, u16 *res);\nint __must_check kstrtos16_from_user(const char __user *s, size_t count, unsigned int base, s16 *res);\nint __must_check kstrtou8_from_user(const char __user *s, size_t count, unsigned int base, u8 *res);\nint __must_check kstrtos8_from_user(const char __user *s, size_t count, unsigned int base, s8 *res);\nint __must_check kstrtobool_from_user(const char __user *s, size_t count, bool *res);\n\nstatic inline int __must_check kstrtou64_from_user(const char __user *s, size_t count, unsigned int base, u64 *res)\n{\n\treturn kstrtoull_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos64_from_user(const char __user *s, size_t count, unsigned int base, s64 *res)\n{\n\treturn kstrtoll_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtou32_from_user(const char __user *s, size_t count, unsigned int base, u32 *res)\n{\n\treturn kstrtouint_from_user(s, count, base, res);\n}\n\nstatic inline int __must_check kstrtos32_from_user(const char __user *s, size_t count, unsigned int base, s32 *res)\n{\n\treturn kstrtoint_from_user(s, count, base, res);\n}\n\n/*\n * Use kstrto<foo> instead.\n *\n * NOTE: simple_strto<foo> does not check for the range overflow and,\n *\t depending on the input, may give interesting results.\n *\n * Use these functions if and only if you cannot use kstrto<foo>, because\n * the conversion ends on the first non-digit character, which may be far\n * beyond the supported range. It might be useful to parse the strings like\n * 10x50 or 12:21 without altering original string or temporary buffer in use.\n * Keep in mind above caveat.\n */\n\nextern unsigned long simple_strtoul(const char *,char **,unsigned int);\nextern long simple_strtol(const char *,char **,unsigned int);\nextern unsigned long long simple_strtoull(const char *,char **,unsigned int);\nextern long long simple_strtoll(const char *,char **,unsigned int);\n\nextern int num_to_str(char *buf, int size,\n\t\t      unsigned long long num, unsigned int width);\n\n/* lib/printf utilities */\n\nextern __printf(2, 3) int sprintf(char *buf, const char * fmt, ...);\nextern __printf(2, 0) int vsprintf(char *buf, const char *, va_list);\nextern __printf(3, 4)\nint snprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vsnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(3, 4)\nint scnprintf(char *buf, size_t size, const char *fmt, ...);\nextern __printf(3, 0)\nint vscnprintf(char *buf, size_t size, const char *fmt, va_list args);\nextern __printf(2, 3) __malloc\nchar *kasprintf(gfp_t gfp, const char *fmt, ...);\nextern __printf(2, 0) __malloc\nchar *kvasprintf(gfp_t gfp, const char *fmt, va_list args);\nextern __printf(2, 0)\nconst char *kvasprintf_const(gfp_t gfp, const char *fmt, va_list args);\n\nextern __scanf(2, 3)\nint sscanf(const char *, const char *, ...);\nextern __scanf(2, 0)\nint vsscanf(const char *, const char *, va_list);\n\nextern int get_option(char **str, int *pint);\nextern char *get_options(const char *str, int nints, int *ints);\nextern unsigned long long memparse(const char *ptr, char **retptr);\nextern bool parse_option_str(const char *str, const char *option);\nextern char *next_arg(char *args, char **param, char **val);\n\nextern int core_kernel_text(unsigned long addr);\nextern int init_kernel_text(unsigned long addr);\nextern int core_kernel_data(unsigned long addr);\nextern int __kernel_text_address(unsigned long addr);\nextern int kernel_text_address(unsigned long addr);\nextern int func_ptr_is_kernel_text(void *ptr);\n\n#ifdef CONFIG_SMP\nextern unsigned int sysctl_oops_all_cpu_backtrace;\n#else\n#define sysctl_oops_all_cpu_backtrace 0\n#endif /* CONFIG_SMP */\n\nextern void bust_spinlocks(int yes);\nextern int panic_timeout;\nextern unsigned long panic_print;\nextern int panic_on_oops;\nextern int panic_on_unrecovered_nmi;\nextern int panic_on_io_nmi;\nextern int panic_on_warn;\nextern unsigned long panic_on_taint;\nextern bool panic_on_taint_nousertaint;\nextern int sysctl_panic_on_rcu_stall;\nextern int sysctl_max_rcu_stall_to_panic;\nextern int sysctl_panic_on_stackoverflow;\n\nextern bool crash_kexec_post_notifiers;\n\n/*\n * panic_cpu is used for synchronizing panic() and crash_kexec() execution. It\n * holds a CPU number which is executing panic() currently. A value of\n * PANIC_CPU_INVALID means no CPU has entered panic() or crash_kexec().\n */\nextern atomic_t panic_cpu;\n#define PANIC_CPU_INVALID\t-1\n\n/*\n * Only to be used by arch init code. If the user over-wrote the default\n * CONFIG_PANIC_TIMEOUT, honor it.\n */\nstatic inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)\n{\n\tif (panic_timeout == arch_default_timeout)\n\t\tpanic_timeout = timeout;\n}\nextern const char *print_tainted(void);\nenum lockdep_ok {\n\tLOCKDEP_STILL_OK,\n\tLOCKDEP_NOW_UNRELIABLE\n};\nextern void add_taint(unsigned flag, enum lockdep_ok);\nextern int test_taint(unsigned flag);\nextern unsigned long get_taint(void);\nextern int root_mountflags;\n\nextern bool early_boot_irqs_disabled;\n\n/*\n * Values used for system_state. Ordering of the states must not be changed\n * as code checks for <, <=, >, >= STATE.\n */\nextern enum system_states {\n\tSYSTEM_BOOTING,\n\tSYSTEM_SCHEDULING,\n\tSYSTEM_RUNNING,\n\tSYSTEM_HALT,\n\tSYSTEM_POWER_OFF,\n\tSYSTEM_RESTART,\n\tSYSTEM_SUSPEND,\n} system_state;\n\n/* This cannot be an enum because some may be used in assembly source. */\n#define TAINT_PROPRIETARY_MODULE\t0\n#define TAINT_FORCED_MODULE\t\t1\n#define TAINT_CPU_OUT_OF_SPEC\t\t2\n#define TAINT_FORCED_RMMOD\t\t3\n#define TAINT_MACHINE_CHECK\t\t4\n#define TAINT_BAD_PAGE\t\t\t5\n#define TAINT_USER\t\t\t6\n#define TAINT_DIE\t\t\t7\n#define TAINT_OVERRIDDEN_ACPI_TABLE\t8\n#define TAINT_WARN\t\t\t9\n#define TAINT_CRAP\t\t\t10\n#define TAINT_FIRMWARE_WORKAROUND\t11\n#define TAINT_OOT_MODULE\t\t12\n#define TAINT_UNSIGNED_MODULE\t\t13\n#define TAINT_SOFTLOCKUP\t\t14\n#define TAINT_LIVEPATCH\t\t\t15\n#define TAINT_AUX\t\t\t16\n#define TAINT_RANDSTRUCT\t\t17\n#define TAINT_FLAGS_COUNT\t\t18\n#define TAINT_FLAGS_MAX\t\t\t((1UL << TAINT_FLAGS_COUNT) - 1)\n\nstruct taint_flag {\n\tchar c_true;\t/* character printed when tainted */\n\tchar c_false;\t/* character printed when not tainted */\n\tbool module;\t/* also show as a per-module taint flag */\n};\n\nextern const struct taint_flag taint_flags[TAINT_FLAGS_COUNT];\n\nextern const char hex_asc[];\n#define hex_asc_lo(x)\thex_asc[((x) & 0x0f)]\n#define hex_asc_hi(x)\thex_asc[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_hi(byte);\n\t*buf++ = hex_asc_lo(byte);\n\treturn buf;\n}\n\nextern const char hex_asc_upper[];\n#define hex_asc_upper_lo(x)\thex_asc_upper[((x) & 0x0f)]\n#define hex_asc_upper_hi(x)\thex_asc_upper[((x) & 0xf0) >> 4]\n\nstatic inline char *hex_byte_pack_upper(char *buf, u8 byte)\n{\n\t*buf++ = hex_asc_upper_hi(byte);\n\t*buf++ = hex_asc_upper_lo(byte);\n\treturn buf;\n}\n\nextern int hex_to_bin(char ch);\nextern int __must_check hex2bin(u8 *dst, const char *src, size_t count);\nextern char *bin2hex(char *dst, const void *src, size_t count);\n\nbool mac_pton(const char *s, u8 *mac);\n\n/*\n * General tracing related utility functions - trace_printk(),\n * tracing_on/tracing_off and tracing_start()/tracing_stop\n *\n * Use tracing_on/tracing_off when you want to quickly turn on or off\n * tracing. It simply enables or disables the recording of the trace events.\n * This also corresponds to the user space /sys/kernel/debug/tracing/tracing_on\n * file, which gives a means for the kernel and userspace to interact.\n * Place a tracing_off() in the kernel where you want tracing to end.\n * From user space, examine the trace, and then echo 1 > tracing_on\n * to continue tracing.\n *\n * tracing_stop/tracing_start has slightly more overhead. It is used\n * by things like suspend to ram where disabling the recording of the\n * trace is not enough, but tracing must actually stop because things\n * like calling smp_processor_id() may crash the system.\n *\n * Most likely, you want to use tracing_on/tracing_off.\n */\n\nenum ftrace_dump_mode {\n\tDUMP_NONE,\n\tDUMP_ALL,\n\tDUMP_ORIG,\n};\n\n#ifdef CONFIG_TRACING\nvoid tracing_on(void);\nvoid tracing_off(void);\nint tracing_is_on(void);\nvoid tracing_snapshot(void);\nvoid tracing_snapshot_alloc(void);\n\nextern void tracing_start(void);\nextern void tracing_stop(void);\n\nstatic inline __printf(1, 2)\nvoid ____trace_printk_check_format(const char *fmt, ...)\n{\n}\n#define __trace_printk_check_format(fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\t____trace_printk_check_format(fmt, ##args);\t\t\\\n} while (0)\n\n/**\n * trace_printk - printf formatting in the ftrace buffer\n * @fmt: the printf format for printing\n *\n * Note: __trace_printk is an internal function for trace_printk() and\n *       the @ip is passed in via the trace_printk() macro.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_printks scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_printk() is used.)\n *\n * A little optimization trick is done here. If there's only one\n * argument, there's no need to scan the string for printf formats.\n * The trace_puts() will suffice. But how can we take advantage of\n * using trace_puts() when trace_printk() has only one argument?\n * By stringifying the args and checking the size we can tell\n * whether or not there are args. __stringify((__VA_ARGS__)) will\n * turn into \"()\\0\" with a size of 3 when there are no args, anything\n * else will be bigger. All we need to do is define a string to this,\n * and then take its size and compare to 3. If it's bigger, use\n * do_trace_printk() otherwise, optimize it to trace_puts(). Then just\n * let gcc optimize the rest.\n */\n\n#define trace_printk(fmt, ...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\\\n\tchar _______STR[] = __stringify((__VA_ARGS__));\t\\\n\tif (sizeof(_______STR) > 3)\t\t\t\\\n\t\tdo_trace_printk(fmt, ##__VA_ARGS__);\t\\\n\telse\t\t\t\t\t\t\\\n\t\ttrace_puts(fmt);\t\t\t\\\n} while (0)\n\n#define do_trace_printk(fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__trace_printk_check_format(fmt, ##args);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt))\t\t\t\t\t\\\n\t\t__trace_bprintk(_THIS_IP_, trace_printk_fmt, ##args);\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_printk(_THIS_IP_, fmt, ##args);\t\t\t\\\n} while (0)\n\nextern __printf(2, 3)\nint __trace_bprintk(unsigned long ip, const char *fmt, ...);\n\nextern __printf(2, 3)\nint __trace_printk(unsigned long ip, const char *fmt, ...);\n\n/**\n * trace_puts - write a string into the ftrace buffer\n * @str: the string to record\n *\n * Note: __trace_bputs is an internal function for trace_puts and\n *       the @ip is passed in via the trace_puts macro.\n *\n * This is similar to trace_printk() but is made for those really fast\n * paths that a developer wants the least amount of \"Heisenbug\" effects,\n * where the processing of the print format is still too much.\n *\n * This function allows a kernel developer to debug fast path sections\n * that printk is not appropriate for. By scattering in various\n * printk like tracing in the code, a developer can quickly see\n * where problems are occurring.\n *\n * This is intended as a debugging tool for the developer only.\n * Please refrain from leaving trace_puts scattered around in\n * your code. (Extra memory is used for special buffers that are\n * allocated when trace_puts() is used.)\n *\n * Returns: 0 if nothing was written, positive # if string was.\n *  (1 when __trace_bputs is used, strlen(str) when __trace_puts is used)\n */\n\n#define trace_puts(str) ({\t\t\t\t\t\t\\\n\tstatic const char *trace_printk_fmt __used\t\t\t\\\n\t\t__section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t__builtin_constant_p(str) ? str : NULL;\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(str))\t\t\t\t\t\\\n\t\t__trace_bputs(_THIS_IP_, trace_printk_fmt);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__trace_puts(_THIS_IP_, str, strlen(str));\t\t\\\n})\nextern int __trace_bputs(unsigned long ip, const char *str);\nextern int __trace_puts(unsigned long ip, const char *str, int size);\n\nextern void trace_dump_stack(int skip);\n\n/*\n * The double __builtin_constant_p is because gcc will give us an error\n * if we try to allocate the static variable to fmt if it is not a\n * constant. Even with the outer if statement.\n */\n#define ftrace_vprintk(fmt, vargs)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (__builtin_constant_p(fmt)) {\t\t\t\t\\\n\t\tstatic const char *trace_printk_fmt __used\t\t\\\n\t\t  __section(\"__trace_printk_fmt\") =\t\t\t\\\n\t\t\t__builtin_constant_p(fmt) ? fmt : NULL;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vbprintk(_THIS_IP_, trace_printk_fmt, vargs);\t\\\n\t} else\t\t\t\t\t\t\t\t\\\n\t\t__ftrace_vprintk(_THIS_IP_, fmt, vargs);\t\t\\\n} while (0)\n\nextern __printf(2, 0) int\n__ftrace_vbprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern __printf(2, 0) int\n__ftrace_vprintk(unsigned long ip, const char *fmt, va_list ap);\n\nextern void ftrace_dump(enum ftrace_dump_mode oops_dump_mode);\n#else\nstatic inline void tracing_start(void) { }\nstatic inline void tracing_stop(void) { }\nstatic inline void trace_dump_stack(int skip) { }\n\nstatic inline void tracing_on(void) { }\nstatic inline void tracing_off(void) { }\nstatic inline int tracing_is_on(void) { return 0; }\nstatic inline void tracing_snapshot(void) { }\nstatic inline void tracing_snapshot_alloc(void) { }\n\nstatic inline __printf(1, 2)\nint trace_printk(const char *fmt, ...)\n{\n\treturn 0;\n}\nstatic __printf(1, 0) inline int\nftrace_vprintk(const char *fmt, va_list ap)\n{\n\treturn 0;\n}\nstatic inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }\n#endif /* CONFIG_TRACING */\n\n/* This counts to 12. Any more, it will return 13th argument. */\n#define __COUNT_ARGS(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _n, X...) _n\n#define COUNT_ARGS(X...) __COUNT_ARGS(, ##X, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n#define __CONCAT(a, b) a ## b\n#define CONCATENATE(a, b) __CONCAT(a, b)\n\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\t((type *)(__mptr - offsetof(type, member))); })\n\n/**\n * container_of_safe - cast a member of a structure out to the containing structure\n * @ptr:\tthe pointer to the member.\n * @type:\tthe type of the container struct this is embedded in.\n * @member:\tthe name of the member within the struct.\n *\n * If IS_ERR_OR_NULL(ptr), ptr is returned unchanged.\n */\n#define container_of_safe(ptr, type, member) ({\t\t\t\t\\\n\tvoid *__mptr = (void *)(ptr);\t\t\t\t\t\\\n\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) &&\t\\\n\t\t\t !__same_type(*(ptr), void),\t\t\t\\\n\t\t\t \"pointer type mismatch in container_of()\");\t\\\n\tIS_ERR_OR_NULL(__mptr) ? ERR_CAST(__mptr) :\t\t\t\\\n\t\t((type *)(__mptr - offsetof(type, member))); })\n\n/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n# define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD\n#endif\n\n/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */\n#define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\\n\t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\\n\t /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\\n\t /* USER_WRITABLE >= GROUP_WRITABLE */\t\t\t\t\t\\\n\t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\\n\t /* OTHER_WRITABLE?  Generally considered a bad idea. */\t\t\\\n\t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\\n\t (perms))\n#endif\n"}, "5": {"id": 5, "path": "/src/include/linux/build_bug.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_BUILD_BUG_H\n#define _LINUX_BUILD_BUG_H\n\n#include <linux/compiler.h>\n\n#ifdef __CHECKER__\n#define BUILD_BUG_ON_ZERO(e) (0)\n#else /* __CHECKER__ */\n/*\n * Force a compilation error if condition is true, but also produce a\n * result (of value 0 and type int), so the expression can be used\n * e.g. in a structure initializer (or where-ever else comma expressions\n * aren't permitted).\n */\n#define BUILD_BUG_ON_ZERO(e) ((int)(sizeof(struct { int:(-!!(e)); })))\n#endif /* __CHECKER__ */\n\n/* Force a compilation error if a constant expression is not a power of 2 */\n#define __BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\\\n\tBUILD_BUG_ON(((n) & ((n) - 1)) != 0)\n#define BUILD_BUG_ON_NOT_POWER_OF_2(n)\t\t\t\\\n\tBUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))\n\n/*\n * BUILD_BUG_ON_INVALID() permits the compiler to check the validity of the\n * expression but avoids the generation of any code, even if that expression\n * has side-effects.\n */\n#define BUILD_BUG_ON_INVALID(e) ((void)(sizeof((__force long)(e))))\n\n/**\n * BUILD_BUG_ON_MSG - break compile if a condition is true & emit supplied\n *\t\t      error message.\n * @condition: the condition which the compiler should know is false.\n *\n * See BUILD_BUG_ON for description.\n */\n#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n\n/**\n * BUILD_BUG_ON - break compile if a condition is true.\n * @condition: the condition which the compiler should know is false.\n *\n * If you have some code which relies on certain constants being equal, or\n * some other compile-time-evaluated condition, you should use BUILD_BUG_ON to\n * detect if someone changes it.\n */\n#define BUILD_BUG_ON(condition) \\\n\tBUILD_BUG_ON_MSG(condition, \"BUILD_BUG_ON failed: \" #condition)\n\n/**\n * BUILD_BUG - break compile if used.\n *\n * If you have some code that you expect the compiler to eliminate at\n * build time, you should use BUILD_BUG to detect if it is\n * unexpectedly used.\n */\n#define BUILD_BUG() BUILD_BUG_ON_MSG(1, \"BUILD_BUG failed\")\n\n/**\n * static_assert - check integer constant expression at build time\n *\n * static_assert() is a wrapper for the C11 _Static_assert, with a\n * little macro magic to make the message optional (defaulting to the\n * stringification of the tested expression).\n *\n * Contrary to BUILD_BUG_ON(), static_assert() can be used at global\n * scope, but requires the expression to be an integer constant\n * expression (i.e., it is not enough that __builtin_constant_p() is\n * true for expr).\n *\n * Also note that BUILD_BUG_ON() fails the build if the condition is\n * true, while static_assert() fails the build if the expression is\n * false.\n */\n#define static_assert(expr, ...) __static_assert(expr, ##__VA_ARGS__, #expr)\n#define __static_assert(expr, msg, ...) _Static_assert(expr, msg)\n\n#endif\t/* _LINUX_BUILD_BUG_H */\n"}, "6": {"id": 6, "path": "/src/include/linux/compiler_types.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef __LINUX_COMPILER_TYPES_H\n#define __LINUX_COMPILER_TYPES_H\n\n#ifndef __ASSEMBLY__\n\n#ifdef __CHECKER__\n/* address spaces */\n# define __kernel\t__attribute__((address_space(0)))\n# define __user\t\t__attribute__((noderef, address_space(__user)))\n# define __iomem\t__attribute__((noderef, address_space(__iomem)))\n# define __percpu\t__attribute__((noderef, address_space(__percpu)))\n# define __rcu\t\t__attribute__((noderef, address_space(__rcu)))\nstatic inline void __chk_user_ptr(const volatile void __user *ptr) { }\nstatic inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n/* context/locking */\n# define __must_hold(x)\t__attribute__((context(x,1,1)))\n# define __acquires(x)\t__attribute__((context(x,0,1)))\n# define __releases(x)\t__attribute__((context(x,1,0)))\n# define __acquire(x)\t__context__(x,1)\n# define __release(x)\t__context__(x,-1)\n# define __cond_lock(x,c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n/* other */\n# define __force\t__attribute__((force))\n# define __nocast\t__attribute__((nocast))\n# define __safe\t\t__attribute__((safe))\n# define __private\t__attribute__((noderef))\n# define ACCESS_PRIVATE(p, member) (*((typeof((p)->member) __force *) &(p)->member))\n#else /* __CHECKER__ */\n/* address spaces */\n# define __kernel\n# ifdef STRUCTLEAK_PLUGIN\n#  define __user\t__attribute__((user))\n# else\n#  define __user\n# endif\n# define __iomem\n# define __percpu\n# define __rcu\n# define __chk_user_ptr(x)\t(void)0\n# define __chk_io_ptr(x)\t(void)0\n/* context/locking */\n# define __must_hold(x)\n# define __acquires(x)\n# define __releases(x)\n# define __acquire(x)\t(void)0\n# define __release(x)\t(void)0\n# define __cond_lock(x,c) (c)\n/* other */\n# define __force\n# define __nocast\n# define __safe\n# define __private\n# define ACCESS_PRIVATE(p, member) ((p)->member)\n# define __builtin_warning(x, y...) (1)\n#endif /* __CHECKER__ */\n\n/* Indirect macros required for expanded argument pasting, eg. __LINE__. */\n#define ___PASTE(a,b) a##b\n#define __PASTE(a,b) ___PASTE(a,b)\n\n#ifdef __KERNEL__\n\n/* Attributes */\n#include <linux/compiler_attributes.h>\n\n/* Builtins */\n\n/*\n * __has_builtin is supported on gcc >= 10, clang >= 3 and icc >= 21.\n * In the meantime, to support gcc < 10, we implement __has_builtin\n * by hand.\n */\n#ifndef __has_builtin\n#define __has_builtin(x) (0)\n#endif\n\n/* Compiler specific macros. */\n#ifdef __clang__\n#include <linux/compiler-clang.h>\n#elif defined(__INTEL_COMPILER)\n#include <linux/compiler-intel.h>\n#elif defined(__GNUC__)\n/* The above compilers also define __GNUC__, so order is important here. */\n#include <linux/compiler-gcc.h>\n#else\n#error \"Unknown compiler\"\n#endif\n\n/*\n * Some architectures need to provide custom definitions of macros provided\n * by linux/compiler-*.h, and can do so using asm/compiler.h. We include that\n * conditionally rather than using an asm-generic wrapper in order to avoid\n * build failures if any C compilation, which will include this file via an\n * -include argument in c_flags, occurs prior to the asm-generic wrappers being\n * generated.\n */\n#ifdef CONFIG_HAVE_ARCH_COMPILER_H\n#include <asm/compiler.h>\n#endif\n\nstruct ftrace_branch_data {\n\tconst char *func;\n\tconst char *file;\n\tunsigned line;\n\tunion {\n\t\tstruct {\n\t\t\tunsigned long correct;\n\t\t\tunsigned long incorrect;\n\t\t};\n\t\tstruct {\n\t\t\tunsigned long miss;\n\t\t\tunsigned long hit;\n\t\t};\n\t\tunsigned long miss_hit[2];\n\t};\n};\n\nstruct ftrace_likely_data {\n\tstruct ftrace_branch_data\tdata;\n\tunsigned long\t\t\tconstant;\n};\n\n#if defined(CC_USING_HOTPATCH)\n#define notrace\t\t\t__attribute__((hotpatch(0, 0)))\n#elif defined(CC_USING_PATCHABLE_FUNCTION_ENTRY)\n#define notrace\t\t\t__attribute__((patchable_function_entry(0, 0)))\n#else\n#define notrace\t\t\t__attribute__((__no_instrument_function__))\n#endif\n\n/*\n * it doesn't make sense on ARM (currently the only user of __naked)\n * to trace naked functions because then mcount is called without\n * stack and frame pointer being set up and there is no chance to\n * restore the lr register to the value before mcount was called.\n */\n#define __naked\t\t\t__attribute__((__naked__)) notrace\n\n#define __compiler_offsetof(a, b)\t__builtin_offsetof(a, b)\n\n/*\n * Prefer gnu_inline, so that extern inline functions do not emit an\n * externally visible function. This makes extern inline behave as per gnu89\n * semantics rather than c99. This prevents multiple symbol definition errors\n * of extern inline functions at link time.\n * A lot of inline functions can cause havoc with function tracing.\n */\n#define inline inline __gnu_inline __inline_maybe_unused notrace\n\n/*\n * gcc provides both __inline__ and __inline as alternate spellings of\n * the inline keyword, though the latter is undocumented. New kernel\n * code should only use the inline spelling, but some existing code\n * uses __inline__. Since we #define inline above, to ensure\n * __inline__ has the same semantics, we need this #define.\n *\n * However, the spelling __inline is strictly reserved for referring\n * to the bare keyword.\n */\n#define __inline__ inline\n\n/*\n * GCC does not warn about unused static inline functions for -Wunused-function.\n * Suppress the warning in clang as well by using __maybe_unused, but enable it\n * for W=1 build. This will allow clang to find unused functions. Remove the\n * __inline_maybe_unused entirely after fixing most of -Wunused-function warnings.\n */\n#ifdef KBUILD_EXTRA_WARN1\n#define __inline_maybe_unused\n#else\n#define __inline_maybe_unused __maybe_unused\n#endif\n\n/*\n * Rather then using noinline to prevent stack consumption, use\n * noinline_for_stack instead.  For documentation reasons.\n */\n#define noinline_for_stack noinline\n\n/*\n * Sanitizer helper attributes: Because using __always_inline and\n * __no_sanitize_* conflict, provide helper attributes that will either expand\n * to __no_sanitize_* in compilation units where instrumentation is enabled\n * (__SANITIZE_*__), or __always_inline in compilation units without\n * instrumentation (__SANITIZE_*__ undefined).\n */\n#ifdef __SANITIZE_ADDRESS__\n/*\n * We can't declare function 'inline' because __no_sanitize_address conflicts\n * with inlining. Attempt to inline it may cause a build failure.\n *     https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67368\n * '__maybe_unused' allows us to avoid defined-but-not-used warnings.\n */\n# define __no_kasan_or_inline __no_sanitize_address notrace __maybe_unused\n# define __no_sanitize_or_inline __no_kasan_or_inline\n#else\n# define __no_kasan_or_inline __always_inline\n#endif\n\n#define __no_kcsan __no_sanitize_thread\n#ifdef __SANITIZE_THREAD__\n# define __no_sanitize_or_inline __no_kcsan notrace __maybe_unused\n#endif\n\n#ifndef __no_sanitize_or_inline\n#define __no_sanitize_or_inline __always_inline\n#endif\n\n/* Section for code which can't be instrumented at all */\n#define noinstr\t\t\t\t\t\t\t\t\\\n\tnoinline notrace __attribute((__section__(\".noinstr.text\")))\t\\\n\t__no_kcsan __no_sanitize_address\n\n#endif /* __KERNEL__ */\n\n#endif /* __ASSEMBLY__ */\n\n/*\n * The below symbols may be defined for one or more, but not ALL, of the above\n * compilers. We don't consider that to be an error, so set them to nothing.\n * For example, some of them are for compiler specific plugins.\n */\n#ifndef __latent_entropy\n# define __latent_entropy\n#endif\n\n#ifndef __randomize_layout\n# define __randomize_layout __designated_init\n#endif\n\n#ifndef __no_randomize_layout\n# define __no_randomize_layout\n#endif\n\n#ifndef randomized_struct_fields_start\n# define randomized_struct_fields_start\n# define randomized_struct_fields_end\n#endif\n\n#ifndef __noscs\n# define __noscs\n#endif\n\n#ifndef asm_volatile_goto\n#define asm_volatile_goto(x...) asm goto(x)\n#endif\n\n#ifdef CONFIG_CC_HAS_ASM_INLINE\n#define asm_inline asm __inline\n#else\n#define asm_inline asm\n#endif\n\n/* Are two types/vars the same type (ignoring qualifiers)? */\n#define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n\n/*\n * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n *\t\t\t       non-scalar types unchanged.\n */\n/*\n * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n * is not type-compatible with 'signed char', and we define a separate case.\n */\n#define __scalar_type_to_expr_cases(type)\t\t\t\t\\\n\t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n\t\tsigned type:\t(signed type)0\n\n#define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n\t\t_Generic((x),\t\t\t\t\t\t\\\n\t\t\t char:\t(char)0,\t\t\t\t\\\n\t\t\t __scalar_type_to_expr_cases(char),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(short),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n\t\t\t __scalar_type_to_expr_cases(long long),\t\\\n\t\t\t default: (x)))\n\n/* Is this type a native word size -- useful for atomic operations */\n#define __native_word(t) \\\n\t(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \\\n\t sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))\n\n/* Compile time object size, -1 for unknown */\n#ifndef __compiletime_object_size\n# define __compiletime_object_size(obj) -1\n#endif\n#ifndef __compiletime_warning\n# define __compiletime_warning(message)\n#endif\n#ifndef __compiletime_error\n# define __compiletime_error(message)\n#endif\n\n#ifdef __OPTIMIZE__\n# define __compiletime_assert(condition, msg, prefix, suffix)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\textern void prefix ## suffix(void) __compiletime_error(msg); \\\n\t\tif (!(condition))\t\t\t\t\t\\\n\t\t\tprefix ## suffix();\t\t\t\t\\\n\t} while (0)\n#else\n# define __compiletime_assert(condition, msg, prefix, suffix) do { } while (0)\n#endif\n\n#define _compiletime_assert(condition, msg, prefix, suffix) \\\n\t__compiletime_assert(condition, msg, prefix, suffix)\n\n/**\n * compiletime_assert - break build and emit msg if condition is false\n * @condition: a compile-time constant condition to check\n * @msg:       a message to emit if condition is false\n *\n * In tradition of POSIX assert, this macro will break the build if the\n * supplied condition is *false*, emitting the supplied error message if the\n * compiler has support to do so.\n */\n#define compiletime_assert(condition, msg) \\\n\t_compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n\n#define compiletime_assert_atomic_type(t)\t\t\t\t\\\n\tcompiletime_assert(__native_word(t),\t\t\t\t\\\n\t\t\"Need native word sized stores/loads for atomicity.\")\n\n/* Helpers for emitting diagnostics in pragmas. */\n#ifndef __diag\n#define __diag(string)\n#endif\n\n#ifndef __diag_GCC\n#define __diag_GCC(version, severity, string)\n#endif\n\n#define __diag_push()\t__diag(push)\n#define __diag_pop()\t__diag(pop)\n\n#define __diag_ignore(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, ignore, option)\n#define __diag_warn(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, warn, option)\n#define __diag_error(compiler, version, option, comment) \\\n\t__diag_ ## compiler(version, error, option)\n\n#endif /* __LINUX_COMPILER_TYPES_H */\n"}, "7": {"id": 7, "path": "/src/include/linux/list.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_LIST_H\n#define _LINUX_LIST_H\n\n#include <linux/types.h>\n#include <linux/stddef.h>\n#include <linux/poison.h>\n#include <linux/const.h>\n#include <linux/kernel.h>\n\n/*\n * Circular doubly linked list implementation.\n *\n * Some of the internal functions (\"__xxx\") are useful when\n * manipulating whole lists rather than single entries, as\n * sometimes we already know the next/prev entries and we can\n * generate better code by using them directly rather than\n * using the generic single-entry routines.\n */\n\n#define LIST_HEAD_INIT(name) { &(name), &(name) }\n\n#define LIST_HEAD(name) \\\n\tstruct list_head name = LIST_HEAD_INIT(name)\n\n/**\n * INIT_LIST_HEAD - Initialize a list_head structure\n * @list: list_head structure to be initialized.\n *\n * Initializes the list_head to point to itself.  If it is a list header,\n * the result is an empty list.\n */\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n\tWRITE_ONCE(list->next, list);\n\tlist->prev = list;\n}\n\n#ifdef CONFIG_DEBUG_LIST\nextern bool __list_add_valid(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next);\nextern bool __list_del_entry_valid(struct list_head *entry);\n#else\nstatic inline bool __list_add_valid(struct list_head *new,\n\t\t\t\tstruct list_head *prev,\n\t\t\t\tstruct list_head *next)\n{\n\treturn true;\n}\nstatic inline bool __list_del_entry_valid(struct list_head *entry)\n{\n\treturn true;\n}\n#endif\n\n/*\n * Insert a new entry between two known consecutive entries.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_add(struct list_head *new,\n\t\t\t      struct list_head *prev,\n\t\t\t      struct list_head *next)\n{\n\tif (!__list_add_valid(new, prev, next))\n\t\treturn;\n\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tWRITE_ONCE(prev->next, new);\n}\n\n/**\n * list_add - add a new entry\n * @new: new entry to be added\n * @head: list head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void list_add(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head, head->next);\n}\n\n\n/**\n * list_add_tail - add a new entry\n * @new: new entry to be added\n * @head: list head to add it before\n *\n * Insert a new entry before the specified head.\n * This is useful for implementing queues.\n */\nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head->prev, head);\n}\n\n/*\n * Delete a list entry by making the prev/next entries\n * point to each other.\n *\n * This is only for internal list manipulation where we know\n * the prev/next entries already!\n */\nstatic inline void __list_del(struct list_head * prev, struct list_head * next)\n{\n\tnext->prev = prev;\n\tWRITE_ONCE(prev->next, next);\n}\n\n/*\n * Delete a list entry and clear the 'prev' pointer.\n *\n * This is a special-purpose list clearing method used in the networking code\n * for lists allocated as per-cpu, where we don't want to incur the extra\n * WRITE_ONCE() overhead of a regular list_del_init(). The code that uses this\n * needs to check the node 'prev' pointer instead of calling list_empty().\n */\nstatic inline void __list_del_clearprev(struct list_head *entry)\n{\n\t__list_del(entry->prev, entry->next);\n\tentry->prev = NULL;\n}\n\nstatic inline void __list_del_entry(struct list_head *entry)\n{\n\tif (!__list_del_entry_valid(entry))\n\t\treturn;\n\n\t__list_del(entry->prev, entry->next);\n}\n\n/**\n * list_del - deletes entry from list.\n * @entry: the element to delete from the list.\n * Note: list_empty() on entry does not return true after this, the entry is\n * in an undefined state.\n */\nstatic inline void list_del(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tentry->next = LIST_POISON1;\n\tentry->prev = LIST_POISON2;\n}\n\n/**\n * list_replace - replace old entry by new one\n * @old : the element to be replaced\n * @new : the new element to insert\n *\n * If @old was empty, it will be overwritten.\n */\nstatic inline void list_replace(struct list_head *old,\n\t\t\t\tstruct list_head *new)\n{\n\tnew->next = old->next;\n\tnew->next->prev = new;\n\tnew->prev = old->prev;\n\tnew->prev->next = new;\n}\n\n/**\n * list_replace_init - replace old entry by new one and initialize the old one\n * @old : the element to be replaced\n * @new : the new element to insert\n *\n * If @old was empty, it will be overwritten.\n */\nstatic inline void list_replace_init(struct list_head *old,\n\t\t\t\t     struct list_head *new)\n{\n\tlist_replace(old, new);\n\tINIT_LIST_HEAD(old);\n}\n\n/**\n * list_swap - replace entry1 with entry2 and re-add entry1 at entry2's position\n * @entry1: the location to place entry2\n * @entry2: the location to place entry1\n */\nstatic inline void list_swap(struct list_head *entry1,\n\t\t\t     struct list_head *entry2)\n{\n\tstruct list_head *pos = entry2->prev;\n\n\tlist_del(entry2);\n\tlist_replace(entry1, entry2);\n\tif (pos == entry1)\n\t\tpos = entry2;\n\tlist_add(entry1, pos);\n}\n\n/**\n * list_del_init - deletes entry from list and reinitialize it.\n * @entry: the element to delete from the list.\n */\nstatic inline void list_del_init(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tINIT_LIST_HEAD(entry);\n}\n\n/**\n * list_move - delete from one list and add as another's head\n * @list: the entry to move\n * @head: the head that will precede our entry\n */\nstatic inline void list_move(struct list_head *list, struct list_head *head)\n{\n\t__list_del_entry(list);\n\tlist_add(list, head);\n}\n\n/**\n * list_move_tail - delete from one list and add as another's tail\n * @list: the entry to move\n * @head: the head that will follow our entry\n */\nstatic inline void list_move_tail(struct list_head *list,\n\t\t\t\t  struct list_head *head)\n{\n\t__list_del_entry(list);\n\tlist_add_tail(list, head);\n}\n\n/**\n * list_bulk_move_tail - move a subsection of a list to its tail\n * @head: the head that will follow our entry\n * @first: first entry to move\n * @last: last entry to move, can be the same as first\n *\n * Move all entries between @first and including @last before @head.\n * All three entries must belong to the same linked list.\n */\nstatic inline void list_bulk_move_tail(struct list_head *head,\n\t\t\t\t       struct list_head *first,\n\t\t\t\t       struct list_head *last)\n{\n\tfirst->prev->next = last->next;\n\tlast->next->prev = first->prev;\n\n\thead->prev->next = first;\n\tfirst->prev = head->prev;\n\n\tlast->next = head;\n\thead->prev = last;\n}\n\n/**\n * list_is_first -- tests whether @list is the first entry in list @head\n * @list: the entry to test\n * @head: the head of the list\n */\nstatic inline int list_is_first(const struct list_head *list,\n\t\t\t\t\tconst struct list_head *head)\n{\n\treturn list->prev == head;\n}\n\n/**\n * list_is_last - tests whether @list is the last entry in list @head\n * @list: the entry to test\n * @head: the head of the list\n */\nstatic inline int list_is_last(const struct list_head *list,\n\t\t\t\tconst struct list_head *head)\n{\n\treturn list->next == head;\n}\n\n/**\n * list_empty - tests whether a list is empty\n * @head: the list to test.\n */\nstatic inline int list_empty(const struct list_head *head)\n{\n\treturn READ_ONCE(head->next) == head;\n}\n\n/**\n * list_del_init_careful - deletes entry from list and reinitialize it.\n * @entry: the element to delete from the list.\n *\n * This is the same as list_del_init(), except designed to be used\n * together with list_empty_careful() in a way to guarantee ordering\n * of other memory operations.\n *\n * Any memory operations done before a list_del_init_careful() are\n * guaranteed to be visible after a list_empty_careful() test.\n */\nstatic inline void list_del_init_careful(struct list_head *entry)\n{\n\t__list_del_entry(entry);\n\tentry->prev = entry;\n\tsmp_store_release(&entry->next, entry);\n}\n\n/**\n * list_empty_careful - tests whether a list is empty and not being modified\n * @head: the list to test\n *\n * Description:\n * tests whether a list is empty _and_ checks that no other CPU might be\n * in the process of modifying either member (next or prev)\n *\n * NOTE: using list_empty_careful() without synchronization\n * can only be safe if the only activity that can happen\n * to the list entry is list_del_init(). Eg. it cannot be used\n * if another CPU could re-list_add() it.\n */\nstatic inline int list_empty_careful(const struct list_head *head)\n{\n\tstruct list_head *next = smp_load_acquire(&head->next);\n\treturn (next == head) && (next == head->prev);\n}\n\n/**\n * list_rotate_left - rotate the list to the left\n * @head: the head of the list\n */\nstatic inline void list_rotate_left(struct list_head *head)\n{\n\tstruct list_head *first;\n\n\tif (!list_empty(head)) {\n\t\tfirst = head->next;\n\t\tlist_move_tail(first, head);\n\t}\n}\n\n/**\n * list_rotate_to_front() - Rotate list to specific item.\n * @list: The desired new front of the list.\n * @head: The head of the list.\n *\n * Rotates list so that @list becomes the new front of the list.\n */\nstatic inline void list_rotate_to_front(struct list_head *list,\n\t\t\t\t\tstruct list_head *head)\n{\n\t/*\n\t * Deletes the list head from the list denoted by @head and\n\t * places it as the tail of @list, this effectively rotates the\n\t * list so that @list is at the front.\n\t */\n\tlist_move_tail(head, list);\n}\n\n/**\n * list_is_singular - tests whether a list has just one entry.\n * @head: the list to test.\n */\nstatic inline int list_is_singular(const struct list_head *head)\n{\n\treturn !list_empty(head) && (head->next == head->prev);\n}\n\nstatic inline void __list_cut_position(struct list_head *list,\n\t\tstruct list_head *head, struct list_head *entry)\n{\n\tstruct list_head *new_first = entry->next;\n\tlist->next = head->next;\n\tlist->next->prev = list;\n\tlist->prev = entry;\n\tentry->next = list;\n\thead->next = new_first;\n\tnew_first->prev = head;\n}\n\n/**\n * list_cut_position - cut a list into two\n * @list: a new list to add all removed entries\n * @head: a list with entries\n * @entry: an entry within head, could be the head itself\n *\tand if so we won't cut the list\n *\n * This helper moves the initial part of @head, up to and\n * including @entry, from @head to @list. You should\n * pass on @entry an element you know is on @head. @list\n * should be an empty list or a list you do not care about\n * losing its data.\n *\n */\nstatic inline void list_cut_position(struct list_head *list,\n\t\tstruct list_head *head, struct list_head *entry)\n{\n\tif (list_empty(head))\n\t\treturn;\n\tif (list_is_singular(head) &&\n\t\t(head->next != entry && head != entry))\n\t\treturn;\n\tif (entry == head)\n\t\tINIT_LIST_HEAD(list);\n\telse\n\t\t__list_cut_position(list, head, entry);\n}\n\n/**\n * list_cut_before - cut a list into two, before given entry\n * @list: a new list to add all removed entries\n * @head: a list with entries\n * @entry: an entry within head, could be the head itself\n *\n * This helper moves the initial part of @head, up to but\n * excluding @entry, from @head to @list.  You should pass\n * in @entry an element you know is on @head.  @list should\n * be an empty list or a list you do not care about losing\n * its data.\n * If @entry == @head, all entries on @head are moved to\n * @list.\n */\nstatic inline void list_cut_before(struct list_head *list,\n\t\t\t\t   struct list_head *head,\n\t\t\t\t   struct list_head *entry)\n{\n\tif (head->next == entry) {\n\t\tINIT_LIST_HEAD(list);\n\t\treturn;\n\t}\n\tlist->next = head->next;\n\tlist->next->prev = list;\n\tlist->prev = entry->prev;\n\tlist->prev->next = list;\n\thead->next = entry;\n\tentry->prev = head;\n}\n\nstatic inline void __list_splice(const struct list_head *list,\n\t\t\t\t struct list_head *prev,\n\t\t\t\t struct list_head *next)\n{\n\tstruct list_head *first = list->next;\n\tstruct list_head *last = list->prev;\n\n\tfirst->prev = prev;\n\tprev->next = first;\n\n\tlast->next = next;\n\tnext->prev = last;\n}\n\n/**\n * list_splice - join two lists, this is designed for stacks\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n */\nstatic inline void list_splice(const struct list_head *list,\n\t\t\t\tstruct list_head *head)\n{\n\tif (!list_empty(list))\n\t\t__list_splice(list, head, head->next);\n}\n\n/**\n * list_splice_tail - join two lists, each list being a queue\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n */\nstatic inline void list_splice_tail(struct list_head *list,\n\t\t\t\tstruct list_head *head)\n{\n\tif (!list_empty(list))\n\t\t__list_splice(list, head->prev, head);\n}\n\n/**\n * list_splice_init - join two lists and reinitialise the emptied list.\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n *\n * The list at @list is reinitialised\n */\nstatic inline void list_splice_init(struct list_head *list,\n\t\t\t\t    struct list_head *head)\n{\n\tif (!list_empty(list)) {\n\t\t__list_splice(list, head, head->next);\n\t\tINIT_LIST_HEAD(list);\n\t}\n}\n\n/**\n * list_splice_tail_init - join two lists and reinitialise the emptied list\n * @list: the new list to add.\n * @head: the place to add it in the first list.\n *\n * Each of the lists is a queue.\n * The list at @list is reinitialised\n */\nstatic inline void list_splice_tail_init(struct list_head *list,\n\t\t\t\t\t struct list_head *head)\n{\n\tif (!list_empty(list)) {\n\t\t__list_splice(list, head->prev, head);\n\t\tINIT_LIST_HEAD(list);\n\t}\n}\n\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n/**\n * list_first_entry - get the first element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_first_entry(ptr, type, member) \\\n\tlist_entry((ptr)->next, type, member)\n\n/**\n * list_last_entry - get the last element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_last_entry(ptr, type, member) \\\n\tlist_entry((ptr)->prev, type, member)\n\n/**\n * list_first_entry_or_null - get the first element from a list\n * @ptr:\tthe list head to take the element from.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n *\n * Note that if the list is empty, it returns NULL.\n */\n#define list_first_entry_or_null(ptr, type, member) ({ \\\n\tstruct list_head *head__ = (ptr); \\\n\tstruct list_head *pos__ = READ_ONCE(head__->next); \\\n\tpos__ != head__ ? list_entry(pos__, type, member) : NULL; \\\n})\n\n/**\n * list_next_entry - get the next element in list\n * @pos:\tthe type * to cursor\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_next_entry(pos, member) \\\n\tlist_entry((pos)->member.next, typeof(*(pos)), member)\n\n/**\n * list_prev_entry - get the prev element in list\n * @pos:\tthe type * to cursor\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_prev_entry(pos, member) \\\n\tlist_entry((pos)->member.prev, typeof(*(pos)), member)\n\n/**\n * list_for_each\t-\titerate over a list\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each(pos, head) \\\n\tfor (pos = (head)->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_continue - continue iteration over a list\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n *\n * Continue to iterate over a list, continuing after the current position.\n */\n#define list_for_each_continue(pos, head) \\\n\tfor (pos = pos->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_prev\t-\titerate over a list backwards\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev(pos, head) \\\n\tfor (pos = (head)->prev; pos != (head); pos = pos->prev)\n\n/**\n * list_for_each_safe - iterate over a list safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->next, n = pos->next; pos != (head); \\\n\t\tpos = n, n = pos->next)\n\n/**\n * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry\n * @pos:\tthe &struct list_head to use as a loop cursor.\n * @n:\t\tanother &struct list_head to use as temporary storage\n * @head:\tthe head for your list.\n */\n#define list_for_each_prev_safe(pos, n, head) \\\n\tfor (pos = (head)->prev, n = pos->prev; \\\n\t     pos != (head); \\\n\t     pos = n, n = pos->prev)\n\n/**\n * list_entry_is_head - test if the entry points to the head of the list\n * @pos:\tthe type * to cursor\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_entry_is_head(pos, head, member)\t\t\t\t\\\n\t(&pos->member == (head))\n\n/**\n * list_for_each_entry\t-\titerate over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member);\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_reverse - iterate backwards over list of given type.\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_for_each_entry_reverse(pos, head, member)\t\t\t\\\n\tfor (pos = list_last_entry(head, typeof(*pos), member);\t\t\\\n\t     !list_entry_is_head(pos, head, member); \t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()\n * @pos:\tthe type * to use as a start point\n * @head:\tthe head of the list\n * @member:\tthe name of the list_head within the struct.\n *\n * Prepares a pos entry for use as a start point in list_for_each_entry_continue().\n */\n#define list_prepare_entry(pos, head, member) \\\n\t((pos) ? : list_entry(head, typeof(*pos), member))\n\n/**\n * list_for_each_entry_continue - continue iteration over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Continue to iterate over list of given type, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue(pos, head, member) \t\t\\\n\tfor (pos = list_next_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_continue_reverse - iterate backwards from the given point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Start to iterate over list of given type backwards, continuing after\n * the current position.\n */\n#define list_for_each_entry_continue_reverse(pos, head, member)\t\t\\\n\tfor (pos = list_prev_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_for_each_entry_from - iterate over list of given type from the current point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate over list of given type, continuing from current position.\n */\n#define list_for_each_entry_from(pos, head, member) \t\t\t\\\n\tfor (; !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_next_entry(pos, member))\n\n/**\n * list_for_each_entry_from_reverse - iterate backwards over list of given type\n *                                    from the current point\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate backwards over list of given type, continuing from current position.\n */\n#define list_for_each_entry_from_reverse(pos, head, member)\t\t\\\n\tfor (; !list_entry_is_head(pos, head, member);\t\t\t\\\n\t     pos = list_prev_entry(pos, member))\n\n/**\n * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_for_each_entry_safe(pos, n, head, member)\t\t\t\\\n\tfor (pos = list_first_entry(head, typeof(*pos), member),\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member); \t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_continue - continue list iteration safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate over list of given type, continuing after current point,\n * safe against removal of list entry.\n */\n#define list_for_each_entry_safe_continue(pos, n, head, member) \t\t\\\n\tfor (pos = list_next_entry(pos, member), \t\t\t\t\\\n\t\tn = list_next_entry(pos, member);\t\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_from - iterate over list from current point safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate over list of given type from current point, safe against\n * removal of list entry.\n */\n#define list_for_each_entry_safe_from(pos, n, head, member) \t\t\t\\\n\tfor (n = list_next_entry(pos, member);\t\t\t\t\t\\\n\t     !list_entry_is_head(pos, head, member);\t\t\t\t\\\n\t     pos = n, n = list_next_entry(n, member))\n\n/**\n * list_for_each_entry_safe_reverse - iterate backwards over list safe against removal\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\tanother type * to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the list_head within the struct.\n *\n * Iterate backwards over list of given type, safe against removal\n * of list entry.\n */\n#define list_for_each_entry_safe_reverse(pos, n, head, member)\t\t\\\n\tfor (pos = list_last_entry(head, typeof(*pos), member),\t\t\\\n\t\tn = list_prev_entry(pos, member);\t\t\t\\\n\t     !list_entry_is_head(pos, head, member); \t\t\t\\\n\t     pos = n, n = list_prev_entry(n, member))\n\n/**\n * list_safe_reset_next - reset a stale list_for_each_entry_safe loop\n * @pos:\tthe loop cursor used in the list_for_each_entry_safe loop\n * @n:\t\ttemporary storage used in list_for_each_entry_safe\n * @member:\tthe name of the list_head within the struct.\n *\n * list_safe_reset_next is not safe to use in general if the list may be\n * modified concurrently (eg. the lock is dropped in the loop body). An\n * exception to this is if the cursor element (pos) is pinned in the list,\n * and list_safe_reset_next is called after re-taking the lock and before\n * completing the current iteration of the loop body.\n */\n#define list_safe_reset_next(pos, n, member)\t\t\t\t\\\n\tn = list_next_entry(pos, member)\n\n/*\n * Double linked lists with a single pointer list head.\n * Mostly useful for hash tables where the two pointer list head is\n * too wasteful.\n * You lose the ability to access the tail in O(1).\n */\n\n#define HLIST_HEAD_INIT { .first = NULL }\n#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }\n#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)\nstatic inline void INIT_HLIST_NODE(struct hlist_node *h)\n{\n\th->next = NULL;\n\th->pprev = NULL;\n}\n\n/**\n * hlist_unhashed - Has node been removed from list and reinitialized?\n * @h: Node to be checked\n *\n * Not that not all removal functions will leave a node in unhashed\n * state.  For example, hlist_nulls_del_init_rcu() does leave the\n * node in unhashed state, but hlist_nulls_del() does not.\n */\nstatic inline int hlist_unhashed(const struct hlist_node *h)\n{\n\treturn !h->pprev;\n}\n\n/**\n * hlist_unhashed_lockless - Version of hlist_unhashed for lockless use\n * @h: Node to be checked\n *\n * This variant of hlist_unhashed() must be used in lockless contexts\n * to avoid potential load-tearing.  The READ_ONCE() is paired with the\n * various WRITE_ONCE() in hlist helpers that are defined below.\n */\nstatic inline int hlist_unhashed_lockless(const struct hlist_node *h)\n{\n\treturn !READ_ONCE(h->pprev);\n}\n\n/**\n * hlist_empty - Is the specified hlist_head structure an empty hlist?\n * @h: Structure to check.\n */\nstatic inline int hlist_empty(const struct hlist_head *h)\n{\n\treturn !READ_ONCE(h->first);\n}\n\nstatic inline void __hlist_del(struct hlist_node *n)\n{\n\tstruct hlist_node *next = n->next;\n\tstruct hlist_node **pprev = n->pprev;\n\n\tWRITE_ONCE(*pprev, next);\n\tif (next)\n\t\tWRITE_ONCE(next->pprev, pprev);\n}\n\n/**\n * hlist_del - Delete the specified hlist_node from its list\n * @n: Node to delete.\n *\n * Note that this function leaves the node in hashed state.  Use\n * hlist_del_init() or similar instead to unhash @n.\n */\nstatic inline void hlist_del(struct hlist_node *n)\n{\n\t__hlist_del(n);\n\tn->next = LIST_POISON1;\n\tn->pprev = LIST_POISON2;\n}\n\n/**\n * hlist_del_init - Delete the specified hlist_node from its list and initialize\n * @n: Node to delete.\n *\n * Note that this function leaves the node in unhashed state.\n */\nstatic inline void hlist_del_init(struct hlist_node *n)\n{\n\tif (!hlist_unhashed(n)) {\n\t\t__hlist_del(n);\n\t\tINIT_HLIST_NODE(n);\n\t}\n}\n\n/**\n * hlist_add_head - add a new entry at the beginning of the hlist\n * @n: new entry to be added\n * @h: hlist head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)\n{\n\tstruct hlist_node *first = h->first;\n\tWRITE_ONCE(n->next, first);\n\tif (first)\n\t\tWRITE_ONCE(first->pprev, &n->next);\n\tWRITE_ONCE(h->first, n);\n\tWRITE_ONCE(n->pprev, &h->first);\n}\n\n/**\n * hlist_add_before - add a new entry before the one specified\n * @n: new entry to be added\n * @next: hlist node to add it before, which must be non-NULL\n */\nstatic inline void hlist_add_before(struct hlist_node *n,\n\t\t\t\t    struct hlist_node *next)\n{\n\tWRITE_ONCE(n->pprev, next->pprev);\n\tWRITE_ONCE(n->next, next);\n\tWRITE_ONCE(next->pprev, &n->next);\n\tWRITE_ONCE(*(n->pprev), n);\n}\n\n/**\n * hlist_add_behind - add a new entry after the one specified\n * @n: new entry to be added\n * @prev: hlist node to add it after, which must be non-NULL\n */\nstatic inline void hlist_add_behind(struct hlist_node *n,\n\t\t\t\t    struct hlist_node *prev)\n{\n\tWRITE_ONCE(n->next, prev->next);\n\tWRITE_ONCE(prev->next, n);\n\tWRITE_ONCE(n->pprev, &prev->next);\n\n\tif (n->next)\n\t\tWRITE_ONCE(n->next->pprev, &n->next);\n}\n\n/**\n * hlist_add_fake - create a fake hlist consisting of a single headless node\n * @n: Node to make a fake list out of\n *\n * This makes @n appear to be its own predecessor on a headless hlist.\n * The point of this is to allow things like hlist_del() to work correctly\n * in cases where there is no list.\n */\nstatic inline void hlist_add_fake(struct hlist_node *n)\n{\n\tn->pprev = &n->next;\n}\n\n/**\n * hlist_fake: Is this node a fake hlist?\n * @h: Node to check for being a self-referential fake hlist.\n */\nstatic inline bool hlist_fake(struct hlist_node *h)\n{\n\treturn h->pprev == &h->next;\n}\n\n/**\n * hlist_is_singular_node - is node the only element of the specified hlist?\n * @n: Node to check for singularity.\n * @h: Header for potentially singular list.\n *\n * Check whether the node is the only node of the head without\n * accessing head, thus avoiding unnecessary cache misses.\n */\nstatic inline bool\nhlist_is_singular_node(struct hlist_node *n, struct hlist_head *h)\n{\n\treturn !n->next && n->pprev == &h->first;\n}\n\n/**\n * hlist_move_list - Move an hlist\n * @old: hlist_head for old list.\n * @new: hlist_head for new list.\n *\n * Move a list from one list head to another. Fixup the pprev\n * reference of the first entry if it exists.\n */\nstatic inline void hlist_move_list(struct hlist_head *old,\n\t\t\t\t   struct hlist_head *new)\n{\n\tnew->first = old->first;\n\tif (new->first)\n\t\tnew->first->pprev = &new->first;\n\told->first = NULL;\n}\n\n#define hlist_entry(ptr, type, member) container_of(ptr,type,member)\n\n#define hlist_for_each(pos, head) \\\n\tfor (pos = (head)->first; pos ; pos = pos->next)\n\n#define hlist_for_each_safe(pos, n, head) \\\n\tfor (pos = (head)->first; pos && ({ n = pos->next; 1; }); \\\n\t     pos = n)\n\n#define hlist_entry_safe(ptr, type, member) \\\n\t({ typeof(ptr) ____ptr = (ptr); \\\n\t   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \\\n\t})\n\n/**\n * hlist_for_each_entry\t- iterate over list of given type\n * @pos:\tthe type * to use as a loop cursor.\n * @head:\tthe head for your list.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\\\n\t     pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\n\n/**\n * hlist_for_each_entry_continue - iterate over a hlist continuing after current point\n * @pos:\tthe type * to use as a loop cursor.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry_continue(pos, member)\t\t\t\\\n\tfor (pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member);\\\n\t     pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\n\n/**\n * hlist_for_each_entry_from - iterate over a hlist continuing from current point\n * @pos:\tthe type * to use as a loop cursor.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry_from(pos, member)\t\t\t\t\\\n\tfor (; pos;\t\t\t\t\t\t\t\\\n\t     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))\n\n/**\n * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry\n * @pos:\tthe type * to use as a loop cursor.\n * @n:\t\ta &struct hlist_node to use as temporary storage\n * @head:\tthe head for your list.\n * @member:\tthe name of the hlist_node within the struct.\n */\n#define hlist_for_each_entry_safe(pos, n, head, member) \t\t\\\n\tfor (pos = hlist_entry_safe((head)->first, typeof(*pos), member);\\\n\t     pos && ({ n = pos->member.next; 1; });\t\t\t\\\n\t     pos = hlist_entry_safe(n, typeof(*pos), member))\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 6, "file": 1, "line": 813}, "message": "Assuming 'share_irqs' is 0"}, {"location": {"col": 2, "file": 1, "line": 813}, "message": "Taking false branch"}, {"location": {"col": 14, "file": 1, "line": 816}, "message": "Assuming 'p' is non-null"}, {"location": {"col": 14, "file": 1, "line": 816}, "message": "Left side of '&&' is true"}, {"location": {"col": 19, "file": 1, "line": 816}, "message": "Assuming field 'flags' is not equal to 0"}, {"location": {"col": 2, "file": 1, "line": 816}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 9, "file": 1, "line": 840}, "message": "Calling 'serial8250_register_8250_port'"}, {"location": {"col": 6, "file": 1, "line": 988}, "message": "Assuming field 'uartclk' is not equal to 0"}, {"location": {"col": 2, "file": 1, "line": 988}, "message": "Taking false branch"}, {"location": {"col": 9, "file": 1, "line": 993}, "message": "Calling 'serial8250_find_match_or_unused'"}, {"location": {"col": 14, "file": 1, "line": 925}, "message": "Assuming 'i' is < 'nr_uarts'"}, {"location": {"col": 2, "file": 1, "line": 925}, "message": "Loop condition is true.  Entering loop body"}, {"location": {"col": 7, "file": 1, "line": 926}, "message": "Value assigned to 'uart.port.dev', which participates in a condition later"}, {"location": {"col": 7, "file": 1, "line": 926}, "message": "Value assigned to field 'dev'"}, {"location": {"col": 7, "file": 1, "line": 926}, "message": "Assuming the condition is true"}, {"location": {"col": 3, "file": 1, "line": 926}, "message": "Taking true branch"}, {"location": {"col": 4, "file": 1, "line": 927}, "message": "Returning pointer, which participates in a condition later"}, {"location": {"col": 9, "file": 1, "line": 993}, "message": "Returning from 'serial8250_find_match_or_unused'"}, {"location": {"col": 6, "file": 1, "line": 994}, "message": "'uart' is non-null"}, {"location": {"col": 6, "file": 1, "line": 994}, "message": "Left side of '&&' is true"}, {"location": {"col": 14, "file": 1, "line": 994}, "message": "Assuming field 'type' is not equal to PORT_8250_CIR"}, {"location": {"col": 2, "file": 1, "line": 994}, "message": "Taking true branch"}, {"location": {"col": 7, "file": 1, "line": 997}, "message": "Assuming field 'dev' is null"}, {"location": {"col": 3, "file": 1, "line": 997}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 1, "line": 1024}, "message": "Assuming field 'fifosize' is 0"}, {"location": {"col": 27, "file": 1, "line": 1024}, "message": "Left side of '&&' is false"}, {"location": {"col": 7, "file": 1, "line": 1027}, "message": "Assuming field 'dev' is null"}, {"location": {"col": 3, "file": 1, "line": 1027}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 1, "line": 1034}, "message": "Assuming the condition is false"}, {"location": {"col": 3, "file": 1, "line": 1034}, "message": "Taking false branch"}, {"location": {"col": 27, "file": 1, "line": 1041}, "message": "Passing null pointer value via 1st parameter 'dev'"}, {"location": {"col": 8, "file": 1, "line": 1041}, "message": "Calling 'has_acpi_companion'"}, {"location": {"col": 29, "file": 0, "line": 86}, "message": "Access to field 'fwnode' results in a dereference of a null pointer (loaded from variable 'dev')"}, {"location": {"col": 29, "file": 0, "line": 86}, "message": "Access to field 'fwnode' results in a dereference of a null pointer (loaded from variable 'dev')"}], "macros": [], "notes": [], "path": "/src/include/linux/acpi.h", "reportHash": "eea3a7f9a3c72f493b3dfe281cdc1c96", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 2, "line": 1818}, "message": "Assuming the condition is true"}, {"location": {"col": 2, "file": 2, "line": 1818}, "message": "Taking true branch"}, {"location": {"col": 28, "file": 2, "line": 1819}, "message": "Left side of '&&' is false"}, {"location": {"col": 27, "file": 3, "line": 725}, "message": "expanded from macro 'to_i2c_adapter'"}, {"location": {"col": 61, "file": 4, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 28, "file": 2, "line": 1819}, "message": "Taking false branch"}, {"location": {"col": 27, "file": 3, "line": 725}, "message": "expanded from macro 'to_i2c_adapter'"}, {"location": {"col": 2, "file": 4, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 5, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 6, "line": 320}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 6, "line": 308}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 3, "file": 6, "line": 300}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 28, "file": 2, "line": 1819}, "message": "Loop condition is false.  Exiting loop"}, {"location": {"col": 27, "file": 3, "line": 725}, "message": "expanded from macro 'to_i2c_adapter'"}, {"location": {"col": 2, "file": 4, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 37, "file": 5, "line": 39}, "message": "expanded from macro 'BUILD_BUG_ON_MSG'"}, {"location": {"col": 2, "file": 6, "line": 320}, "message": "expanded from macro 'compiletime_assert'"}, {"location": {"col": 2, "file": 6, "line": 308}, "message": "expanded from macro '_compiletime_assert'"}, {"location": {"col": 2, "file": 6, "line": 298}, "message": "expanded from macro '__compiletime_assert'"}, {"location": {"col": 3, "file": 2, "line": 1819}, "message": "Calling 'i2c_do_del_adapter'"}, {"location": {"col": 2, "file": 2, "line": 1592}, "message": "Left side of '&&' is false"}, {"location": {"col": 13, "file": 7, "line": 715}, "message": "expanded from macro 'list_for_each_entry_safe'"}, {"location": {"col": 2, "file": 7, "line": 522}, "message": "expanded from macro 'list_first_entry'"}, {"location": {"col": 2, "file": 7, "line": 511}, "message": "expanded from macro 'list_entry'"}, {"location": {"col": 61, "file": 4, "line": 694}, "message": "expanded from macro 'container_of'"}, {"location": {"col": 2, "file": 2, "line": 1592}, "message": "Taking false branch"}, {"location": {"col": 13, "file": 7, "line": 715}, "message": "expanded from macro 'list_for_each_entry_safe'"}, {"location": {"col": 2, "file": 7, "line": 522}, "message": "expanded from macro 'list_first_entry'"}, {"location": {"col": 2, "file": 7, "line": 511}, "message": "expanded from macro 'list_entry'"}, {"location": {"col": 22, "file": 0, "line": 668}, "message": "Dereference of null pointer"}], "macros": [], "notes": [], "path": "/src/include/linux/acpi.h", "reportHash": "9ab5859cce95835e4779ff0892a3d6a5", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
