<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/kernel/sched/fair.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * Completely Fair Scheduling (CFS) Class (SCHED_NORMAL/SCHED_BATCH)\n *\n *  Copyright (C) 2007 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>\n *\n *  Interactivity improvements by Mike Galbraith\n *  (C) 2007 Mike Galbraith <efault@gmx.de>\n *\n *  Various enhancements by Dmitry Adamushko.\n *  (C) 2007 Dmitry Adamushko <dmitry.adamushko@gmail.com>\n *\n *  Group scheduling enhancements by Srivatsa Vaddagiri\n *  Copyright IBM Corporation, 2007\n *  Author: Srivatsa Vaddagiri <vatsa@linux.vnet.ibm.com>\n *\n *  Scaled math optimizations by Thomas Gleixner\n *  Copyright (C) 2007, Thomas Gleixner <tglx@linutronix.de>\n *\n *  Adaptive scheduling granularity, math enhancements by Peter Zijlstra\n *  Copyright (C) 2007 Red Hat, Inc., Peter Zijlstra\n */\n#include \"sched.h\"\n\n/*\n * Targeted preemption latency for CPU-bound tasks:\n *\n * NOTE: this latency value is not the same as the concept of\n * 'timeslice length' - timeslices in CFS are of variable length\n * and have no persistent notion like in traditional, time-slice\n * based scheduling concepts.\n *\n * (to see the precise effective timeslice length of your workload,\n *  run vmstat and monitor the context-switches (cs) field)\n *\n * (default: 6ms * (1 + ilog(ncpus)), units: nanoseconds)\n */\nunsigned int sysctl_sched_latency\t\t\t= 6000000ULL;\nstatic unsigned int normalized_sysctl_sched_latency\t= 6000000ULL;\n\n/*\n * The initial- and re-scaling of tunables is configurable\n *\n * Options are:\n *\n *   SCHED_TUNABLESCALING_NONE - unscaled, always *1\n *   SCHED_TUNABLESCALING_LOG - scaled logarithmical, *1+ilog(ncpus)\n *   SCHED_TUNABLESCALING_LINEAR - scaled linear, *ncpus\n *\n * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))\n */\nenum sched_tunable_scaling sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;\n\n/*\n * Minimal preemption granularity for CPU-bound tasks:\n *\n * (default: 0.75 msec * (1 + ilog(ncpus)), units: nanoseconds)\n */\nunsigned int sysctl_sched_min_granularity\t\t\t= 750000ULL;\nstatic unsigned int normalized_sysctl_sched_min_granularity\t= 750000ULL;\n\n/*\n * This value is kept at sysctl_sched_latency/sysctl_sched_min_granularity\n */\nstatic unsigned int sched_nr_latency = 8;\n\n/*\n * After fork, child runs first. If set to 0 (default) then\n * parent will (try to) run first.\n */\nunsigned int sysctl_sched_child_runs_first __read_mostly;\n\n/*\n * SCHED_OTHER wake-up granularity.\n *\n * This option delays the preemption effects of decoupled workloads\n * and reduces their over-scheduling. Synchronous workloads will still\n * have immediate wakeup/sleep latencies.\n *\n * (default: 1 msec * (1 + ilog(ncpus)), units: nanoseconds)\n */\nunsigned int sysctl_sched_wakeup_granularity\t\t\t= 1000000UL;\nstatic unsigned int normalized_sysctl_sched_wakeup_granularity\t= 1000000UL;\n\nconst_debug unsigned int sysctl_sched_migration_cost\t= 500000UL;\n\nint sched_thermal_decay_shift;\nstatic int __init setup_sched_thermal_decay_shift(char *str)\n{\n\tint _shift = 0;\n\n\tif (kstrtoint(str, 0, &_shift))\n\t\tpr_warn(\"Unable to set scheduler thermal pressure decay shift parameter\\n\");\n\n\tsched_thermal_decay_shift = clamp(_shift, 0, 10);\n\treturn 1;\n}\n__setup(\"sched_thermal_decay_shift=\", setup_sched_thermal_decay_shift);\n\n#ifdef CONFIG_SMP\n/*\n * For asym packing, by default the lower numbered CPU has higher priority.\n */\nint __weak arch_asym_cpu_priority(int cpu)\n{\n\treturn -cpu;\n}\n\n/*\n * The margin used when comparing utilization with CPU capacity.\n *\n * (default: ~20%)\n */\n#define fits_capacity(cap, max)\t((cap) * 1280 < (max) * 1024)\n\n#endif\n\n#ifdef CONFIG_CFS_BANDWIDTH\n/*\n * Amount of runtime to allocate from global (tg) to local (per-cfs_rq) pool\n * each time a cfs_rq requests quota.\n *\n * Note: in the case that the slice exceeds the runtime remaining (either due\n * to consumption or the quota being specified to be smaller than the slice)\n * we will always only issue the remaining available time.\n *\n * (default: 5 msec, units: microseconds)\n */\nunsigned int sysctl_sched_cfs_bandwidth_slice\t\t= 5000UL;\n#endif\n\nstatic inline void update_load_add(struct load_weight *lw, unsigned long inc)\n{\n\tlw->weight += inc;\n\tlw->inv_weight = 0;\n}\n\nstatic inline void update_load_sub(struct load_weight *lw, unsigned long dec)\n{\n\tlw->weight -= dec;\n\tlw->inv_weight = 0;\n}\n\nstatic inline void update_load_set(struct load_weight *lw, unsigned long w)\n{\n\tlw->weight = w;\n\tlw->inv_weight = 0;\n}\n\n/*\n * Increase the granularity value when there are more CPUs,\n * because with more CPUs the 'effective latency' as visible\n * to users decreases. But the relationship is not linear,\n * so pick a second-best guess by going with the log2 of the\n * number of CPUs.\n *\n * This idea comes from the SD scheduler of Con Kolivas:\n */\nstatic unsigned int get_update_sysctl_factor(void)\n{\n\tunsigned int cpus = min_t(unsigned int, num_online_cpus(), 8);\n\tunsigned int factor;\n\n\tswitch (sysctl_sched_tunable_scaling) {\n\tcase SCHED_TUNABLESCALING_NONE:\n\t\tfactor = 1;\n\t\tbreak;\n\tcase SCHED_TUNABLESCALING_LINEAR:\n\t\tfactor = cpus;\n\t\tbreak;\n\tcase SCHED_TUNABLESCALING_LOG:\n\tdefault:\n\t\tfactor = 1 + ilog2(cpus);\n\t\tbreak;\n\t}\n\n\treturn factor;\n}\n\nstatic void update_sysctl(void)\n{\n\tunsigned int factor = get_update_sysctl_factor();\n\n#define SET_SYSCTL(name) \\\n\t(sysctl_##name = (factor) * normalized_sysctl_##name)\n\tSET_SYSCTL(sched_min_granularity);\n\tSET_SYSCTL(sched_latency);\n\tSET_SYSCTL(sched_wakeup_granularity);\n#undef SET_SYSCTL\n}\n\nvoid __init sched_init_granularity(void)\n{\n\tupdate_sysctl();\n}\n\n#define WMULT_CONST\t(~0U)\n#define WMULT_SHIFT\t32\n\nstatic void __update_inv_weight(struct load_weight *lw)\n{\n\tunsigned long w;\n\n\tif (likely(lw->inv_weight))\n\t\treturn;\n\n\tw = scale_load_down(lw->weight);\n\n\tif (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))\n\t\tlw->inv_weight = 1;\n\telse if (unlikely(!w))\n\t\tlw->inv_weight = WMULT_CONST;\n\telse\n\t\tlw->inv_weight = WMULT_CONST / w;\n}\n\n/*\n * delta_exec * weight / lw.weight\n *   OR\n * (delta_exec * (weight * lw->inv_weight)) >> WMULT_SHIFT\n *\n * Either weight := NICE_0_LOAD and lw \\e sched_prio_to_wmult[], in which case\n * we're guaranteed shift stays positive because inv_weight is guaranteed to\n * fit 32 bits, and NICE_0_LOAD gives another 10 bits; therefore shift >= 22.\n *\n * Or, weight =< lw.weight (because lw.weight is the runqueue weight), thus\n * weight/lw.weight <= 1, and therefore our shift will also be positive.\n */\nstatic u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw)\n{\n\tu64 fact = scale_load_down(weight);\n\tint shift = WMULT_SHIFT;\n\n\t__update_inv_weight(lw);\n\n\tif (unlikely(fact >> 32)) {\n\t\twhile (fact >> 32) {\n\t\t\tfact >>= 1;\n\t\t\tshift--;\n\t\t}\n\t}\n\n\tfact = mul_u32_u32(fact, lw->inv_weight);\n\n\twhile (fact >> 32) {\n\t\tfact >>= 1;\n\t\tshift--;\n\t}\n\n\treturn mul_u64_u32_shr(delta_exec, fact, shift);\n}\n\n\nconst struct sched_class fair_sched_class;\n\n/**************************************************************\n * CFS operations on generic schedulable entities:\n */\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\nstatic inline struct task_struct *task_of(struct sched_entity *se)\n{\n\tSCHED_WARN_ON(!entity_is_task(se));\n\treturn container_of(se, struct task_struct, se);\n}\n\n/* Walk up scheduling entities hierarchy */\n#define for_each_sched_entity(se) \\\n\t\tfor (; se; se = se->parent)\n\nstatic inline struct cfs_rq *task_cfs_rq(struct task_struct *p)\n{\n\treturn p->se.cfs_rq;\n}\n\n/* runqueue on which this entity is (to be) queued */\nstatic inline struct cfs_rq *cfs_rq_of(struct sched_entity *se)\n{\n\treturn se->cfs_rq;\n}\n\n/* runqueue \"owned\" by this group */\nstatic inline struct cfs_rq *group_cfs_rq(struct sched_entity *grp)\n{\n\treturn grp->my_q;\n}\n\nstatic inline void cfs_rq_tg_path(struct cfs_rq *cfs_rq, char *path, int len)\n{\n\tif (!path)\n\t\treturn;\n\n\tif (cfs_rq && task_group_is_autogroup(cfs_rq->tg))\n\t\tautogroup_path(cfs_rq->tg, path, len);\n\telse if (cfs_rq && cfs_rq->tg->css.cgroup)\n\t\tcgroup_path(cfs_rq->tg->css.cgroup, path, len);\n\telse\n\t\tstrlcpy(path, \"(null)\", len);\n}\n\nstatic inline bool list_add_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\tint cpu = cpu_of(rq);\n\n\tif (cfs_rq->on_list)\n\t\treturn rq->tmp_alone_branch == &rq->leaf_cfs_rq_list;\n\n\tcfs_rq->on_list = 1;\n\n\t/*\n\t * Ensure we either appear before our parent (if already\n\t * enqueued) or force our parent to appear after us when it is\n\t * enqueued. The fact that we always enqueue bottom-up\n\t * reduces this to two cases and a special case for the root\n\t * cfs_rq. Furthermore, it also means that we will always reset\n\t * tmp_alone_branch either when the branch is connected\n\t * to a tree or when we reach the top of the tree\n\t */\n\tif (cfs_rq->tg->parent &&\n\t    cfs_rq->tg->parent->cfs_rq[cpu]->on_list) {\n\t\t/*\n\t\t * If parent is already on the list, we add the child\n\t\t * just before. Thanks to circular linked property of\n\t\t * the list, this means to put the child at the tail\n\t\t * of the list that starts by parent.\n\t\t */\n\t\tlist_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t&(cfs_rq->tg->parent->cfs_rq[cpu]->leaf_cfs_rq_list));\n\t\t/*\n\t\t * The branch is now connected to its tree so we can\n\t\t * reset tmp_alone_branch to the beginning of the\n\t\t * list.\n\t\t */\n\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\treturn true;\n\t}\n\n\tif (!cfs_rq->tg->parent) {\n\t\t/*\n\t\t * cfs rq without parent should be put\n\t\t * at the tail of the list.\n\t\t */\n\t\tlist_add_tail_rcu(&cfs_rq->leaf_cfs_rq_list,\n\t\t\t&rq->leaf_cfs_rq_list);\n\t\t/*\n\t\t * We have reach the top of a tree so we can reset\n\t\t * tmp_alone_branch to the beginning of the list.\n\t\t */\n\t\trq->tmp_alone_branch = &rq->leaf_cfs_rq_list;\n\t\treturn true;\n\t}\n\n\t/*\n\t * The parent has not already been added so we want to\n\t * make sure that it will be put after us.\n\t * tmp_alone_branch points to the begin of the branch\n\t * where we will add parent.\n\t */\n\tlist_add_rcu(&cfs_rq->leaf_cfs_rq_list, rq->tmp_alone_branch);\n\t/*\n\t * update tmp_alone_branch to points to the new begin\n\t * of the branch\n\t */\n\trq->tmp_alone_branch = &cfs_rq->leaf_cfs_rq_list;\n\treturn false;\n}\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->on_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\n\t\t/*\n\t\t * With cfs_rq being unthrottled/throttled during an enqueue,\n\t\t * it can happen the tmp_alone_branch points the a leaf that\n\t\t * we finally want to del. In this case, tmp_alone_branch moves\n\t\t * to the prev element but it will point to rq->leaf_cfs_rq_list\n\t\t * at the end of the enqueue.\n\t\t */\n\t\tif (rq->tmp_alone_branch == &cfs_rq->leaf_cfs_rq_list)\n\t\t\trq->tmp_alone_branch = cfs_rq->leaf_cfs_rq_list.prev;\n\n\t\tlist_del_rcu(&cfs_rq->leaf_cfs_rq_list);\n\t\tcfs_rq->on_list = 0;\n\t}\n}\n\nstatic inline void assert_list_leaf_cfs_rq(struct rq *rq)\n{\n\tSCHED_WARN_ON(rq->tmp_alone_branch != &rq->leaf_cfs_rq_list);\n}\n\n/* Iterate thr' all leaf cfs_rq's on a runqueue */\n#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\t\t\\\n\tlist_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,\t\\\n\t\t\t\t leaf_cfs_rq_list)\n\n/* Do the two (enqueued) entities belong to the same group ? */\nstatic inline struct cfs_rq *\nis_same_group(struct sched_entity *se, struct sched_entity *pse)\n{\n\tif (se->cfs_rq == pse->cfs_rq)\n\t\treturn se->cfs_rq;\n\n\treturn NULL;\n}\n\nstatic inline struct sched_entity *parent_entity(struct sched_entity *se)\n{\n\treturn se->parent;\n}\n\nstatic void\nfind_matching_se(struct sched_entity **se, struct sched_entity **pse)\n{\n\tint se_depth, pse_depth;\n\n\t/*\n\t * preemption test can be made between sibling entities who are in the\n\t * same cfs_rq i.e who have a common parent. Walk up the hierarchy of\n\t * both tasks until we find their ancestors who are siblings of common\n\t * parent.\n\t */\n\n\t/* First walk up until both entities are at same depth */\n\tse_depth = (*se)->depth;\n\tpse_depth = (*pse)->depth;\n\n\twhile (se_depth > pse_depth) {\n\t\tse_depth--;\n\t\t*se = parent_entity(*se);\n\t}\n\n\twhile (pse_depth > se_depth) {\n\t\tpse_depth--;\n\t\t*pse = parent_entity(*pse);\n\t}\n\n\twhile (!is_same_group(*se, *pse)) {\n\t\t*se = parent_entity(*se);\n\t\t*pse = parent_entity(*pse);\n\t}\n}\n\n#else\t/* !CONFIG_FAIR_GROUP_SCHED */\n\nstatic inline struct task_struct *task_of(struct sched_entity *se)\n{\n\treturn container_of(se, struct task_struct, se);\n}\n\n#define for_each_sched_entity(se) \\\n\t\tfor (; se; se = NULL)\n\nstatic inline struct cfs_rq *task_cfs_rq(struct task_struct *p)\n{\n\treturn &task_rq(p)->cfs;\n}\n\nstatic inline struct cfs_rq *cfs_rq_of(struct sched_entity *se)\n{\n\tstruct task_struct *p = task_of(se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->cfs;\n}\n\n/* runqueue \"owned\" by this group */\nstatic inline struct cfs_rq *group_cfs_rq(struct sched_entity *grp)\n{\n\treturn NULL;\n}\n\nstatic inline void cfs_rq_tg_path(struct cfs_rq *cfs_rq, char *path, int len)\n{\n\tif (path)\n\t\tstrlcpy(path, \"(null)\", len);\n}\n\nstatic inline bool list_add_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\treturn true;\n}\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}\n\nstatic inline void assert_list_leaf_cfs_rq(struct rq *rq)\n{\n}\n\n#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\\\n\t\tfor (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)\n\nstatic inline struct sched_entity *parent_entity(struct sched_entity *se)\n{\n\treturn NULL;\n}\n\nstatic inline void\nfind_matching_se(struct sched_entity **se, struct sched_entity **pse)\n{\n}\n\n#endif\t/* CONFIG_FAIR_GROUP_SCHED */\n\nstatic __always_inline\nvoid account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec);\n\n/**************************************************************\n * Scheduling class tree data structure manipulation methods:\n */\n\nstatic inline u64 max_vruntime(u64 max_vruntime, u64 vruntime)\n{\n\ts64 delta = (s64)(vruntime - max_vruntime);\n\tif (delta > 0)\n\t\tmax_vruntime = vruntime;\n\n\treturn max_vruntime;\n}\n\nstatic inline u64 min_vruntime(u64 min_vruntime, u64 vruntime)\n{\n\ts64 delta = (s64)(vruntime - min_vruntime);\n\tif (delta < 0)\n\t\tmin_vruntime = vruntime;\n\n\treturn min_vruntime;\n}\n\nstatic inline int entity_before(struct sched_entity *a,\n\t\t\t\tstruct sched_entity *b)\n{\n\treturn (s64)(a->vruntime - b->vruntime) < 0;\n}\n\nstatic void update_min_vruntime(struct cfs_rq *cfs_rq)\n{\n\tstruct sched_entity *curr = cfs_rq->curr;\n\tstruct rb_node *leftmost = rb_first_cached(&cfs_rq->tasks_timeline);\n\n\tu64 vruntime = cfs_rq->min_vruntime;\n\n\tif (curr) {\n\t\tif (curr->on_rq)\n\t\t\tvruntime = curr->vruntime;\n\t\telse\n\t\t\tcurr = NULL;\n\t}\n\n\tif (leftmost) { /* non-empty tree */\n\t\tstruct sched_entity *se;\n\t\tse = rb_entry(leftmost, struct sched_entity, run_node);\n\n\t\tif (!curr)\n\t\t\tvruntime = se->vruntime;\n\t\telse\n\t\t\tvruntime = min_vruntime(vruntime, se->vruntime);\n\t}\n\n\t/* ensure we never gain time by being placed backwards. */\n\tcfs_rq->min_vruntime = max_vruntime(cfs_rq->min_vruntime, vruntime);\n#ifndef CONFIG_64BIT\n\tsmp_wmb();\n\tcfs_rq->min_vruntime_copy = cfs_rq->min_vruntime;\n#endif\n}\n\n/*\n * Enqueue an entity into the rb-tree:\n */\nstatic void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tstruct rb_node **link = &cfs_rq->tasks_timeline.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sched_entity *entry;\n\tbool leftmost = true;\n\n\t/*\n\t * Find the right place in the rbtree:\n\t */\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_entity, run_node);\n\t\t/*\n\t\t * We dont care about collisions. Nodes with\n\t\t * the same key stay together.\n\t\t */\n\t\tif (entity_before(se, entry)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&se->run_node, parent, link);\n\trb_insert_color_cached(&se->run_node,\n\t\t\t       &cfs_rq->tasks_timeline, leftmost);\n}\n\nstatic void __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\trb_erase_cached(&se->run_node, &cfs_rq->tasks_timeline);\n}\n\nstruct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&cfs_rq->tasks_timeline);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_entity, run_node);\n}\n\nstatic struct sched_entity *__pick_next_entity(struct sched_entity *se)\n{\n\tstruct rb_node *next = rb_next(&se->run_node);\n\n\tif (!next)\n\t\treturn NULL;\n\n\treturn rb_entry(next, struct sched_entity, run_node);\n}\n\n#ifdef CONFIG_SCHED_DEBUG\nstruct sched_entity *__pick_last_entity(struct cfs_rq *cfs_rq)\n{\n\tstruct rb_node *last = rb_last(&cfs_rq->tasks_timeline.rb_root);\n\n\tif (!last)\n\t\treturn NULL;\n\n\treturn rb_entry(last, struct sched_entity, run_node);\n}\n\n/**************************************************************\n * Scheduling class statistics methods:\n */\n\nint sched_proc_update_handler(struct ctl_table *table, int write,\n\t\tvoid *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tunsigned int factor = get_update_sysctl_factor();\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tsched_nr_latency = DIV_ROUND_UP(sysctl_sched_latency,\n\t\t\t\t\tsysctl_sched_min_granularity);\n\n#define WRT_SYSCTL(name) \\\n\t(normalized_sysctl_##name = sysctl_##name / (factor))\n\tWRT_SYSCTL(sched_min_granularity);\n\tWRT_SYSCTL(sched_latency);\n\tWRT_SYSCTL(sched_wakeup_granularity);\n#undef WRT_SYSCTL\n\n\treturn 0;\n}\n#endif\n\n/*\n * delta /= w\n */\nstatic inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)\n{\n\tif (unlikely(se->load.weight != NICE_0_LOAD))\n\t\tdelta = __calc_delta(delta, NICE_0_LOAD, &se->load);\n\n\treturn delta;\n}\n\n/*\n * The idea is to set a period in which each task runs once.\n *\n * When there are too many tasks (sched_nr_latency) we have to stretch\n * this period because otherwise the slices get too small.\n *\n * p = (nr <= nl) ? l : l*nr/nl\n */\nstatic u64 __sched_period(unsigned long nr_running)\n{\n\tif (unlikely(nr_running > sched_nr_latency))\n\t\treturn nr_running * sysctl_sched_min_granularity;\n\telse\n\t\treturn sysctl_sched_latency;\n}\n\n/*\n * We calculate the wall-time slice from the period by taking a part\n * proportional to the weight.\n *\n * s = p*P[w/rw]\n */\nstatic u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running + !se->on_rq);\n\n\tfor_each_sched_entity(se) {\n\t\tstruct load_weight *load;\n\t\tstruct load_weight lw;\n\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tload = &cfs_rq->load;\n\n\t\tif (unlikely(!se->on_rq)) {\n\t\t\tlw = cfs_rq->load;\n\n\t\t\tupdate_load_add(&lw, se->load.weight);\n\t\t\tload = &lw;\n\t\t}\n\t\tslice = __calc_delta(slice, se->load.weight, load);\n\t}\n\treturn slice;\n}\n\n/*\n * We calculate the vruntime slice of a to-be-inserted task.\n *\n * vs = s/w\n */\nstatic u64 sched_vslice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn calc_delta_fair(sched_slice(cfs_rq, se), se);\n}\n\n#include \"pelt.h\"\n#ifdef CONFIG_SMP\n\nstatic int select_idle_sibling(struct task_struct *p, int prev_cpu, int cpu);\nstatic unsigned long task_h_load(struct task_struct *p);\nstatic unsigned long capacity_of(int cpu);\n\n/* Give new sched_entity start runnable values to heavy its load in infant time */\nvoid init_entity_runnable_average(struct sched_entity *se)\n{\n\tstruct sched_avg *sa = &se->avg;\n\n\tmemset(sa, 0, sizeof(*sa));\n\n\t/*\n\t * Tasks are initialized with full load to be seen as heavy tasks until\n\t * they get a chance to stabilize to their real load level.\n\t * Group entities are initialized with zero load to reflect the fact that\n\t * nothing has been attached to the task group yet.\n\t */\n\tif (entity_is_task(se))\n\t\tsa->load_avg = scale_load_down(se->load.weight);\n\n\t/* when this task enqueue'ed, it will contribute to its cfs_rq's load_avg */\n}\n\nstatic void attach_entity_cfs_rq(struct sched_entity *se);\n\n/*\n * With new tasks being created, their initial util_avgs are extrapolated\n * based on the cfs_rq's current util_avg:\n *\n *   util_avg = cfs_rq->util_avg / (cfs_rq->load_avg + 1) * se.load.weight\n *\n * However, in many cases, the above util_avg does not give a desired\n * value. Moreover, the sum of the util_avgs may be divergent, such\n * as when the series is a harmonic series.\n *\n * To solve this problem, we also cap the util_avg of successive tasks to\n * only 1/2 of the left utilization budget:\n *\n *   util_avg_cap = (cpu_scale - cfs_rq->avg.util_avg) / 2^n\n *\n * where n denotes the nth task and cpu_scale the CPU capacity.\n *\n * For example, for a CPU with 1024 of capacity, a simplest series from\n * the beginning would be like:\n *\n *  task  util_avg: 512, 256, 128,  64,  32,   16,    8, ...\n * cfs_rq util_avg: 512, 768, 896, 960, 992, 1008, 1016, ...\n *\n * Finally, that extrapolated util_avg is clamped to the cap (util_avg_cap)\n * if util_avg > util_avg_cap.\n */\nvoid post_init_entity_util_avg(struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tstruct sched_avg *sa = &se->avg;\n\tlong cpu_scale = arch_scale_cpu_capacity(cpu_of(rq_of(cfs_rq)));\n\tlong cap = (long)(cpu_scale - cfs_rq->avg.util_avg) / 2;\n\n\tif (cap > 0) {\n\t\tif (cfs_rq->avg.util_avg != 0) {\n\t\t\tsa->util_avg  = cfs_rq->avg.util_avg * se->load.weight;\n\t\t\tsa->util_avg /= (cfs_rq->avg.load_avg + 1);\n\n\t\t\tif (sa->util_avg > cap)\n\t\t\t\tsa->util_avg = cap;\n\t\t} else {\n\t\t\tsa->util_avg = cap;\n\t\t}\n\t}\n\n\tsa->runnable_avg = sa->util_avg;\n\n\tif (p->sched_class != &fair_sched_class) {\n\t\t/*\n\t\t * For !fair tasks do:\n\t\t *\n\t\tupdate_cfs_rq_load_avg(now, cfs_rq);\n\t\tattach_entity_load_avg(cfs_rq, se);\n\t\tswitched_from_fair(rq, p);\n\t\t *\n\t\t * such that the next switched_to_fair() has the\n\t\t * expected state.\n\t\t */\n\t\tse->avg.last_update_time = cfs_rq_clock_pelt(cfs_rq);\n\t\treturn;\n\t}\n\n\tattach_entity_cfs_rq(se);\n}\n\n#else /* !CONFIG_SMP */\nvoid init_entity_runnable_average(struct sched_entity *se)\n{\n}\nvoid post_init_entity_util_avg(struct task_struct *p)\n{\n}\nstatic void update_tg_load_avg(struct cfs_rq *cfs_rq)\n{\n}\n#endif /* CONFIG_SMP */\n\n/*\n * Update the current task's runtime statistics.\n */\nstatic void update_curr(struct cfs_rq *cfs_rq)\n{\n\tstruct sched_entity *curr = cfs_rq->curr;\n\tu64 now = rq_clock_task(rq_of(cfs_rq));\n\tu64 delta_exec;\n\n\tif (unlikely(!curr))\n\t\treturn;\n\n\tdelta_exec = now - curr->exec_start;\n\tif (unlikely((s64)delta_exec <= 0))\n\t\treturn;\n\n\tcurr->exec_start = now;\n\n\tschedstat_set(curr->statistics.exec_max,\n\t\t      max(delta_exec, curr->statistics.exec_max));\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tschedstat_add(cfs_rq->exec_clock, delta_exec);\n\n\tcurr->vruntime += calc_delta_fair(delta_exec, curr);\n\tupdate_min_vruntime(cfs_rq);\n\n\tif (entity_is_task(curr)) {\n\t\tstruct task_struct *curtask = task_of(curr);\n\n\t\ttrace_sched_stat_runtime(curtask, delta_exec, curr->vruntime);\n\t\tcgroup_account_cputime(curtask, delta_exec);\n\t\taccount_group_exec_runtime(curtask, delta_exec);\n\t}\n\n\taccount_cfs_rq_runtime(cfs_rq, delta_exec);\n}\n\nstatic void update_curr_fair(struct rq *rq)\n{\n\tupdate_curr(cfs_rq_of(&rq->curr->se));\n}\n\nstatic inline void\nupdate_stats_wait_start(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 wait_start, prev_wait_start;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\twait_start = rq_clock(rq_of(cfs_rq));\n\tprev_wait_start = schedstat_val(se->statistics.wait_start);\n\n\tif (entity_is_task(se) && task_on_rq_migrating(task_of(se)) &&\n\t    likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(se->statistics.wait_start, wait_start);\n}\n\nstatic inline void\nupdate_stats_wait_end(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tstruct task_struct *p;\n\tu64 delta;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\t/*\n\t * When the sched_schedstat changes from 0 to 1, some sched se\n\t * maybe already in the runqueue, the se->statistics.wait_start\n\t * will be 0.So it will let the delta wrong. We need to avoid this\n\t * scenario.\n\t */\n\tif (unlikely(!schedstat_val(se->statistics.wait_start)))\n\t\treturn;\n\n\tdelta = rq_clock(rq_of(cfs_rq)) - schedstat_val(se->statistics.wait_start);\n\n\tif (entity_is_task(se)) {\n\t\tp = task_of(se);\n\t\tif (task_on_rq_migrating(p)) {\n\t\t\t/*\n\t\t\t * Preserve migrating task's wait time so wait_start\n\t\t\t * time stamp can be adjusted to accumulate wait time\n\t\t\t * prior to migration.\n\t\t\t */\n\t\t\t__schedstat_set(se->statistics.wait_start, delta);\n\t\t\treturn;\n\t\t}\n\t\ttrace_sched_stat_wait(p, delta);\n\t}\n\n\t__schedstat_set(se->statistics.wait_max,\n\t\t      max(schedstat_val(se->statistics.wait_max), delta));\n\t__schedstat_inc(se->statistics.wait_count);\n\t__schedstat_add(se->statistics.wait_sum, delta);\n\t__schedstat_set(se->statistics.wait_start, 0);\n}\n\nstatic inline void\nupdate_stats_enqueue_sleeper(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tstruct task_struct *tsk = NULL;\n\tu64 sleep_start, block_start;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tsleep_start = schedstat_val(se->statistics.sleep_start);\n\tblock_start = schedstat_val(se->statistics.block_start);\n\n\tif (entity_is_task(se))\n\t\ttsk = task_of(se);\n\n\tif (sleep_start) {\n\t\tu64 delta = rq_clock(rq_of(cfs_rq)) - sleep_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(se->statistics.sleep_max)))\n\t\t\t__schedstat_set(se->statistics.sleep_max, delta);\n\n\t\t__schedstat_set(se->statistics.sleep_start, 0);\n\t\t__schedstat_add(se->statistics.sum_sleep_runtime, delta);\n\n\t\tif (tsk) {\n\t\t\taccount_scheduler_latency(tsk, delta >> 10, 1);\n\t\t\ttrace_sched_stat_sleep(tsk, delta);\n\t\t}\n\t}\n\tif (block_start) {\n\t\tu64 delta = rq_clock(rq_of(cfs_rq)) - block_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(se->statistics.block_max)))\n\t\t\t__schedstat_set(se->statistics.block_max, delta);\n\n\t\t__schedstat_set(se->statistics.block_start, 0);\n\t\t__schedstat_add(se->statistics.sum_sleep_runtime, delta);\n\n\t\tif (tsk) {\n\t\t\tif (tsk->in_iowait) {\n\t\t\t\t__schedstat_add(se->statistics.iowait_sum, delta);\n\t\t\t\t__schedstat_inc(se->statistics.iowait_count);\n\t\t\t\ttrace_sched_stat_iowait(tsk, delta);\n\t\t\t}\n\n\t\t\ttrace_sched_stat_blocked(tsk, delta);\n\n\t\t\t/*\n\t\t\t * Blocking time is in units of nanosecs, so shift by\n\t\t\t * 20 to get a milliseconds-range estimation of the\n\t\t\t * amount of time that the task spent sleeping:\n\t\t\t */\n\t\t\tif (unlikely(prof_on == SLEEP_PROFILING)) {\n\t\t\t\tprofile_hits(SLEEP_PROFILING,\n\t\t\t\t\t\t(void *)get_wchan(tsk),\n\t\t\t\t\t\tdelta >> 20);\n\t\t\t}\n\t\t\taccount_scheduler_latency(tsk, delta >> 10, 0);\n\t\t}\n\t}\n}\n\n/*\n * Task is being enqueued - update stats:\n */\nstatic inline void\nupdate_stats_enqueue(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)\n{\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\t/*\n\t * Are we enqueueing a waiting task? (for current tasks\n\t * a dequeue/enqueue event is a NOP)\n\t */\n\tif (se != cfs_rq->curr)\n\t\tupdate_stats_wait_start(cfs_rq, se);\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tupdate_stats_enqueue_sleeper(cfs_rq, se);\n}\n\nstatic inline void\nupdate_stats_dequeue(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)\n{\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\t/*\n\t * Mark the end of the wait period if dequeueing a\n\t * waiting task:\n\t */\n\tif (se != cfs_rq->curr)\n\t\tupdate_stats_wait_end(cfs_rq, se);\n\n\tif ((flags & DEQUEUE_SLEEP) && entity_is_task(se)) {\n\t\tstruct task_struct *tsk = task_of(se);\n\n\t\tif (tsk->state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(se->statistics.sleep_start,\n\t\t\t\t      rq_clock(rq_of(cfs_rq)));\n\t\tif (tsk->state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(se->statistics.block_start,\n\t\t\t\t      rq_clock(rq_of(cfs_rq)));\n\t}\n}\n\n/*\n * We are picking a new current task - update its stats:\n */\nstatic inline void\nupdate_stats_curr_start(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\t/*\n\t * We are starting a new run period:\n\t */\n\tse->exec_start = rq_clock_task(rq_of(cfs_rq));\n}\n\n/**************************************************\n * Scheduling class queueing methods:\n */\n\n#ifdef CONFIG_NUMA_BALANCING\n/*\n * Approximate time to scan a full NUMA task in ms. The task scan period is\n * calculated based on the tasks virtual memory size and\n * numa_balancing_scan_size.\n */\nunsigned int sysctl_numa_balancing_scan_period_min = 1000;\nunsigned int sysctl_numa_balancing_scan_period_max = 60000;\n\n/* Portion of address space to scan in MB */\nunsigned int sysctl_numa_balancing_scan_size = 256;\n\n/* Scan @scan_size MB every @scan_period after an initial @scan_delay in ms */\nunsigned int sysctl_numa_balancing_scan_delay = 1000;\n\nstruct numa_group {\n\trefcount_t refcount;\n\n\tspinlock_t lock; /* nr_tasks, tasks */\n\tint nr_tasks;\n\tpid_t gid;\n\tint active_nodes;\n\n\tstruct rcu_head rcu;\n\tunsigned long total_faults;\n\tunsigned long max_faults_cpu;\n\t/*\n\t * Faults_cpu is used to decide whether memory should move\n\t * towards the CPU. As a consequence, these stats are weighted\n\t * more by CPU use than by memory faults.\n\t */\n\tunsigned long *faults_cpu;\n\tunsigned long faults[];\n};\n\n/*\n * For functions that can be called in multiple contexts that permit reading\n * ->numa_group (see struct task_struct for locking rules).\n */\nstatic struct numa_group *deref_task_numa_group(struct task_struct *p)\n{\n\treturn rcu_dereference_check(p->numa_group, p == current ||\n\t\t(lockdep_is_held(&task_rq(p)->lock) && !READ_ONCE(p->on_cpu)));\n}\n\nstatic struct numa_group *deref_curr_numa_group(struct task_struct *p)\n{\n\treturn rcu_dereference_protected(p->numa_group, p == current);\n}\n\nstatic inline unsigned long group_faults_priv(struct numa_group *ng);\nstatic inline unsigned long group_faults_shared(struct numa_group *ng);\n\nstatic unsigned int task_nr_scan_windows(struct task_struct *p)\n{\n\tunsigned long rss = 0;\n\tunsigned long nr_scan_pages;\n\n\t/*\n\t * Calculations based on RSS as non-present and empty pages are skipped\n\t * by the PTE scanner and NUMA hinting faults should be trapped based\n\t * on resident pages\n\t */\n\tnr_scan_pages = sysctl_numa_balancing_scan_size << (20 - PAGE_SHIFT);\n\trss = get_mm_rss(p->mm);\n\tif (!rss)\n\t\trss = nr_scan_pages;\n\n\trss = round_up(rss, nr_scan_pages);\n\treturn rss / nr_scan_pages;\n}\n\n/* For sanitys sake, never scan more PTEs than MAX_SCAN_WINDOW MB/sec. */\n#define MAX_SCAN_WINDOW 2560\n\nstatic unsigned int task_scan_min(struct task_struct *p)\n{\n\tunsigned int scan_size = READ_ONCE(sysctl_numa_balancing_scan_size);\n\tunsigned int scan, floor;\n\tunsigned int windows = 1;\n\n\tif (scan_size < MAX_SCAN_WINDOW)\n\t\twindows = MAX_SCAN_WINDOW / scan_size;\n\tfloor = 1000 / windows;\n\n\tscan = sysctl_numa_balancing_scan_period_min / task_nr_scan_windows(p);\n\treturn max_t(unsigned int, floor, scan);\n}\n\nstatic unsigned int task_scan_start(struct task_struct *p)\n{\n\tunsigned long smin = task_scan_min(p);\n\tunsigned long period = smin;\n\tstruct numa_group *ng;\n\n\t/* Scale the maximum scan period with the amount of shared memory. */\n\trcu_read_lock();\n\tng = rcu_dereference(p->numa_group);\n\tif (ng) {\n\t\tunsigned long shared = group_faults_shared(ng);\n\t\tunsigned long private = group_faults_priv(ng);\n\n\t\tperiod *= refcount_read(&ng->refcount);\n\t\tperiod *= shared + 1;\n\t\tperiod /= private + shared + 1;\n\t}\n\trcu_read_unlock();\n\n\treturn max(smin, period);\n}\n\nstatic unsigned int task_scan_max(struct task_struct *p)\n{\n\tunsigned long smin = task_scan_min(p);\n\tunsigned long smax;\n\tstruct numa_group *ng;\n\n\t/* Watch for min being lower than max due to floor calculations */\n\tsmax = sysctl_numa_balancing_scan_period_max / task_nr_scan_windows(p);\n\n\t/* Scale the maximum scan period with the amount of shared memory. */\n\tng = deref_curr_numa_group(p);\n\tif (ng) {\n\t\tunsigned long shared = group_faults_shared(ng);\n\t\tunsigned long private = group_faults_priv(ng);\n\t\tunsigned long period = smax;\n\n\t\tperiod *= refcount_read(&ng->refcount);\n\t\tperiod *= shared + 1;\n\t\tperiod /= private + shared + 1;\n\n\t\tsmax = max(smax, period);\n\t}\n\n\treturn max(smin, smax);\n}\n\nstatic void account_numa_enqueue(struct rq *rq, struct task_struct *p)\n{\n\trq->nr_numa_running += (p->numa_preferred_nid != NUMA_NO_NODE);\n\trq->nr_preferred_running += (p->numa_preferred_nid == task_node(p));\n}\n\nstatic void account_numa_dequeue(struct rq *rq, struct task_struct *p)\n{\n\trq->nr_numa_running -= (p->numa_preferred_nid != NUMA_NO_NODE);\n\trq->nr_preferred_running -= (p->numa_preferred_nid == task_node(p));\n}\n\n/* Shared or private faults. */\n#define NR_NUMA_HINT_FAULT_TYPES 2\n\n/* Memory and CPU locality */\n#define NR_NUMA_HINT_FAULT_STATS (NR_NUMA_HINT_FAULT_TYPES * 2)\n\n/* Averaged statistics, and temporary buffers. */\n#define NR_NUMA_HINT_FAULT_BUCKETS (NR_NUMA_HINT_FAULT_STATS * 2)\n\npid_t task_numa_group_id(struct task_struct *p)\n{\n\tstruct numa_group *ng;\n\tpid_t gid = 0;\n\n\trcu_read_lock();\n\tng = rcu_dereference(p->numa_group);\n\tif (ng)\n\t\tgid = ng->gid;\n\trcu_read_unlock();\n\n\treturn gid;\n}\n\n/*\n * The averaged statistics, shared & private, memory & CPU,\n * occupy the first half of the array. The second half of the\n * array is for current counters, which are averaged into the\n * first set by task_numa_placement.\n */\nstatic inline int task_faults_idx(enum numa_faults_stats s, int nid, int priv)\n{\n\treturn NR_NUMA_HINT_FAULT_TYPES * (s * nr_node_ids + nid) + priv;\n}\n\nstatic inline unsigned long task_faults(struct task_struct *p, int nid)\n{\n\tif (!p->numa_faults)\n\t\treturn 0;\n\n\treturn p->numa_faults[task_faults_idx(NUMA_MEM, nid, 0)] +\n\t\tp->numa_faults[task_faults_idx(NUMA_MEM, nid, 1)];\n}\n\nstatic inline unsigned long group_faults(struct task_struct *p, int nid)\n{\n\tstruct numa_group *ng = deref_task_numa_group(p);\n\n\tif (!ng)\n\t\treturn 0;\n\n\treturn ng->faults[task_faults_idx(NUMA_MEM, nid, 0)] +\n\t\tng->faults[task_faults_idx(NUMA_MEM, nid, 1)];\n}\n\nstatic inline unsigned long group_faults_cpu(struct numa_group *group, int nid)\n{\n\treturn group->faults_cpu[task_faults_idx(NUMA_MEM, nid, 0)] +\n\t\tgroup->faults_cpu[task_faults_idx(NUMA_MEM, nid, 1)];\n}\n\nstatic inline unsigned long group_faults_priv(struct numa_group *ng)\n{\n\tunsigned long faults = 0;\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tfaults += ng->faults[task_faults_idx(NUMA_MEM, node, 1)];\n\t}\n\n\treturn faults;\n}\n\nstatic inline unsigned long group_faults_shared(struct numa_group *ng)\n{\n\tunsigned long faults = 0;\n\tint node;\n\n\tfor_each_online_node(node) {\n\t\tfaults += ng->faults[task_faults_idx(NUMA_MEM, node, 0)];\n\t}\n\n\treturn faults;\n}\n\n/*\n * A node triggering more than 1/3 as many NUMA faults as the maximum is\n * considered part of a numa group's pseudo-interleaving set. Migrations\n * between these nodes are slowed down, to allow things to settle down.\n */\n#define ACTIVE_NODE_FRACTION 3\n\nstatic bool numa_is_active_node(int nid, struct numa_group *ng)\n{\n\treturn group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;\n}\n\n/* Handle placement on systems where not all nodes are directly connected. */\nstatic unsigned long score_nearby_nodes(struct task_struct *p, int nid,\n\t\t\t\t\tint maxdist, bool task)\n{\n\tunsigned long score = 0;\n\tint node;\n\n\t/*\n\t * All nodes are directly connected, and the same distance\n\t * from each other. No need for fancy placement algorithms.\n\t */\n\tif (sched_numa_topology_type == NUMA_DIRECT)\n\t\treturn 0;\n\n\t/*\n\t * This code is called for each node, introducing N^2 complexity,\n\t * which should be ok given the number of nodes rarely exceeds 8.\n\t */\n\tfor_each_online_node(node) {\n\t\tunsigned long faults;\n\t\tint dist = node_distance(nid, node);\n\n\t\t/*\n\t\t * The furthest away nodes in the system are not interesting\n\t\t * for placement; nid was already counted.\n\t\t */\n\t\tif (dist == sched_max_numa_distance || node == nid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * On systems with a backplane NUMA topology, compare groups\n\t\t * of nodes, and move tasks towards the group with the most\n\t\t * memory accesses. When comparing two nodes at distance\n\t\t * \"hoplimit\", only nodes closer by than \"hoplimit\" are part\n\t\t * of each group. Skip other nodes.\n\t\t */\n\t\tif (sched_numa_topology_type == NUMA_BACKPLANE &&\n\t\t\t\t\tdist >= maxdist)\n\t\t\tcontinue;\n\n\t\t/* Add up the faults from nearby nodes. */\n\t\tif (task)\n\t\t\tfaults = task_faults(p, node);\n\t\telse\n\t\t\tfaults = group_faults(p, node);\n\n\t\t/*\n\t\t * On systems with a glueless mesh NUMA topology, there are\n\t\t * no fixed \"groups of nodes\". Instead, nodes that are not\n\t\t * directly connected bounce traffic through intermediate\n\t\t * nodes; a numa_group can occupy any set of nodes.\n\t\t * The further away a node is, the less the faults count.\n\t\t * This seems to result in good task placement.\n\t\t */\n\t\tif (sched_numa_topology_type == NUMA_GLUELESS_MESH) {\n\t\t\tfaults *= (sched_max_numa_distance - dist);\n\t\t\tfaults /= (sched_max_numa_distance - LOCAL_DISTANCE);\n\t\t}\n\n\t\tscore += faults;\n\t}\n\n\treturn score;\n}\n\n/*\n * These return the fraction of accesses done by a particular task, or\n * task group, on a particular numa node.  The group weight is given a\n * larger multiplier, in order to group tasks together that are almost\n * evenly spread out between numa nodes.\n */\nstatic inline unsigned long task_weight(struct task_struct *p, int nid,\n\t\t\t\t\tint dist)\n{\n\tunsigned long faults, total_faults;\n\n\tif (!p->numa_faults)\n\t\treturn 0;\n\n\ttotal_faults = p->total_numa_faults;\n\n\tif (!total_faults)\n\t\treturn 0;\n\n\tfaults = task_faults(p, nid);\n\tfaults += score_nearby_nodes(p, nid, dist, true);\n\n\treturn 1000 * faults / total_faults;\n}\n\nstatic inline unsigned long group_weight(struct task_struct *p, int nid,\n\t\t\t\t\t int dist)\n{\n\tstruct numa_group *ng = deref_task_numa_group(p);\n\tunsigned long faults, total_faults;\n\n\tif (!ng)\n\t\treturn 0;\n\n\ttotal_faults = ng->total_faults;\n\n\tif (!total_faults)\n\t\treturn 0;\n\n\tfaults = group_faults(p, nid);\n\tfaults += score_nearby_nodes(p, nid, dist, false);\n\n\treturn 1000 * faults / total_faults;\n}\n\nbool should_numa_migrate_memory(struct task_struct *p, struct page * page,\n\t\t\t\tint src_nid, int dst_cpu)\n{\n\tstruct numa_group *ng = deref_curr_numa_group(p);\n\tint dst_nid = cpu_to_node(dst_cpu);\n\tint last_cpupid, this_cpupid;\n\n\tthis_cpupid = cpu_pid_to_cpupid(dst_cpu, current->pid);\n\tlast_cpupid = page_cpupid_xchg_last(page, this_cpupid);\n\n\t/*\n\t * Allow first faults or private faults to migrate immediately early in\n\t * the lifetime of a task. The magic number 4 is based on waiting for\n\t * two full passes of the \"multi-stage node selection\" test that is\n\t * executed below.\n\t */\n\tif ((p->numa_preferred_nid == NUMA_NO_NODE || p->numa_scan_seq <= 4) &&\n\t    (cpupid_pid_unset(last_cpupid) || cpupid_match_pid(p, last_cpupid)))\n\t\treturn true;\n\n\t/*\n\t * Multi-stage node selection is used in conjunction with a periodic\n\t * migration fault to build a temporal task<->page relation. By using\n\t * a two-stage filter we remove short/unlikely relations.\n\t *\n\t * Using P(p) ~ n_p / n_t as per frequentist probability, we can equate\n\t * a task's usage of a particular page (n_p) per total usage of this\n\t * page (n_t) (in a given time-span) to a probability.\n\t *\n\t * Our periodic faults will sample this probability and getting the\n\t * same result twice in a row, given these samples are fully\n\t * independent, is then given by P(n)^2, provided our sample period\n\t * is sufficiently short compared to the usage pattern.\n\t *\n\t * This quadric squishes small probabilities, making it less likely we\n\t * act on an unlikely task<->page relation.\n\t */\n\tif (!cpupid_pid_unset(last_cpupid) &&\n\t\t\t\tcpupid_to_nid(last_cpupid) != dst_nid)\n\t\treturn false;\n\n\t/* Always allow migrate on private faults */\n\tif (cpupid_match_pid(p, last_cpupid))\n\t\treturn true;\n\n\t/* A shared fault, but p->numa_group has not been set up yet. */\n\tif (!ng)\n\t\treturn true;\n\n\t/*\n\t * Destination node is much more heavily used than the source\n\t * node? Allow migration.\n\t */\n\tif (group_faults_cpu(ng, dst_nid) > group_faults_cpu(ng, src_nid) *\n\t\t\t\t\tACTIVE_NODE_FRACTION)\n\t\treturn true;\n\n\t/*\n\t * Distribute memory according to CPU & memory use on each node,\n\t * with 3/4 hysteresis to avoid unnecessary memory migrations:\n\t *\n\t * faults_cpu(dst)   3   faults_cpu(src)\n\t * --------------- * - > ---------------\n\t * faults_mem(dst)   4   faults_mem(src)\n\t */\n\treturn group_faults_cpu(ng, dst_nid) * group_faults(p, src_nid) * 3 >\n\t       group_faults_cpu(ng, src_nid) * group_faults(p, dst_nid) * 4;\n}\n\n/*\n * 'numa_type' describes the node at the moment of load balancing.\n */\nenum numa_type {\n\t/* The node has spare capacity that can be used to run more tasks.  */\n\tnode_has_spare = 0,\n\t/*\n\t * The node is fully used and the tasks don't compete for more CPU\n\t * cycles. Nevertheless, some tasks might wait before running.\n\t */\n\tnode_fully_busy,\n\t/*\n\t * The node is overloaded and can't provide expected CPU cycles to all\n\t * tasks.\n\t */\n\tnode_overloaded\n};\n\n/* Cached statistics for all CPUs within a node */\nstruct numa_stats {\n\tunsigned long load;\n\tunsigned long runnable;\n\tunsigned long util;\n\t/* Total compute capacity of CPUs on a node */\n\tunsigned long compute_capacity;\n\tunsigned int nr_running;\n\tunsigned int weight;\n\tenum numa_type node_type;\n\tint idle_cpu;\n};\n\nstatic inline bool is_core_idle(int cpu)\n{\n#ifdef CONFIG_SCHED_SMT\n\tint sibling;\n\n\tfor_each_cpu(sibling, cpu_smt_mask(cpu)) {\n\t\tif (cpu == sibling)\n\t\t\tcontinue;\n\n\t\tif (!idle_cpu(cpu))\n\t\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}\n\nstruct task_numa_env {\n\tstruct task_struct *p;\n\n\tint src_cpu, src_nid;\n\tint dst_cpu, dst_nid;\n\n\tstruct numa_stats src_stats, dst_stats;\n\n\tint imbalance_pct;\n\tint dist;\n\n\tstruct task_struct *best_task;\n\tlong best_imp;\n\tint best_cpu;\n};\n\nstatic unsigned long cpu_load(struct rq *rq);\nstatic unsigned long cpu_runnable(struct rq *rq);\nstatic unsigned long cpu_util(int cpu);\nstatic inline long adjust_numa_imbalance(int imbalance,\n\t\t\t\t\tint dst_running, int dst_weight);\n\nstatic inline enum\nnuma_type numa_classify(unsigned int imbalance_pct,\n\t\t\t struct numa_stats *ns)\n{\n\tif ((ns->nr_running > ns->weight) &&\n\t    (((ns->compute_capacity * 100) < (ns->util * imbalance_pct)) ||\n\t     ((ns->compute_capacity * imbalance_pct) < (ns->runnable * 100))))\n\t\treturn node_overloaded;\n\n\tif ((ns->nr_running < ns->weight) ||\n\t    (((ns->compute_capacity * 100) > (ns->util * imbalance_pct)) &&\n\t     ((ns->compute_capacity * imbalance_pct) > (ns->runnable * 100))))\n\t\treturn node_has_spare;\n\n\treturn node_fully_busy;\n}\n\n#ifdef CONFIG_SCHED_SMT\n/* Forward declarations of select_idle_sibling helpers */\nstatic inline bool test_idle_cores(int cpu, bool def);\nstatic inline int numa_idle_core(int idle_core, int cpu)\n{\n\tif (!static_branch_likely(&sched_smt_present) ||\n\t    idle_core >= 0 || !test_idle_cores(cpu, false))\n\t\treturn idle_core;\n\n\t/*\n\t * Prefer cores instead of packing HT siblings\n\t * and triggering future load balancing.\n\t */\n\tif (is_core_idle(cpu))\n\t\tidle_core = cpu;\n\n\treturn idle_core;\n}\n#else\nstatic inline int numa_idle_core(int idle_core, int cpu)\n{\n\treturn idle_core;\n}\n#endif\n\n/*\n * Gather all necessary information to make NUMA balancing placement\n * decisions that are compatible with standard load balancer. This\n * borrows code and logic from update_sg_lb_stats but sharing a\n * common implementation is impractical.\n */\nstatic void update_numa_stats(struct task_numa_env *env,\n\t\t\t      struct numa_stats *ns, int nid,\n\t\t\t      bool find_idle)\n{\n\tint cpu, idle_core = -1;\n\n\tmemset(ns, 0, sizeof(*ns));\n\tns->idle_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_cpu(cpu, cpumask_of_node(nid)) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\n\t\tns->load += cpu_load(rq);\n\t\tns->runnable += cpu_runnable(rq);\n\t\tns->util += cpu_util(cpu);\n\t\tns->nr_running += rq->cfs.h_nr_running;\n\t\tns->compute_capacity += capacity_of(cpu);\n\n\t\tif (find_idle && !rq->nr_running && idle_cpu(cpu)) {\n\t\t\tif (READ_ONCE(rq->numa_migrate_on) ||\n\t\t\t    !cpumask_test_cpu(cpu, env->p->cpus_ptr))\n\t\t\t\tcontinue;\n\n\t\t\tif (ns->idle_cpu == -1)\n\t\t\t\tns->idle_cpu = cpu;\n\n\t\t\tidle_core = numa_idle_core(idle_core, cpu);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tns->weight = cpumask_weight(cpumask_of_node(nid));\n\n\tns->node_type = numa_classify(env->imbalance_pct, ns);\n\n\tif (idle_core >= 0)\n\t\tns->idle_cpu = idle_core;\n}\n\nstatic void task_numa_assign(struct task_numa_env *env,\n\t\t\t     struct task_struct *p, long imp)\n{\n\tstruct rq *rq = cpu_rq(env->dst_cpu);\n\n\t/* Check if run-queue part of active NUMA balance. */\n\tif (env->best_cpu != env->dst_cpu && xchg(&rq->numa_migrate_on, 1)) {\n\t\tint cpu;\n\t\tint start = env->dst_cpu;\n\n\t\t/* Find alternative idle CPU. */\n\t\tfor_each_cpu_wrap(cpu, cpumask_of_node(env->dst_nid), start) {\n\t\t\tif (cpu == env->best_cpu || !idle_cpu(cpu) ||\n\t\t\t    !cpumask_test_cpu(cpu, env->p->cpus_ptr)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tenv->dst_cpu = cpu;\n\t\t\trq = cpu_rq(env->dst_cpu);\n\t\t\tif (!xchg(&rq->numa_migrate_on, 1))\n\t\t\t\tgoto assign;\n\t\t}\n\n\t\t/* Failed to find an alternative idle CPU */\n\t\treturn;\n\t}\n\nassign:\n\t/*\n\t * Clear previous best_cpu/rq numa-migrate flag, since task now\n\t * found a better CPU to move/swap.\n\t */\n\tif (env->best_cpu != -1 && env->best_cpu != env->dst_cpu) {\n\t\trq = cpu_rq(env->best_cpu);\n\t\tWRITE_ONCE(rq->numa_migrate_on, 0);\n\t}\n\n\tif (env->best_task)\n\t\tput_task_struct(env->best_task);\n\tif (p)\n\t\tget_task_struct(p);\n\n\tenv->best_task = p;\n\tenv->best_imp = imp;\n\tenv->best_cpu = env->dst_cpu;\n}\n\nstatic bool load_too_imbalanced(long src_load, long dst_load,\n\t\t\t\tstruct task_numa_env *env)\n{\n\tlong imb, old_imb;\n\tlong orig_src_load, orig_dst_load;\n\tlong src_capacity, dst_capacity;\n\n\t/*\n\t * The load is corrected for the CPU capacity available on each node.\n\t *\n\t * src_load        dst_load\n\t * ------------ vs ---------\n\t * src_capacity    dst_capacity\n\t */\n\tsrc_capacity = env->src_stats.compute_capacity;\n\tdst_capacity = env->dst_stats.compute_capacity;\n\n\timb = abs(dst_load * src_capacity - src_load * dst_capacity);\n\n\torig_src_load = env->src_stats.load;\n\torig_dst_load = env->dst_stats.load;\n\n\told_imb = abs(orig_dst_load * src_capacity - orig_src_load * dst_capacity);\n\n\t/* Would this change make things worse? */\n\treturn (imb > old_imb);\n}\n\n/*\n * Maximum NUMA importance can be 1998 (2*999);\n * SMALLIMP @ 30 would be close to 1998/64.\n * Used to deter task migration.\n */\n#define SMALLIMP\t30\n\n/*\n * This checks if the overall compute and NUMA accesses of the system would\n * be improved if the source tasks was migrated to the target dst_cpu taking\n * into account that it might be best if task running on the dst_cpu should\n * be exchanged with the source task\n */\nstatic bool task_numa_compare(struct task_numa_env *env,\n\t\t\t      long taskimp, long groupimp, bool maymove)\n{\n\tstruct numa_group *cur_ng, *p_ng = deref_curr_numa_group(env->p);\n\tstruct rq *dst_rq = cpu_rq(env->dst_cpu);\n\tlong imp = p_ng ? groupimp : taskimp;\n\tstruct task_struct *cur;\n\tlong src_load, dst_load;\n\tint dist = env->dist;\n\tlong moveimp = imp;\n\tlong load;\n\tbool stopsearch = false;\n\n\tif (READ_ONCE(dst_rq->numa_migrate_on))\n\t\treturn false;\n\n\trcu_read_lock();\n\tcur = rcu_dereference(dst_rq->curr);\n\tif (cur && ((cur->flags & PF_EXITING) || is_idle_task(cur)))\n\t\tcur = NULL;\n\n\t/*\n\t * Because we have preemption enabled we can get migrated around and\n\t * end try selecting ourselves (current == env->p) as a swap candidate.\n\t */\n\tif (cur == env->p) {\n\t\tstopsearch = true;\n\t\tgoto unlock;\n\t}\n\n\tif (!cur) {\n\t\tif (maymove && moveimp >= env->best_imp)\n\t\t\tgoto assign;\n\t\telse\n\t\t\tgoto unlock;\n\t}\n\n\t/* Skip this swap candidate if cannot move to the source cpu. */\n\tif (!cpumask_test_cpu(env->src_cpu, cur->cpus_ptr))\n\t\tgoto unlock;\n\n\t/*\n\t * Skip this swap candidate if it is not moving to its preferred\n\t * node and the best task is.\n\t */\n\tif (env->best_task &&\n\t    env->best_task->numa_preferred_nid == env->src_nid &&\n\t    cur->numa_preferred_nid != env->src_nid) {\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * \"imp\" is the fault differential for the source task between the\n\t * source and destination node. Calculate the total differential for\n\t * the source task and potential destination task. The more negative\n\t * the value is, the more remote accesses that would be expected to\n\t * be incurred if the tasks were swapped.\n\t *\n\t * If dst and source tasks are in the same NUMA group, or not\n\t * in any group then look only at task weights.\n\t */\n\tcur_ng = rcu_dereference(cur->numa_group);\n\tif (cur_ng == p_ng) {\n\t\timp = taskimp + task_weight(cur, env->src_nid, dist) -\n\t\t      task_weight(cur, env->dst_nid, dist);\n\t\t/*\n\t\t * Add some hysteresis to prevent swapping the\n\t\t * tasks within a group over tiny differences.\n\t\t */\n\t\tif (cur_ng)\n\t\t\timp -= imp / 16;\n\t} else {\n\t\t/*\n\t\t * Compare the group weights. If a task is all by itself\n\t\t * (not part of a group), use the task weight instead.\n\t\t */\n\t\tif (cur_ng && p_ng)\n\t\t\timp += group_weight(cur, env->src_nid, dist) -\n\t\t\t       group_weight(cur, env->dst_nid, dist);\n\t\telse\n\t\t\timp += task_weight(cur, env->src_nid, dist) -\n\t\t\t       task_weight(cur, env->dst_nid, dist);\n\t}\n\n\t/* Discourage picking a task already on its preferred node */\n\tif (cur->numa_preferred_nid == env->dst_nid)\n\t\timp -= imp / 16;\n\n\t/*\n\t * Encourage picking a task that moves to its preferred node.\n\t * This potentially makes imp larger than it's maximum of\n\t * 1998 (see SMALLIMP and task_weight for why) but in this\n\t * case, it does not matter.\n\t */\n\tif (cur->numa_preferred_nid == env->src_nid)\n\t\timp += imp / 8;\n\n\tif (maymove && moveimp > imp && moveimp > env->best_imp) {\n\t\timp = moveimp;\n\t\tcur = NULL;\n\t\tgoto assign;\n\t}\n\n\t/*\n\t * Prefer swapping with a task moving to its preferred node over a\n\t * task that is not.\n\t */\n\tif (env->best_task && cur->numa_preferred_nid == env->src_nid &&\n\t    env->best_task->numa_preferred_nid != env->src_nid) {\n\t\tgoto assign;\n\t}\n\n\t/*\n\t * If the NUMA importance is less than SMALLIMP,\n\t * task migration might only result in ping pong\n\t * of tasks and also hurt performance due to cache\n\t * misses.\n\t */\n\tif (imp < SMALLIMP || imp <= env->best_imp + SMALLIMP / 2)\n\t\tgoto unlock;\n\n\t/*\n\t * In the overloaded case, try and keep the load balanced.\n\t */\n\tload = task_h_load(env->p) - task_h_load(cur);\n\tif (!load)\n\t\tgoto assign;\n\n\tdst_load = env->dst_stats.load + load;\n\tsrc_load = env->src_stats.load - load;\n\n\tif (load_too_imbalanced(src_load, dst_load, env))\n\t\tgoto unlock;\n\nassign:\n\t/* Evaluate an idle CPU for a task numa move. */\n\tif (!cur) {\n\t\tint cpu = env->dst_stats.idle_cpu;\n\n\t\t/* Nothing cached so current CPU went idle since the search. */\n\t\tif (cpu < 0)\n\t\t\tcpu = env->dst_cpu;\n\n\t\t/*\n\t\t * If the CPU is no longer truly idle and the previous best CPU\n\t\t * is, keep using it.\n\t\t */\n\t\tif (!idle_cpu(cpu) && env->best_cpu >= 0 &&\n\t\t    idle_cpu(env->best_cpu)) {\n\t\t\tcpu = env->best_cpu;\n\t\t}\n\n\t\tenv->dst_cpu = cpu;\n\t}\n\n\ttask_numa_assign(env, cur, imp);\n\n\t/*\n\t * If a move to idle is allowed because there is capacity or load\n\t * balance improves then stop the search. While a better swap\n\t * candidate may exist, a search is not free.\n\t */\n\tif (maymove && !cur && env->best_cpu >= 0 && idle_cpu(env->best_cpu))\n\t\tstopsearch = true;\n\n\t/*\n\t * If a swap candidate must be identified and the current best task\n\t * moves its preferred node then stop the search.\n\t */\n\tif (!maymove && env->best_task &&\n\t    env->best_task->numa_preferred_nid == env->src_nid) {\n\t\tstopsearch = true;\n\t}\nunlock:\n\trcu_read_unlock();\n\n\treturn stopsearch;\n}\n\nstatic void task_numa_find_cpu(struct task_numa_env *env,\n\t\t\t\tlong taskimp, long groupimp)\n{\n\tbool maymove = false;\n\tint cpu;\n\n\t/*\n\t * If dst node has spare capacity, then check if there is an\n\t * imbalance that would be overruled by the load balancer.\n\t */\n\tif (env->dst_stats.node_type == node_has_spare) {\n\t\tunsigned int imbalance;\n\t\tint src_running, dst_running;\n\n\t\t/*\n\t\t * Would movement cause an imbalance? Note that if src has\n\t\t * more running tasks that the imbalance is ignored as the\n\t\t * move improves the imbalance from the perspective of the\n\t\t * CPU load balancer.\n\t\t * */\n\t\tsrc_running = env->src_stats.nr_running - 1;\n\t\tdst_running = env->dst_stats.nr_running + 1;\n\t\timbalance = max(0, dst_running - src_running);\n\t\timbalance = adjust_numa_imbalance(imbalance, dst_running,\n\t\t\t\t\t\t\tenv->dst_stats.weight);\n\n\t\t/* Use idle CPU if there is no imbalance */\n\t\tif (!imbalance) {\n\t\t\tmaymove = true;\n\t\t\tif (env->dst_stats.idle_cpu >= 0) {\n\t\t\t\tenv->dst_cpu = env->dst_stats.idle_cpu;\n\t\t\t\ttask_numa_assign(env, NULL, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlong src_load, dst_load, load;\n\t\t/*\n\t\t * If the improvement from just moving env->p direction is better\n\t\t * than swapping tasks around, check if a move is possible.\n\t\t */\n\t\tload = task_h_load(env->p);\n\t\tdst_load = env->dst_stats.load + load;\n\t\tsrc_load = env->src_stats.load - load;\n\t\tmaymove = !load_too_imbalanced(src_load, dst_load, env);\n\t}\n\n\tfor_each_cpu(cpu, cpumask_of_node(env->dst_nid)) {\n\t\t/* Skip this CPU if the source task cannot migrate */\n\t\tif (!cpumask_test_cpu(cpu, env->p->cpus_ptr))\n\t\t\tcontinue;\n\n\t\tenv->dst_cpu = cpu;\n\t\tif (task_numa_compare(env, taskimp, groupimp, maymove))\n\t\t\tbreak;\n\t}\n}\n\nstatic int task_numa_migrate(struct task_struct *p)\n{\n\tstruct task_numa_env env = {\n\t\t.p = p,\n\n\t\t.src_cpu = task_cpu(p),\n\t\t.src_nid = task_node(p),\n\n\t\t.imbalance_pct = 112,\n\n\t\t.best_task = NULL,\n\t\t.best_imp = 0,\n\t\t.best_cpu = -1,\n\t};\n\tunsigned long taskweight, groupweight;\n\tstruct sched_domain *sd;\n\tlong taskimp, groupimp;\n\tstruct numa_group *ng;\n\tstruct rq *best_rq;\n\tint nid, ret, dist;\n\n\t/*\n\t * Pick the lowest SD_NUMA domain, as that would have the smallest\n\t * imbalance and would be the first to start moving tasks about.\n\t *\n\t * And we want to avoid any moving of tasks about, as that would create\n\t * random movement of tasks -- counter the numa conditions we're trying\n\t * to satisfy here.\n\t */\n\trcu_read_lock();\n\tsd = rcu_dereference(per_cpu(sd_numa, env.src_cpu));\n\tif (sd)\n\t\tenv.imbalance_pct = 100 + (sd->imbalance_pct - 100) / 2;\n\trcu_read_unlock();\n\n\t/*\n\t * Cpusets can break the scheduler domain tree into smaller\n\t * balance domains, some of which do not cross NUMA boundaries.\n\t * Tasks that are \"trapped\" in such domains cannot be migrated\n\t * elsewhere, so there is no point in (re)trying.\n\t */\n\tif (unlikely(!sd)) {\n\t\tsched_setnuma(p, task_node(p));\n\t\treturn -EINVAL;\n\t}\n\n\tenv.dst_nid = p->numa_preferred_nid;\n\tdist = env.dist = node_distance(env.src_nid, env.dst_nid);\n\ttaskweight = task_weight(p, env.src_nid, dist);\n\tgroupweight = group_weight(p, env.src_nid, dist);\n\tupdate_numa_stats(&env, &env.src_stats, env.src_nid, false);\n\ttaskimp = task_weight(p, env.dst_nid, dist) - taskweight;\n\tgroupimp = group_weight(p, env.dst_nid, dist) - groupweight;\n\tupdate_numa_stats(&env, &env.dst_stats, env.dst_nid, true);\n\n\t/* Try to find a spot on the preferred nid. */\n\ttask_numa_find_cpu(&env, taskimp, groupimp);\n\n\t/*\n\t * Look at other nodes in these cases:\n\t * - there is no space available on the preferred_nid\n\t * - the task is part of a numa_group that is interleaved across\n\t *   multiple NUMA nodes; in order to better consolidate the group,\n\t *   we need to check other locations.\n\t */\n\tng = deref_curr_numa_group(p);\n\tif (env.best_cpu == -1 || (ng && ng->active_nodes > 1)) {\n\t\tfor_each_online_node(nid) {\n\t\t\tif (nid == env.src_nid || nid == p->numa_preferred_nid)\n\t\t\t\tcontinue;\n\n\t\t\tdist = node_distance(env.src_nid, env.dst_nid);\n\t\t\tif (sched_numa_topology_type == NUMA_BACKPLANE &&\n\t\t\t\t\t\tdist != env.dist) {\n\t\t\t\ttaskweight = task_weight(p, env.src_nid, dist);\n\t\t\t\tgroupweight = group_weight(p, env.src_nid, dist);\n\t\t\t}\n\n\t\t\t/* Only consider nodes where both task and groups benefit */\n\t\t\ttaskimp = task_weight(p, nid, dist) - taskweight;\n\t\t\tgroupimp = group_weight(p, nid, dist) - groupweight;\n\t\t\tif (taskimp < 0 && groupimp < 0)\n\t\t\t\tcontinue;\n\n\t\t\tenv.dist = dist;\n\t\t\tenv.dst_nid = nid;\n\t\t\tupdate_numa_stats(&env, &env.dst_stats, env.dst_nid, true);\n\t\t\ttask_numa_find_cpu(&env, taskimp, groupimp);\n\t\t}\n\t}\n\n\t/*\n\t * If the task is part of a workload that spans multiple NUMA nodes,\n\t * and is migrating into one of the workload's active nodes, remember\n\t * this node as the task's preferred numa node, so the workload can\n\t * settle down.\n\t * A task that migrated to a second choice node will be better off\n\t * trying for a better one later. Do not set the preferred node here.\n\t */\n\tif (ng) {\n\t\tif (env.best_cpu == -1)\n\t\t\tnid = env.src_nid;\n\t\telse\n\t\t\tnid = cpu_to_node(env.best_cpu);\n\n\t\tif (nid != p->numa_preferred_nid)\n\t\t\tsched_setnuma(p, nid);\n\t}\n\n\t/* No better CPU than the current one was found. */\n\tif (env.best_cpu == -1) {\n\t\ttrace_sched_stick_numa(p, env.src_cpu, NULL, -1);\n\t\treturn -EAGAIN;\n\t}\n\n\tbest_rq = cpu_rq(env.best_cpu);\n\tif (env.best_task == NULL) {\n\t\tret = migrate_task_to(p, env.best_cpu);\n\t\tWRITE_ONCE(best_rq->numa_migrate_on, 0);\n\t\tif (ret != 0)\n\t\t\ttrace_sched_stick_numa(p, env.src_cpu, NULL, env.best_cpu);\n\t\treturn ret;\n\t}\n\n\tret = migrate_swap(p, env.best_task, env.best_cpu, env.src_cpu);\n\tWRITE_ONCE(best_rq->numa_migrate_on, 0);\n\n\tif (ret != 0)\n\t\ttrace_sched_stick_numa(p, env.src_cpu, env.best_task, env.best_cpu);\n\tput_task_struct(env.best_task);\n\treturn ret;\n}\n\n/* Attempt to migrate a task to a CPU on the preferred node. */\nstatic void numa_migrate_preferred(struct task_struct *p)\n{\n\tunsigned long interval = HZ;\n\n\t/* This task has no NUMA fault statistics yet */\n\tif (unlikely(p->numa_preferred_nid == NUMA_NO_NODE || !p->numa_faults))\n\t\treturn;\n\n\t/* Periodically retry migrating the task to the preferred node */\n\tinterval = min(interval, msecs_to_jiffies(p->numa_scan_period) / 16);\n\tp->numa_migrate_retry = jiffies + interval;\n\n\t/* Success if task is already running on preferred CPU */\n\tif (task_node(p) == p->numa_preferred_nid)\n\t\treturn;\n\n\t/* Otherwise, try migrate to a CPU on the preferred node */\n\ttask_numa_migrate(p);\n}\n\n/*\n * Find out how many nodes on the workload is actively running on. Do this by\n * tracking the nodes from which NUMA hinting faults are triggered. This can\n * be different from the set of nodes where the workload's memory is currently\n * located.\n */\nstatic void numa_group_count_active_nodes(struct numa_group *numa_group)\n{\n\tunsigned long faults, max_faults = 0;\n\tint nid, active_nodes = 0;\n\n\tfor_each_online_node(nid) {\n\t\tfaults = group_faults_cpu(numa_group, nid);\n\t\tif (faults > max_faults)\n\t\t\tmax_faults = faults;\n\t}\n\n\tfor_each_online_node(nid) {\n\t\tfaults = group_faults_cpu(numa_group, nid);\n\t\tif (faults * ACTIVE_NODE_FRACTION > max_faults)\n\t\t\tactive_nodes++;\n\t}\n\n\tnuma_group->max_faults_cpu = max_faults;\n\tnuma_group->active_nodes = active_nodes;\n}\n\n/*\n * When adapting the scan rate, the period is divided into NUMA_PERIOD_SLOTS\n * increments. The more local the fault statistics are, the higher the scan\n * period will be for the next scan window. If local/(local+remote) ratio is\n * below NUMA_PERIOD_THRESHOLD (where range of ratio is 1..NUMA_PERIOD_SLOTS)\n * the scan period will decrease. Aim for 70% local accesses.\n */\n#define NUMA_PERIOD_SLOTS 10\n#define NUMA_PERIOD_THRESHOLD 7\n\n/*\n * Increase the scan period (slow down scanning) if the majority of\n * our memory is already on our local node, or if the majority of\n * the page accesses are shared with other processes.\n * Otherwise, decrease the scan period.\n */\nstatic void update_task_scan_period(struct task_struct *p,\n\t\t\tunsigned long shared, unsigned long private)\n{\n\tunsigned int period_slot;\n\tint lr_ratio, ps_ratio;\n\tint diff;\n\n\tunsigned long remote = p->numa_faults_locality[0];\n\tunsigned long local = p->numa_faults_locality[1];\n\n\t/*\n\t * If there were no record hinting faults then either the task is\n\t * completely idle or all activity is areas that are not of interest\n\t * to automatic numa balancing. Related to that, if there were failed\n\t * migration then it implies we are migrating too quickly or the local\n\t * node is overloaded. In either case, scan slower\n\t */\n\tif (local + shared == 0 || p->numa_faults_locality[2]) {\n\t\tp->numa_scan_period = min(p->numa_scan_period_max,\n\t\t\tp->numa_scan_period << 1);\n\n\t\tp->mm->numa_next_scan = jiffies +\n\t\t\tmsecs_to_jiffies(p->numa_scan_period);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Prepare to scale scan period relative to the current period.\n\t *\t == NUMA_PERIOD_THRESHOLD scan period stays the same\n\t *       <  NUMA_PERIOD_THRESHOLD scan period decreases (scan faster)\n\t *\t >= NUMA_PERIOD_THRESHOLD scan period increases (scan slower)\n\t */\n\tperiod_slot = DIV_ROUND_UP(p->numa_scan_period, NUMA_PERIOD_SLOTS);\n\tlr_ratio = (local * NUMA_PERIOD_SLOTS) / (local + remote);\n\tps_ratio = (private * NUMA_PERIOD_SLOTS) / (private + shared);\n\n\tif (ps_ratio >= NUMA_PERIOD_THRESHOLD) {\n\t\t/*\n\t\t * Most memory accesses are local. There is no need to\n\t\t * do fast NUMA scanning, since memory is already local.\n\t\t */\n\t\tint slot = ps_ratio - NUMA_PERIOD_THRESHOLD;\n\t\tif (!slot)\n\t\t\tslot = 1;\n\t\tdiff = slot * period_slot;\n\t} else if (lr_ratio >= NUMA_PERIOD_THRESHOLD) {\n\t\t/*\n\t\t * Most memory accesses are shared with other tasks.\n\t\t * There is no point in continuing fast NUMA scanning,\n\t\t * since other tasks may just move the memory elsewhere.\n\t\t */\n\t\tint slot = lr_ratio - NUMA_PERIOD_THRESHOLD;\n\t\tif (!slot)\n\t\t\tslot = 1;\n\t\tdiff = slot * period_slot;\n\t} else {\n\t\t/*\n\t\t * Private memory faults exceed (SLOTS-THRESHOLD)/SLOTS,\n\t\t * yet they are not on the local NUMA node. Speed up\n\t\t * NUMA scanning to get the memory moved over.\n\t\t */\n\t\tint ratio = max(lr_ratio, ps_ratio);\n\t\tdiff = -(NUMA_PERIOD_THRESHOLD - ratio) * period_slot;\n\t}\n\n\tp->numa_scan_period = clamp(p->numa_scan_period + diff,\n\t\t\ttask_scan_min(p), task_scan_max(p));\n\tmemset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));\n}\n\n/*\n * Get the fraction of time the task has been running since the last\n * NUMA placement cycle. The scheduler keeps similar statistics, but\n * decays those on a 32ms period, which is orders of magnitude off\n * from the dozens-of-seconds NUMA balancing period. Use the scheduler\n * stats only if the task is so new there are no NUMA statistics yet.\n */\nstatic u64 numa_get_avg_runtime(struct task_struct *p, u64 *period)\n{\n\tu64 runtime, delta, now;\n\t/* Use the start of this time slice to avoid calculations. */\n\tnow = p->se.exec_start;\n\truntime = p->se.sum_exec_runtime;\n\n\tif (p->last_task_numa_placement) {\n\t\tdelta = runtime - p->last_sum_exec_runtime;\n\t\t*period = now - p->last_task_numa_placement;\n\n\t\t/* Avoid time going backwards, prevent potential divide error: */\n\t\tif (unlikely((s64)*period < 0))\n\t\t\t*period = 0;\n\t} else {\n\t\tdelta = p->se.avg.load_sum;\n\t\t*period = LOAD_AVG_MAX;\n\t}\n\n\tp->last_sum_exec_runtime = runtime;\n\tp->last_task_numa_placement = now;\n\n\treturn delta;\n}\n\n/*\n * Determine the preferred nid for a task in a numa_group. This needs to\n * be done in a way that produces consistent results with group_weight,\n * otherwise workloads might not converge.\n */\nstatic int preferred_group_nid(struct task_struct *p, int nid)\n{\n\tnodemask_t nodes;\n\tint dist;\n\n\t/* Direct connections between all NUMA nodes. */\n\tif (sched_numa_topology_type == NUMA_DIRECT)\n\t\treturn nid;\n\n\t/*\n\t * On a system with glueless mesh NUMA topology, group_weight\n\t * scores nodes according to the number of NUMA hinting faults on\n\t * both the node itself, and on nearby nodes.\n\t */\n\tif (sched_numa_topology_type == NUMA_GLUELESS_MESH) {\n\t\tunsigned long score, max_score = 0;\n\t\tint node, max_node = nid;\n\n\t\tdist = sched_max_numa_distance;\n\n\t\tfor_each_online_node(node) {\n\t\t\tscore = group_weight(p, node, dist);\n\t\t\tif (score > max_score) {\n\t\t\t\tmax_score = score;\n\t\t\t\tmax_node = node;\n\t\t\t}\n\t\t}\n\t\treturn max_node;\n\t}\n\n\t/*\n\t * Finding the preferred nid in a system with NUMA backplane\n\t * interconnect topology is more involved. The goal is to locate\n\t * tasks from numa_groups near each other in the system, and\n\t * untangle workloads from different sides of the system. This requires\n\t * searching down the hierarchy of node groups, recursively searching\n\t * inside the highest scoring group of nodes. The nodemask tricks\n\t * keep the complexity of the search down.\n\t */\n\tnodes = node_online_map;\n\tfor (dist = sched_max_numa_distance; dist > LOCAL_DISTANCE; dist--) {\n\t\tunsigned long max_faults = 0;\n\t\tnodemask_t max_group = NODE_MASK_NONE;\n\t\tint a, b;\n\n\t\t/* Are there nodes at this distance from each other? */\n\t\tif (!find_numa_distance(dist))\n\t\t\tcontinue;\n\n\t\tfor_each_node_mask(a, nodes) {\n\t\t\tunsigned long faults = 0;\n\t\t\tnodemask_t this_group;\n\t\t\tnodes_clear(this_group);\n\n\t\t\t/* Sum group's NUMA faults; includes a==b case. */\n\t\t\tfor_each_node_mask(b, nodes) {\n\t\t\t\tif (node_distance(a, b) < dist) {\n\t\t\t\t\tfaults += group_faults(p, b);\n\t\t\t\t\tnode_set(b, this_group);\n\t\t\t\t\tnode_clear(b, nodes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Remember the top group. */\n\t\t\tif (faults > max_faults) {\n\t\t\t\tmax_faults = faults;\n\t\t\t\tmax_group = this_group;\n\t\t\t\t/*\n\t\t\t\t * subtle: at the smallest distance there is\n\t\t\t\t * just one node left in each \"group\", the\n\t\t\t\t * winner is the preferred nid.\n\t\t\t\t */\n\t\t\t\tnid = a;\n\t\t\t}\n\t\t}\n\t\t/* Next round, evaluate the nodes within max_group. */\n\t\tif (!max_faults)\n\t\t\tbreak;\n\t\tnodes = max_group;\n\t}\n\treturn nid;\n}\n\nstatic void task_numa_placement(struct task_struct *p)\n{\n\tint seq, nid, max_nid = NUMA_NO_NODE;\n\tunsigned long max_faults = 0;\n\tunsigned long fault_types[2] = { 0, 0 };\n\tunsigned long total_faults;\n\tu64 runtime, period;\n\tspinlock_t *group_lock = NULL;\n\tstruct numa_group *ng;\n\n\t/*\n\t * The p->mm->numa_scan_seq field gets updated without\n\t * exclusive access. Use READ_ONCE() here to ensure\n\t * that the field is read in a single access:\n\t */\n\tseq = READ_ONCE(p->mm->numa_scan_seq);\n\tif (p->numa_scan_seq == seq)\n\t\treturn;\n\tp->numa_scan_seq = seq;\n\tp->numa_scan_period_max = task_scan_max(p);\n\n\ttotal_faults = p->numa_faults_locality[0] +\n\t\t       p->numa_faults_locality[1];\n\truntime = numa_get_avg_runtime(p, &period);\n\n\t/* If the task is part of a group prevent parallel updates to group stats */\n\tng = deref_curr_numa_group(p);\n\tif (ng) {\n\t\tgroup_lock = &ng->lock;\n\t\tspin_lock_irq(group_lock);\n\t}\n\n\t/* Find the node with the highest number of faults */\n\tfor_each_online_node(nid) {\n\t\t/* Keep track of the offsets in numa_faults array */\n\t\tint mem_idx, membuf_idx, cpu_idx, cpubuf_idx;\n\t\tunsigned long faults = 0, group_faults = 0;\n\t\tint priv;\n\n\t\tfor (priv = 0; priv < NR_NUMA_HINT_FAULT_TYPES; priv++) {\n\t\t\tlong diff, f_diff, f_weight;\n\n\t\t\tmem_idx = task_faults_idx(NUMA_MEM, nid, priv);\n\t\t\tmembuf_idx = task_faults_idx(NUMA_MEMBUF, nid, priv);\n\t\t\tcpu_idx = task_faults_idx(NUMA_CPU, nid, priv);\n\t\t\tcpubuf_idx = task_faults_idx(NUMA_CPUBUF, nid, priv);\n\n\t\t\t/* Decay existing window, copy faults since last scan */\n\t\t\tdiff = p->numa_faults[membuf_idx] - p->numa_faults[mem_idx] / 2;\n\t\t\tfault_types[priv] += p->numa_faults[membuf_idx];\n\t\t\tp->numa_faults[membuf_idx] = 0;\n\n\t\t\t/*\n\t\t\t * Normalize the faults_from, so all tasks in a group\n\t\t\t * count according to CPU use, instead of by the raw\n\t\t\t * number of faults. Tasks with little runtime have\n\t\t\t * little over-all impact on throughput, and thus their\n\t\t\t * faults are less important.\n\t\t\t */\n\t\t\tf_weight = div64_u64(runtime << 16, period + 1);\n\t\t\tf_weight = (f_weight * p->numa_faults[cpubuf_idx]) /\n\t\t\t\t   (total_faults + 1);\n\t\t\tf_diff = f_weight - p->numa_faults[cpu_idx] / 2;\n\t\t\tp->numa_faults[cpubuf_idx] = 0;\n\n\t\t\tp->numa_faults[mem_idx] += diff;\n\t\t\tp->numa_faults[cpu_idx] += f_diff;\n\t\t\tfaults += p->numa_faults[mem_idx];\n\t\t\tp->total_numa_faults += diff;\n\t\t\tif (ng) {\n\t\t\t\t/*\n\t\t\t\t * safe because we can only change our own group\n\t\t\t\t *\n\t\t\t\t * mem_idx represents the offset for a given\n\t\t\t\t * nid and priv in a specific region because it\n\t\t\t\t * is at the beginning of the numa_faults array.\n\t\t\t\t */\n\t\t\t\tng->faults[mem_idx] += diff;\n\t\t\t\tng->faults_cpu[mem_idx] += f_diff;\n\t\t\t\tng->total_faults += diff;\n\t\t\t\tgroup_faults += ng->faults[mem_idx];\n\t\t\t}\n\t\t}\n\n\t\tif (!ng) {\n\t\t\tif (faults > max_faults) {\n\t\t\t\tmax_faults = faults;\n\t\t\t\tmax_nid = nid;\n\t\t\t}\n\t\t} else if (group_faults > max_faults) {\n\t\t\tmax_faults = group_faults;\n\t\t\tmax_nid = nid;\n\t\t}\n\t}\n\n\tif (ng) {\n\t\tnuma_group_count_active_nodes(ng);\n\t\tspin_unlock_irq(group_lock);\n\t\tmax_nid = preferred_group_nid(p, max_nid);\n\t}\n\n\tif (max_faults) {\n\t\t/* Set the new preferred node */\n\t\tif (max_nid != p->numa_preferred_nid)\n\t\t\tsched_setnuma(p, max_nid);\n\t}\n\n\tupdate_task_scan_period(p, fault_types[0], fault_types[1]);\n}\n\nstatic inline int get_numa_group(struct numa_group *grp)\n{\n\treturn refcount_inc_not_zero(&grp->refcount);\n}\n\nstatic inline void put_numa_group(struct numa_group *grp)\n{\n\tif (refcount_dec_and_test(&grp->refcount))\n\t\tkfree_rcu(grp, rcu);\n}\n\nstatic void task_numa_group(struct task_struct *p, int cpupid, int flags,\n\t\t\tint *priv)\n{\n\tstruct numa_group *grp, *my_grp;\n\tstruct task_struct *tsk;\n\tbool join = false;\n\tint cpu = cpupid_to_cpu(cpupid);\n\tint i;\n\n\tif (unlikely(!deref_curr_numa_group(p))) {\n\t\tunsigned int size = sizeof(struct numa_group) +\n\t\t\t\t    4*nr_node_ids*sizeof(unsigned long);\n\n\t\tgrp = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!grp)\n\t\t\treturn;\n\n\t\trefcount_set(&grp->refcount, 1);\n\t\tgrp->active_nodes = 1;\n\t\tgrp->max_faults_cpu = 0;\n\t\tspin_lock_init(&grp->lock);\n\t\tgrp->gid = p->pid;\n\t\t/* Second half of the array tracks nids where faults happen */\n\t\tgrp->faults_cpu = grp->faults + NR_NUMA_HINT_FAULT_TYPES *\n\t\t\t\t\t\tnr_node_ids;\n\n\t\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++)\n\t\t\tgrp->faults[i] = p->numa_faults[i];\n\n\t\tgrp->total_faults = p->total_numa_faults;\n\n\t\tgrp->nr_tasks++;\n\t\trcu_assign_pointer(p->numa_group, grp);\n\t}\n\n\trcu_read_lock();\n\ttsk = READ_ONCE(cpu_rq(cpu)->curr);\n\n\tif (!cpupid_match_pid(tsk, cpupid))\n\t\tgoto no_join;\n\n\tgrp = rcu_dereference(tsk->numa_group);\n\tif (!grp)\n\t\tgoto no_join;\n\n\tmy_grp = deref_curr_numa_group(p);\n\tif (grp == my_grp)\n\t\tgoto no_join;\n\n\t/*\n\t * Only join the other group if its bigger; if we're the bigger group,\n\t * the other task will join us.\n\t */\n\tif (my_grp->nr_tasks > grp->nr_tasks)\n\t\tgoto no_join;\n\n\t/*\n\t * Tie-break on the grp address.\n\t */\n\tif (my_grp->nr_tasks == grp->nr_tasks && my_grp > grp)\n\t\tgoto no_join;\n\n\t/* Always join threads in the same process. */\n\tif (tsk->mm == current->mm)\n\t\tjoin = true;\n\n\t/* Simple filter to avoid false positives due to PID collisions */\n\tif (flags & TNF_SHARED)\n\t\tjoin = true;\n\n\t/* Update priv based on whether false sharing was detected */\n\t*priv = !join;\n\n\tif (join && !get_numa_group(grp))\n\t\tgoto no_join;\n\n\trcu_read_unlock();\n\n\tif (!join)\n\t\treturn;\n\n\tBUG_ON(irqs_disabled());\n\tdouble_lock_irq(&my_grp->lock, &grp->lock);\n\n\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++) {\n\t\tmy_grp->faults[i] -= p->numa_faults[i];\n\t\tgrp->faults[i] += p->numa_faults[i];\n\t}\n\tmy_grp->total_faults -= p->total_numa_faults;\n\tgrp->total_faults += p->total_numa_faults;\n\n\tmy_grp->nr_tasks--;\n\tgrp->nr_tasks++;\n\n\tspin_unlock(&my_grp->lock);\n\tspin_unlock_irq(&grp->lock);\n\n\trcu_assign_pointer(p->numa_group, grp);\n\n\tput_numa_group(my_grp);\n\treturn;\n\nno_join:\n\trcu_read_unlock();\n\treturn;\n}\n\n/*\n * Get rid of NUMA staticstics associated with a task (either current or dead).\n * If @final is set, the task is dead and has reached refcount zero, so we can\n * safely free all relevant data structures. Otherwise, there might be\n * concurrent reads from places like load balancing and procfs, and we should\n * reset the data back to default state without freeing ->numa_faults.\n */\nvoid task_numa_free(struct task_struct *p, bool final)\n{\n\t/* safe: p either is current or is being freed by current */\n\tstruct numa_group *grp = rcu_dereference_raw(p->numa_group);\n\tunsigned long *numa_faults = p->numa_faults;\n\tunsigned long flags;\n\tint i;\n\n\tif (!numa_faults)\n\t\treturn;\n\n\tif (grp) {\n\t\tspin_lock_irqsave(&grp->lock, flags);\n\t\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++)\n\t\t\tgrp->faults[i] -= p->numa_faults[i];\n\t\tgrp->total_faults -= p->total_numa_faults;\n\n\t\tgrp->nr_tasks--;\n\t\tspin_unlock_irqrestore(&grp->lock, flags);\n\t\tRCU_INIT_POINTER(p->numa_group, NULL);\n\t\tput_numa_group(grp);\n\t}\n\n\tif (final) {\n\t\tp->numa_faults = NULL;\n\t\tkfree(numa_faults);\n\t} else {\n\t\tp->total_numa_faults = 0;\n\t\tfor (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++)\n\t\t\tnuma_faults[i] = 0;\n\t}\n}\n\n/*\n * Got a PROT_NONE fault for a page on @node.\n */\nvoid task_numa_fault(int last_cpupid, int mem_node, int pages, int flags)\n{\n\tstruct task_struct *p = current;\n\tbool migrated = flags & TNF_MIGRATED;\n\tint cpu_node = task_node(current);\n\tint local = !!(flags & TNF_FAULT_LOCAL);\n\tstruct numa_group *ng;\n\tint priv;\n\n\tif (!static_branch_likely(&sched_numa_balancing))\n\t\treturn;\n\n\t/* for example, ksmd faulting in a user's mm */\n\tif (!p->mm)\n\t\treturn;\n\n\t/* Allocate buffer to track faults on a per-node basis */\n\tif (unlikely(!p->numa_faults)) {\n\t\tint size = sizeof(*p->numa_faults) *\n\t\t\t   NR_NUMA_HINT_FAULT_BUCKETS * nr_node_ids;\n\n\t\tp->numa_faults = kzalloc(size, GFP_KERNEL|__GFP_NOWARN);\n\t\tif (!p->numa_faults)\n\t\t\treturn;\n\n\t\tp->total_numa_faults = 0;\n\t\tmemset(p->numa_faults_locality, 0, sizeof(p->numa_faults_locality));\n\t}\n\n\t/*\n\t * First accesses are treated as private, otherwise consider accesses\n\t * to be private if the accessing pid has not changed\n\t */\n\tif (unlikely(last_cpupid == (-1 & LAST_CPUPID_MASK))) {\n\t\tpriv = 1;\n\t} else {\n\t\tpriv = cpupid_match_pid(p, last_cpupid);\n\t\tif (!priv && !(flags & TNF_NO_GROUP))\n\t\t\ttask_numa_group(p, last_cpupid, flags, &priv);\n\t}\n\n\t/*\n\t * If a workload spans multiple NUMA nodes, a shared fault that\n\t * occurs wholly within the set of nodes that the workload is\n\t * actively using should be counted as local. This allows the\n\t * scan rate to slow down when a workload has settled down.\n\t */\n\tng = deref_curr_numa_group(p);\n\tif (!priv && !local && ng && ng->active_nodes > 1 &&\n\t\t\t\tnuma_is_active_node(cpu_node, ng) &&\n\t\t\t\tnuma_is_active_node(mem_node, ng))\n\t\tlocal = 1;\n\n\t/*\n\t * Retry to migrate task to preferred node periodically, in case it\n\t * previously failed, or the scheduler moved us.\n\t */\n\tif (time_after(jiffies, p->numa_migrate_retry)) {\n\t\ttask_numa_placement(p);\n\t\tnuma_migrate_preferred(p);\n\t}\n\n\tif (migrated)\n\t\tp->numa_pages_migrated += pages;\n\tif (flags & TNF_MIGRATE_FAIL)\n\t\tp->numa_faults_locality[2] += pages;\n\n\tp->numa_faults[task_faults_idx(NUMA_MEMBUF, mem_node, priv)] += pages;\n\tp->numa_faults[task_faults_idx(NUMA_CPUBUF, cpu_node, priv)] += pages;\n\tp->numa_faults_locality[local] += pages;\n}\n\nstatic void reset_ptenuma_scan(struct task_struct *p)\n{\n\t/*\n\t * We only did a read acquisition of the mmap sem, so\n\t * p->mm->numa_scan_seq is written to without exclusive access\n\t * and the update is not guaranteed to be atomic. That's not\n\t * much of an issue though, since this is just used for\n\t * statistical sampling. Use READ_ONCE/WRITE_ONCE, which are not\n\t * expensive, to avoid any form of compiler optimizations:\n\t */\n\tWRITE_ONCE(p->mm->numa_scan_seq, READ_ONCE(p->mm->numa_scan_seq) + 1);\n\tp->mm->numa_scan_offset = 0;\n}\n\n/*\n * The expensive part of numa migration is done from task_work context.\n * Triggered from task_tick_numa().\n */\nstatic void task_numa_work(struct callback_head *work)\n{\n\tunsigned long migrate, next_scan, now = jiffies;\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tu64 runtime = p->se.sum_exec_runtime;\n\tstruct vm_area_struct *vma;\n\tunsigned long start, end;\n\tunsigned long nr_pte_updates = 0;\n\tlong pages, virtpages;\n\n\tSCHED_WARN_ON(p != container_of(work, struct task_struct, numa_work));\n\n\twork->next = work;\n\t/*\n\t * Who cares about NUMA placement when they're dying.\n\t *\n\t * NOTE: make sure not to dereference p->mm before this check,\n\t * exit_task_work() happens _after_ exit_mm() so we could be called\n\t * without p->mm even though we still had it when we enqueued this\n\t * work.\n\t */\n\tif (p->flags & PF_EXITING)\n\t\treturn;\n\n\tif (!mm->numa_next_scan) {\n\t\tmm->numa_next_scan = now +\n\t\t\tmsecs_to_jiffies(sysctl_numa_balancing_scan_delay);\n\t}\n\n\t/*\n\t * Enforce maximal scan/migration frequency..\n\t */\n\tmigrate = mm->numa_next_scan;\n\tif (time_before(now, migrate))\n\t\treturn;\n\n\tif (p->numa_scan_period == 0) {\n\t\tp->numa_scan_period_max = task_scan_max(p);\n\t\tp->numa_scan_period = task_scan_start(p);\n\t}\n\n\tnext_scan = now + msecs_to_jiffies(p->numa_scan_period);\n\tif (cmpxchg(&mm->numa_next_scan, migrate, next_scan) != migrate)\n\t\treturn;\n\n\t/*\n\t * Delay this task enough that another task of this mm will likely win\n\t * the next time around.\n\t */\n\tp->node_stamp += 2 * TICK_NSEC;\n\n\tstart = mm->numa_scan_offset;\n\tpages = sysctl_numa_balancing_scan_size;\n\tpages <<= 20 - PAGE_SHIFT; /* MB in pages */\n\tvirtpages = pages * 8;\t   /* Scan up to this much virtual space */\n\tif (!pages)\n\t\treturn;\n\n\n\tif (!mmap_read_trylock(mm))\n\t\treturn;\n\tvma = find_vma(mm, start);\n\tif (!vma) {\n\t\treset_ptenuma_scan(p);\n\t\tstart = 0;\n\t\tvma = mm->mmap;\n\t}\n\tfor (; vma; vma = vma->vm_next) {\n\t\tif (!vma_migratable(vma) || !vma_policy_mof(vma) ||\n\t\t\tis_vm_hugetlb_page(vma) || (vma->vm_flags & VM_MIXEDMAP)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Shared library pages mapped by multiple processes are not\n\t\t * migrated as it is expected they are cache replicated. Avoid\n\t\t * hinting faults in read-only file-backed mappings or the vdso\n\t\t * as migrating the pages will be of marginal benefit.\n\t\t */\n\t\tif (!vma->vm_mm ||\n\t\t    (vma->vm_file && (vma->vm_flags & (VM_READ|VM_WRITE)) == (VM_READ)))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Skip inaccessible VMAs to avoid any confusion between\n\t\t * PROT_NONE and NUMA hinting ptes\n\t\t */\n\t\tif (!vma_is_accessible(vma))\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tstart = max(start, vma->vm_start);\n\t\t\tend = ALIGN(start + (pages << PAGE_SHIFT), HPAGE_SIZE);\n\t\t\tend = min(end, vma->vm_end);\n\t\t\tnr_pte_updates = change_prot_numa(vma, start, end);\n\n\t\t\t/*\n\t\t\t * Try to scan sysctl_numa_balancing_size worth of\n\t\t\t * hpages that have at least one present PTE that\n\t\t\t * is not already pte-numa. If the VMA contains\n\t\t\t * areas that are unused or already full of prot_numa\n\t\t\t * PTEs, scan up to virtpages, to skip through those\n\t\t\t * areas faster.\n\t\t\t */\n\t\t\tif (nr_pte_updates)\n\t\t\t\tpages -= (end - start) >> PAGE_SHIFT;\n\t\t\tvirtpages -= (end - start) >> PAGE_SHIFT;\n\n\t\t\tstart = end;\n\t\t\tif (pages <= 0 || virtpages <= 0)\n\t\t\t\tgoto out;\n\n\t\t\tcond_resched();\n\t\t} while (end != vma->vm_end);\n\t}\n\nout:\n\t/*\n\t * It is possible to reach the end of the VMA list but the last few\n\t * VMAs are not guaranteed to the vma_migratable. If they are not, we\n\t * would find the !migratable VMA on the next scan but not reset the\n\t * scanner to the start so check it now.\n\t */\n\tif (vma)\n\t\tmm->numa_scan_offset = start;\n\telse\n\t\treset_ptenuma_scan(p);\n\tmmap_read_unlock(mm);\n\n\t/*\n\t * Make sure tasks use at least 32x as much time to run other code\n\t * than they used here, to limit NUMA PTE scanning overhead to 3% max.\n\t * Usually update_task_scan_period slows down scanning enough; on an\n\t * overloaded system we need to limit overhead on a per task basis.\n\t */\n\tif (unlikely(p->se.sum_exec_runtime != runtime)) {\n\t\tu64 diff = p->se.sum_exec_runtime - runtime;\n\t\tp->node_stamp += 32 * diff;\n\t}\n}\n\nvoid init_numa_balancing(unsigned long clone_flags, struct task_struct *p)\n{\n\tint mm_users = 0;\n\tstruct mm_struct *mm = p->mm;\n\n\tif (mm) {\n\t\tmm_users = atomic_read(&mm->mm_users);\n\t\tif (mm_users == 1) {\n\t\t\tmm->numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay);\n\t\t\tmm->numa_scan_seq = 0;\n\t\t}\n\t}\n\tp->node_stamp\t\t\t= 0;\n\tp->numa_scan_seq\t\t= mm ? mm->numa_scan_seq : 0;\n\tp->numa_scan_period\t\t= sysctl_numa_balancing_scan_delay;\n\t/* Protect against double add, see task_tick_numa and task_numa_work */\n\tp->numa_work.next\t\t= &p->numa_work;\n\tp->numa_faults\t\t\t= NULL;\n\tRCU_INIT_POINTER(p->numa_group, NULL);\n\tp->last_task_numa_placement\t= 0;\n\tp->last_sum_exec_runtime\t= 0;\n\n\tinit_task_work(&p->numa_work, task_numa_work);\n\n\t/* New address space, reset the preferred nid */\n\tif (!(clone_flags & CLONE_VM)) {\n\t\tp->numa_preferred_nid = NUMA_NO_NODE;\n\t\treturn;\n\t}\n\n\t/*\n\t * New thread, keep existing numa_preferred_nid which should be copied\n\t * already by arch_dup_task_struct but stagger when scans start.\n\t */\n\tif (mm) {\n\t\tunsigned int delay;\n\n\t\tdelay = min_t(unsigned int, task_scan_max(current),\n\t\t\tcurrent->numa_scan_period * mm_users * NSEC_PER_MSEC);\n\t\tdelay += 2 * TICK_NSEC;\n\t\tp->node_stamp = delay;\n\t}\n}\n\n/*\n * Drive the periodic memory faults..\n */\nstatic void task_tick_numa(struct rq *rq, struct task_struct *curr)\n{\n\tstruct callback_head *work = &curr->numa_work;\n\tu64 period, now;\n\n\t/*\n\t * We don't care about NUMA placement if we don't have memory.\n\t */\n\tif ((curr->flags & (PF_EXITING | PF_KTHREAD)) || work->next != work)\n\t\treturn;\n\n\t/*\n\t * Using runtime rather than walltime has the dual advantage that\n\t * we (mostly) drive the selection from busy threads and that the\n\t * task needs to have done some actual work before we bother with\n\t * NUMA placement.\n\t */\n\tnow = curr->se.sum_exec_runtime;\n\tperiod = (u64)curr->numa_scan_period * NSEC_PER_MSEC;\n\n\tif (now > curr->node_stamp + period) {\n\t\tif (!curr->node_stamp)\n\t\t\tcurr->numa_scan_period = task_scan_start(curr);\n\t\tcurr->node_stamp += period;\n\n\t\tif (!time_before(jiffies, curr->mm->numa_next_scan))\n\t\t\ttask_work_add(curr, work, TWA_RESUME);\n\t}\n}\n\nstatic void update_scan_period(struct task_struct *p, int new_cpu)\n{\n\tint src_nid = cpu_to_node(task_cpu(p));\n\tint dst_nid = cpu_to_node(new_cpu);\n\n\tif (!static_branch_likely(&sched_numa_balancing))\n\t\treturn;\n\n\tif (!p->mm || !p->numa_faults || (p->flags & PF_EXITING))\n\t\treturn;\n\n\tif (src_nid == dst_nid)\n\t\treturn;\n\n\t/*\n\t * Allow resets if faults have been trapped before one scan\n\t * has completed. This is most likely due to a new task that\n\t * is pulled cross-node due to wakeups or load balancing.\n\t */\n\tif (p->numa_scan_seq) {\n\t\t/*\n\t\t * Avoid scan adjustments if moving to the preferred\n\t\t * node or if the task was not previously running on\n\t\t * the preferred node.\n\t\t */\n\t\tif (dst_nid == p->numa_preferred_nid ||\n\t\t    (p->numa_preferred_nid != NUMA_NO_NODE &&\n\t\t\tsrc_nid != p->numa_preferred_nid))\n\t\t\treturn;\n\t}\n\n\tp->numa_scan_period = task_scan_start(p);\n}\n\n#else\nstatic void task_tick_numa(struct rq *rq, struct task_struct *curr)\n{\n}\n\nstatic inline void account_numa_enqueue(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline void update_scan_period(struct task_struct *p, int new_cpu)\n{\n}\n\n#endif /* CONFIG_NUMA_BALANCING */\n\nstatic void\naccount_entity_enqueue(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tupdate_load_add(&cfs_rq->load, se->load.weight);\n#ifdef CONFIG_SMP\n\tif (entity_is_task(se)) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\n\t\taccount_numa_enqueue(rq, task_of(se));\n\t\tlist_add(&se->group_node, &rq->cfs_tasks);\n\t}\n#endif\n\tcfs_rq->nr_running++;\n}\n\nstatic void\naccount_entity_dequeue(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tupdate_load_sub(&cfs_rq->load, se->load.weight);\n#ifdef CONFIG_SMP\n\tif (entity_is_task(se)) {\n\t\taccount_numa_dequeue(rq_of(cfs_rq), task_of(se));\n\t\tlist_del_init(&se->group_node);\n\t}\n#endif\n\tcfs_rq->nr_running--;\n}\n\n/*\n * Signed add and clamp on underflow.\n *\n * Explicitly do a load-store to ensure the intermediate value never hits\n * memory. This allows lockless observations without ever seeing the negative\n * values.\n */\n#define add_positive(_ptr, _val) do {                           \\\n\ttypeof(_ptr) ptr = (_ptr);                              \\\n\ttypeof(_val) val = (_val);                              \\\n\ttypeof(*ptr) res, var = READ_ONCE(*ptr);                \\\n\t\t\t\t\t\t\t\t\\\n\tres = var + val;                                        \\\n\t\t\t\t\t\t\t\t\\\n\tif (val < 0 && res > var)                               \\\n\t\tres = 0;                                        \\\n\t\t\t\t\t\t\t\t\\\n\tWRITE_ONCE(*ptr, res);                                  \\\n} while (0)\n\n/*\n * Unsigned subtract and clamp on underflow.\n *\n * Explicitly do a load-store to ensure the intermediate value never hits\n * memory. This allows lockless observations without ever seeing the negative\n * values.\n */\n#define sub_positive(_ptr, _val) do {\t\t\t\t\\\n\ttypeof(_ptr) ptr = (_ptr);\t\t\t\t\\\n\ttypeof(*ptr) val = (_val);\t\t\t\t\\\n\ttypeof(*ptr) res, var = READ_ONCE(*ptr);\t\t\\\n\tres = var - val;\t\t\t\t\t\\\n\tif (res > var)\t\t\t\t\t\t\\\n\t\tres = 0;\t\t\t\t\t\\\n\tWRITE_ONCE(*ptr, res);\t\t\t\t\t\\\n} while (0)\n\n/*\n * Remove and clamp on negative, from a local variable.\n *\n * A variant of sub_positive(), which does not use explicit load-store\n * and is thus optimized for local variable updates.\n */\n#define lsub_positive(_ptr, _val) do {\t\t\t\t\\\n\ttypeof(_ptr) ptr = (_ptr);\t\t\t\t\\\n\t*ptr -= min_t(typeof(*ptr), *ptr, _val);\t\t\\\n} while (0)\n\n#ifdef CONFIG_SMP\nstatic inline void\nenqueue_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tcfs_rq->avg.load_avg += se->avg.load_avg;\n\tcfs_rq->avg.load_sum += se_weight(se) * se->avg.load_sum;\n}\n\nstatic inline void\ndequeue_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tsub_positive(&cfs_rq->avg.load_avg, se->avg.load_avg);\n\tsub_positive(&cfs_rq->avg.load_sum, se_weight(se) * se->avg.load_sum);\n}\n#else\nstatic inline void\nenqueue_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se) { }\nstatic inline void\ndequeue_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se) { }\n#endif\n\nstatic void reweight_entity(struct cfs_rq *cfs_rq, struct sched_entity *se,\n\t\t\t    unsigned long weight)\n{\n\tif (se->on_rq) {\n\t\t/* commit outstanding execution time */\n\t\tif (cfs_rq->curr == se)\n\t\t\tupdate_curr(cfs_rq);\n\t\tupdate_load_sub(&cfs_rq->load, se->load.weight);\n\t}\n\tdequeue_load_avg(cfs_rq, se);\n\n\tupdate_load_set(&se->load, weight);\n\n#ifdef CONFIG_SMP\n\tdo {\n\t\tu32 divider = get_pelt_divider(&se->avg);\n\n\t\tse->avg.load_avg = div_u64(se_weight(se) * se->avg.load_sum, divider);\n\t} while (0);\n#endif\n\n\tenqueue_load_avg(cfs_rq, se);\n\tif (se->on_rq)\n\t\tupdate_load_add(&cfs_rq->load, se->load.weight);\n\n}\n\nvoid reweight_task(struct task_struct *p, int prio)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tstruct load_weight *load = &se->load;\n\tunsigned long weight = scale_load(sched_prio_to_weight[prio]);\n\n\treweight_entity(cfs_rq, se, weight);\n\tload->inv_weight = sched_prio_to_wmult[prio];\n}\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n#ifdef CONFIG_SMP\n/*\n * All this does is approximate the hierarchical proportion which includes that\n * global sum we all love to hate.\n *\n * That is, the weight of a group entity, is the proportional share of the\n * group weight based on the group runqueue weights. That is:\n *\n *                     tg->weight * grq->load.weight\n *   ge->load.weight = -----------------------------               (1)\n *\t\t\t  \\Sum grq->load.weight\n *\n * Now, because computing that sum is prohibitively expensive to compute (been\n * there, done that) we approximate it with this average stuff. The average\n * moves slower and therefore the approximation is cheaper and more stable.\n *\n * So instead of the above, we substitute:\n *\n *   grq->load.weight -> grq->avg.load_avg                         (2)\n *\n * which yields the following:\n *\n *                     tg->weight * grq->avg.load_avg\n *   ge->load.weight = ------------------------------              (3)\n *\t\t\t\ttg->load_avg\n *\n * Where: tg->load_avg ~= \\Sum grq->avg.load_avg\n *\n * That is shares_avg, and it is right (given the approximation (2)).\n *\n * The problem with it is that because the average is slow -- it was designed\n * to be exactly that of course -- this leads to transients in boundary\n * conditions. In specific, the case where the group was idle and we start the\n * one task. It takes time for our CPU's grq->avg.load_avg to build up,\n * yielding bad latency etc..\n *\n * Now, in that special case (1) reduces to:\n *\n *                     tg->weight * grq->load.weight\n *   ge->load.weight = ----------------------------- = tg->weight   (4)\n *\t\t\t    grp->load.weight\n *\n * That is, the sum collapses because all other CPUs are idle; the UP scenario.\n *\n * So what we do is modify our approximation (3) to approach (4) in the (near)\n * UP case, like:\n *\n *   ge->load.weight =\n *\n *              tg->weight * grq->load.weight\n *     ---------------------------------------------------         (5)\n *     tg->load_avg - grq->avg.load_avg + grq->load.weight\n *\n * But because grq->load.weight can drop to 0, resulting in a divide by zero,\n * we need to use grq->avg.load_avg as its lower bound, which then gives:\n *\n *\n *                     tg->weight * grq->load.weight\n *   ge->load.weight = -----------------------------\t\t   (6)\n *\t\t\t\ttg_load_avg'\n *\n * Where:\n *\n *   tg_load_avg' = tg->load_avg - grq->avg.load_avg +\n *                  max(grq->load.weight, grq->avg.load_avg)\n *\n * And that is shares_weight and is icky. In the (near) UP case it approaches\n * (4) while in the normal case it approaches (3). It consistently\n * overestimates the ge->load.weight and therefore:\n *\n *   \\Sum ge->load.weight >= tg->weight\n *\n * hence icky!\n */\nstatic long calc_group_shares(struct cfs_rq *cfs_rq)\n{\n\tlong tg_weight, tg_shares, load, shares;\n\tstruct task_group *tg = cfs_rq->tg;\n\n\ttg_shares = READ_ONCE(tg->shares);\n\n\tload = max(scale_load_down(cfs_rq->load.weight), cfs_rq->avg.load_avg);\n\n\ttg_weight = atomic_long_read(&tg->load_avg);\n\n\t/* Ensure tg_weight >= load */\n\ttg_weight -= cfs_rq->tg_load_avg_contrib;\n\ttg_weight += load;\n\n\tshares = (tg_shares * load);\n\tif (tg_weight)\n\t\tshares /= tg_weight;\n\n\t/*\n\t * MIN_SHARES has to be unscaled here to support per-CPU partitioning\n\t * of a group with small tg->shares value. It is a floor value which is\n\t * assigned as a minimum load.weight to the sched_entity representing\n\t * the group on a CPU.\n\t *\n\t * E.g. on 64-bit for a group with tg->shares of scale_load(15)=15*1024\n\t * on an 8-core system with 8 tasks each runnable on one CPU shares has\n\t * to be 15*1024*1/8=1920 instead of scale_load(MIN_SHARES)=2*1024. In\n\t * case no task is runnable on a CPU MIN_SHARES=2 should be returned\n\t * instead of 0.\n\t */\n\treturn clamp_t(long, shares, MIN_SHARES, tg_shares);\n}\n#endif /* CONFIG_SMP */\n\nstatic inline int throttled_hierarchy(struct cfs_rq *cfs_rq);\n\n/*\n * Recomputes the group entity based on the current state of its group\n * runqueue.\n */\nstatic void update_cfs_group(struct sched_entity *se)\n{\n\tstruct cfs_rq *gcfs_rq = group_cfs_rq(se);\n\tlong shares;\n\n\tif (!gcfs_rq)\n\t\treturn;\n\n\tif (throttled_hierarchy(gcfs_rq))\n\t\treturn;\n\n#ifndef CONFIG_SMP\n\tshares = READ_ONCE(gcfs_rq->tg->shares);\n\n\tif (likely(se->load.weight == shares))\n\t\treturn;\n#else\n\tshares   = calc_group_shares(gcfs_rq);\n#endif\n\n\treweight_entity(cfs_rq_of(se), se, shares);\n}\n\n#else /* CONFIG_FAIR_GROUP_SCHED */\nstatic inline void update_cfs_group(struct sched_entity *se)\n{\n}\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\nstatic inline void cfs_rq_util_change(struct cfs_rq *cfs_rq, int flags)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\n\tif (&rq->cfs == cfs_rq) {\n\t\t/*\n\t\t * There are a few boundary cases this might miss but it should\n\t\t * get called often enough that that should (hopefully) not be\n\t\t * a real problem.\n\t\t *\n\t\t * It will not get called when we go idle, because the idle\n\t\t * thread is a different class (!fair), nor will the utilization\n\t\t * number include things like RT tasks.\n\t\t *\n\t\t * As is, the util number is not freq-invariant (we'd have to\n\t\t * implement arch_scale_freq_capacity() for that).\n\t\t *\n\t\t * See cpu_util().\n\t\t */\n\t\tcpufreq_update_util(rq, flags);\n\t}\n}\n\n#ifdef CONFIG_SMP\n#ifdef CONFIG_FAIR_GROUP_SCHED\n/**\n * update_tg_load_avg - update the tg's load avg\n * @cfs_rq: the cfs_rq whose avg changed\n *\n * This function 'ensures': tg->load_avg := \\Sum tg->cfs_rq[]->avg.load.\n * However, because tg->load_avg is a global value there are performance\n * considerations.\n *\n * In order to avoid having to look at the other cfs_rq's, we use a\n * differential update where we store the last value we propagated. This in\n * turn allows skipping updates if the differential is 'small'.\n *\n * Updating tg's load_avg is necessary before update_cfs_share().\n */\nstatic inline void update_tg_load_avg(struct cfs_rq *cfs_rq)\n{\n\tlong delta = cfs_rq->avg.load_avg - cfs_rq->tg_load_avg_contrib;\n\n\t/*\n\t * No need to update load_avg for root_task_group as it is not used.\n\t */\n\tif (cfs_rq->tg == &root_task_group)\n\t\treturn;\n\n\tif (abs(delta) > cfs_rq->tg_load_avg_contrib / 64) {\n\t\tatomic_long_add(delta, &cfs_rq->tg->load_avg);\n\t\tcfs_rq->tg_load_avg_contrib = cfs_rq->avg.load_avg;\n\t}\n}\n\n/*\n * Called within set_task_rq() right before setting a task's CPU. The\n * caller only guarantees p->pi_lock is held; no other assumptions,\n * including the state of rq->lock, should be made.\n */\nvoid set_task_rq_fair(struct sched_entity *se,\n\t\t      struct cfs_rq *prev, struct cfs_rq *next)\n{\n\tu64 p_last_update_time;\n\tu64 n_last_update_time;\n\n\tif (!sched_feat(ATTACH_AGE_LOAD))\n\t\treturn;\n\n\t/*\n\t * We are supposed to update the task to \"current\" time, then its up to\n\t * date and ready to go to new CPU/cfs_rq. But we have difficulty in\n\t * getting what current time is, so simply throw away the out-of-date\n\t * time. This will result in the wakee task is less decayed, but giving\n\t * the wakee more load sounds not bad.\n\t */\n\tif (!(se->avg.last_update_time && prev))\n\t\treturn;\n\n#ifndef CONFIG_64BIT\n\t{\n\t\tu64 p_last_update_time_copy;\n\t\tu64 n_last_update_time_copy;\n\n\t\tdo {\n\t\t\tp_last_update_time_copy = prev->load_last_update_time_copy;\n\t\t\tn_last_update_time_copy = next->load_last_update_time_copy;\n\n\t\t\tsmp_rmb();\n\n\t\t\tp_last_update_time = prev->avg.last_update_time;\n\t\t\tn_last_update_time = next->avg.last_update_time;\n\n\t\t} while (p_last_update_time != p_last_update_time_copy ||\n\t\t\t n_last_update_time != n_last_update_time_copy);\n\t}\n#else\n\tp_last_update_time = prev->avg.last_update_time;\n\tn_last_update_time = next->avg.last_update_time;\n#endif\n\t__update_load_avg_blocked_se(p_last_update_time, se);\n\tse->avg.last_update_time = n_last_update_time;\n}\n\n\n/*\n * When on migration a sched_entity joins/leaves the PELT hierarchy, we need to\n * propagate its contribution. The key to this propagation is the invariant\n * that for each group:\n *\n *   ge->avg == grq->avg\t\t\t\t\t\t(1)\n *\n * _IFF_ we look at the pure running and runnable sums. Because they\n * represent the very same entity, just at different points in the hierarchy.\n *\n * Per the above update_tg_cfs_util() and update_tg_cfs_runnable() are trivial\n * and simply copies the running/runnable sum over (but still wrong, because\n * the group entity and group rq do not have their PELT windows aligned).\n *\n * However, update_tg_cfs_load() is more complex. So we have:\n *\n *   ge->avg.load_avg = ge->load.weight * ge->avg.runnable_avg\t\t(2)\n *\n * And since, like util, the runnable part should be directly transferable,\n * the following would _appear_ to be the straight forward approach:\n *\n *   grq->avg.load_avg = grq->load.weight * grq->avg.runnable_avg\t(3)\n *\n * And per (1) we have:\n *\n *   ge->avg.runnable_avg == grq->avg.runnable_avg\n *\n * Which gives:\n *\n *                      ge->load.weight * grq->avg.load_avg\n *   ge->avg.load_avg = -----------------------------------\t\t(4)\n *                               grq->load.weight\n *\n * Except that is wrong!\n *\n * Because while for entities historical weight is not important and we\n * really only care about our future and therefore can consider a pure\n * runnable sum, runqueues can NOT do this.\n *\n * We specifically want runqueues to have a load_avg that includes\n * historical weights. Those represent the blocked load, the load we expect\n * to (shortly) return to us. This only works by keeping the weights as\n * integral part of the sum. We therefore cannot decompose as per (3).\n *\n * Another reason this doesn't work is that runnable isn't a 0-sum entity.\n * Imagine a rq with 2 tasks that each are runnable 2/3 of the time. Then the\n * rq itself is runnable anywhere between 2/3 and 1 depending on how the\n * runnable section of these tasks overlap (or not). If they were to perfectly\n * align the rq as a whole would be runnable 2/3 of the time. If however we\n * always have at least 1 runnable task, the rq as a whole is always runnable.\n *\n * So we'll have to approximate.. :/\n *\n * Given the constraint:\n *\n *   ge->avg.running_sum <= ge->avg.runnable_sum <= LOAD_AVG_MAX\n *\n * We can construct a rule that adds runnable to a rq by assuming minimal\n * overlap.\n *\n * On removal, we'll assume each task is equally runnable; which yields:\n *\n *   grq->avg.runnable_sum = grq->avg.load_sum / grq->load.weight\n *\n * XXX: only do this for the part of runnable > running ?\n *\n */\n\nstatic inline void\nupdate_tg_cfs_util(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)\n{\n\tlong delta = gcfs_rq->avg.util_avg - se->avg.util_avg;\n\tu32 divider;\n\n\t/* Nothing to update */\n\tif (!delta)\n\t\treturn;\n\n\t/*\n\t * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.\n\t * See ___update_load_avg() for details.\n\t */\n\tdivider = get_pelt_divider(&cfs_rq->avg);\n\n\t/* Set new sched_entity's utilization */\n\tse->avg.util_avg = gcfs_rq->avg.util_avg;\n\tse->avg.util_sum = se->avg.util_avg * divider;\n\n\t/* Update parent cfs_rq utilization */\n\tadd_positive(&cfs_rq->avg.util_avg, delta);\n\tcfs_rq->avg.util_sum = cfs_rq->avg.util_avg * divider;\n}\n\nstatic inline void\nupdate_tg_cfs_runnable(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)\n{\n\tlong delta = gcfs_rq->avg.runnable_avg - se->avg.runnable_avg;\n\tu32 divider;\n\n\t/* Nothing to update */\n\tif (!delta)\n\t\treturn;\n\n\t/*\n\t * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.\n\t * See ___update_load_avg() for details.\n\t */\n\tdivider = get_pelt_divider(&cfs_rq->avg);\n\n\t/* Set new sched_entity's runnable */\n\tse->avg.runnable_avg = gcfs_rq->avg.runnable_avg;\n\tse->avg.runnable_sum = se->avg.runnable_avg * divider;\n\n\t/* Update parent cfs_rq runnable */\n\tadd_positive(&cfs_rq->avg.runnable_avg, delta);\n\tcfs_rq->avg.runnable_sum = cfs_rq->avg.runnable_avg * divider;\n}\n\nstatic inline void\nupdate_tg_cfs_load(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)\n{\n\tlong delta_avg, running_sum, runnable_sum = gcfs_rq->prop_runnable_sum;\n\tunsigned long load_avg;\n\tu64 load_sum = 0;\n\ts64 delta_sum;\n\tu32 divider;\n\n\tif (!runnable_sum)\n\t\treturn;\n\n\tgcfs_rq->prop_runnable_sum = 0;\n\n\t/*\n\t * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.\n\t * See ___update_load_avg() for details.\n\t */\n\tdivider = get_pelt_divider(&cfs_rq->avg);\n\n\tif (runnable_sum >= 0) {\n\t\t/*\n\t\t * Add runnable; clip at LOAD_AVG_MAX. Reflects that until\n\t\t * the CPU is saturated running == runnable.\n\t\t */\n\t\trunnable_sum += se->avg.load_sum;\n\t\trunnable_sum = min_t(long, runnable_sum, divider);\n\t} else {\n\t\t/*\n\t\t * Estimate the new unweighted runnable_sum of the gcfs_rq by\n\t\t * assuming all tasks are equally runnable.\n\t\t */\n\t\tif (scale_load_down(gcfs_rq->load.weight)) {\n\t\t\tload_sum = div_s64(gcfs_rq->avg.load_sum,\n\t\t\t\tscale_load_down(gcfs_rq->load.weight));\n\t\t}\n\n\t\t/* But make sure to not inflate se's runnable */\n\t\trunnable_sum = min(se->avg.load_sum, load_sum);\n\t}\n\n\t/*\n\t * runnable_sum can't be lower than running_sum\n\t * Rescale running sum to be in the same range as runnable sum\n\t * running_sum is in [0 : LOAD_AVG_MAX <<  SCHED_CAPACITY_SHIFT]\n\t * runnable_sum is in [0 : LOAD_AVG_MAX]\n\t */\n\trunning_sum = se->avg.util_sum >> SCHED_CAPACITY_SHIFT;\n\trunnable_sum = max(runnable_sum, running_sum);\n\n\tload_sum = (s64)se_weight(se) * runnable_sum;\n\tload_avg = div_s64(load_sum, divider);\n\n\tdelta_sum = load_sum - (s64)se_weight(se) * se->avg.load_sum;\n\tdelta_avg = load_avg - se->avg.load_avg;\n\n\tse->avg.load_sum = runnable_sum;\n\tse->avg.load_avg = load_avg;\n\tadd_positive(&cfs_rq->avg.load_avg, delta_avg);\n\tadd_positive(&cfs_rq->avg.load_sum, delta_sum);\n}\n\nstatic inline void add_tg_cfs_propagate(struct cfs_rq *cfs_rq, long runnable_sum)\n{\n\tcfs_rq->propagate = 1;\n\tcfs_rq->prop_runnable_sum += runnable_sum;\n}\n\n/* Update task and its cfs_rq load average */\nstatic inline int propagate_entity_load_avg(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq, *gcfs_rq;\n\n\tif (entity_is_task(se))\n\t\treturn 0;\n\n\tgcfs_rq = group_cfs_rq(se);\n\tif (!gcfs_rq->propagate)\n\t\treturn 0;\n\n\tgcfs_rq->propagate = 0;\n\n\tcfs_rq = cfs_rq_of(se);\n\n\tadd_tg_cfs_propagate(cfs_rq, gcfs_rq->prop_runnable_sum);\n\n\tupdate_tg_cfs_util(cfs_rq, se, gcfs_rq);\n\tupdate_tg_cfs_runnable(cfs_rq, se, gcfs_rq);\n\tupdate_tg_cfs_load(cfs_rq, se, gcfs_rq);\n\n\ttrace_pelt_cfs_tp(cfs_rq);\n\ttrace_pelt_se_tp(se);\n\n\treturn 1;\n}\n\n/*\n * Check if we need to update the load and the utilization of a blocked\n * group_entity:\n */\nstatic inline bool skip_blocked_update(struct sched_entity *se)\n{\n\tstruct cfs_rq *gcfs_rq = group_cfs_rq(se);\n\n\t/*\n\t * If sched_entity still have not zero load or utilization, we have to\n\t * decay it:\n\t */\n\tif (se->avg.load_avg || se->avg.util_avg)\n\t\treturn false;\n\n\t/*\n\t * If there is a pending propagation, we have to update the load and\n\t * the utilization of the sched_entity:\n\t */\n\tif (gcfs_rq->propagate)\n\t\treturn false;\n\n\t/*\n\t * Otherwise, the load and the utilization of the sched_entity is\n\t * already zero and there is no pending propagation, so it will be a\n\t * waste of time to try to decay it:\n\t */\n\treturn true;\n}\n\n#else /* CONFIG_FAIR_GROUP_SCHED */\n\nstatic inline void update_tg_load_avg(struct cfs_rq *cfs_rq) {}\n\nstatic inline int propagate_entity_load_avg(struct sched_entity *se)\n{\n\treturn 0;\n}\n\nstatic inline void add_tg_cfs_propagate(struct cfs_rq *cfs_rq, long runnable_sum) {}\n\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n/**\n * update_cfs_rq_load_avg - update the cfs_rq's load/util averages\n * @now: current time, as per cfs_rq_clock_pelt()\n * @cfs_rq: cfs_rq to update\n *\n * The cfs_rq avg is the direct sum of all its entities (blocked and runnable)\n * avg. The immediate corollary is that all (fair) tasks must be attached, see\n * post_init_entity_util_avg().\n *\n * cfs_rq->avg is used for task_h_load() and update_cfs_share() for example.\n *\n * Returns true if the load decayed or we removed load.\n *\n * Since both these conditions indicate a changed cfs_rq->avg.load we should\n * call update_tg_load_avg() when this function returns true.\n */\nstatic inline int\nupdate_cfs_rq_load_avg(u64 now, struct cfs_rq *cfs_rq)\n{\n\tunsigned long removed_load = 0, removed_util = 0, removed_runnable = 0;\n\tstruct sched_avg *sa = &cfs_rq->avg;\n\tint decayed = 0;\n\n\tif (cfs_rq->removed.nr) {\n\t\tunsigned long r;\n\t\tu32 divider = get_pelt_divider(&cfs_rq->avg);\n\n\t\traw_spin_lock(&cfs_rq->removed.lock);\n\t\tswap(cfs_rq->removed.util_avg, removed_util);\n\t\tswap(cfs_rq->removed.load_avg, removed_load);\n\t\tswap(cfs_rq->removed.runnable_avg, removed_runnable);\n\t\tcfs_rq->removed.nr = 0;\n\t\traw_spin_unlock(&cfs_rq->removed.lock);\n\n\t\tr = removed_load;\n\t\tsub_positive(&sa->load_avg, r);\n\t\tsub_positive(&sa->load_sum, r * divider);\n\n\t\tr = removed_util;\n\t\tsub_positive(&sa->util_avg, r);\n\t\tsub_positive(&sa->util_sum, r * divider);\n\n\t\tr = removed_runnable;\n\t\tsub_positive(&sa->runnable_avg, r);\n\t\tsub_positive(&sa->runnable_sum, r * divider);\n\n\t\t/*\n\t\t * removed_runnable is the unweighted version of removed_load so we\n\t\t * can use it to estimate removed_load_sum.\n\t\t */\n\t\tadd_tg_cfs_propagate(cfs_rq,\n\t\t\t-(long)(removed_runnable * divider) >> SCHED_CAPACITY_SHIFT);\n\n\t\tdecayed = 1;\n\t}\n\n\tdecayed |= __update_load_avg_cfs_rq(now, cfs_rq);\n\n#ifndef CONFIG_64BIT\n\tsmp_wmb();\n\tcfs_rq->load_last_update_time_copy = sa->last_update_time;\n#endif\n\n\treturn decayed;\n}\n\n/**\n * attach_entity_load_avg - attach this entity to its cfs_rq load avg\n * @cfs_rq: cfs_rq to attach to\n * @se: sched_entity to attach\n *\n * Must call update_cfs_rq_load_avg() before this, since we rely on\n * cfs_rq->avg.last_update_time being current.\n */\nstatic void attach_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\t/*\n\t * cfs_rq->avg.period_contrib can be used for both cfs_rq and se.\n\t * See ___update_load_avg() for details.\n\t */\n\tu32 divider = get_pelt_divider(&cfs_rq->avg);\n\n\t/*\n\t * When we attach the @se to the @cfs_rq, we must align the decay\n\t * window because without that, really weird and wonderful things can\n\t * happen.\n\t *\n\t * XXX illustrate\n\t */\n\tse->avg.last_update_time = cfs_rq->avg.last_update_time;\n\tse->avg.period_contrib = cfs_rq->avg.period_contrib;\n\n\t/*\n\t * Hell(o) Nasty stuff.. we need to recompute _sum based on the new\n\t * period_contrib. This isn't strictly correct, but since we're\n\t * entirely outside of the PELT hierarchy, nobody cares if we truncate\n\t * _sum a little.\n\t */\n\tse->avg.util_sum = se->avg.util_avg * divider;\n\n\tse->avg.runnable_sum = se->avg.runnable_avg * divider;\n\n\tse->avg.load_sum = divider;\n\tif (se_weight(se)) {\n\t\tse->avg.load_sum =\n\t\t\tdiv_u64(se->avg.load_avg * se->avg.load_sum, se_weight(se));\n\t}\n\n\tenqueue_load_avg(cfs_rq, se);\n\tcfs_rq->avg.util_avg += se->avg.util_avg;\n\tcfs_rq->avg.util_sum += se->avg.util_sum;\n\tcfs_rq->avg.runnable_avg += se->avg.runnable_avg;\n\tcfs_rq->avg.runnable_sum += se->avg.runnable_sum;\n\n\tadd_tg_cfs_propagate(cfs_rq, se->avg.load_sum);\n\n\tcfs_rq_util_change(cfs_rq, 0);\n\n\ttrace_pelt_cfs_tp(cfs_rq);\n}\n\n/**\n * detach_entity_load_avg - detach this entity from its cfs_rq load avg\n * @cfs_rq: cfs_rq to detach from\n * @se: sched_entity to detach\n *\n * Must call update_cfs_rq_load_avg() before this, since we rely on\n * cfs_rq->avg.last_update_time being current.\n */\nstatic void detach_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tdequeue_load_avg(cfs_rq, se);\n\tsub_positive(&cfs_rq->avg.util_avg, se->avg.util_avg);\n\tsub_positive(&cfs_rq->avg.util_sum, se->avg.util_sum);\n\tsub_positive(&cfs_rq->avg.runnable_avg, se->avg.runnable_avg);\n\tsub_positive(&cfs_rq->avg.runnable_sum, se->avg.runnable_sum);\n\n\tadd_tg_cfs_propagate(cfs_rq, -se->avg.load_sum);\n\n\tcfs_rq_util_change(cfs_rq, 0);\n\n\ttrace_pelt_cfs_tp(cfs_rq);\n}\n\n/*\n * Optional action to be done while updating the load average\n */\n#define UPDATE_TG\t0x1\n#define SKIP_AGE_LOAD\t0x2\n#define DO_ATTACH\t0x4\n\n/* Update task and its cfs_rq load average */\nstatic inline void update_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)\n{\n\tu64 now = cfs_rq_clock_pelt(cfs_rq);\n\tint decayed;\n\n\t/*\n\t * Track task load average for carrying it to new CPU after migrated, and\n\t * track group sched_entity load average for task_h_load calc in migration\n\t */\n\tif (se->avg.last_update_time && !(flags & SKIP_AGE_LOAD))\n\t\t__update_load_avg_se(now, cfs_rq, se);\n\n\tdecayed  = update_cfs_rq_load_avg(now, cfs_rq);\n\tdecayed |= propagate_entity_load_avg(se);\n\n\tif (!se->avg.last_update_time && (flags & DO_ATTACH)) {\n\n\t\t/*\n\t\t * DO_ATTACH means we're here from enqueue_entity().\n\t\t * !last_update_time means we've passed through\n\t\t * migrate_task_rq_fair() indicating we migrated.\n\t\t *\n\t\t * IOW we're enqueueing a task on a new CPU.\n\t\t */\n\t\tattach_entity_load_avg(cfs_rq, se);\n\t\tupdate_tg_load_avg(cfs_rq);\n\n\t} else if (decayed) {\n\t\tcfs_rq_util_change(cfs_rq, 0);\n\n\t\tif (flags & UPDATE_TG)\n\t\t\tupdate_tg_load_avg(cfs_rq);\n\t}\n}\n\n#ifndef CONFIG_64BIT\nstatic inline u64 cfs_rq_last_update_time(struct cfs_rq *cfs_rq)\n{\n\tu64 last_update_time_copy;\n\tu64 last_update_time;\n\n\tdo {\n\t\tlast_update_time_copy = cfs_rq->load_last_update_time_copy;\n\t\tsmp_rmb();\n\t\tlast_update_time = cfs_rq->avg.last_update_time;\n\t} while (last_update_time != last_update_time_copy);\n\n\treturn last_update_time;\n}\n#else\nstatic inline u64 cfs_rq_last_update_time(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->avg.last_update_time;\n}\n#endif\n\n/*\n * Synchronize entity load avg of dequeued entity without locking\n * the previous rq.\n */\nstatic void sync_entity_load_avg(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tu64 last_update_time;\n\n\tlast_update_time = cfs_rq_last_update_time(cfs_rq);\n\t__update_load_avg_blocked_se(last_update_time, se);\n}\n\n/*\n * Task first catches up with cfs_rq, and then subtract\n * itself from the cfs_rq (task must be off the queue now).\n */\nstatic void remove_entity_load_avg(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\tunsigned long flags;\n\n\t/*\n\t * tasks cannot exit without having gone through wake_up_new_task() ->\n\t * post_init_entity_util_avg() which will have added things to the\n\t * cfs_rq, so we can remove unconditionally.\n\t */\n\n\tsync_entity_load_avg(se);\n\n\traw_spin_lock_irqsave(&cfs_rq->removed.lock, flags);\n\t++cfs_rq->removed.nr;\n\tcfs_rq->removed.util_avg\t+= se->avg.util_avg;\n\tcfs_rq->removed.load_avg\t+= se->avg.load_avg;\n\tcfs_rq->removed.runnable_avg\t+= se->avg.runnable_avg;\n\traw_spin_unlock_irqrestore(&cfs_rq->removed.lock, flags);\n}\n\nstatic inline unsigned long cfs_rq_runnable_avg(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->avg.runnable_avg;\n}\n\nstatic inline unsigned long cfs_rq_load_avg(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->avg.load_avg;\n}\n\nstatic int newidle_balance(struct rq *this_rq, struct rq_flags *rf);\n\nstatic inline unsigned long task_util(struct task_struct *p)\n{\n\treturn READ_ONCE(p->se.avg.util_avg);\n}\n\nstatic inline unsigned long _task_util_est(struct task_struct *p)\n{\n\tstruct util_est ue = READ_ONCE(p->se.avg.util_est);\n\n\treturn (max(ue.ewma, ue.enqueued) | UTIL_AVG_UNCHANGED);\n}\n\nstatic inline unsigned long task_util_est(struct task_struct *p)\n{\n\treturn max(task_util(p), _task_util_est(p));\n}\n\n#ifdef CONFIG_UCLAMP_TASK\nstatic inline unsigned long uclamp_task_util(struct task_struct *p)\n{\n\treturn clamp(task_util_est(p),\n\t\t     uclamp_eff_value(p, UCLAMP_MIN),\n\t\t     uclamp_eff_value(p, UCLAMP_MAX));\n}\n#else\nstatic inline unsigned long uclamp_task_util(struct task_struct *p)\n{\n\treturn task_util_est(p);\n}\n#endif\n\nstatic inline void util_est_enqueue(struct cfs_rq *cfs_rq,\n\t\t\t\t    struct task_struct *p)\n{\n\tunsigned int enqueued;\n\n\tif (!sched_feat(UTIL_EST))\n\t\treturn;\n\n\t/* Update root cfs_rq's estimated utilization */\n\tenqueued  = cfs_rq->avg.util_est.enqueued;\n\tenqueued += _task_util_est(p);\n\tWRITE_ONCE(cfs_rq->avg.util_est.enqueued, enqueued);\n\n\ttrace_sched_util_est_cfs_tp(cfs_rq);\n}\n\nstatic inline void util_est_dequeue(struct cfs_rq *cfs_rq,\n\t\t\t\t    struct task_struct *p)\n{\n\tunsigned int enqueued;\n\n\tif (!sched_feat(UTIL_EST))\n\t\treturn;\n\n\t/* Update root cfs_rq's estimated utilization */\n\tenqueued  = cfs_rq->avg.util_est.enqueued;\n\tenqueued -= min_t(unsigned int, enqueued, _task_util_est(p));\n\tWRITE_ONCE(cfs_rq->avg.util_est.enqueued, enqueued);\n\n\ttrace_sched_util_est_cfs_tp(cfs_rq);\n}\n\n/*\n * Check if a (signed) value is within a specified (unsigned) margin,\n * based on the observation that:\n *\n *     abs(x) < y := (unsigned)(x + y - 1) < (2 * y - 1)\n *\n * NOTE: this only works when value + maring < INT_MAX.\n */\nstatic inline bool within_margin(int value, int margin)\n{\n\treturn ((unsigned int)(value + margin - 1) < (2 * margin - 1));\n}\n\nstatic inline void util_est_update(struct cfs_rq *cfs_rq,\n\t\t\t\t   struct task_struct *p,\n\t\t\t\t   bool task_sleep)\n{\n\tlong last_ewma_diff;\n\tstruct util_est ue;\n\n\tif (!sched_feat(UTIL_EST))\n\t\treturn;\n\n\t/*\n\t * Skip update of task's estimated utilization when the task has not\n\t * yet completed an activation, e.g. being migrated.\n\t */\n\tif (!task_sleep)\n\t\treturn;\n\n\t/*\n\t * If the PELT values haven't changed since enqueue time,\n\t * skip the util_est update.\n\t */\n\tue = p->se.avg.util_est;\n\tif (ue.enqueued & UTIL_AVG_UNCHANGED)\n\t\treturn;\n\n\t/*\n\t * Reset EWMA on utilization increases, the moving average is used only\n\t * to smooth utilization decreases.\n\t */\n\tue.enqueued = (task_util(p) | UTIL_AVG_UNCHANGED);\n\tif (sched_feat(UTIL_EST_FASTUP)) {\n\t\tif (ue.ewma < ue.enqueued) {\n\t\t\tue.ewma = ue.enqueued;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * Skip update of task's estimated utilization when its EWMA is\n\t * already ~1% close to its last activation value.\n\t */\n\tlast_ewma_diff = ue.enqueued - ue.ewma;\n\tif (within_margin(last_ewma_diff, (SCHED_CAPACITY_SCALE / 100)))\n\t\treturn;\n\n\t/*\n\t * To avoid overestimation of actual task utilization, skip updates if\n\t * we cannot grant there is idle time in this CPU.\n\t */\n\tif (task_util(p) > capacity_orig_of(cpu_of(rq_of(cfs_rq))))\n\t\treturn;\n\n\t/*\n\t * Update Task's estimated utilization\n\t *\n\t * When *p completes an activation we can consolidate another sample\n\t * of the task size. This is done by storing the current PELT value\n\t * as ue.enqueued and by using this value to update the Exponential\n\t * Weighted Moving Average (EWMA):\n\t *\n\t *  ewma(t) = w *  task_util(p) + (1-w) * ewma(t-1)\n\t *          = w *  task_util(p) +         ewma(t-1)  - w * ewma(t-1)\n\t *          = w * (task_util(p) -         ewma(t-1)) +     ewma(t-1)\n\t *          = w * (      last_ewma_diff            ) +     ewma(t-1)\n\t *          = w * (last_ewma_diff  +  ewma(t-1) / w)\n\t *\n\t * Where 'w' is the weight of new samples, which is configured to be\n\t * 0.25, thus making w=1/4 ( >>= UTIL_EST_WEIGHT_SHIFT)\n\t */\n\tue.ewma <<= UTIL_EST_WEIGHT_SHIFT;\n\tue.ewma  += last_ewma_diff;\n\tue.ewma >>= UTIL_EST_WEIGHT_SHIFT;\ndone:\n\tWRITE_ONCE(p->se.avg.util_est, ue);\n\n\ttrace_sched_util_est_se_tp(&p->se);\n}\n\nstatic inline int task_fits_capacity(struct task_struct *p, long capacity)\n{\n\treturn fits_capacity(uclamp_task_util(p), capacity);\n}\n\nstatic inline void update_misfit_status(struct task_struct *p, struct rq *rq)\n{\n\tif (!static_branch_unlikely(&sched_asym_cpucapacity))\n\t\treturn;\n\n\tif (!p) {\n\t\trq->misfit_task_load = 0;\n\t\treturn;\n\t}\n\n\tif (task_fits_capacity(p, capacity_of(cpu_of(rq)))) {\n\t\trq->misfit_task_load = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * Make sure that misfit_task_load will not be null even if\n\t * task_h_load() returns 0.\n\t */\n\trq->misfit_task_load = max_t(unsigned long, task_h_load(p), 1);\n}\n\n#else /* CONFIG_SMP */\n\n#define UPDATE_TG\t0x0\n#define SKIP_AGE_LOAD\t0x0\n#define DO_ATTACH\t0x0\n\nstatic inline void update_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se, int not_used1)\n{\n\tcfs_rq_util_change(cfs_rq, 0);\n}\n\nstatic inline void remove_entity_load_avg(struct sched_entity *se) {}\n\nstatic inline void\nattach_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se) {}\nstatic inline void\ndetach_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se) {}\n\nstatic inline int newidle_balance(struct rq *rq, struct rq_flags *rf)\n{\n\treturn 0;\n}\n\nstatic inline void\nutil_est_enqueue(struct cfs_rq *cfs_rq, struct task_struct *p) {}\n\nstatic inline void\nutil_est_dequeue(struct cfs_rq *cfs_rq, struct task_struct *p) {}\n\nstatic inline void\nutil_est_update(struct cfs_rq *cfs_rq, struct task_struct *p,\n\t\tbool task_sleep) {}\nstatic inline void update_misfit_status(struct task_struct *p, struct rq *rq) {}\n\n#endif /* CONFIG_SMP */\n\nstatic void check_spread(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\ts64 d = se->vruntime - cfs_rq->min_vruntime;\n\n\tif (d < 0)\n\t\td = -d;\n\n\tif (d > 3*sysctl_sched_latency)\n\t\tschedstat_inc(cfs_rq->nr_spread_over);\n#endif\n}\n\nstatic void\nplace_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)\n{\n\tu64 vruntime = cfs_rq->min_vruntime;\n\n\t/*\n\t * The 'current' period is already promised to the current tasks,\n\t * however the extra weight of the new task will slow them down a\n\t * little, place the new task so that it fits in the slot that\n\t * stays open at the end.\n\t */\n\tif (initial && sched_feat(START_DEBIT))\n\t\tvruntime += sched_vslice(cfs_rq, se);\n\n\t/* sleeps up to a single latency don't count. */\n\tif (!initial) {\n\t\tunsigned long thresh = sysctl_sched_latency;\n\n\t\t/*\n\t\t * Halve their sleep time's effect, to allow\n\t\t * for a gentler effect of sleepers:\n\t\t */\n\t\tif (sched_feat(GENTLE_FAIR_SLEEPERS))\n\t\t\tthresh >>= 1;\n\n\t\tvruntime -= thresh;\n\t}\n\n\t/* ensure we never gain time by being placed backwards. */\n\tse->vruntime = max_vruntime(se->vruntime, vruntime);\n}\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\n\nstatic inline void check_schedstat_required(void)\n{\n#ifdef CONFIG_SCHEDSTATS\n\tif (schedstat_enabled())\n\t\treturn;\n\n\t/* Force schedstat enabled if a dependent tracepoint is active */\n\tif (trace_sched_stat_wait_enabled()    ||\n\t\t\ttrace_sched_stat_sleep_enabled()   ||\n\t\t\ttrace_sched_stat_iowait_enabled()  ||\n\t\t\ttrace_sched_stat_blocked_enabled() ||\n\t\t\ttrace_sched_stat_runtime_enabled())  {\n\t\tprintk_deferred_once(\"Scheduler tracepoints stat_sleep, stat_iowait, \"\n\t\t\t     \"stat_blocked and stat_runtime require the \"\n\t\t\t     \"kernel parameter schedstats=enable or \"\n\t\t\t     \"kernel.sched_schedstats=1\\n\");\n\t}\n#endif\n}\n\nstatic inline bool cfs_bandwidth_used(void);\n\n/*\n * MIGRATION\n *\n *\tdequeue\n *\t  update_curr()\n *\t    update_min_vruntime()\n *\t  vruntime -= min_vruntime\n *\n *\tenqueue\n *\t  update_curr()\n *\t    update_min_vruntime()\n *\t  vruntime += min_vruntime\n *\n * this way the vruntime transition between RQs is done when both\n * min_vruntime are up-to-date.\n *\n * WAKEUP (remote)\n *\n *\t->migrate_task_rq_fair() (p->state == TASK_WAKING)\n *\t  vruntime -= min_vruntime\n *\n *\tenqueue\n *\t  update_curr()\n *\t    update_min_vruntime()\n *\t  vruntime += min_vruntime\n *\n * this way we don't have the most up-to-date min_vruntime on the originating\n * CPU and an up-to-date min_vruntime on the destination CPU.\n */\n\nstatic void\nenqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)\n{\n\tbool renorm = !(flags & ENQUEUE_WAKEUP) || (flags & ENQUEUE_MIGRATED);\n\tbool curr = cfs_rq->curr == se;\n\n\t/*\n\t * If we're the current task, we must renormalise before calling\n\t * update_curr().\n\t */\n\tif (renorm && curr)\n\t\tse->vruntime += cfs_rq->min_vruntime;\n\n\tupdate_curr(cfs_rq);\n\n\t/*\n\t * Otherwise, renormalise after, such that we're placed at the current\n\t * moment in time, instead of some random moment in the past. Being\n\t * placed in the past could significantly boost this task to the\n\t * fairness detriment of existing tasks.\n\t */\n\tif (renorm && !curr)\n\t\tse->vruntime += cfs_rq->min_vruntime;\n\n\t/*\n\t * When enqueuing a sched_entity, we must:\n\t *   - Update loads to have both entity and cfs_rq synced with now.\n\t *   - Add its load to cfs_rq->runnable_avg\n\t *   - For group_entity, update its weight to reflect the new share of\n\t *     its group cfs_rq\n\t *   - Add its new weight to cfs_rq->load.weight\n\t */\n\tupdate_load_avg(cfs_rq, se, UPDATE_TG | DO_ATTACH);\n\tse_update_runnable(se);\n\tupdate_cfs_group(se);\n\taccount_entity_enqueue(cfs_rq, se);\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tplace_entity(cfs_rq, se, 0);\n\n\tcheck_schedstat_required();\n\tupdate_stats_enqueue(cfs_rq, se, flags);\n\tcheck_spread(cfs_rq, se);\n\tif (!curr)\n\t\t__enqueue_entity(cfs_rq, se);\n\tse->on_rq = 1;\n\n\t/*\n\t * When bandwidth control is enabled, cfs might have been removed\n\t * because of a parent been throttled but cfs->nr_running > 1. Try to\n\t * add it unconditionnally.\n\t */\n\tif (cfs_rq->nr_running == 1 || cfs_bandwidth_used())\n\t\tlist_add_leaf_cfs_rq(cfs_rq);\n\n\tif (cfs_rq->nr_running == 1)\n\t\tcheck_enqueue_throttle(cfs_rq);\n}\n\nstatic void __clear_buddies_last(struct sched_entity *se)\n{\n\tfor_each_sched_entity(se) {\n\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\t\tif (cfs_rq->last != se)\n\t\t\tbreak;\n\n\t\tcfs_rq->last = NULL;\n\t}\n}\n\nstatic void __clear_buddies_next(struct sched_entity *se)\n{\n\tfor_each_sched_entity(se) {\n\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\t\tif (cfs_rq->next != se)\n\t\t\tbreak;\n\n\t\tcfs_rq->next = NULL;\n\t}\n}\n\nstatic void __clear_buddies_skip(struct sched_entity *se)\n{\n\tfor_each_sched_entity(se) {\n\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\t\tif (cfs_rq->skip != se)\n\t\t\tbreak;\n\n\t\tcfs_rq->skip = NULL;\n\t}\n}\n\nstatic void clear_buddies(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tif (cfs_rq->last == se)\n\t\t__clear_buddies_last(se);\n\n\tif (cfs_rq->next == se)\n\t\t__clear_buddies_next(se);\n\n\tif (cfs_rq->skip == se)\n\t\t__clear_buddies_skip(se);\n}\n\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic void\ndequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)\n{\n\t/*\n\t * Update run-time statistics of the 'current'.\n\t */\n\tupdate_curr(cfs_rq);\n\n\t/*\n\t * When dequeuing a sched_entity, we must:\n\t *   - Update loads to have both entity and cfs_rq synced with now.\n\t *   - Subtract its load from the cfs_rq->runnable_avg.\n\t *   - Subtract its previous weight from cfs_rq->load.weight.\n\t *   - For group entity, update its weight to reflect the new share\n\t *     of its group cfs_rq.\n\t */\n\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\tse_update_runnable(se);\n\n\tupdate_stats_dequeue(cfs_rq, se, flags);\n\n\tclear_buddies(cfs_rq, se);\n\n\tif (se != cfs_rq->curr)\n\t\t__dequeue_entity(cfs_rq, se);\n\tse->on_rq = 0;\n\taccount_entity_dequeue(cfs_rq, se);\n\n\t/*\n\t * Normalize after update_curr(); which will also have moved\n\t * min_vruntime if @se is the one holding it back. But before doing\n\t * update_min_vruntime() again, which will discount @se's position and\n\t * can move min_vruntime forward still more.\n\t */\n\tif (!(flags & DEQUEUE_SLEEP))\n\t\tse->vruntime -= cfs_rq->min_vruntime;\n\n\t/* return excess runtime on last dequeue */\n\treturn_cfs_rq_runtime(cfs_rq);\n\n\tupdate_cfs_group(se);\n\n\t/*\n\t * Now advance min_vruntime if @se was the entity holding it back,\n\t * except when: DEQUEUE_SAVE && !DEQUEUE_MOVE, in this case we'll be\n\t * put back on, and if we advance min_vruntime, we'll be placed back\n\t * further than we started -- ie. we'll be penalized.\n\t */\n\tif ((flags & (DEQUEUE_SAVE | DEQUEUE_MOVE)) != DEQUEUE_SAVE)\n\t\tupdate_min_vruntime(cfs_rq);\n}\n\n/*\n * Preempt the current task with a newly woken task if needed:\n */\nstatic void\ncheck_preempt_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr)\n{\n\tunsigned long ideal_runtime, delta_exec;\n\tstruct sched_entity *se;\n\ts64 delta;\n\n\tideal_runtime = sched_slice(cfs_rq, curr);\n\tdelta_exec = curr->sum_exec_runtime - curr->prev_sum_exec_runtime;\n\tif (delta_exec > ideal_runtime) {\n\t\tresched_curr(rq_of(cfs_rq));\n\t\t/*\n\t\t * The current task ran long enough, ensure it doesn't get\n\t\t * re-elected due to buddy favours.\n\t\t */\n\t\tclear_buddies(cfs_rq, curr);\n\t\treturn;\n\t}\n\n\t/*\n\t * Ensure that a task that missed wakeup preemption by a\n\t * narrow margin doesn't have to wait for a full slice.\n\t * This also mitigates buddy induced latencies under load.\n\t */\n\tif (delta_exec < sysctl_sched_min_granularity)\n\t\treturn;\n\n\tse = __pick_first_entity(cfs_rq);\n\tdelta = curr->vruntime - se->vruntime;\n\n\tif (delta < 0)\n\t\treturn;\n\n\tif (delta > ideal_runtime)\n\t\tresched_curr(rq_of(cfs_rq));\n}\n\nstatic void\nset_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\t/* 'current' is not kept within the tree. */\n\tif (se->on_rq) {\n\t\t/*\n\t\t * Any task has to be enqueued before it get to execute on\n\t\t * a CPU. So account for the time it spent waiting on the\n\t\t * runqueue.\n\t\t */\n\t\tupdate_stats_wait_end(cfs_rq, se);\n\t\t__dequeue_entity(cfs_rq, se);\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t}\n\n\tupdate_stats_curr_start(cfs_rq, se);\n\tcfs_rq->curr = se;\n\n\t/*\n\t * Track our maximum slice length, if the CPU's load is at\n\t * least twice that of our own weight (i.e. dont track it\n\t * when there are only lesser-weight tasks around):\n\t */\n\tif (schedstat_enabled() &&\n\t    rq_of(cfs_rq)->cfs.load.weight >= 2*se->load.weight) {\n\t\tschedstat_set(se->statistics.slice_max,\n\t\t\tmax((u64)schedstat_val(se->statistics.slice_max),\n\t\t\t    se->sum_exec_runtime - se->prev_sum_exec_runtime));\n\t}\n\n\tse->prev_sum_exec_runtime = se->sum_exec_runtime;\n}\n\nstatic int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se);\n\n/*\n * Pick the next process, keeping these things in mind, in this order:\n * 1) keep things fair between processes/task groups\n * 2) pick the \"next\" process, since someone really wants that to run\n * 3) pick the \"last\" process, for cache locality\n * 4) do not run the \"skip\" process, if something else is available\n */\nstatic struct sched_entity *\npick_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *curr)\n{\n\tstruct sched_entity *left = __pick_first_entity(cfs_rq);\n\tstruct sched_entity *se;\n\n\t/*\n\t * If curr is set we have to see if its left of the leftmost entity\n\t * still in the tree, provided there was anything in the tree at all.\n\t */\n\tif (!left || (curr && entity_before(curr, left)))\n\t\tleft = curr;\n\n\tse = left; /* ideally we run the leftmost entity */\n\n\t/*\n\t * Avoid running the skip buddy, if running something else can\n\t * be done without getting too unfair.\n\t */\n\tif (cfs_rq->skip == se) {\n\t\tstruct sched_entity *second;\n\n\t\tif (se == curr) {\n\t\t\tsecond = __pick_first_entity(cfs_rq);\n\t\t} else {\n\t\t\tsecond = __pick_next_entity(se);\n\t\t\tif (!second || (curr && entity_before(curr, second)))\n\t\t\t\tsecond = curr;\n\t\t}\n\n\t\tif (second && wakeup_preempt_entity(second, left) < 1)\n\t\t\tse = second;\n\t}\n\n\tif (cfs_rq->next && wakeup_preempt_entity(cfs_rq->next, left) < 1) {\n\t\t/*\n\t\t * Someone really wants this to run. If it's not unfair, run it.\n\t\t */\n\t\tse = cfs_rq->next;\n\t} else if (cfs_rq->last && wakeup_preempt_entity(cfs_rq->last, left) < 1) {\n\t\t/*\n\t\t * Prefer last buddy, try to return the CPU to a preempted task.\n\t\t */\n\t\tse = cfs_rq->last;\n\t}\n\n\tclear_buddies(cfs_rq, se);\n\n\treturn se;\n}\n\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic void put_prev_entity(struct cfs_rq *cfs_rq, struct sched_entity *prev)\n{\n\t/*\n\t * If still on the runqueue then deactivate_task()\n\t * was not called and update_curr() has to be done:\n\t */\n\tif (prev->on_rq)\n\t\tupdate_curr(cfs_rq);\n\n\t/* throttle cfs_rqs exceeding runtime */\n\tcheck_cfs_rq_runtime(cfs_rq);\n\n\tcheck_spread(cfs_rq, prev);\n\n\tif (prev->on_rq) {\n\t\tupdate_stats_wait_start(cfs_rq, prev);\n\t\t/* Put 'current' back into the tree. */\n\t\t__enqueue_entity(cfs_rq, prev);\n\t\t/* in !on_rq case, update occurred at dequeue */\n\t\tupdate_load_avg(cfs_rq, prev, 0);\n\t}\n\tcfs_rq->curr = NULL;\n}\n\nstatic void\nentity_tick(struct cfs_rq *cfs_rq, struct sched_entity *curr, int queued)\n{\n\t/*\n\t * Update run-time statistics of the 'current'.\n\t */\n\tupdate_curr(cfs_rq);\n\n\t/*\n\t * Ensure that runnable average is periodically updated.\n\t */\n\tupdate_load_avg(cfs_rq, curr, UPDATE_TG);\n\tupdate_cfs_group(curr);\n\n#ifdef CONFIG_SCHED_HRTICK\n\t/*\n\t * queued ticks are scheduled to match the slice, so don't bother\n\t * validating it and just reschedule.\n\t */\n\tif (queued) {\n\t\tresched_curr(rq_of(cfs_rq));\n\t\treturn;\n\t}\n\t/*\n\t * don't let the period tick interfere with the hrtick preemption\n\t */\n\tif (!sched_feat(DOUBLE_TICK) &&\n\t\t\thrtimer_active(&rq_of(cfs_rq)->hrtick_timer))\n\t\treturn;\n#endif\n\n\tif (cfs_rq->nr_running > 1)\n\t\tcheck_preempt_tick(cfs_rq, curr);\n}\n\n\n/**************************************************\n * CFS bandwidth control machinery\n */\n\n#ifdef CONFIG_CFS_BANDWIDTH\n\n#ifdef CONFIG_JUMP_LABEL\nstatic struct static_key __cfs_bandwidth_used;\n\nstatic inline bool cfs_bandwidth_used(void)\n{\n\treturn static_key_false(&__cfs_bandwidth_used);\n}\n\nvoid cfs_bandwidth_usage_inc(void)\n{\n\tstatic_key_slow_inc_cpuslocked(&__cfs_bandwidth_used);\n}\n\nvoid cfs_bandwidth_usage_dec(void)\n{\n\tstatic_key_slow_dec_cpuslocked(&__cfs_bandwidth_used);\n}\n#else /* CONFIG_JUMP_LABEL */\nstatic bool cfs_bandwidth_used(void)\n{\n\treturn true;\n}\n\nvoid cfs_bandwidth_usage_inc(void) {}\nvoid cfs_bandwidth_usage_dec(void) {}\n#endif /* CONFIG_JUMP_LABEL */\n\n/*\n * default period for cfs group bandwidth.\n * default: 0.1s, units: nanoseconds\n */\nstatic inline u64 default_cfs_period(void)\n{\n\treturn 100000000ULL;\n}\n\nstatic inline u64 sched_cfs_bandwidth_slice(void)\n{\n\treturn (u64)sysctl_sched_cfs_bandwidth_slice * NSEC_PER_USEC;\n}\n\n/*\n * Replenish runtime according to assigned quota. We use sched_clock_cpu\n * directly instead of rq->clock to avoid adding additional synchronization\n * around rq->lock.\n *\n * requires cfs_b->lock\n */\nvoid __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tif (cfs_b->quota != RUNTIME_INF)\n\t\tcfs_b->runtime = cfs_b->quota;\n}\n\nstatic inline struct cfs_bandwidth *tg_cfs_bandwidth(struct task_group *tg)\n{\n\treturn &tg->cfs_bandwidth;\n}\n\n/* returns 0 on failure to allocate runtime */\nstatic int __assign_cfs_rq_runtime(struct cfs_bandwidth *cfs_b,\n\t\t\t\t   struct cfs_rq *cfs_rq, u64 target_runtime)\n{\n\tu64 min_amount, amount = 0;\n\n\tlockdep_assert_held(&cfs_b->lock);\n\n\t/* note: this is a positive sum as runtime_remaining <= 0 */\n\tmin_amount = target_runtime - cfs_rq->runtime_remaining;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\n\tcfs_rq->runtime_remaining += amount;\n\n\treturn cfs_rq->runtime_remaining > 0;\n}\n\n/* returns 0 on failure to allocate runtime */\nstatic int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tint ret;\n\n\traw_spin_lock(&cfs_b->lock);\n\tret = __assign_cfs_rq_runtime(cfs_b, cfs_rq, sched_cfs_bandwidth_slice());\n\traw_spin_unlock(&cfs_b->lock);\n\n\treturn ret;\n}\n\nstatic void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\t/* dock delta_exec before expiring quota (as it could span periods) */\n\tcfs_rq->runtime_remaining -= delta_exec;\n\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\n\tif (cfs_rq->throttled)\n\t\treturn;\n\t/*\n\t * if we're unable to extend our runtime we resched so that the active\n\t * hierarchy can be throttled\n\t */\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}\n\nstatic __always_inline\nvoid account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tif (!cfs_bandwidth_used() || !cfs_rq->runtime_enabled)\n\t\treturn;\n\n\t__account_cfs_rq_runtime(cfs_rq, delta_exec);\n}\n\nstatic inline int cfs_rq_throttled(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_bandwidth_used() && cfs_rq->throttled;\n}\n\n/* check whether cfs_rq, or any parent, is throttled */\nstatic inline int throttled_hierarchy(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_bandwidth_used() && cfs_rq->throttle_count;\n}\n\n/*\n * Ensure that neither of the group entities corresponding to src_cpu or\n * dest_cpu are members of a throttled hierarchy when performing group\n * load-balance operations.\n */\nstatic inline int throttled_lb_pair(struct task_group *tg,\n\t\t\t\t    int src_cpu, int dest_cpu)\n{\n\tstruct cfs_rq *src_cfs_rq, *dest_cfs_rq;\n\n\tsrc_cfs_rq = tg->cfs_rq[src_cpu];\n\tdest_cfs_rq = tg->cfs_rq[dest_cpu];\n\n\treturn throttled_hierarchy(src_cfs_rq) ||\n\t       throttled_hierarchy(dest_cfs_rq);\n}\n\nstatic int tg_unthrottle_up(struct task_group *tg, void *data)\n{\n\tstruct rq *rq = data;\n\tstruct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];\n\n\tcfs_rq->throttle_count--;\n\tif (!cfs_rq->throttle_count) {\n\t\tcfs_rq->throttled_clock_task_time += rq_clock_task(rq) -\n\t\t\t\t\t     cfs_rq->throttled_clock_task;\n\n\t\t/* Add cfs_rq with already running entity in the list */\n\t\tif (cfs_rq->nr_running >= 1)\n\t\t\tlist_add_leaf_cfs_rq(cfs_rq);\n\t}\n\n\treturn 0;\n}\n\nstatic int tg_throttle_down(struct task_group *tg, void *data)\n{\n\tstruct rq *rq = data;\n\tstruct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];\n\n\t/* group is entering throttled state, stop time */\n\tif (!cfs_rq->throttle_count) {\n\t\tcfs_rq->throttled_clock_task = rq_clock_task(rq);\n\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t}\n\tcfs_rq->throttle_count++;\n\n\treturn 0;\n}\n\nstatic bool throttle_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tstruct sched_entity *se;\n\tlong task_delta, idle_task_delta, dequeue = 1;\n\n\traw_spin_lock(&cfs_b->lock);\n\t/* This will start the period timer if necessary */\n\tif (__assign_cfs_rq_runtime(cfs_b, cfs_rq, 1)) {\n\t\t/*\n\t\t * We have raced with bandwidth becoming available, and if we\n\t\t * actually throttled the timer might not unthrottle us for an\n\t\t * entire period. We additionally needed to make sure that any\n\t\t * subsequent check_cfs_rq_runtime calls agree not to throttle\n\t\t * us, as we may commit to do cfs put_prev+pick_next, so we ask\n\t\t * for 1ns of runtime rather than just check cfs_b.\n\t\t */\n\t\tdequeue = 0;\n\t} else {\n\t\tlist_add_tail_rcu(&cfs_rq->throttled_list,\n\t\t\t\t  &cfs_b->throttled_cfs_rq);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tif (!dequeue)\n\t\treturn false;  /* Throttle no longer required. */\n\n\tse = cfs_rq->tg->se[cpu_of(rq_of(cfs_rq))];\n\n\t/* freeze hierarchy runnable averages while throttled */\n\trcu_read_lock();\n\twalk_tg_tree_from(cfs_rq->tg, tg_throttle_down, tg_nop, (void *)rq);\n\trcu_read_unlock();\n\n\ttask_delta = cfs_rq->h_nr_running;\n\tidle_task_delta = cfs_rq->idle_h_nr_running;\n\tfor_each_sched_entity(se) {\n\t\tstruct cfs_rq *qcfs_rq = cfs_rq_of(se);\n\t\t/* throttled entity or throttle-on-deactivate */\n\t\tif (!se->on_rq)\n\t\t\tgoto done;\n\n\t\tdequeue_entity(qcfs_rq, se, DEQUEUE_SLEEP);\n\n\t\tqcfs_rq->h_nr_running -= task_delta;\n\t\tqcfs_rq->idle_h_nr_running -= idle_task_delta;\n\n\t\tif (qcfs_rq->load.weight) {\n\t\t\t/* Avoid re-evaluating load for this entity: */\n\t\t\tse = parent_entity(se);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor_each_sched_entity(se) {\n\t\tstruct cfs_rq *qcfs_rq = cfs_rq_of(se);\n\t\t/* throttled entity or throttle-on-deactivate */\n\t\tif (!se->on_rq)\n\t\t\tgoto done;\n\n\t\tupdate_load_avg(qcfs_rq, se, 0);\n\t\tse_update_runnable(se);\n\n\t\tqcfs_rq->h_nr_running -= task_delta;\n\t\tqcfs_rq->idle_h_nr_running -= idle_task_delta;\n\t}\n\n\t/* At this point se is NULL and we are at root level*/\n\tsub_nr_running(rq, task_delta);\n\ndone:\n\t/*\n\t * Note: distribution will already see us throttled via the\n\t * throttled-list.  rq->lock protects completion.\n\t */\n\tcfs_rq->throttled = 1;\n\tcfs_rq->throttled_clock = rq_clock(rq);\n\treturn true;\n}\n\nvoid unthrottle_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tstruct sched_entity *se;\n\tlong task_delta, idle_task_delta;\n\n\tse = cfs_rq->tg->se[cpu_of(rq)];\n\n\tcfs_rq->throttled = 0;\n\n\tupdate_rq_clock(rq);\n\n\traw_spin_lock(&cfs_b->lock);\n\tcfs_b->throttled_time += rq_clock(rq) - cfs_rq->throttled_clock;\n\tlist_del_rcu(&cfs_rq->throttled_list);\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* update hierarchical throttle state */\n\twalk_tg_tree_from(cfs_rq->tg, tg_nop, tg_unthrottle_up, (void *)rq);\n\n\tif (!cfs_rq->load.weight)\n\t\treturn;\n\n\ttask_delta = cfs_rq->h_nr_running;\n\tidle_task_delta = cfs_rq->idle_h_nr_running;\n\tfor_each_sched_entity(se) {\n\t\tif (se->on_rq)\n\t\t\tbreak;\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tenqueue_entity(cfs_rq, se, ENQUEUE_WAKEUP);\n\n\t\tcfs_rq->h_nr_running += task_delta;\n\t\tcfs_rq->idle_h_nr_running += idle_task_delta;\n\n\t\t/* end evaluation on encountering a throttled cfs_rq */\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tgoto unthrottle_throttle;\n\t}\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t\tse_update_runnable(se);\n\n\t\tcfs_rq->h_nr_running += task_delta;\n\t\tcfs_rq->idle_h_nr_running += idle_task_delta;\n\n\n\t\t/* end evaluation on encountering a throttled cfs_rq */\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tgoto unthrottle_throttle;\n\n\t\t/*\n\t\t * One parent has been throttled and cfs_rq removed from the\n\t\t * list. Add it back to not break the leaf list.\n\t\t */\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tlist_add_leaf_cfs_rq(cfs_rq);\n\t}\n\n\t/* At this point se is NULL and we are at root level*/\n\tadd_nr_running(rq, task_delta);\n\nunthrottle_throttle:\n\t/*\n\t * The cfs_rq_throttled() breaks in the above iteration can result in\n\t * incomplete leaf list maintenance, resulting in triggering the\n\t * assertion below.\n\t */\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tif (list_add_leaf_cfs_rq(cfs_rq))\n\t\t\tbreak;\n\t}\n\n\tassert_list_leaf_cfs_rq(rq);\n\n\t/* Determine whether we need to wake up potentially idle CPU: */\n\tif (rq->curr == rq->idle && rq->cfs.nr_running)\n\t\tresched_curr(rq);\n}\n\nstatic void distribute_cfs_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime, remaining = 1;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\t/* By the above check, this should never be true */\n\t\tSCHED_WARN_ON(cfs_rq->runtime_remaining > 0);\n\n\t\traw_spin_lock(&cfs_b->lock);\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > cfs_b->runtime)\n\t\t\truntime = cfs_b->runtime;\n\t\tcfs_b->runtime -= runtime;\n\t\tremaining = cfs_b->runtime;\n\t\traw_spin_unlock(&cfs_b->lock);\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\n\t\t/* we check whether we're throttled above */\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\n\n/*\n * Responsible for refilling a task_group's bandwidth and unthrottling its\n * cfs_rqs as appropriate. If there has been no activity within the last\n * period the timer is deactivated until scheduling resumes; cfs_b->idle is\n * used to track this state.\n */\nstatic int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)\n{\n\tint throttled;\n\n\t/* no need to continue the timer with no bandwidth constraint */\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tgoto out_deactivate;\n\n\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\tcfs_b->nr_periods += overrun;\n\n\t/*\n\t * idle depends on !throttled (for the case of a large deficit), and if\n\t * we're going inactive then everything else can be deferred\n\t */\n\tif (cfs_b->idle && !throttled)\n\t\tgoto out_deactivate;\n\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\n\tif (!throttled) {\n\t\t/* mark as potentially idle for the upcoming period */\n\t\tcfs_b->idle = 1;\n\t\treturn 0;\n\t}\n\n\t/* account preceding periods in which throttling occurred */\n\tcfs_b->nr_throttled += overrun;\n\n\t/*\n\t * This check is repeated as we release cfs_b->lock while we unthrottle.\n\t */\n\twhile (throttled && cfs_b->runtime > 0) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\t/* we can't nest cfs_b->lock while distributing bandwidth */\n\t\tdistribute_cfs_runtime(cfs_b);\n\t\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\n\t\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\t}\n\n\t/*\n\t * While we are ensured activity in the period following an\n\t * unthrottle, this also covers the case in which the new bandwidth is\n\t * insufficient to cover the existing bandwidth deficit.  (Forcing the\n\t * timer to remain active while there are any throttled entities.)\n\t */\n\tcfs_b->idle = 0;\n\n\treturn 0;\n\nout_deactivate:\n\treturn 1;\n}\n\n/* a cfs_rq won't donate quota below this amount */\nstatic const u64 min_cfs_rq_runtime = 1 * NSEC_PER_MSEC;\n/* minimum remaining period time to redistribute slack quota */\nstatic const u64 min_bandwidth_expiration = 2 * NSEC_PER_MSEC;\n/* how long we wait to gather additional slack before distributing */\nstatic const u64 cfs_bandwidth_slack_period = 5 * NSEC_PER_MSEC;\n\n/*\n * Are we near the end of the current quota period?\n *\n * Requires cfs_b->lock for hrtimer_expires_remaining to be safe against the\n * hrtimer base being cleared by hrtimer_start. In the case of\n * migrate_hrtimers, base is never cleared, so we are fine.\n */\nstatic int runtime_refresh_within(struct cfs_bandwidth *cfs_b, u64 min_expire)\n{\n\tstruct hrtimer *refresh_timer = &cfs_b->period_timer;\n\tu64 remaining;\n\n\t/* if the call-back is running a quota refresh is already occurring */\n\tif (hrtimer_callback_running(refresh_timer))\n\t\treturn 1;\n\n\t/* is a quota refresh about to occur? */\n\tremaining = ktime_to_ns(hrtimer_expires_remaining(refresh_timer));\n\tif (remaining < min_expire)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;\n\n\t/* if there's a quota refresh soon don't bother with slack */\n\tif (runtime_refresh_within(cfs_b, min_left))\n\t\treturn;\n\n\t/* don't push forwards an existing deferred unthrottle */\n\tif (cfs_b->slack_started)\n\t\treturn;\n\tcfs_b->slack_started = true;\n\n\thrtimer_start(&cfs_b->slack_timer,\n\t\t\tns_to_ktime(cfs_bandwidth_slack_period),\n\t\t\tHRTIMER_MODE_REL);\n}\n\n/* we know any runtime found here is valid as update_curr() precedes return */\nstatic void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\n\tif (slack_runtime <= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF) {\n\t\tcfs_b->runtime += slack_runtime;\n\n\t\t/* we are under rq->lock, defer unthrottling using a timer */\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* even if it's not valid for return we don't want to try again */\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}\n\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_bandwidth_used())\n\t\treturn;\n\n\tif (!cfs_rq->runtime_enabled || cfs_rq->nr_running)\n\t\treturn;\n\n\t__return_cfs_rq_runtime(cfs_rq);\n}\n\n/*\n * This is done with a timer (instead of inline with bandwidth return) since\n * it's necessary to juggle rq->locks to unthrottle their respective cfs_rqs.\n */\nstatic void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)\n{\n\tu64 runtime = 0, slice = sched_cfs_bandwidth_slice();\n\tunsigned long flags;\n\n\t/* confirm we're still not at a refresh boundary */\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tcfs_b->slack_started = false;\n\n\tif (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\n\tif (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)\n\t\truntime = cfs_b->runtime;\n\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\n\tif (!runtime)\n\t\treturn;\n\n\tdistribute_cfs_runtime(cfs_b);\n}\n\n/*\n * When a group wakes up we want to make sure that its quota is not already\n * expired/exceeded, otherwise it may be allowed to steal additional ticks of\n * runtime as update_curr() throttling can not trigger until it's on-rq.\n */\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_bandwidth_used())\n\t\treturn;\n\n\t/* an active group must be handled by the update_curr()->put() path */\n\tif (!cfs_rq->runtime_enabled || cfs_rq->curr)\n\t\treturn;\n\n\t/* ensure the group is not already throttled */\n\tif (cfs_rq_throttled(cfs_rq))\n\t\treturn;\n\n\t/* update runtime allocation */\n\taccount_cfs_rq_runtime(cfs_rq, 0);\n\tif (cfs_rq->runtime_remaining <= 0)\n\t\tthrottle_cfs_rq(cfs_rq);\n}\n\nstatic void sync_throttle(struct task_group *tg, int cpu)\n{\n\tstruct cfs_rq *pcfs_rq, *cfs_rq;\n\n\tif (!cfs_bandwidth_used())\n\t\treturn;\n\n\tif (!tg->parent)\n\t\treturn;\n\n\tcfs_rq = tg->cfs_rq[cpu];\n\tpcfs_rq = tg->parent->cfs_rq[cpu];\n\n\tcfs_rq->throttle_count = pcfs_rq->throttle_count;\n\tcfs_rq->throttled_clock_task = rq_clock_task(cpu_rq(cpu));\n}\n\n/* conditionally throttle active cfs_rq's from put_prev_entity() */\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_bandwidth_used())\n\t\treturn false;\n\n\tif (likely(!cfs_rq->runtime_enabled || cfs_rq->runtime_remaining > 0))\n\t\treturn false;\n\n\t/*\n\t * it's possible for a throttled entity to be forced into a running\n\t * state (e.g. set_curr_task), in this case we're finished.\n\t */\n\tif (cfs_rq_throttled(cfs_rq))\n\t\treturn true;\n\n\treturn throttle_cfs_rq(cfs_rq);\n}\n\nstatic enum hrtimer_restart sched_cfs_slack_timer(struct hrtimer *timer)\n{\n\tstruct cfs_bandwidth *cfs_b =\n\t\tcontainer_of(timer, struct cfs_bandwidth, slack_timer);\n\n\tdo_sched_cfs_slack_timer(cfs_b);\n\n\treturn HRTIMER_NORESTART;\n}\n\nextern const u64 max_cfs_quota_period;\n\nstatic enum hrtimer_restart sched_cfs_period_timer(struct hrtimer *timer)\n{\n\tstruct cfs_bandwidth *cfs_b =\n\t\tcontainer_of(timer, struct cfs_bandwidth, period_timer);\n\tunsigned long flags;\n\tint overrun;\n\tint idle = 0;\n\tint count = 0;\n\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tfor (;;) {\n\t\toverrun = hrtimer_forward_now(timer, cfs_b->period);\n\t\tif (!overrun)\n\t\t\tbreak;\n\n\t\tidle = do_sched_cfs_period_timer(cfs_b, overrun, flags);\n\n\t\tif (++count > 3) {\n\t\t\tu64 new, old = ktime_to_ns(cfs_b->period);\n\n\t\t\t/*\n\t\t\t * Grow period by a factor of 2 to avoid losing precision.\n\t\t\t * Precision loss in the quota/period ratio can cause __cfs_schedulable\n\t\t\t * to fail.\n\t\t\t */\n\t\t\tnew = old * 2;\n\t\t\tif (new < max_cfs_quota_period) {\n\t\t\t\tcfs_b->period = ns_to_ktime(new);\n\t\t\t\tcfs_b->quota *= 2;\n\n\t\t\t\tpr_warn_ratelimited(\n\t\"cfs_period_timer[cpu%d]: period too short, scaling up (new cfs_period_us = %lld, cfs_quota_us = %lld)\\n\",\n\t\t\t\t\tsmp_processor_id(),\n\t\t\t\t\tdiv_u64(new, NSEC_PER_USEC),\n\t\t\t\t\tdiv_u64(cfs_b->quota, NSEC_PER_USEC));\n\t\t\t} else {\n\t\t\t\tpr_warn_ratelimited(\n\t\"cfs_period_timer[cpu%d]: period too short, but cannot scale up without losing precision (cfs_period_us = %lld, cfs_quota_us = %lld)\\n\",\n\t\t\t\t\tsmp_processor_id(),\n\t\t\t\t\tdiv_u64(old, NSEC_PER_USEC),\n\t\t\t\t\tdiv_u64(cfs_b->quota, NSEC_PER_USEC));\n\t\t\t}\n\n\t\t\t/* reset count so we don't come right back in here */\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (idle)\n\t\tcfs_b->period_active = 0;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\n\treturn idle ? HRTIMER_NORESTART : HRTIMER_RESTART;\n}\n\nvoid init_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\traw_spin_lock_init(&cfs_b->lock);\n\tcfs_b->runtime = 0;\n\tcfs_b->quota = RUNTIME_INF;\n\tcfs_b->period = ns_to_ktime(default_cfs_period());\n\n\tINIT_LIST_HEAD(&cfs_b->throttled_cfs_rq);\n\thrtimer_init(&cfs_b->period_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);\n\tcfs_b->period_timer.function = sched_cfs_period_timer;\n\thrtimer_init(&cfs_b->slack_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tcfs_b->slack_timer.function = sched_cfs_slack_timer;\n\tcfs_b->slack_started = false;\n}\n\nstatic void init_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tcfs_rq->runtime_enabled = 0;\n\tINIT_LIST_HEAD(&cfs_rq->throttled_list);\n}\n\nvoid start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tlockdep_assert_held(&cfs_b->lock);\n\n\tif (cfs_b->period_active)\n\t\treturn;\n\n\tcfs_b->period_active = 1;\n\thrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}\n\nstatic void destroy_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\t/* init_cfs_bandwidth() was not called */\n\tif (!cfs_b->throttled_cfs_rq.next)\n\t\treturn;\n\n\thrtimer_cancel(&cfs_b->period_timer);\n\thrtimer_cancel(&cfs_b->slack_timer);\n}\n\n/*\n * Both these CPU hotplug callbacks race against unregister_fair_sched_group()\n *\n * The race is harmless, since modifying bandwidth settings of unhooked group\n * bits doesn't do much.\n */\n\n/* cpu online calback */\nstatic void __maybe_unused update_runtime_enabled(struct rq *rq)\n{\n\tstruct task_group *tg;\n\n\tlockdep_assert_held(&rq->lock);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(tg, &task_groups, list) {\n\t\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];\n\n\t\traw_spin_lock(&cfs_b->lock);\n\t\tcfs_rq->runtime_enabled = cfs_b->quota != RUNTIME_INF;\n\t\traw_spin_unlock(&cfs_b->lock);\n\t}\n\trcu_read_unlock();\n}\n\n/* cpu offline callback */\nstatic void __maybe_unused unthrottle_offline_cfs_rqs(struct rq *rq)\n{\n\tstruct task_group *tg;\n\n\tlockdep_assert_held(&rq->lock);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(tg, &task_groups, list) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[cpu_of(rq)];\n\n\t\tif (!cfs_rq->runtime_enabled)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * clock_task is not advancing so we just need to make sure\n\t\t * there's some valid quota amount\n\t\t */\n\t\tcfs_rq->runtime_remaining = 1;\n\t\t/*\n\t\t * Offline rq is schedulable till CPU is completely disabled\n\t\t * in take_cpu_down(), so we prevent new cfs throttling here.\n\t\t */\n\t\tcfs_rq->runtime_enabled = 0;\n\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t}\n\trcu_read_unlock();\n}\n\n#else /* CONFIG_CFS_BANDWIDTH */\n\nstatic inline bool cfs_bandwidth_used(void)\n{\n\treturn false;\n}\n\nstatic void account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec) {}\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq) { return false; }\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq) {}\nstatic inline void sync_throttle(struct task_group *tg, int cpu) {}\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq) {}\n\nstatic inline int cfs_rq_throttled(struct cfs_rq *cfs_rq)\n{\n\treturn 0;\n}\n\nstatic inline int throttled_hierarchy(struct cfs_rq *cfs_rq)\n{\n\treturn 0;\n}\n\nstatic inline int throttled_lb_pair(struct task_group *tg,\n\t\t\t\t    int src_cpu, int dest_cpu)\n{\n\treturn 0;\n}\n\nvoid init_cfs_bandwidth(struct cfs_bandwidth *cfs_b) {}\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\nstatic void init_cfs_rq_runtime(struct cfs_rq *cfs_rq) {}\n#endif\n\nstatic inline struct cfs_bandwidth *tg_cfs_bandwidth(struct task_group *tg)\n{\n\treturn NULL;\n}\nstatic inline void destroy_cfs_bandwidth(struct cfs_bandwidth *cfs_b) {}\nstatic inline void update_runtime_enabled(struct rq *rq) {}\nstatic inline void unthrottle_offline_cfs_rqs(struct rq *rq) {}\n\n#endif /* CONFIG_CFS_BANDWIDTH */\n\n/**************************************************\n * CFS operations on tasks:\n */\n\n#ifdef CONFIG_SCHED_HRTICK\nstatic void hrtick_start_fair(struct rq *rq, struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n\tSCHED_WARN_ON(task_rq(p) != rq);\n\n\tif (rq->cfs.h_nr_running > 1) {\n\t\tu64 slice = sched_slice(cfs_rq, se);\n\t\tu64 ran = se->sum_exec_runtime - se->prev_sum_exec_runtime;\n\t\ts64 delta = slice - ran;\n\n\t\tif (delta < 0) {\n\t\t\tif (task_current(rq, p))\n\t\t\t\tresched_curr(rq);\n\t\t\treturn;\n\t\t}\n\t\thrtick_start(rq, delta);\n\t}\n}\n\n/*\n * called from enqueue/dequeue and updates the hrtick when the\n * current task is from our class and nr_running is low enough\n * to matter.\n */\nstatic void hrtick_update(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\n\tif (!hrtick_enabled(rq) || curr->sched_class != &fair_sched_class)\n\t\treturn;\n\n\tif (cfs_rq_of(&curr->se)->nr_running < sched_nr_latency)\n\t\thrtick_start_fair(rq, curr);\n}\n#else /* !CONFIG_SCHED_HRTICK */\nstatic inline void\nhrtick_start_fair(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline void hrtick_update(struct rq *rq)\n{\n}\n#endif\n\n#ifdef CONFIG_SMP\nstatic inline unsigned long cpu_util(int cpu);\n\nstatic inline bool cpu_overutilized(int cpu)\n{\n\treturn !fits_capacity(cpu_util(cpu), capacity_of(cpu));\n}\n\nstatic inline void update_overutilized_status(struct rq *rq)\n{\n\tif (!READ_ONCE(rq->rd->overutilized) && cpu_overutilized(rq->cpu)) {\n\t\tWRITE_ONCE(rq->rd->overutilized, SG_OVERUTILIZED);\n\t\ttrace_sched_overutilized_tp(rq->rd, SG_OVERUTILIZED);\n\t}\n}\n#else\nstatic inline void update_overutilized_status(struct rq *rq) { }\n#endif\n\n/* Runqueue only has SCHED_IDLE tasks enqueued */\nstatic int sched_idle_rq(struct rq *rq)\n{\n\treturn unlikely(rq->nr_running == rq->cfs.idle_h_nr_running &&\n\t\t\trq->nr_running);\n}\n\n#ifdef CONFIG_SMP\nstatic int sched_idle_cpu(int cpu)\n{\n\treturn sched_idle_rq(cpu_rq(cpu));\n}\n#endif\n\n/*\n * The enqueue_task method is called before nr_running is\n * increased. Here we update the fair scheduling stats and\n * then put the task into the rbtree:\n */\nstatic void\nenqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->se;\n\tint idle_h_nr_running = task_has_idle_policy(p);\n\tint task_new = !(flags & ENQUEUE_WAKEUP);\n\n\t/*\n\t * The code below (indirectly) updates schedutil which looks at\n\t * the cfs_rq utilization to select a frequency.\n\t * Let's add the task's estimated utilization to the cfs_rq's\n\t * estimated utilization, before we update schedutil.\n\t */\n\tutil_est_enqueue(&rq->cfs, p);\n\n\t/*\n\t * If in_iowait is set, the code below may not trigger any cpufreq\n\t * utilization updates, so do it here explicitly with the IOWAIT flag\n\t * passed.\n\t */\n\tif (p->in_iowait)\n\t\tcpufreq_update_util(rq, SCHED_CPUFREQ_IOWAIT);\n\n\tfor_each_sched_entity(se) {\n\t\tif (se->on_rq)\n\t\t\tbreak;\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tenqueue_entity(cfs_rq, se, flags);\n\n\t\tcfs_rq->h_nr_running++;\n\t\tcfs_rq->idle_h_nr_running += idle_h_nr_running;\n\n\t\t/* end evaluation on encountering a throttled cfs_rq */\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tgoto enqueue_throttle;\n\n\t\tflags = ENQUEUE_WAKEUP;\n\t}\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t\tse_update_runnable(se);\n\t\tupdate_cfs_group(se);\n\n\t\tcfs_rq->h_nr_running++;\n\t\tcfs_rq->idle_h_nr_running += idle_h_nr_running;\n\n\t\t/* end evaluation on encountering a throttled cfs_rq */\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tgoto enqueue_throttle;\n\n               /*\n                * One parent has been throttled and cfs_rq removed from the\n                * list. Add it back to not break the leaf list.\n                */\n               if (throttled_hierarchy(cfs_rq))\n                       list_add_leaf_cfs_rq(cfs_rq);\n\t}\n\n\t/* At this point se is NULL and we are at root level*/\n\tadd_nr_running(rq, 1);\n\n\t/*\n\t * Since new tasks are assigned an initial util_avg equal to\n\t * half of the spare capacity of their CPU, tiny tasks have the\n\t * ability to cross the overutilized threshold, which will\n\t * result in the load balancer ruining all the task placement\n\t * done by EAS. As a way to mitigate that effect, do not account\n\t * for the first enqueue operation of new tasks during the\n\t * overutilized flag detection.\n\t *\n\t * A better way of solving this problem would be to wait for\n\t * the PELT signals of tasks to converge before taking them\n\t * into account, but that is not straightforward to implement,\n\t * and the following generally works well enough in practice.\n\t */\n\tif (!task_new)\n\t\tupdate_overutilized_status(rq);\n\nenqueue_throttle:\n\tif (cfs_bandwidth_used()) {\n\t\t/*\n\t\t * When bandwidth control is enabled; the cfs_rq_throttled()\n\t\t * breaks in the above iteration can result in incomplete\n\t\t * leaf list maintenance, resulting in triggering the assertion\n\t\t * below.\n\t\t */\n\t\tfor_each_sched_entity(se) {\n\t\t\tcfs_rq = cfs_rq_of(se);\n\n\t\t\tif (list_add_leaf_cfs_rq(cfs_rq))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tassert_list_leaf_cfs_rq(rq);\n\n\thrtick_update(rq);\n}\n\nstatic void set_next_buddy(struct sched_entity *se);\n\n/*\n * The dequeue_task method is called before nr_running is\n * decreased. We remove the task from the rbtree and\n * update the fair scheduling stats:\n */\nstatic void dequeue_task_fair(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->se;\n\tint task_sleep = flags & DEQUEUE_SLEEP;\n\tint idle_h_nr_running = task_has_idle_policy(p);\n\tbool was_sched_idle = sched_idle_rq(rq);\n\n\tutil_est_dequeue(&rq->cfs, p);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tdequeue_entity(cfs_rq, se, flags);\n\n\t\tcfs_rq->h_nr_running--;\n\t\tcfs_rq->idle_h_nr_running -= idle_h_nr_running;\n\n\t\t/* end evaluation on encountering a throttled cfs_rq */\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tgoto dequeue_throttle;\n\n\t\t/* Don't dequeue parent if it has other entities besides us */\n\t\tif (cfs_rq->load.weight) {\n\t\t\t/* Avoid re-evaluating load for this entity: */\n\t\t\tse = parent_entity(se);\n\t\t\t/*\n\t\t\t * Bias pick_next to pick a task from this cfs_rq, as\n\t\t\t * p is sleeping when it is within its sched_slice.\n\t\t\t */\n\t\t\tif (task_sleep && se && !throttled_hierarchy(cfs_rq))\n\t\t\t\tset_next_buddy(se);\n\t\t\tbreak;\n\t\t}\n\t\tflags |= DEQUEUE_SLEEP;\n\t}\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t\tse_update_runnable(se);\n\t\tupdate_cfs_group(se);\n\n\t\tcfs_rq->h_nr_running--;\n\t\tcfs_rq->idle_h_nr_running -= idle_h_nr_running;\n\n\t\t/* end evaluation on encountering a throttled cfs_rq */\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tgoto dequeue_throttle;\n\n\t}\n\n\t/* At this point se is NULL and we are at root level*/\n\tsub_nr_running(rq, 1);\n\n\t/* balance early to pull high priority tasks */\n\tif (unlikely(!was_sched_idle && sched_idle_rq(rq)))\n\t\trq->next_balance = jiffies;\n\ndequeue_throttle:\n\tutil_est_update(&rq->cfs, p, task_sleep);\n\thrtick_update(rq);\n}\n\n#ifdef CONFIG_SMP\n\n/* Working cpumask for: load_balance, load_balance_newidle. */\nDEFINE_PER_CPU(cpumask_var_t, load_balance_mask);\nDEFINE_PER_CPU(cpumask_var_t, select_idle_mask);\n\n#ifdef CONFIG_NO_HZ_COMMON\n\nstatic struct {\n\tcpumask_var_t idle_cpus_mask;\n\tatomic_t nr_cpus;\n\tint has_blocked;\t\t/* Idle CPUS has blocked load */\n\tunsigned long next_balance;     /* in jiffy units */\n\tunsigned long next_blocked;\t/* Next update of blocked load in jiffies */\n} nohz ____cacheline_aligned;\n\n#endif /* CONFIG_NO_HZ_COMMON */\n\nstatic unsigned long cpu_load(struct rq *rq)\n{\n\treturn cfs_rq_load_avg(&rq->cfs);\n}\n\n/*\n * cpu_load_without - compute CPU load without any contributions from *p\n * @cpu: the CPU which load is requested\n * @p: the task which load should be discounted\n *\n * The load of a CPU is defined by the load of tasks currently enqueued on that\n * CPU as well as tasks which are currently sleeping after an execution on that\n * CPU.\n *\n * This method returns the load of the specified CPU by discounting the load of\n * the specified task, whenever the task is currently contributing to the CPU\n * load.\n */\nstatic unsigned long cpu_load_without(struct rq *rq, struct task_struct *p)\n{\n\tstruct cfs_rq *cfs_rq;\n\tunsigned int load;\n\n\t/* Task has no contribution or is new */\n\tif (cpu_of(rq) != task_cpu(p) || !READ_ONCE(p->se.avg.last_update_time))\n\t\treturn cpu_load(rq);\n\n\tcfs_rq = &rq->cfs;\n\tload = READ_ONCE(cfs_rq->avg.load_avg);\n\n\t/* Discount task's util from CPU's util */\n\tlsub_positive(&load, task_h_load(p));\n\n\treturn load;\n}\n\nstatic unsigned long cpu_runnable(struct rq *rq)\n{\n\treturn cfs_rq_runnable_avg(&rq->cfs);\n}\n\nstatic unsigned long cpu_runnable_without(struct rq *rq, struct task_struct *p)\n{\n\tstruct cfs_rq *cfs_rq;\n\tunsigned int runnable;\n\n\t/* Task has no contribution or is new */\n\tif (cpu_of(rq) != task_cpu(p) || !READ_ONCE(p->se.avg.last_update_time))\n\t\treturn cpu_runnable(rq);\n\n\tcfs_rq = &rq->cfs;\n\trunnable = READ_ONCE(cfs_rq->avg.runnable_avg);\n\n\t/* Discount task's runnable from CPU's runnable */\n\tlsub_positive(&runnable, p->se.avg.runnable_avg);\n\n\treturn runnable;\n}\n\nstatic unsigned long capacity_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity;\n}\n\nstatic void record_wakee(struct task_struct *p)\n{\n\t/*\n\t * Only decay a single time; tasks that have less then 1 wakeup per\n\t * jiffy will not have built up many flips.\n\t */\n\tif (time_after(jiffies, current->wakee_flip_decay_ts + HZ)) {\n\t\tcurrent->wakee_flips >>= 1;\n\t\tcurrent->wakee_flip_decay_ts = jiffies;\n\t}\n\n\tif (current->last_wakee != p) {\n\t\tcurrent->last_wakee = p;\n\t\tcurrent->wakee_flips++;\n\t}\n}\n\n/*\n * Detect M:N waker/wakee relationships via a switching-frequency heuristic.\n *\n * A waker of many should wake a different task than the one last awakened\n * at a frequency roughly N times higher than one of its wakees.\n *\n * In order to determine whether we should let the load spread vs consolidating\n * to shared cache, we look for a minimum 'flip' frequency of llc_size in one\n * partner, and a factor of lls_size higher frequency in the other.\n *\n * With both conditions met, we can be relatively sure that the relationship is\n * non-monogamous, with partner count exceeding socket size.\n *\n * Waker/wakee being client/server, worker/dispatcher, interrupt source or\n * whatever is irrelevant, spread criteria is apparent partner count exceeds\n * socket size.\n */\nstatic int wake_wide(struct task_struct *p)\n{\n\tunsigned int master = current->wakee_flips;\n\tunsigned int slave = p->wakee_flips;\n\tint factor = __this_cpu_read(sd_llc_size);\n\n\tif (master < slave)\n\t\tswap(master, slave);\n\tif (slave < factor || master < slave * factor)\n\t\treturn 0;\n\treturn 1;\n}\n\n/*\n * The purpose of wake_affine() is to quickly determine on which CPU we can run\n * soonest. For the purpose of speed we only consider the waking and previous\n * CPU.\n *\n * wake_affine_idle() - only considers 'now', it check if the waking CPU is\n *\t\t\tcache-affine and is (or\twill be) idle.\n *\n * wake_affine_weight() - considers the weight to reflect the average\n *\t\t\t  scheduling latency of the CPUs. This seems to work\n *\t\t\t  for the overloaded case.\n */\nstatic int\nwake_affine_idle(int this_cpu, int prev_cpu, int sync)\n{\n\t/*\n\t * If this_cpu is idle, it implies the wakeup is from interrupt\n\t * context. Only allow the move if cache is shared. Otherwise an\n\t * interrupt intensive workload could force all tasks onto one\n\t * node depending on the IO topology or IRQ affinity settings.\n\t *\n\t * If the prev_cpu is idle and cache affine then avoid a migration.\n\t * There is no guarantee that the cache hot data from an interrupt\n\t * is more important than cache hot data on the prev_cpu and from\n\t * a cpufreq perspective, it's better to have higher utilisation\n\t * on one CPU.\n\t */\n\tif (available_idle_cpu(this_cpu) && cpus_share_cache(this_cpu, prev_cpu))\n\t\treturn available_idle_cpu(prev_cpu) ? prev_cpu : this_cpu;\n\n\tif (sync && cpu_rq(this_cpu)->nr_running == 1)\n\t\treturn this_cpu;\n\n\tif (available_idle_cpu(prev_cpu))\n\t\treturn prev_cpu;\n\n\treturn nr_cpumask_bits;\n}\n\nstatic int\nwake_affine_weight(struct sched_domain *sd, struct task_struct *p,\n\t\t   int this_cpu, int prev_cpu, int sync)\n{\n\ts64 this_eff_load, prev_eff_load;\n\tunsigned long task_load;\n\n\tthis_eff_load = cpu_load(cpu_rq(this_cpu));\n\n\tif (sync) {\n\t\tunsigned long current_load = task_h_load(current);\n\n\t\tif (current_load > this_eff_load)\n\t\t\treturn this_cpu;\n\n\t\tthis_eff_load -= current_load;\n\t}\n\n\ttask_load = task_h_load(p);\n\n\tthis_eff_load += task_load;\n\tif (sched_feat(WA_BIAS))\n\t\tthis_eff_load *= 100;\n\tthis_eff_load *= capacity_of(prev_cpu);\n\n\tprev_eff_load = cpu_load(cpu_rq(prev_cpu));\n\tprev_eff_load -= task_load;\n\tif (sched_feat(WA_BIAS))\n\t\tprev_eff_load *= 100 + (sd->imbalance_pct - 100) / 2;\n\tprev_eff_load *= capacity_of(this_cpu);\n\n\t/*\n\t * If sync, adjust the weight of prev_eff_load such that if\n\t * prev_eff == this_eff that select_idle_sibling() will consider\n\t * stacking the wakee on top of the waker if no other CPU is\n\t * idle.\n\t */\n\tif (sync)\n\t\tprev_eff_load += 1;\n\n\treturn this_eff_load < prev_eff_load ? this_cpu : nr_cpumask_bits;\n}\n\nstatic int wake_affine(struct sched_domain *sd, struct task_struct *p,\n\t\t       int this_cpu, int prev_cpu, int sync)\n{\n\tint target = nr_cpumask_bits;\n\n\tif (sched_feat(WA_IDLE))\n\t\ttarget = wake_affine_idle(this_cpu, prev_cpu, sync);\n\n\tif (sched_feat(WA_WEIGHT) && target == nr_cpumask_bits)\n\t\ttarget = wake_affine_weight(sd, p, this_cpu, prev_cpu, sync);\n\n\tschedstat_inc(p->se.statistics.nr_wakeups_affine_attempts);\n\tif (target == nr_cpumask_bits)\n\t\treturn prev_cpu;\n\n\tschedstat_inc(sd->ttwu_move_affine);\n\tschedstat_inc(p->se.statistics.nr_wakeups_affine);\n\treturn target;\n}\n\nstatic struct sched_group *\nfind_idlest_group(struct sched_domain *sd, struct task_struct *p, int this_cpu);\n\n/*\n * find_idlest_group_cpu - find the idlest CPU among the CPUs in the group.\n */\nstatic int\nfind_idlest_group_cpu(struct sched_group *group, struct task_struct *p, int this_cpu)\n{\n\tunsigned long load, min_load = ULONG_MAX;\n\tunsigned int min_exit_latency = UINT_MAX;\n\tu64 latest_idle_timestamp = 0;\n\tint least_loaded_cpu = this_cpu;\n\tint shallowest_idle_cpu = -1;\n\tint i;\n\n\t/* Check if we have any choice: */\n\tif (group->group_weight == 1)\n\t\treturn cpumask_first(sched_group_span(group));\n\n\t/* Traverse only the allowed CPUs */\n\tfor_each_cpu_and(i, sched_group_span(group), p->cpus_ptr) {\n\t\tif (sched_idle_cpu(i))\n\t\t\treturn i;\n\n\t\tif (available_idle_cpu(i)) {\n\t\t\tstruct rq *rq = cpu_rq(i);\n\t\t\tstruct cpuidle_state *idle = idle_get_state(rq);\n\t\t\tif (idle && idle->exit_latency < min_exit_latency) {\n\t\t\t\t/*\n\t\t\t\t * We give priority to a CPU whose idle state\n\t\t\t\t * has the smallest exit latency irrespective\n\t\t\t\t * of any idle timestamp.\n\t\t\t\t */\n\t\t\t\tmin_exit_latency = idle->exit_latency;\n\t\t\t\tlatest_idle_timestamp = rq->idle_stamp;\n\t\t\t\tshallowest_idle_cpu = i;\n\t\t\t} else if ((!idle || idle->exit_latency == min_exit_latency) &&\n\t\t\t\t   rq->idle_stamp > latest_idle_timestamp) {\n\t\t\t\t/*\n\t\t\t\t * If equal or no active idle state, then\n\t\t\t\t * the most recently idled CPU might have\n\t\t\t\t * a warmer cache.\n\t\t\t\t */\n\t\t\t\tlatest_idle_timestamp = rq->idle_stamp;\n\t\t\t\tshallowest_idle_cpu = i;\n\t\t\t}\n\t\t} else if (shallowest_idle_cpu == -1) {\n\t\t\tload = cpu_load(cpu_rq(i));\n\t\t\tif (load < min_load) {\n\t\t\t\tmin_load = load;\n\t\t\t\tleast_loaded_cpu = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn shallowest_idle_cpu != -1 ? shallowest_idle_cpu : least_loaded_cpu;\n}\n\nstatic inline int find_idlest_cpu(struct sched_domain *sd, struct task_struct *p,\n\t\t\t\t  int cpu, int prev_cpu, int sd_flag)\n{\n\tint new_cpu = cpu;\n\n\tif (!cpumask_intersects(sched_domain_span(sd), p->cpus_ptr))\n\t\treturn prev_cpu;\n\n\t/*\n\t * We need task's util for cpu_util_without, sync it up to\n\t * prev_cpu's last_update_time.\n\t */\n\tif (!(sd_flag & SD_BALANCE_FORK))\n\t\tsync_entity_load_avg(&p->se);\n\n\twhile (sd) {\n\t\tstruct sched_group *group;\n\t\tstruct sched_domain *tmp;\n\t\tint weight;\n\n\t\tif (!(sd->flags & sd_flag)) {\n\t\t\tsd = sd->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\tgroup = find_idlest_group(sd, p, cpu);\n\t\tif (!group) {\n\t\t\tsd = sd->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\tnew_cpu = find_idlest_group_cpu(group, p, cpu);\n\t\tif (new_cpu == cpu) {\n\t\t\t/* Now try balancing at a lower domain level of 'cpu': */\n\t\t\tsd = sd->child;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Now try balancing at a lower domain level of 'new_cpu': */\n\t\tcpu = new_cpu;\n\t\tweight = sd->span_weight;\n\t\tsd = NULL;\n\t\tfor_each_domain(cpu, tmp) {\n\t\t\tif (weight <= tmp->span_weight)\n\t\t\t\tbreak;\n\t\t\tif (tmp->flags & sd_flag)\n\t\t\t\tsd = tmp;\n\t\t}\n\t}\n\n\treturn new_cpu;\n}\n\n#ifdef CONFIG_SCHED_SMT\nDEFINE_STATIC_KEY_FALSE(sched_smt_present);\nEXPORT_SYMBOL_GPL(sched_smt_present);\n\nstatic inline void set_idle_cores(int cpu, int val)\n{\n\tstruct sched_domain_shared *sds;\n\n\tsds = rcu_dereference(per_cpu(sd_llc_shared, cpu));\n\tif (sds)\n\t\tWRITE_ONCE(sds->has_idle_cores, val);\n}\n\nstatic inline bool test_idle_cores(int cpu, bool def)\n{\n\tstruct sched_domain_shared *sds;\n\n\tsds = rcu_dereference(per_cpu(sd_llc_shared, cpu));\n\tif (sds)\n\t\treturn READ_ONCE(sds->has_idle_cores);\n\n\treturn def;\n}\n\n/*\n * Scans the local SMT mask to see if the entire core is idle, and records this\n * information in sd_llc_shared->has_idle_cores.\n *\n * Since SMT siblings share all cache levels, inspecting this limited remote\n * state should be fairly cheap.\n */\nvoid __update_idle_core(struct rq *rq)\n{\n\tint core = cpu_of(rq);\n\tint cpu;\n\n\trcu_read_lock();\n\tif (test_idle_cores(core, true))\n\t\tgoto unlock;\n\n\tfor_each_cpu(cpu, cpu_smt_mask(core)) {\n\t\tif (cpu == core)\n\t\t\tcontinue;\n\n\t\tif (!available_idle_cpu(cpu))\n\t\t\tgoto unlock;\n\t}\n\n\tset_idle_cores(core, 1);\nunlock:\n\trcu_read_unlock();\n}\n\n/*\n * Scan the entire LLC domain for idle cores; this dynamically switches off if\n * there are no idle cores left in the system; tracked through\n * sd_llc->shared->has_idle_cores and enabled through update_idle_core() above.\n */\nstatic int select_idle_core(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\tstruct cpumask *cpus = this_cpu_cpumask_var_ptr(select_idle_mask);\n\tint core, cpu;\n\n\tif (!static_branch_likely(&sched_smt_present))\n\t\treturn -1;\n\n\tif (!test_idle_cores(target, false))\n\t\treturn -1;\n\n\tcpumask_and(cpus, sched_domain_span(sd), p->cpus_ptr);\n\n\tfor_each_cpu_wrap(core, cpus, target) {\n\t\tbool idle = true;\n\n\t\tfor_each_cpu(cpu, cpu_smt_mask(core)) {\n\t\t\tif (!available_idle_cpu(cpu)) {\n\t\t\t\tidle = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (idle)\n\t\t\treturn core;\n\n\t\tcpumask_andnot(cpus, cpus, cpu_smt_mask(core));\n\t}\n\n\t/*\n\t * Failed to find an idle core; stop looking for one.\n\t */\n\tset_idle_cores(target, 0);\n\n\treturn -1;\n}\n\n/*\n * Scan the local SMT mask for idle CPUs.\n */\nstatic int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\tint cpu;\n\n\tif (!static_branch_likely(&sched_smt_present))\n\t\treturn -1;\n\n\tfor_each_cpu(cpu, cpu_smt_mask(target)) {\n\t\tif (!cpumask_test_cpu(cpu, p->cpus_ptr) ||\n\t\t    !cpumask_test_cpu(cpu, sched_domain_span(sd)))\n\t\t\tcontinue;\n\t\tif (available_idle_cpu(cpu) || sched_idle_cpu(cpu))\n\t\t\treturn cpu;\n\t}\n\n\treturn -1;\n}\n\n#else /* CONFIG_SCHED_SMT */\n\nstatic inline int select_idle_core(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\treturn -1;\n}\n\nstatic inline int select_idle_smt(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\treturn -1;\n}\n\n#endif /* CONFIG_SCHED_SMT */\n\n/*\n * Scan the LLC domain for idle CPUs; this is dynamically regulated by\n * comparing the average scan cost (tracked in sd->avg_scan_cost) against the\n * average idle time for this rq (as found in rq->avg_idle).\n */\nstatic int select_idle_cpu(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\tstruct cpumask *cpus = this_cpu_cpumask_var_ptr(select_idle_mask);\n\tstruct sched_domain *this_sd;\n\tu64 avg_cost, avg_idle;\n\tu64 time;\n\tint this = smp_processor_id();\n\tint cpu, nr = INT_MAX;\n\n\tthis_sd = rcu_dereference(*this_cpu_ptr(&sd_llc));\n\tif (!this_sd)\n\t\treturn -1;\n\n\t/*\n\t * Due to large variance we need a large fuzz factor; hackbench in\n\t * particularly is sensitive here.\n\t */\n\tavg_idle = this_rq()->avg_idle / 512;\n\tavg_cost = this_sd->avg_scan_cost + 1;\n\n\tif (sched_feat(SIS_AVG_CPU) && avg_idle < avg_cost)\n\t\treturn -1;\n\n\tif (sched_feat(SIS_PROP)) {\n\t\tu64 span_avg = sd->span_weight * avg_idle;\n\t\tif (span_avg > 4*avg_cost)\n\t\t\tnr = div_u64(span_avg, avg_cost);\n\t\telse\n\t\t\tnr = 4;\n\t}\n\n\ttime = cpu_clock(this);\n\n\tcpumask_and(cpus, sched_domain_span(sd), p->cpus_ptr);\n\n\tfor_each_cpu_wrap(cpu, cpus, target) {\n\t\tif (!--nr)\n\t\t\treturn -1;\n\t\tif (available_idle_cpu(cpu) || sched_idle_cpu(cpu))\n\t\t\tbreak;\n\t}\n\n\ttime = cpu_clock(this) - time;\n\tupdate_avg(&this_sd->avg_scan_cost, time);\n\n\treturn cpu;\n}\n\n/*\n * Scan the asym_capacity domain for idle CPUs; pick the first idle one on which\n * the task fits. If no CPU is big enough, but there are idle ones, try to\n * maximize capacity.\n */\nstatic int\nselect_idle_capacity(struct task_struct *p, struct sched_domain *sd, int target)\n{\n\tunsigned long task_util, best_cap = 0;\n\tint cpu, best_cpu = -1;\n\tstruct cpumask *cpus;\n\n\tcpus = this_cpu_cpumask_var_ptr(select_idle_mask);\n\tcpumask_and(cpus, sched_domain_span(sd), p->cpus_ptr);\n\n\ttask_util = uclamp_task_util(p);\n\n\tfor_each_cpu_wrap(cpu, cpus, target) {\n\t\tunsigned long cpu_cap = capacity_of(cpu);\n\n\t\tif (!available_idle_cpu(cpu) && !sched_idle_cpu(cpu))\n\t\t\tcontinue;\n\t\tif (fits_capacity(task_util, cpu_cap))\n\t\t\treturn cpu;\n\n\t\tif (cpu_cap > best_cap) {\n\t\t\tbest_cap = cpu_cap;\n\t\t\tbest_cpu = cpu;\n\t\t}\n\t}\n\n\treturn best_cpu;\n}\n\nstatic inline bool asym_fits_capacity(int task_util, int cpu)\n{\n\tif (static_branch_unlikely(&sched_asym_cpucapacity))\n\t\treturn fits_capacity(task_util, capacity_of(cpu));\n\n\treturn true;\n}\n\n/*\n * Try and locate an idle core/thread in the LLC cache domain.\n */\nstatic int select_idle_sibling(struct task_struct *p, int prev, int target)\n{\n\tstruct sched_domain *sd;\n\tunsigned long task_util;\n\tint i, recent_used_cpu;\n\n\t/*\n\t * On asymmetric system, update task utilization because we will check\n\t * that the task fits with cpu's capacity.\n\t */\n\tif (static_branch_unlikely(&sched_asym_cpucapacity)) {\n\t\tsync_entity_load_avg(&p->se);\n\t\ttask_util = uclamp_task_util(p);\n\t}\n\n\tif ((available_idle_cpu(target) || sched_idle_cpu(target)) &&\n\t    asym_fits_capacity(task_util, target))\n\t\treturn target;\n\n\t/*\n\t * If the previous CPU is cache affine and idle, don't be stupid:\n\t */\n\tif (prev != target && cpus_share_cache(prev, target) &&\n\t    (available_idle_cpu(prev) || sched_idle_cpu(prev)) &&\n\t    asym_fits_capacity(task_util, prev))\n\t\treturn prev;\n\n\t/*\n\t * Allow a per-cpu kthread to stack with the wakee if the\n\t * kworker thread and the tasks previous CPUs are the same.\n\t * The assumption is that the wakee queued work for the\n\t * per-cpu kthread that is now complete and the wakeup is\n\t * essentially a sync wakeup. An obvious example of this\n\t * pattern is IO completions.\n\t */\n\tif (is_per_cpu_kthread(current) &&\n\t    prev == smp_processor_id() &&\n\t    this_rq()->nr_running <= 1) {\n\t\treturn prev;\n\t}\n\n\t/* Check a recently used CPU as a potential idle candidate: */\n\trecent_used_cpu = p->recent_used_cpu;\n\tif (recent_used_cpu != prev &&\n\t    recent_used_cpu != target &&\n\t    cpus_share_cache(recent_used_cpu, target) &&\n\t    (available_idle_cpu(recent_used_cpu) || sched_idle_cpu(recent_used_cpu)) &&\n\t    cpumask_test_cpu(p->recent_used_cpu, p->cpus_ptr) &&\n\t    asym_fits_capacity(task_util, recent_used_cpu)) {\n\t\t/*\n\t\t * Replace recent_used_cpu with prev as it is a potential\n\t\t * candidate for the next wake:\n\t\t */\n\t\tp->recent_used_cpu = prev;\n\t\treturn recent_used_cpu;\n\t}\n\n\t/*\n\t * For asymmetric CPU capacity systems, our domain of interest is\n\t * sd_asym_cpucapacity rather than sd_llc.\n\t */\n\tif (static_branch_unlikely(&sched_asym_cpucapacity)) {\n\t\tsd = rcu_dereference(per_cpu(sd_asym_cpucapacity, target));\n\t\t/*\n\t\t * On an asymmetric CPU capacity system where an exclusive\n\t\t * cpuset defines a symmetric island (i.e. one unique\n\t\t * capacity_orig value through the cpuset), the key will be set\n\t\t * but the CPUs within that cpuset will not have a domain with\n\t\t * SD_ASYM_CPUCAPACITY. These should follow the usual symmetric\n\t\t * capacity path.\n\t\t */\n\t\tif (sd) {\n\t\t\ti = select_idle_capacity(p, sd, target);\n\t\t\treturn ((unsigned)i < nr_cpumask_bits) ? i : target;\n\t\t}\n\t}\n\n\tsd = rcu_dereference(per_cpu(sd_llc, target));\n\tif (!sd)\n\t\treturn target;\n\n\ti = select_idle_core(p, sd, target);\n\tif ((unsigned)i < nr_cpumask_bits)\n\t\treturn i;\n\n\ti = select_idle_cpu(p, sd, target);\n\tif ((unsigned)i < nr_cpumask_bits)\n\t\treturn i;\n\n\ti = select_idle_smt(p, sd, target);\n\tif ((unsigned)i < nr_cpumask_bits)\n\t\treturn i;\n\n\treturn target;\n}\n\n/**\n * cpu_util - Estimates the amount of capacity of a CPU used by CFS tasks.\n * @cpu: the CPU to get the utilization of\n *\n * The unit of the return value must be the one of capacity so we can compare\n * the utilization with the capacity of the CPU that is available for CFS task\n * (ie cpu_capacity).\n *\n * cfs_rq.avg.util_avg is the sum of running time of runnable tasks plus the\n * recent utilization of currently non-runnable tasks on a CPU. It represents\n * the amount of utilization of a CPU in the range [0..capacity_orig] where\n * capacity_orig is the cpu_capacity available at the highest frequency\n * (arch_scale_freq_capacity()).\n * The utilization of a CPU converges towards a sum equal to or less than the\n * current capacity (capacity_curr <= capacity_orig) of the CPU because it is\n * the running time on this CPU scaled by capacity_curr.\n *\n * The estimated utilization of a CPU is defined to be the maximum between its\n * cfs_rq.avg.util_avg and the sum of the estimated utilization of the tasks\n * currently RUNNABLE on that CPU.\n * This allows to properly represent the expected utilization of a CPU which\n * has just got a big task running since a long sleep period. At the same time\n * however it preserves the benefits of the \"blocked utilization\" in\n * describing the potential for other tasks waking up on the same CPU.\n *\n * Nevertheless, cfs_rq.avg.util_avg can be higher than capacity_curr or even\n * higher than capacity_orig because of unfortunate rounding in\n * cfs.avg.util_avg or just after migrating tasks and new task wakeups until\n * the average stabilizes with the new running time. We need to check that the\n * utilization stays within the range of [0..capacity_orig] and cap it if\n * necessary. Without utilization capping, a group could be seen as overloaded\n * (CPU0 utilization at 121% + CPU1 utilization at 80%) whereas CPU1 has 20% of\n * available capacity. We allow utilization to overshoot capacity_curr (but not\n * capacity_orig) as it useful for predicting the capacity required after task\n * migrations (scheduler-driven DVFS).\n *\n * Return: the (estimated) utilization for the specified CPU\n */\nstatic inline unsigned long cpu_util(int cpu)\n{\n\tstruct cfs_rq *cfs_rq;\n\tunsigned int util;\n\n\tcfs_rq = &cpu_rq(cpu)->cfs;\n\tutil = READ_ONCE(cfs_rq->avg.util_avg);\n\n\tif (sched_feat(UTIL_EST))\n\t\tutil = max(util, READ_ONCE(cfs_rq->avg.util_est.enqueued));\n\n\treturn min_t(unsigned long, util, capacity_orig_of(cpu));\n}\n\n/*\n * cpu_util_without: compute cpu utilization without any contributions from *p\n * @cpu: the CPU which utilization is requested\n * @p: the task which utilization should be discounted\n *\n * The utilization of a CPU is defined by the utilization of tasks currently\n * enqueued on that CPU as well as tasks which are currently sleeping after an\n * execution on that CPU.\n *\n * This method returns the utilization of the specified CPU by discounting the\n * utilization of the specified task, whenever the task is currently\n * contributing to the CPU utilization.\n */\nstatic unsigned long cpu_util_without(int cpu, struct task_struct *p)\n{\n\tstruct cfs_rq *cfs_rq;\n\tunsigned int util;\n\n\t/* Task has no contribution or is new */\n\tif (cpu != task_cpu(p) || !READ_ONCE(p->se.avg.last_update_time))\n\t\treturn cpu_util(cpu);\n\n\tcfs_rq = &cpu_rq(cpu)->cfs;\n\tutil = READ_ONCE(cfs_rq->avg.util_avg);\n\n\t/* Discount task's util from CPU's util */\n\tlsub_positive(&util, task_util(p));\n\n\t/*\n\t * Covered cases:\n\t *\n\t * a) if *p is the only task sleeping on this CPU, then:\n\t *      cpu_util (== task_util) > util_est (== 0)\n\t *    and thus we return:\n\t *      cpu_util_without = (cpu_util - task_util) = 0\n\t *\n\t * b) if other tasks are SLEEPING on this CPU, which is now exiting\n\t *    IDLE, then:\n\t *      cpu_util >= task_util\n\t *      cpu_util > util_est (== 0)\n\t *    and thus we discount *p's blocked utilization to return:\n\t *      cpu_util_without = (cpu_util - task_util) >= 0\n\t *\n\t * c) if other tasks are RUNNABLE on that CPU and\n\t *      util_est > cpu_util\n\t *    then we use util_est since it returns a more restrictive\n\t *    estimation of the spare capacity on that CPU, by just\n\t *    considering the expected utilization of tasks already\n\t *    runnable on that CPU.\n\t *\n\t * Cases a) and b) are covered by the above code, while case c) is\n\t * covered by the following code when estimated utilization is\n\t * enabled.\n\t */\n\tif (sched_feat(UTIL_EST)) {\n\t\tunsigned int estimated =\n\t\t\tREAD_ONCE(cfs_rq->avg.util_est.enqueued);\n\n\t\t/*\n\t\t * Despite the following checks we still have a small window\n\t\t * for a possible race, when an execl's select_task_rq_fair()\n\t\t * races with LB's detach_task():\n\t\t *\n\t\t *   detach_task()\n\t\t *     p->on_rq = TASK_ON_RQ_MIGRATING;\n\t\t *     ---------------------------------- A\n\t\t *     deactivate_task()                   \\\n\t\t *       dequeue_task()                     + RaceTime\n\t\t *         util_est_dequeue()              /\n\t\t *     ---------------------------------- B\n\t\t *\n\t\t * The additional check on \"current == p\" it's required to\n\t\t * properly fix the execl regression and it helps in further\n\t\t * reducing the chances for the above race.\n\t\t */\n\t\tif (unlikely(task_on_rq_queued(p) || current == p))\n\t\t\tlsub_positive(&estimated, _task_util_est(p));\n\n\t\tutil = max(util, estimated);\n\t}\n\n\t/*\n\t * Utilization (estimated) can exceed the CPU capacity, thus let's\n\t * clamp to the maximum CPU capacity to ensure consistency with\n\t * the cpu_util call.\n\t */\n\treturn min_t(unsigned long, util, capacity_orig_of(cpu));\n}\n\n/*\n * Predicts what cpu_util(@cpu) would return if @p was migrated (and enqueued)\n * to @dst_cpu.\n */\nstatic unsigned long cpu_util_next(int cpu, struct task_struct *p, int dst_cpu)\n{\n\tstruct cfs_rq *cfs_rq = &cpu_rq(cpu)->cfs;\n\tunsigned long util_est, util = READ_ONCE(cfs_rq->avg.util_avg);\n\n\t/*\n\t * If @p migrates from @cpu to another, remove its contribution. Or,\n\t * if @p migrates from another CPU to @cpu, add its contribution. In\n\t * the other cases, @cpu is not impacted by the migration, so the\n\t * util_avg should already be correct.\n\t */\n\tif (task_cpu(p) == cpu && dst_cpu != cpu)\n\t\tsub_positive(&util, task_util(p));\n\telse if (task_cpu(p) != cpu && dst_cpu == cpu)\n\t\tutil += task_util(p);\n\n\tif (sched_feat(UTIL_EST)) {\n\t\tutil_est = READ_ONCE(cfs_rq->avg.util_est.enqueued);\n\n\t\t/*\n\t\t * During wake-up, the task isn't enqueued yet and doesn't\n\t\t * appear in the cfs_rq->avg.util_est.enqueued of any rq,\n\t\t * so just add it (if needed) to \"simulate\" what will be\n\t\t * cpu_util() after the task has been enqueued.\n\t\t */\n\t\tif (dst_cpu == cpu)\n\t\t\tutil_est += _task_util_est(p);\n\n\t\tutil = max(util, util_est);\n\t}\n\n\treturn min(util, capacity_orig_of(cpu));\n}\n\n/*\n * compute_energy(): Estimates the energy that @pd would consume if @p was\n * migrated to @dst_cpu. compute_energy() predicts what will be the utilization\n * landscape of @pd's CPUs after the task migration, and uses the Energy Model\n * to compute what would be the energy if we decided to actually migrate that\n * task.\n */\nstatic long\ncompute_energy(struct task_struct *p, int dst_cpu, struct perf_domain *pd)\n{\n\tstruct cpumask *pd_mask = perf_domain_span(pd);\n\tunsigned long cpu_cap = arch_scale_cpu_capacity(cpumask_first(pd_mask));\n\tunsigned long max_util = 0, sum_util = 0;\n\tint cpu;\n\n\t/*\n\t * The capacity state of CPUs of the current rd can be driven by CPUs\n\t * of another rd if they belong to the same pd. So, account for the\n\t * utilization of these CPUs too by masking pd with cpu_online_mask\n\t * instead of the rd span.\n\t *\n\t * If an entire pd is outside of the current rd, it will not appear in\n\t * its pd list and will not be accounted by compute_energy().\n\t */\n\tfor_each_cpu_and(cpu, pd_mask, cpu_online_mask) {\n\t\tunsigned long cpu_util, util_cfs = cpu_util_next(cpu, p, dst_cpu);\n\t\tstruct task_struct *tsk = cpu == dst_cpu ? p : NULL;\n\n\t\t/*\n\t\t * Busy time computation: utilization clamping is not\n\t\t * required since the ratio (sum_util / cpu_capacity)\n\t\t * is already enough to scale the EM reported power\n\t\t * consumption at the (eventually clamped) cpu_capacity.\n\t\t */\n\t\tsum_util += effective_cpu_util(cpu, util_cfs, cpu_cap,\n\t\t\t\t\t       ENERGY_UTIL, NULL);\n\n\t\t/*\n\t\t * Performance domain frequency: utilization clamping\n\t\t * must be considered since it affects the selection\n\t\t * of the performance domain frequency.\n\t\t * NOTE: in case RT tasks are running, by default the\n\t\t * FREQUENCY_UTIL's utilization can be max OPP.\n\t\t */\n\t\tcpu_util = effective_cpu_util(cpu, util_cfs, cpu_cap,\n\t\t\t\t\t      FREQUENCY_UTIL, tsk);\n\t\tmax_util = max(max_util, cpu_util);\n\t}\n\n\treturn em_cpu_energy(pd->em_pd, max_util, sum_util);\n}\n\n/*\n * find_energy_efficient_cpu(): Find most energy-efficient target CPU for the\n * waking task. find_energy_efficient_cpu() looks for the CPU with maximum\n * spare capacity in each performance domain and uses it as a potential\n * candidate to execute the task. Then, it uses the Energy Model to figure\n * out which of the CPU candidates is the most energy-efficient.\n *\n * The rationale for this heuristic is as follows. In a performance domain,\n * all the most energy efficient CPU candidates (according to the Energy\n * Model) are those for which we'll request a low frequency. When there are\n * several CPUs for which the frequency request will be the same, we don't\n * have enough data to break the tie between them, because the Energy Model\n * only includes active power costs. With this model, if we assume that\n * frequency requests follow utilization (e.g. using schedutil), the CPU with\n * the maximum spare capacity in a performance domain is guaranteed to be among\n * the best candidates of the performance domain.\n *\n * In practice, it could be preferable from an energy standpoint to pack\n * small tasks on a CPU in order to let other CPUs go in deeper idle states,\n * but that could also hurt our chances to go cluster idle, and we have no\n * ways to tell with the current Energy Model if this is actually a good\n * idea or not. So, find_energy_efficient_cpu() basically favors\n * cluster-packing, and spreading inside a cluster. That should at least be\n * a good thing for latency, and this is consistent with the idea that most\n * of the energy savings of EAS come from the asymmetry of the system, and\n * not so much from breaking the tie between identical CPUs. That's also the\n * reason why EAS is enabled in the topology code only for systems where\n * SD_ASYM_CPUCAPACITY is set.\n *\n * NOTE: Forkees are not accepted in the energy-aware wake-up path because\n * they don't have any useful utilization data yet and it's not possible to\n * forecast their impact on energy consumption. Consequently, they will be\n * placed by find_idlest_cpu() on the least loaded CPU, which might turn out\n * to be energy-inefficient in some use-cases. The alternative would be to\n * bias new tasks towards specific types of CPUs first, or to try to infer\n * their util_avg from the parent task, but those heuristics could hurt\n * other use-cases too. So, until someone finds a better way to solve this,\n * let's keep things simple by re-using the existing slow path.\n */\nstatic int find_energy_efficient_cpu(struct task_struct *p, int prev_cpu)\n{\n\tunsigned long prev_delta = ULONG_MAX, best_delta = ULONG_MAX;\n\tstruct root_domain *rd = cpu_rq(smp_processor_id())->rd;\n\tunsigned long cpu_cap, util, base_energy = 0;\n\tint cpu, best_energy_cpu = prev_cpu;\n\tstruct sched_domain *sd;\n\tstruct perf_domain *pd;\n\n\trcu_read_lock();\n\tpd = rcu_dereference(rd->pd);\n\tif (!pd || READ_ONCE(rd->overutilized))\n\t\tgoto fail;\n\n\t/*\n\t * Energy-aware wake-up happens on the lowest sched_domain starting\n\t * from sd_asym_cpucapacity spanning over this_cpu and prev_cpu.\n\t */\n\tsd = rcu_dereference(*this_cpu_ptr(&sd_asym_cpucapacity));\n\twhile (sd && !cpumask_test_cpu(prev_cpu, sched_domain_span(sd)))\n\t\tsd = sd->parent;\n\tif (!sd)\n\t\tgoto fail;\n\n\tsync_entity_load_avg(&p->se);\n\tif (!task_util_est(p))\n\t\tgoto unlock;\n\n\tfor (; pd; pd = pd->next) {\n\t\tunsigned long cur_delta, spare_cap, max_spare_cap = 0;\n\t\tunsigned long base_energy_pd;\n\t\tint max_spare_cap_cpu = -1;\n\n\t\t/* Compute the 'base' energy of the pd, without @p */\n\t\tbase_energy_pd = compute_energy(p, -1, pd);\n\t\tbase_energy += base_energy_pd;\n\n\t\tfor_each_cpu_and(cpu, perf_domain_span(pd), sched_domain_span(sd)) {\n\t\t\tif (!cpumask_test_cpu(cpu, p->cpus_ptr))\n\t\t\t\tcontinue;\n\n\t\t\tutil = cpu_util_next(cpu, p, cpu);\n\t\t\tcpu_cap = capacity_of(cpu);\n\t\t\tspare_cap = cpu_cap;\n\t\t\tlsub_positive(&spare_cap, util);\n\n\t\t\t/*\n\t\t\t * Skip CPUs that cannot satisfy the capacity request.\n\t\t\t * IOW, placing the task there would make the CPU\n\t\t\t * overutilized. Take uclamp into account to see how\n\t\t\t * much capacity we can get out of the CPU; this is\n\t\t\t * aligned with sched_cpu_util().\n\t\t\t */\n\t\t\tutil = uclamp_rq_util_with(cpu_rq(cpu), util, p);\n\t\t\tif (!fits_capacity(util, cpu_cap))\n\t\t\t\tcontinue;\n\n\t\t\t/* Always use prev_cpu as a candidate. */\n\t\t\tif (cpu == prev_cpu) {\n\t\t\t\tprev_delta = compute_energy(p, prev_cpu, pd);\n\t\t\t\tprev_delta -= base_energy_pd;\n\t\t\t\tbest_delta = min(best_delta, prev_delta);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the CPU with the maximum spare capacity in\n\t\t\t * the performance domain\n\t\t\t */\n\t\t\tif (spare_cap > max_spare_cap) {\n\t\t\t\tmax_spare_cap = spare_cap;\n\t\t\t\tmax_spare_cap_cpu = cpu;\n\t\t\t}\n\t\t}\n\n\t\t/* Evaluate the energy impact of using this CPU. */\n\t\tif (max_spare_cap_cpu >= 0 && max_spare_cap_cpu != prev_cpu) {\n\t\t\tcur_delta = compute_energy(p, max_spare_cap_cpu, pd);\n\t\t\tcur_delta -= base_energy_pd;\n\t\t\tif (cur_delta < best_delta) {\n\t\t\t\tbest_delta = cur_delta;\n\t\t\t\tbest_energy_cpu = max_spare_cap_cpu;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\trcu_read_unlock();\n\n\t/*\n\t * Pick the best CPU if prev_cpu cannot be used, or if it saves at\n\t * least 6% of the energy used by prev_cpu.\n\t */\n\tif (prev_delta == ULONG_MAX)\n\t\treturn best_energy_cpu;\n\n\tif ((prev_delta - best_delta) > ((prev_delta + base_energy) >> 4))\n\t\treturn best_energy_cpu;\n\n\treturn prev_cpu;\n\nfail:\n\trcu_read_unlock();\n\n\treturn -1;\n}\n\n/*\n * select_task_rq_fair: Select target runqueue for the waking task in domains\n * that have the relevant SD flag set. In practice, this is SD_BALANCE_WAKE,\n * SD_BALANCE_FORK, or SD_BALANCE_EXEC.\n *\n * Balances load by selecting the idlest CPU in the idlest group, or under\n * certain conditions an idle sibling CPU if the domain has SD_WAKE_AFFINE set.\n *\n * Returns the target CPU number.\n *\n * preempt must be disabled.\n */\nstatic int\nselect_task_rq_fair(struct task_struct *p, int prev_cpu, int wake_flags)\n{\n\tint sync = (wake_flags & WF_SYNC) && !(current->flags & PF_EXITING);\n\tstruct sched_domain *tmp, *sd = NULL;\n\tint cpu = smp_processor_id();\n\tint new_cpu = prev_cpu;\n\tint want_affine = 0;\n\t/* SD_flags and WF_flags share the first nibble */\n\tint sd_flag = wake_flags & 0xF;\n\n\tif (wake_flags & WF_TTWU) {\n\t\trecord_wakee(p);\n\n\t\tif (sched_energy_enabled()) {\n\t\t\tnew_cpu = find_energy_efficient_cpu(p, prev_cpu);\n\t\t\tif (new_cpu >= 0)\n\t\t\t\treturn new_cpu;\n\t\t\tnew_cpu = prev_cpu;\n\t\t}\n\n\t\twant_affine = !wake_wide(p) && cpumask_test_cpu(cpu, p->cpus_ptr);\n\t}\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, tmp) {\n\t\t/*\n\t\t * If both 'cpu' and 'prev_cpu' are part of this domain,\n\t\t * cpu is a valid SD_WAKE_AFFINE target.\n\t\t */\n\t\tif (want_affine && (tmp->flags & SD_WAKE_AFFINE) &&\n\t\t    cpumask_test_cpu(prev_cpu, sched_domain_span(tmp))) {\n\t\t\tif (cpu != prev_cpu)\n\t\t\t\tnew_cpu = wake_affine(tmp, p, cpu, prev_cpu, sync);\n\n\t\t\tsd = NULL; /* Prefer wake_affine over balance flags */\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tmp->flags & sd_flag)\n\t\t\tsd = tmp;\n\t\telse if (!want_affine)\n\t\t\tbreak;\n\t}\n\n\tif (unlikely(sd)) {\n\t\t/* Slow path */\n\t\tnew_cpu = find_idlest_cpu(sd, p, cpu, prev_cpu, sd_flag);\n\t} else if (wake_flags & WF_TTWU) { /* XXX always ? */\n\t\t/* Fast path */\n\t\tnew_cpu = select_idle_sibling(p, prev_cpu, new_cpu);\n\n\t\tif (want_affine)\n\t\t\tcurrent->recent_used_cpu = cpu;\n\t}\n\trcu_read_unlock();\n\n\treturn new_cpu;\n}\n\nstatic void detach_entity_cfs_rq(struct sched_entity *se);\n\n/*\n * Called immediately before a task is migrated to a new CPU; task_cpu(p) and\n * cfs_rq_of(p) references at time of call are still valid and identify the\n * previous CPU. The caller guarantees p->pi_lock or task_rq(p)->lock is held.\n */\nstatic void migrate_task_rq_fair(struct task_struct *p, int new_cpu)\n{\n\t/*\n\t * As blocked tasks retain absolute vruntime the migration needs to\n\t * deal with this by subtracting the old and adding the new\n\t * min_vruntime -- the latter is done by enqueue_entity() when placing\n\t * the task on the new runqueue.\n\t */\n\tif (p->state == TASK_WAKING) {\n\t\tstruct sched_entity *se = &p->se;\n\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\t\tu64 min_vruntime;\n\n#ifndef CONFIG_64BIT\n\t\tu64 min_vruntime_copy;\n\n\t\tdo {\n\t\t\tmin_vruntime_copy = cfs_rq->min_vruntime_copy;\n\t\t\tsmp_rmb();\n\t\t\tmin_vruntime = cfs_rq->min_vruntime;\n\t\t} while (min_vruntime != min_vruntime_copy);\n#else\n\t\tmin_vruntime = cfs_rq->min_vruntime;\n#endif\n\n\t\tse->vruntime -= min_vruntime;\n\t}\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING) {\n\t\t/*\n\t\t * In case of TASK_ON_RQ_MIGRATING we in fact hold the 'old'\n\t\t * rq->lock and can modify state directly.\n\t\t */\n\t\tlockdep_assert_held(&task_rq(p)->lock);\n\t\tdetach_entity_cfs_rq(&p->se);\n\n\t} else {\n\t\t/*\n\t\t * We are supposed to update the task to \"current\" time, then\n\t\t * its up to date and ready to go to new CPU/cfs_rq. But we\n\t\t * have difficulty in getting what current time is, so simply\n\t\t * throw away the out-of-date time. This will result in the\n\t\t * wakee task is less decayed, but giving the wakee more load\n\t\t * sounds not bad.\n\t\t */\n\t\tremove_entity_load_avg(&p->se);\n\t}\n\n\t/* Tell new CPU we are migrated */\n\tp->se.avg.last_update_time = 0;\n\n\t/* We have migrated, no longer consider this task hot */\n\tp->se.exec_start = 0;\n\n\tupdate_scan_period(p, new_cpu);\n}\n\nstatic void task_dead_fair(struct task_struct *p)\n{\n\tremove_entity_load_avg(&p->se);\n}\n\nstatic int\nbalance_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tif (rq->nr_running)\n\t\treturn 1;\n\n\treturn newidle_balance(rq, rf) != 0;\n}\n#endif /* CONFIG_SMP */\n\nstatic unsigned long wakeup_gran(struct sched_entity *se)\n{\n\tunsigned long gran = sysctl_sched_wakeup_granularity;\n\n\t/*\n\t * Since its curr running now, convert the gran from real-time\n\t * to virtual-time in his units.\n\t *\n\t * By using 'se' instead of 'curr' we penalize light tasks, so\n\t * they get preempted easier. That is, if 'se' < 'curr' then\n\t * the resulting gran will be larger, therefore penalizing the\n\t * lighter, if otoh 'se' > 'curr' then the resulting gran will\n\t * be smaller, again penalizing the lighter task.\n\t *\n\t * This is especially important for buddies when the leftmost\n\t * task is higher priority than the buddy.\n\t */\n\treturn calc_delta_fair(gran, se);\n}\n\n/*\n * Should 'se' preempt 'curr'.\n *\n *             |s1\n *        |s2\n *   |s3\n *         g\n *      |<--->|c\n *\n *  w(c, s1) = -1\n *  w(c, s2) =  0\n *  w(c, s3) =  1\n *\n */\nstatic int\nwakeup_preempt_entity(struct sched_entity *curr, struct sched_entity *se)\n{\n\ts64 gran, vdiff = curr->vruntime - se->vruntime;\n\n\tif (vdiff <= 0)\n\t\treturn -1;\n\n\tgran = wakeup_gran(se);\n\tif (vdiff > gran)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void set_last_buddy(struct sched_entity *se)\n{\n\tif (entity_is_task(se) && unlikely(task_has_idle_policy(task_of(se))))\n\t\treturn;\n\n\tfor_each_sched_entity(se) {\n\t\tif (SCHED_WARN_ON(!se->on_rq))\n\t\t\treturn;\n\t\tcfs_rq_of(se)->last = se;\n\t}\n}\n\nstatic void set_next_buddy(struct sched_entity *se)\n{\n\tif (entity_is_task(se) && unlikely(task_has_idle_policy(task_of(se))))\n\t\treturn;\n\n\tfor_each_sched_entity(se) {\n\t\tif (SCHED_WARN_ON(!se->on_rq))\n\t\t\treturn;\n\t\tcfs_rq_of(se)->next = se;\n\t}\n}\n\nstatic void set_skip_buddy(struct sched_entity *se)\n{\n\tfor_each_sched_entity(se)\n\t\tcfs_rq_of(se)->skip = se;\n}\n\n/*\n * Preempt the current task with a newly woken task if needed:\n */\nstatic void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_entity *se = &curr->se, *pse = &p->se;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tint scale = cfs_rq->nr_running >= sched_nr_latency;\n\tint next_buddy_marked = 0;\n\n\tif (unlikely(se == pse))\n\t\treturn;\n\n\t/*\n\t * This is possible from callers such as attach_tasks(), in which we\n\t * unconditionally check_prempt_curr() after an enqueue (which may have\n\t * lead to a throttle).  This both saves work and prevents false\n\t * next-buddy nomination below.\n\t */\n\tif (unlikely(throttled_hierarchy(cfs_rq_of(pse))))\n\t\treturn;\n\n\tif (sched_feat(NEXT_BUDDY) && scale && !(wake_flags & WF_FORK)) {\n\t\tset_next_buddy(pse);\n\t\tnext_buddy_marked = 1;\n\t}\n\n\t/*\n\t * We can come here with TIF_NEED_RESCHED already set from new task\n\t * wake up path.\n\t *\n\t * Note: this also catches the edge-case of curr being in a throttled\n\t * group (e.g. via set_curr_task), since update_curr() (in the\n\t * enqueue of curr) will have resulted in resched being set.  This\n\t * prevents us from potentially nominating it as a false LAST_BUDDY\n\t * below.\n\t */\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\t/* Idle tasks are by definition preempted by non-idle tasks. */\n\tif (unlikely(task_has_idle_policy(curr)) &&\n\t    likely(!task_has_idle_policy(p)))\n\t\tgoto preempt;\n\n\t/*\n\t * Batch and idle tasks do not preempt non-idle tasks (their preemption\n\t * is driven by the tick):\n\t */\n\tif (unlikely(p->policy != SCHED_NORMAL) || !sched_feat(WAKEUP_PREEMPTION))\n\t\treturn;\n\n\tfind_matching_se(&se, &pse);\n\tupdate_curr(cfs_rq_of(se));\n\tBUG_ON(!pse);\n\tif (wakeup_preempt_entity(se, pse) == 1) {\n\t\t/*\n\t\t * Bias pick_next to pick the sched entity that is\n\t\t * triggering this preemption.\n\t\t */\n\t\tif (!next_buddy_marked)\n\t\t\tset_next_buddy(pse);\n\t\tgoto preempt;\n\t}\n\n\treturn;\n\npreempt:\n\tresched_curr(rq);\n\t/*\n\t * Only set the backward buddy when the current task is still\n\t * on the rq. This can happen when a wakeup gets interleaved\n\t * with schedule on the ->pre_schedule() or idle_balance()\n\t * point, either of which can * drop the rq lock.\n\t *\n\t * Also, during early boot the idle thread is in the fair class,\n\t * for obvious reasons its a bad idea to schedule back to it.\n\t */\n\tif (unlikely(!se->on_rq || curr == rq->idle))\n\t\treturn;\n\n\tif (sched_feat(LAST_BUDDY) && scale && entity_is_task(se))\n\t\tset_last_buddy(se);\n}\n\nstruct task_struct *\npick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tstruct cfs_rq *cfs_rq = &rq->cfs;\n\tstruct sched_entity *se;\n\tstruct task_struct *p;\n\tint new_tasks;\n\nagain:\n\tif (!sched_fair_runnable(rq))\n\t\tgoto idle;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tif (!prev || prev->sched_class != &fair_sched_class)\n\t\tgoto simple;\n\n\t/*\n\t * Because of the set_next_buddy() in dequeue_task_fair() it is rather\n\t * likely that a next task is from the same cgroup as the current.\n\t *\n\t * Therefore attempt to avoid putting and setting the entire cgroup\n\t * hierarchy, only change the part that actually changes.\n\t */\n\n\tdo {\n\t\tstruct sched_entity *curr = cfs_rq->curr;\n\n\t\t/*\n\t\t * Since we got here without doing put_prev_entity() we also\n\t\t * have to consider cfs_rq->curr. If it is still a runnable\n\t\t * entity, update_curr() will update its vruntime, otherwise\n\t\t * forget we've ever seen it.\n\t\t */\n\t\tif (curr) {\n\t\t\tif (curr->on_rq)\n\t\t\t\tupdate_curr(cfs_rq);\n\t\t\telse\n\t\t\t\tcurr = NULL;\n\n\t\t\t/*\n\t\t\t * This call to check_cfs_rq_runtime() will do the\n\t\t\t * throttle and dequeue its entity in the parent(s).\n\t\t\t * Therefore the nr_running test will indeed\n\t\t\t * be correct.\n\t\t\t */\n\t\t\tif (unlikely(check_cfs_rq_runtime(cfs_rq))) {\n\t\t\t\tcfs_rq = &rq->cfs;\n\n\t\t\t\tif (!cfs_rq->nr_running)\n\t\t\t\t\tgoto idle;\n\n\t\t\t\tgoto simple;\n\t\t\t}\n\t\t}\n\n\t\tse = pick_next_entity(cfs_rq, curr);\n\t\tcfs_rq = group_cfs_rq(se);\n\t} while (cfs_rq);\n\n\tp = task_of(se);\n\n\t/*\n\t * Since we haven't yet done put_prev_entity and if the selected task\n\t * is a different task than we started out with, try and touch the\n\t * least amount of cfs_rqs.\n\t */\n\tif (prev != p) {\n\t\tstruct sched_entity *pse = &prev->se;\n\n\t\twhile (!(cfs_rq = is_same_group(se, pse))) {\n\t\t\tint se_depth = se->depth;\n\t\t\tint pse_depth = pse->depth;\n\n\t\t\tif (se_depth <= pse_depth) {\n\t\t\t\tput_prev_entity(cfs_rq_of(pse), pse);\n\t\t\t\tpse = parent_entity(pse);\n\t\t\t}\n\t\t\tif (se_depth >= pse_depth) {\n\t\t\t\tset_next_entity(cfs_rq_of(se), se);\n\t\t\t\tse = parent_entity(se);\n\t\t\t}\n\t\t}\n\n\t\tput_prev_entity(cfs_rq, pse);\n\t\tset_next_entity(cfs_rq, se);\n\t}\n\n\tgoto done;\nsimple:\n#endif\n\tif (prev)\n\t\tput_prev_task(rq, prev);\n\n\tdo {\n\t\tse = pick_next_entity(cfs_rq, NULL);\n\t\tset_next_entity(cfs_rq, se);\n\t\tcfs_rq = group_cfs_rq(se);\n\t} while (cfs_rq);\n\n\tp = task_of(se);\n\ndone: __maybe_unused;\n#ifdef CONFIG_SMP\n\t/*\n\t * Move the next running task to the front of\n\t * the list, so our cfs_tasks list becomes MRU\n\t * one.\n\t */\n\tlist_move(&p->se.group_node, &rq->cfs_tasks);\n#endif\n\n\tif (hrtick_enabled(rq))\n\t\thrtick_start_fair(rq, p);\n\n\tupdate_misfit_status(p, rq);\n\n\treturn p;\n\nidle:\n\tif (!rf)\n\t\treturn NULL;\n\n\tnew_tasks = newidle_balance(rq, rf);\n\n\t/*\n\t * Because newidle_balance() releases (and re-acquires) rq->lock, it is\n\t * possible for any higher priority task to appear. In that case we\n\t * must re-start the pick_next_entity() loop.\n\t */\n\tif (new_tasks < 0)\n\t\treturn RETRY_TASK;\n\n\tif (new_tasks > 0)\n\t\tgoto again;\n\n\t/*\n\t * rq is about to be idle, check if we need to update the\n\t * lost_idle_time of clock_pelt\n\t */\n\tupdate_idle_rq_clock_pelt(rq);\n\n\treturn NULL;\n}\n\nstatic struct task_struct *__pick_next_task_fair(struct rq *rq)\n{\n\treturn pick_next_task_fair(rq, NULL, NULL);\n}\n\n/*\n * Account for a descheduled task:\n */\nstatic void put_prev_task_fair(struct rq *rq, struct task_struct *prev)\n{\n\tstruct sched_entity *se = &prev->se;\n\tstruct cfs_rq *cfs_rq;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tput_prev_entity(cfs_rq, se);\n\t}\n}\n\n/*\n * sched_yield() is very simple\n *\n * The magic of dealing with the ->skip buddy is in pick_next_entity.\n */\nstatic void yield_task_fair(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(curr);\n\tstruct sched_entity *se = &curr->se;\n\n\t/*\n\t * Are we the only task in the tree?\n\t */\n\tif (unlikely(rq->nr_running == 1))\n\t\treturn;\n\n\tclear_buddies(cfs_rq, se);\n\n\tif (curr->policy != SCHED_BATCH) {\n\t\tupdate_rq_clock(rq);\n\t\t/*\n\t\t * Update run-time statistics of the 'current'.\n\t\t */\n\t\tupdate_curr(cfs_rq);\n\t\t/*\n\t\t * Tell update_rq_clock() that we've just updated,\n\t\t * so we don't do microscopic update in schedule()\n\t\t * and double the fastpath cost.\n\t\t */\n\t\trq_clock_skip_update(rq);\n\t}\n\n\tset_skip_buddy(se);\n}\n\nstatic bool yield_to_task_fair(struct rq *rq, struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\n\t/* throttled hierarchies are not runnable */\n\tif (!se->on_rq || throttled_hierarchy(cfs_rq_of(se)))\n\t\treturn false;\n\n\t/* Tell the scheduler that we'd really like pse to run next. */\n\tset_next_buddy(se);\n\n\tyield_task_fair(rq);\n\n\treturn true;\n}\n\n#ifdef CONFIG_SMP\n/**************************************************\n * Fair scheduling class load-balancing methods.\n *\n * BASICS\n *\n * The purpose of load-balancing is to achieve the same basic fairness the\n * per-CPU scheduler provides, namely provide a proportional amount of compute\n * time to each task. This is expressed in the following equation:\n *\n *   W_i,n/P_i == W_j,n/P_j for all i,j                               (1)\n *\n * Where W_i,n is the n-th weight average for CPU i. The instantaneous weight\n * W_i,0 is defined as:\n *\n *   W_i,0 = \\Sum_j w_i,j                                             (2)\n *\n * Where w_i,j is the weight of the j-th runnable task on CPU i. This weight\n * is derived from the nice value as per sched_prio_to_weight[].\n *\n * The weight average is an exponential decay average of the instantaneous\n * weight:\n *\n *   W'_i,n = (2^n - 1) / 2^n * W_i,n + 1 / 2^n * W_i,0               (3)\n *\n * C_i is the compute capacity of CPU i, typically it is the\n * fraction of 'recent' time available for SCHED_OTHER task execution. But it\n * can also include other factors [XXX].\n *\n * To achieve this balance we define a measure of imbalance which follows\n * directly from (1):\n *\n *   imb_i,j = max{ avg(W/C), W_i/C_i } - min{ avg(W/C), W_j/C_j }    (4)\n *\n * We them move tasks around to minimize the imbalance. In the continuous\n * function space it is obvious this converges, in the discrete case we get\n * a few fun cases generally called infeasible weight scenarios.\n *\n * [XXX expand on:\n *     - infeasible weights;\n *     - local vs global optima in the discrete case. ]\n *\n *\n * SCHED DOMAINS\n *\n * In order to solve the imbalance equation (4), and avoid the obvious O(n^2)\n * for all i,j solution, we create a tree of CPUs that follows the hardware\n * topology where each level pairs two lower groups (or better). This results\n * in O(log n) layers. Furthermore we reduce the number of CPUs going up the\n * tree to only the first of the previous level and we decrease the frequency\n * of load-balance at each level inv. proportional to the number of CPUs in\n * the groups.\n *\n * This yields:\n *\n *     log_2 n     1     n\n *   \\Sum       { --- * --- * 2^i } = O(n)                            (5)\n *     i = 0      2^i   2^i\n *                               `- size of each group\n *         |         |     `- number of CPUs doing load-balance\n *         |         `- freq\n *         `- sum over all levels\n *\n * Coupled with a limit on how many tasks we can migrate every balance pass,\n * this makes (5) the runtime complexity of the balancer.\n *\n * An important property here is that each CPU is still (indirectly) connected\n * to every other CPU in at most O(log n) steps:\n *\n * The adjacency matrix of the resulting graph is given by:\n *\n *             log_2 n\n *   A_i,j = \\Union     (i % 2^k == 0) && i / 2^(k+1) == j / 2^(k+1)  (6)\n *             k = 0\n *\n * And you'll find that:\n *\n *   A^(log_2 n)_i,j != 0  for all i,j                                (7)\n *\n * Showing there's indeed a path between every CPU in at most O(log n) steps.\n * The task movement gives a factor of O(m), giving a convergence complexity\n * of:\n *\n *   O(nm log n),  n := nr_cpus, m := nr_tasks                        (8)\n *\n *\n * WORK CONSERVING\n *\n * In order to avoid CPUs going idle while there's still work to do, new idle\n * balancing is more aggressive and has the newly idle CPU iterate up the domain\n * tree itself instead of relying on other CPUs to bring it work.\n *\n * This adds some complexity to both (5) and (8) but it reduces the total idle\n * time.\n *\n * [XXX more?]\n *\n *\n * CGROUPS\n *\n * Cgroups make a horror show out of (2), instead of a simple sum we get:\n *\n *                                s_k,i\n *   W_i,0 = \\Sum_j \\Prod_k w_k * -----                               (9)\n *                                 S_k\n *\n * Where\n *\n *   s_k,i = \\Sum_j w_i,j,k  and  S_k = \\Sum_i s_k,i                 (10)\n *\n * w_i,j,k is the weight of the j-th runnable task in the k-th cgroup on CPU i.\n *\n * The big problem is S_k, its a global sum needed to compute a local (W_i)\n * property.\n *\n * [XXX write more on how we solve this.. _after_ merging pjt's patches that\n *      rewrite all of this once again.]\n */\n\nstatic unsigned long __read_mostly max_load_balance_interval = HZ/10;\n\nenum fbq_type { regular, remote, all };\n\n/*\n * 'group_type' describes the group of CPUs at the moment of load balancing.\n *\n * The enum is ordered by pulling priority, with the group with lowest priority\n * first so the group_type can simply be compared when selecting the busiest\n * group. See update_sd_pick_busiest().\n */\nenum group_type {\n\t/* The group has spare capacity that can be used to run more tasks.  */\n\tgroup_has_spare = 0,\n\t/*\n\t * The group is fully used and the tasks don't compete for more CPU\n\t * cycles. Nevertheless, some tasks might wait before running.\n\t */\n\tgroup_fully_busy,\n\t/*\n\t * SD_ASYM_CPUCAPACITY only: One task doesn't fit with CPU's capacity\n\t * and must be migrated to a more powerful CPU.\n\t */\n\tgroup_misfit_task,\n\t/*\n\t * SD_ASYM_PACKING only: One local CPU with higher capacity is available,\n\t * and the task should be migrated to it instead of running on the\n\t * current CPU.\n\t */\n\tgroup_asym_packing,\n\t/*\n\t * The tasks' affinity constraints previously prevented the scheduler\n\t * from balancing the load across the system.\n\t */\n\tgroup_imbalanced,\n\t/*\n\t * The CPU is overloaded and can't provide expected CPU cycles to all\n\t * tasks.\n\t */\n\tgroup_overloaded\n};\n\nenum migration_type {\n\tmigrate_load = 0,\n\tmigrate_util,\n\tmigrate_task,\n\tmigrate_misfit\n};\n\n#define LBF_ALL_PINNED\t0x01\n#define LBF_NEED_BREAK\t0x02\n#define LBF_DST_PINNED  0x04\n#define LBF_SOME_PINNED\t0x08\n#define LBF_NOHZ_STATS\t0x10\n#define LBF_NOHZ_AGAIN\t0x20\n\nstruct lb_env {\n\tstruct sched_domain\t*sd;\n\n\tstruct rq\t\t*src_rq;\n\tint\t\t\tsrc_cpu;\n\n\tint\t\t\tdst_cpu;\n\tstruct rq\t\t*dst_rq;\n\n\tstruct cpumask\t\t*dst_grpmask;\n\tint\t\t\tnew_dst_cpu;\n\tenum cpu_idle_type\tidle;\n\tlong\t\t\timbalance;\n\t/* The set of CPUs under consideration for load-balancing */\n\tstruct cpumask\t\t*cpus;\n\n\tunsigned int\t\tflags;\n\n\tunsigned int\t\tloop;\n\tunsigned int\t\tloop_break;\n\tunsigned int\t\tloop_max;\n\n\tenum fbq_type\t\tfbq_type;\n\tenum migration_type\tmigration_type;\n\tstruct list_head\ttasks;\n};\n\n/*\n * Is this task likely cache-hot:\n */\nstatic int task_hot(struct task_struct *p, struct lb_env *env)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tif (p->sched_class != &fair_sched_class)\n\t\treturn 0;\n\n\tif (unlikely(task_has_idle_policy(p)))\n\t\treturn 0;\n\n\t/* SMT siblings share cache */\n\tif (env->sd->flags & SD_SHARE_CPUCAPACITY)\n\t\treturn 0;\n\n\t/*\n\t * Buddy candidates are cache hot:\n\t */\n\tif (sched_feat(CACHE_HOT_BUDDY) && env->dst_rq->nr_running &&\n\t\t\t(&p->se == cfs_rq_of(&p->se)->next ||\n\t\t\t &p->se == cfs_rq_of(&p->se)->last))\n\t\treturn 1;\n\n\tif (sysctl_sched_migration_cost == -1)\n\t\treturn 1;\n\tif (sysctl_sched_migration_cost == 0)\n\t\treturn 0;\n\n\tdelta = rq_clock_task(env->src_rq) - p->se.exec_start;\n\n\treturn delta < (s64)sysctl_sched_migration_cost;\n}\n\n#ifdef CONFIG_NUMA_BALANCING\n/*\n * Returns 1, if task migration degrades locality\n * Returns 0, if task migration improves locality i.e migration preferred.\n * Returns -1, if task migration is not affected by locality.\n */\nstatic int migrate_degrades_locality(struct task_struct *p, struct lb_env *env)\n{\n\tstruct numa_group *numa_group = rcu_dereference(p->numa_group);\n\tunsigned long src_weight, dst_weight;\n\tint src_nid, dst_nid, dist;\n\n\tif (!static_branch_likely(&sched_numa_balancing))\n\t\treturn -1;\n\n\tif (!p->numa_faults || !(env->sd->flags & SD_NUMA))\n\t\treturn -1;\n\n\tsrc_nid = cpu_to_node(env->src_cpu);\n\tdst_nid = cpu_to_node(env->dst_cpu);\n\n\tif (src_nid == dst_nid)\n\t\treturn -1;\n\n\t/* Migrating away from the preferred node is always bad. */\n\tif (src_nid == p->numa_preferred_nid) {\n\t\tif (env->src_rq->nr_running > env->src_rq->nr_preferred_running)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/* Encourage migration to the preferred node. */\n\tif (dst_nid == p->numa_preferred_nid)\n\t\treturn 0;\n\n\t/* Leaving a core idle is often worse than degrading locality. */\n\tif (env->idle == CPU_IDLE)\n\t\treturn -1;\n\n\tdist = node_distance(src_nid, dst_nid);\n\tif (numa_group) {\n\t\tsrc_weight = group_weight(p, src_nid, dist);\n\t\tdst_weight = group_weight(p, dst_nid, dist);\n\t} else {\n\t\tsrc_weight = task_weight(p, src_nid, dist);\n\t\tdst_weight = task_weight(p, dst_nid, dist);\n\t}\n\n\treturn dst_weight < src_weight;\n}\n\n#else\nstatic inline int migrate_degrades_locality(struct task_struct *p,\n\t\t\t\t\t     struct lb_env *env)\n{\n\treturn -1;\n}\n#endif\n\n/*\n * can_migrate_task - may task p from runqueue rq be migrated to this_cpu?\n */\nstatic\nint can_migrate_task(struct task_struct *p, struct lb_env *env)\n{\n\tint tsk_cache_hot;\n\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\t/*\n\t * We do not migrate tasks that are:\n\t * 1) throttled_lb_pair, or\n\t * 2) cannot be migrated to this CPU due to cpus_ptr, or\n\t * 3) running (obviously), or\n\t * 4) are cache-hot on their current CPU.\n\t */\n\tif (throttled_lb_pair(task_group(p), env->src_cpu, env->dst_cpu))\n\t\treturn 0;\n\n\tif (!cpumask_test_cpu(env->dst_cpu, p->cpus_ptr)) {\n\t\tint cpu;\n\n\t\tschedstat_inc(p->se.statistics.nr_failed_migrations_affine);\n\n\t\tenv->flags |= LBF_SOME_PINNED;\n\n\t\t/*\n\t\t * Remember if this task can be migrated to any other CPU in\n\t\t * our sched_group. We may want to revisit it if we couldn't\n\t\t * meet load balance goals by pulling other tasks on src_cpu.\n\t\t *\n\t\t * Avoid computing new_dst_cpu for NEWLY_IDLE or if we have\n\t\t * already computed one in current iteration.\n\t\t */\n\t\tif (env->idle == CPU_NEWLY_IDLE || (env->flags & LBF_DST_PINNED))\n\t\t\treturn 0;\n\n\t\t/* Prevent to re-select dst_cpu via env's CPUs: */\n\t\tfor_each_cpu_and(cpu, env->dst_grpmask, env->cpus) {\n\t\t\tif (cpumask_test_cpu(cpu, p->cpus_ptr)) {\n\t\t\t\tenv->flags |= LBF_DST_PINNED;\n\t\t\t\tenv->new_dst_cpu = cpu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t/* Record that we found atleast one task that could run on dst_cpu */\n\tenv->flags &= ~LBF_ALL_PINNED;\n\n\tif (task_running(env->src_rq, p)) {\n\t\tschedstat_inc(p->se.statistics.nr_failed_migrations_running);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Aggressive migration if:\n\t * 1) destination numa is preferred\n\t * 2) task is cache cold, or\n\t * 3) too many balance attempts have failed.\n\t */\n\ttsk_cache_hot = migrate_degrades_locality(p, env);\n\tif (tsk_cache_hot == -1)\n\t\ttsk_cache_hot = task_hot(p, env);\n\n\tif (tsk_cache_hot <= 0 ||\n\t    env->sd->nr_balance_failed > env->sd->cache_nice_tries) {\n\t\tif (tsk_cache_hot == 1) {\n\t\t\tschedstat_inc(env->sd->lb_hot_gained[env->idle]);\n\t\t\tschedstat_inc(p->se.statistics.nr_forced_migrations);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tschedstat_inc(p->se.statistics.nr_failed_migrations_hot);\n\treturn 0;\n}\n\n/*\n * detach_task() -- detach the task for the migration specified in env\n */\nstatic void detach_task(struct task_struct *p, struct lb_env *env)\n{\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tdeactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, env->dst_cpu);\n}\n\n/*\n * detach_one_task() -- tries to dequeue exactly one task from env->src_rq, as\n * part of active balancing operations within \"domain\".\n *\n * Returns a task if successful and NULL otherwise.\n */\nstatic struct task_struct *detach_one_task(struct lb_env *env)\n{\n\tstruct task_struct *p;\n\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tlist_for_each_entry_reverse(p,\n\t\t\t&env->src_rq->cfs_tasks, se.group_node) {\n\t\tif (!can_migrate_task(p, env))\n\t\t\tcontinue;\n\n\t\tdetach_task(p, env);\n\n\t\t/*\n\t\t * Right now, this is only the second place where\n\t\t * lb_gained[env->idle] is updated (other is detach_tasks)\n\t\t * so we can safely collect stats here rather than\n\t\t * inside detach_tasks().\n\t\t */\n\t\tschedstat_inc(env->sd->lb_gained[env->idle]);\n\t\treturn p;\n\t}\n\treturn NULL;\n}\n\nstatic const unsigned int sched_nr_migrate_break = 32;\n\n/*\n * detach_tasks() -- tries to detach up to imbalance load/util/tasks from\n * busiest_rq, as part of a balancing operation within domain \"sd\".\n *\n * Returns number of detached tasks if successful and 0 otherwise.\n */\nstatic int detach_tasks(struct lb_env *env)\n{\n\tstruct list_head *tasks = &env->src_rq->cfs_tasks;\n\tunsigned long util, load;\n\tstruct task_struct *p;\n\tint detached = 0;\n\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tif (env->imbalance <= 0)\n\t\treturn 0;\n\n\twhile (!list_empty(tasks)) {\n\t\t/*\n\t\t * We don't want to steal all, otherwise we may be treated likewise,\n\t\t * which could at worst lead to a livelock crash.\n\t\t */\n\t\tif (env->idle != CPU_NOT_IDLE && env->src_rq->nr_running <= 1)\n\t\t\tbreak;\n\n\t\tp = list_last_entry(tasks, struct task_struct, se.group_node);\n\n\t\tenv->loop++;\n\t\t/* We've more or less seen every task there is, call it quits */\n\t\tif (env->loop > env->loop_max)\n\t\t\tbreak;\n\n\t\t/* take a breather every nr_migrate tasks */\n\t\tif (env->loop > env->loop_break) {\n\t\t\tenv->loop_break += sched_nr_migrate_break;\n\t\t\tenv->flags |= LBF_NEED_BREAK;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!can_migrate_task(p, env))\n\t\t\tgoto next;\n\n\t\tswitch (env->migration_type) {\n\t\tcase migrate_load:\n\t\t\t/*\n\t\t\t * Depending of the number of CPUs and tasks and the\n\t\t\t * cgroup hierarchy, task_h_load() can return a null\n\t\t\t * value. Make sure that env->imbalance decreases\n\t\t\t * otherwise detach_tasks() will stop only after\n\t\t\t * detaching up to loop_max tasks.\n\t\t\t */\n\t\t\tload = max_t(unsigned long, task_h_load(p), 1);\n\n\t\t\tif (sched_feat(LB_MIN) &&\n\t\t\t    load < 16 && !env->sd->nr_balance_failed)\n\t\t\t\tgoto next;\n\n\t\t\t/*\n\t\t\t * Make sure that we don't migrate too much load.\n\t\t\t * Nevertheless, let relax the constraint if\n\t\t\t * scheduler fails to find a good waiting task to\n\t\t\t * migrate.\n\t\t\t */\n\n\t\t\tif ((load >> env->sd->nr_balance_failed) > env->imbalance)\n\t\t\t\tgoto next;\n\n\t\t\tenv->imbalance -= load;\n\t\t\tbreak;\n\n\t\tcase migrate_util:\n\t\t\tutil = task_util_est(p);\n\n\t\t\tif (util > env->imbalance)\n\t\t\t\tgoto next;\n\n\t\t\tenv->imbalance -= util;\n\t\t\tbreak;\n\n\t\tcase migrate_task:\n\t\t\tenv->imbalance--;\n\t\t\tbreak;\n\n\t\tcase migrate_misfit:\n\t\t\t/* This is not a misfit task */\n\t\t\tif (task_fits_capacity(p, capacity_of(env->src_cpu)))\n\t\t\t\tgoto next;\n\n\t\t\tenv->imbalance = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tdetach_task(p, env);\n\t\tlist_add(&p->se.group_node, &env->tasks);\n\n\t\tdetached++;\n\n#ifdef CONFIG_PREEMPTION\n\t\t/*\n\t\t * NEWIDLE balancing is a source of latency, so preemptible\n\t\t * kernels will stop after the first task is detached to minimize\n\t\t * the critical section.\n\t\t */\n\t\tif (env->idle == CPU_NEWLY_IDLE)\n\t\t\tbreak;\n#endif\n\n\t\t/*\n\t\t * We only want to steal up to the prescribed amount of\n\t\t * load/util/tasks.\n\t\t */\n\t\tif (env->imbalance <= 0)\n\t\t\tbreak;\n\n\t\tcontinue;\nnext:\n\t\tlist_move(&p->se.group_node, tasks);\n\t}\n\n\t/*\n\t * Right now, this is one of only two places we collect this stat\n\t * so we can safely collect detach_one_task() stats here rather\n\t * than inside detach_one_task().\n\t */\n\tschedstat_add(env->sd->lb_gained[env->idle], detached);\n\n\treturn detached;\n}\n\n/*\n * attach_task() -- attach the task detached by detach_task() to its new rq.\n */\nstatic void attach_task(struct rq *rq, struct task_struct *p)\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tBUG_ON(task_rq(p) != rq);\n\tactivate_task(rq, p, ENQUEUE_NOCLOCK);\n\tcheck_preempt_curr(rq, p, 0);\n}\n\n/*\n * attach_one_task() -- attaches the task returned from detach_one_task() to\n * its new rq.\n */\nstatic void attach_one_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\tattach_task(rq, p);\n\trq_unlock(rq, &rf);\n}\n\n/*\n * attach_tasks() -- attaches all tasks detached by detach_tasks() to their\n * new rq.\n */\nstatic void attach_tasks(struct lb_env *env)\n{\n\tstruct list_head *tasks = &env->tasks;\n\tstruct task_struct *p;\n\tstruct rq_flags rf;\n\n\trq_lock(env->dst_rq, &rf);\n\tupdate_rq_clock(env->dst_rq);\n\n\twhile (!list_empty(tasks)) {\n\t\tp = list_first_entry(tasks, struct task_struct, se.group_node);\n\t\tlist_del_init(&p->se.group_node);\n\n\t\tattach_task(env->dst_rq, p);\n\t}\n\n\trq_unlock(env->dst_rq, &rf);\n}\n\n#ifdef CONFIG_NO_HZ_COMMON\nstatic inline bool cfs_rq_has_blocked(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->avg.load_avg)\n\t\treturn true;\n\n\tif (cfs_rq->avg.util_avg)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool others_have_blocked(struct rq *rq)\n{\n\tif (READ_ONCE(rq->avg_rt.util_avg))\n\t\treturn true;\n\n\tif (READ_ONCE(rq->avg_dl.util_avg))\n\t\treturn true;\n\n\tif (thermal_load_avg(rq))\n\t\treturn true;\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tif (READ_ONCE(rq->avg_irq.util_avg))\n\t\treturn true;\n#endif\n\n\treturn false;\n}\n\nstatic inline void update_blocked_load_status(struct rq *rq, bool has_blocked)\n{\n\trq->last_blocked_load_update_tick = jiffies;\n\n\tif (!has_blocked)\n\t\trq->has_blocked_load = 0;\n}\n#else\nstatic inline bool cfs_rq_has_blocked(struct cfs_rq *cfs_rq) { return false; }\nstatic inline bool others_have_blocked(struct rq *rq) { return false; }\nstatic inline void update_blocked_load_status(struct rq *rq, bool has_blocked) {}\n#endif\n\nstatic bool __update_blocked_others(struct rq *rq, bool *done)\n{\n\tconst struct sched_class *curr_class;\n\tu64 now = rq_clock_pelt(rq);\n\tunsigned long thermal_pressure;\n\tbool decayed;\n\n\t/*\n\t * update_load_avg() can call cpufreq_update_util(). Make sure that RT,\n\t * DL and IRQ signals have been updated before updating CFS.\n\t */\n\tcurr_class = rq->curr->sched_class;\n\n\tthermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));\n\n\tdecayed = update_rt_rq_load_avg(now, rq, curr_class == &rt_sched_class) |\n\t\t  update_dl_rq_load_avg(now, rq, curr_class == &dl_sched_class) |\n\t\t  update_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure) |\n\t\t  update_irq_load_avg(rq, 0);\n\n\tif (others_have_blocked(rq))\n\t\t*done = false;\n\n\treturn decayed;\n}\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\nstatic inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\n\tif (cfs_rq->avg.runnable_sum)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool __update_blocked_fair(struct rq *rq, bool *done)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\tbool decayed = false;\n\tint cpu = cpu_of(rq);\n\n\t/*\n\t * Iterates the task_group tree in a bottom up fashion, see\n\t * list_add_leaf_cfs_rq() for details.\n\t */\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_pelt(cfs_rq), cfs_rq)) {\n\t\t\tupdate_tg_load_avg(cfs_rq);\n\n\t\t\tif (cfs_rq == &rq->cfs)\n\t\t\t\tdecayed = true;\n\t\t}\n\n\t\t/* Propagate pending load changes to the parent, if any: */\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\n\t\t/*\n\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n\t\t * decayed cfs_rqs linger on the list.\n\t\t */\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\n\t\t/* Don't need periodic decay once load/util_avg are null */\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\t*done = false;\n\t}\n\n\treturn decayed;\n}\n\n/*\n * Compute the hierarchical load factor for cfs_rq and all its ascendants.\n * This needs to be done in a top-down fashion because the load of a child\n * group is a fraction of its parents load.\n */\nstatic void update_cfs_rq_h_load(struct cfs_rq *cfs_rq)\n{\n\tstruct rq *rq = rq_of(cfs_rq);\n\tstruct sched_entity *se = cfs_rq->tg->se[cpu_of(rq)];\n\tunsigned long now = jiffies;\n\tunsigned long load;\n\n\tif (cfs_rq->last_h_load_update == now)\n\t\treturn;\n\n\tWRITE_ONCE(cfs_rq->h_load_next, NULL);\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tWRITE_ONCE(cfs_rq->h_load_next, se);\n\t\tif (cfs_rq->last_h_load_update == now)\n\t\t\tbreak;\n\t}\n\n\tif (!se) {\n\t\tcfs_rq->h_load = cfs_rq_load_avg(cfs_rq);\n\t\tcfs_rq->last_h_load_update = now;\n\t}\n\n\twhile ((se = READ_ONCE(cfs_rq->h_load_next)) != NULL) {\n\t\tload = cfs_rq->h_load;\n\t\tload = div64_ul(load * se->avg.load_avg,\n\t\t\tcfs_rq_load_avg(cfs_rq) + 1);\n\t\tcfs_rq = group_cfs_rq(se);\n\t\tcfs_rq->h_load = load;\n\t\tcfs_rq->last_h_load_update = now;\n\t}\n}\n\nstatic unsigned long task_h_load(struct task_struct *p)\n{\n\tstruct cfs_rq *cfs_rq = task_cfs_rq(p);\n\n\tupdate_cfs_rq_h_load(cfs_rq);\n\treturn div64_ul(p->se.avg.load_avg * cfs_rq->h_load,\n\t\t\tcfs_rq_load_avg(cfs_rq) + 1);\n}\n#else\nstatic bool __update_blocked_fair(struct rq *rq, bool *done)\n{\n\tstruct cfs_rq *cfs_rq = &rq->cfs;\n\tbool decayed;\n\n\tdecayed = update_cfs_rq_load_avg(cfs_rq_clock_pelt(cfs_rq), cfs_rq);\n\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t*done = false;\n\n\treturn decayed;\n}\n\nstatic unsigned long task_h_load(struct task_struct *p)\n{\n\treturn p->se.avg.load_avg;\n}\n#endif\n\nstatic void update_blocked_averages(int cpu)\n{\n\tbool decayed = false, done = true;\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tdecayed |= __update_blocked_others(rq, &done);\n\tdecayed |= __update_blocked_fair(rq, &done);\n\n\tupdate_blocked_load_status(rq, !done);\n\tif (decayed)\n\t\tcpufreq_update_util(rq, 0);\n\trq_unlock_irqrestore(rq, &rf);\n}\n\n/********** Helpers for find_busiest_group ************************/\n\n/*\n * sg_lb_stats - stats of a sched_group required for load_balancing\n */\nstruct sg_lb_stats {\n\tunsigned long avg_load; /*Avg load across the CPUs of the group */\n\tunsigned long group_load; /* Total load over the CPUs of the group */\n\tunsigned long group_capacity;\n\tunsigned long group_util; /* Total utilization over the CPUs of the group */\n\tunsigned long group_runnable; /* Total runnable time over the CPUs of the group */\n\tunsigned int sum_nr_running; /* Nr of tasks running in the group */\n\tunsigned int sum_h_nr_running; /* Nr of CFS tasks running in the group */\n\tunsigned int idle_cpus;\n\tunsigned int group_weight;\n\tenum group_type group_type;\n\tunsigned int group_asym_packing; /* Tasks should be moved to preferred CPU */\n\tunsigned long group_misfit_task_load; /* A CPU has a task too big for its capacity */\n#ifdef CONFIG_NUMA_BALANCING\n\tunsigned int nr_numa_running;\n\tunsigned int nr_preferred_running;\n#endif\n};\n\n/*\n * sd_lb_stats - Structure to store the statistics of a sched_domain\n *\t\t during load balancing.\n */\nstruct sd_lb_stats {\n\tstruct sched_group *busiest;\t/* Busiest group in this sd */\n\tstruct sched_group *local;\t/* Local group in this sd */\n\tunsigned long total_load;\t/* Total load of all groups in sd */\n\tunsigned long total_capacity;\t/* Total capacity of all groups in sd */\n\tunsigned long avg_load;\t/* Average load across all groups in sd */\n\tunsigned int prefer_sibling; /* tasks should go to sibling first */\n\n\tstruct sg_lb_stats busiest_stat;/* Statistics of the busiest group */\n\tstruct sg_lb_stats local_stat;\t/* Statistics of the local group */\n};\n\nstatic inline void init_sd_lb_stats(struct sd_lb_stats *sds)\n{\n\t/*\n\t * Skimp on the clearing to avoid duplicate work. We can avoid clearing\n\t * local_stat because update_sg_lb_stats() does a full clear/assignment.\n\t * We must however set busiest_stat::group_type and\n\t * busiest_stat::idle_cpus to the worst busiest group because\n\t * update_sd_pick_busiest() reads these before assignment.\n\t */\n\t*sds = (struct sd_lb_stats){\n\t\t.busiest = NULL,\n\t\t.local = NULL,\n\t\t.total_load = 0UL,\n\t\t.total_capacity = 0UL,\n\t\t.busiest_stat = {\n\t\t\t.idle_cpus = UINT_MAX,\n\t\t\t.group_type = group_has_spare,\n\t\t},\n\t};\n}\n\nstatic unsigned long scale_rt_capacity(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long max = arch_scale_cpu_capacity(cpu);\n\tunsigned long used, free;\n\tunsigned long irq;\n\n\tirq = cpu_util_irq(rq);\n\n\tif (unlikely(irq >= max))\n\t\treturn 1;\n\n\t/*\n\t * avg_rt.util_avg and avg_dl.util_avg track binary signals\n\t * (running and not running) with weights 0 and 1024 respectively.\n\t * avg_thermal.load_avg tracks thermal pressure and the weighted\n\t * average uses the actual delta max capacity(load).\n\t */\n\tused = READ_ONCE(rq->avg_rt.util_avg);\n\tused += READ_ONCE(rq->avg_dl.util_avg);\n\tused += thermal_load_avg(rq);\n\n\tif (unlikely(used >= max))\n\t\treturn 1;\n\n\tfree = max - used;\n\n\treturn scale_irq_capacity(free, irq, max);\n}\n\nstatic void update_cpu_capacity(struct sched_domain *sd, int cpu)\n{\n\tunsigned long capacity = scale_rt_capacity(cpu);\n\tstruct sched_group *sdg = sd->groups;\n\n\tcpu_rq(cpu)->cpu_capacity_orig = arch_scale_cpu_capacity(cpu);\n\n\tif (!capacity)\n\t\tcapacity = 1;\n\n\tcpu_rq(cpu)->cpu_capacity = capacity;\n\ttrace_sched_cpu_capacity_tp(cpu_rq(cpu));\n\n\tsdg->sgc->capacity = capacity;\n\tsdg->sgc->min_capacity = capacity;\n\tsdg->sgc->max_capacity = capacity;\n}\n\nvoid update_group_capacity(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_domain *child = sd->child;\n\tstruct sched_group *group, *sdg = sd->groups;\n\tunsigned long capacity, min_capacity, max_capacity;\n\tunsigned long interval;\n\n\tinterval = msecs_to_jiffies(sd->balance_interval);\n\tinterval = clamp(interval, 1UL, max_load_balance_interval);\n\tsdg->sgc->next_update = jiffies + interval;\n\n\tif (!child) {\n\t\tupdate_cpu_capacity(sd, cpu);\n\t\treturn;\n\t}\n\n\tcapacity = 0;\n\tmin_capacity = ULONG_MAX;\n\tmax_capacity = 0;\n\n\tif (child->flags & SD_OVERLAP) {\n\t\t/*\n\t\t * SD_OVERLAP domains cannot assume that child groups\n\t\t * span the current group.\n\t\t */\n\n\t\tfor_each_cpu(cpu, sched_group_span(sdg)) {\n\t\t\tunsigned long cpu_cap = capacity_of(cpu);\n\n\t\t\tcapacity += cpu_cap;\n\t\t\tmin_capacity = min(cpu_cap, min_capacity);\n\t\t\tmax_capacity = max(cpu_cap, max_capacity);\n\t\t}\n\t} else  {\n\t\t/*\n\t\t * !SD_OVERLAP domains can assume that child groups\n\t\t * span the current group.\n\t\t */\n\n\t\tgroup = child->groups;\n\t\tdo {\n\t\t\tstruct sched_group_capacity *sgc = group->sgc;\n\n\t\t\tcapacity += sgc->capacity;\n\t\t\tmin_capacity = min(sgc->min_capacity, min_capacity);\n\t\t\tmax_capacity = max(sgc->max_capacity, max_capacity);\n\t\t\tgroup = group->next;\n\t\t} while (group != child->groups);\n\t}\n\n\tsdg->sgc->capacity = capacity;\n\tsdg->sgc->min_capacity = min_capacity;\n\tsdg->sgc->max_capacity = max_capacity;\n}\n\n/*\n * Check whether the capacity of the rq has been noticeably reduced by side\n * activity. The imbalance_pct is used for the threshold.\n * Return true is the capacity is reduced\n */\nstatic inline int\ncheck_cpu_capacity(struct rq *rq, struct sched_domain *sd)\n{\n\treturn ((rq->cpu_capacity * sd->imbalance_pct) <\n\t\t\t\t(rq->cpu_capacity_orig * 100));\n}\n\n/*\n * Check whether a rq has a misfit task and if it looks like we can actually\n * help that task: we can migrate the task to a CPU of higher capacity, or\n * the task's current CPU is heavily pressured.\n */\nstatic inline int check_misfit_status(struct rq *rq, struct sched_domain *sd)\n{\n\treturn rq->misfit_task_load &&\n\t\t(rq->cpu_capacity_orig < rq->rd->max_cpu_capacity ||\n\t\t check_cpu_capacity(rq, sd));\n}\n\n/*\n * Group imbalance indicates (and tries to solve) the problem where balancing\n * groups is inadequate due to ->cpus_ptr constraints.\n *\n * Imagine a situation of two groups of 4 CPUs each and 4 tasks each with a\n * cpumask covering 1 CPU of the first group and 3 CPUs of the second group.\n * Something like:\n *\n *\t{ 0 1 2 3 } { 4 5 6 7 }\n *\t        *     * * *\n *\n * If we were to balance group-wise we'd place two tasks in the first group and\n * two tasks in the second group. Clearly this is undesired as it will overload\n * cpu 3 and leave one of the CPUs in the second group unused.\n *\n * The current solution to this issue is detecting the skew in the first group\n * by noticing the lower domain failed to reach balance and had difficulty\n * moving tasks due to affinity constraints.\n *\n * When this is so detected; this group becomes a candidate for busiest; see\n * update_sd_pick_busiest(). And calculate_imbalance() and\n * find_busiest_group() avoid some of the usual balance conditions to allow it\n * to create an effective group imbalance.\n *\n * This is a somewhat tricky proposition since the next run might not find the\n * group imbalance and decide the groups need to be balanced again. A most\n * subtle and fragile situation.\n */\n\nstatic inline int sg_imbalanced(struct sched_group *group)\n{\n\treturn group->sgc->imbalance;\n}\n\n/*\n * group_has_capacity returns true if the group has spare capacity that could\n * be used by some tasks.\n * We consider that a group has spare capacity if the  * number of task is\n * smaller than the number of CPUs or if the utilization is lower than the\n * available capacity for CFS tasks.\n * For the latter, we use a threshold to stabilize the state, to take into\n * account the variance of the tasks' load and to return true if the available\n * capacity in meaningful for the load balancer.\n * As an example, an available capacity of 1% can appear but it doesn't make\n * any benefit for the load balance.\n */\nstatic inline bool\ngroup_has_capacity(unsigned int imbalance_pct, struct sg_lb_stats *sgs)\n{\n\tif (sgs->sum_nr_running < sgs->group_weight)\n\t\treturn true;\n\n\tif ((sgs->group_capacity * imbalance_pct) <\n\t\t\t(sgs->group_runnable * 100))\n\t\treturn false;\n\n\tif ((sgs->group_capacity * 100) >\n\t\t\t(sgs->group_util * imbalance_pct))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n *  group_is_overloaded returns true if the group has more tasks than it can\n *  handle.\n *  group_is_overloaded is not equals to !group_has_capacity because a group\n *  with the exact right number of tasks, has no more spare capacity but is not\n *  overloaded so both group_has_capacity and group_is_overloaded return\n *  false.\n */\nstatic inline bool\ngroup_is_overloaded(unsigned int imbalance_pct, struct sg_lb_stats *sgs)\n{\n\tif (sgs->sum_nr_running <= sgs->group_weight)\n\t\treturn false;\n\n\tif ((sgs->group_capacity * 100) <\n\t\t\t(sgs->group_util * imbalance_pct))\n\t\treturn true;\n\n\tif ((sgs->group_capacity * imbalance_pct) <\n\t\t\t(sgs->group_runnable * 100))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * group_smaller_min_cpu_capacity: Returns true if sched_group sg has smaller\n * per-CPU capacity than sched_group ref.\n */\nstatic inline bool\ngroup_smaller_min_cpu_capacity(struct sched_group *sg, struct sched_group *ref)\n{\n\treturn fits_capacity(sg->sgc->min_capacity, ref->sgc->min_capacity);\n}\n\n/*\n * group_smaller_max_cpu_capacity: Returns true if sched_group sg has smaller\n * per-CPU capacity_orig than sched_group ref.\n */\nstatic inline bool\ngroup_smaller_max_cpu_capacity(struct sched_group *sg, struct sched_group *ref)\n{\n\treturn fits_capacity(sg->sgc->max_capacity, ref->sgc->max_capacity);\n}\n\nstatic inline enum\ngroup_type group_classify(unsigned int imbalance_pct,\n\t\t\t  struct sched_group *group,\n\t\t\t  struct sg_lb_stats *sgs)\n{\n\tif (group_is_overloaded(imbalance_pct, sgs))\n\t\treturn group_overloaded;\n\n\tif (sg_imbalanced(group))\n\t\treturn group_imbalanced;\n\n\tif (sgs->group_asym_packing)\n\t\treturn group_asym_packing;\n\n\tif (sgs->group_misfit_task_load)\n\t\treturn group_misfit_task;\n\n\tif (!group_has_capacity(imbalance_pct, sgs))\n\t\treturn group_fully_busy;\n\n\treturn group_has_spare;\n}\n\nstatic bool update_nohz_stats(struct rq *rq, bool force)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned int cpu = rq->cpu;\n\n\tif (!rq->has_blocked_load)\n\t\treturn false;\n\n\tif (!cpumask_test_cpu(cpu, nohz.idle_cpus_mask))\n\t\treturn false;\n\n\tif (!force && !time_after(jiffies, rq->last_blocked_load_update_tick))\n\t\treturn true;\n\n\tupdate_blocked_averages(cpu);\n\n\treturn rq->has_blocked_load;\n#else\n\treturn false;\n#endif\n}\n\n/**\n * update_sg_lb_stats - Update sched_group's statistics for load balancing.\n * @env: The load balancing environment.\n * @group: sched_group whose statistics are to be updated.\n * @sgs: variable to hold the statistics for this group.\n * @sg_status: Holds flag indicating the status of the sched_group\n */\nstatic inline void update_sg_lb_stats(struct lb_env *env,\n\t\t\t\t      struct sched_group *group,\n\t\t\t\t      struct sg_lb_stats *sgs,\n\t\t\t\t      int *sg_status)\n{\n\tint i, nr_running, local_group;\n\n\tmemset(sgs, 0, sizeof(*sgs));\n\n\tlocal_group = cpumask_test_cpu(env->dst_cpu, sched_group_span(group));\n\n\tfor_each_cpu_and(i, sched_group_span(group), env->cpus) {\n\t\tstruct rq *rq = cpu_rq(i);\n\n\t\tif ((env->flags & LBF_NOHZ_STATS) && update_nohz_stats(rq, false))\n\t\t\tenv->flags |= LBF_NOHZ_AGAIN;\n\n\t\tsgs->group_load += cpu_load(rq);\n\t\tsgs->group_util += cpu_util(i);\n\t\tsgs->group_runnable += cpu_runnable(rq);\n\t\tsgs->sum_h_nr_running += rq->cfs.h_nr_running;\n\n\t\tnr_running = rq->nr_running;\n\t\tsgs->sum_nr_running += nr_running;\n\n\t\tif (nr_running > 1)\n\t\t\t*sg_status |= SG_OVERLOAD;\n\n\t\tif (cpu_overutilized(i))\n\t\t\t*sg_status |= SG_OVERUTILIZED;\n\n#ifdef CONFIG_NUMA_BALANCING\n\t\tsgs->nr_numa_running += rq->nr_numa_running;\n\t\tsgs->nr_preferred_running += rq->nr_preferred_running;\n#endif\n\t\t/*\n\t\t * No need to call idle_cpu() if nr_running is not 0\n\t\t */\n\t\tif (!nr_running && idle_cpu(i)) {\n\t\t\tsgs->idle_cpus++;\n\t\t\t/* Idle cpu can't have misfit task */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (local_group)\n\t\t\tcontinue;\n\n\t\t/* Check for a misfit task on the cpu */\n\t\tif (env->sd->flags & SD_ASYM_CPUCAPACITY &&\n\t\t    sgs->group_misfit_task_load < rq->misfit_task_load) {\n\t\t\tsgs->group_misfit_task_load = rq->misfit_task_load;\n\t\t\t*sg_status |= SG_OVERLOAD;\n\t\t}\n\t}\n\n\t/* Check if dst CPU is idle and preferred to this group */\n\tif (env->sd->flags & SD_ASYM_PACKING &&\n\t    env->idle != CPU_NOT_IDLE &&\n\t    sgs->sum_h_nr_running &&\n\t    sched_asym_prefer(env->dst_cpu, group->asym_prefer_cpu)) {\n\t\tsgs->group_asym_packing = 1;\n\t}\n\n\tsgs->group_capacity = group->sgc->capacity;\n\n\tsgs->group_weight = group->group_weight;\n\n\tsgs->group_type = group_classify(env->sd->imbalance_pct, group, sgs);\n\n\t/* Computing avg_load makes sense only when group is overloaded */\n\tif (sgs->group_type == group_overloaded)\n\t\tsgs->avg_load = (sgs->group_load * SCHED_CAPACITY_SCALE) /\n\t\t\t\tsgs->group_capacity;\n}\n\n/**\n * update_sd_pick_busiest - return 1 on busiest group\n * @env: The load balancing environment.\n * @sds: sched_domain statistics\n * @sg: sched_group candidate to be checked for being the busiest\n * @sgs: sched_group statistics\n *\n * Determine if @sg is a busier group than the previously selected\n * busiest group.\n *\n * Return: %true if @sg is a busier group than the previously selected\n * busiest group. %false otherwise.\n */\nstatic bool update_sd_pick_busiest(struct lb_env *env,\n\t\t\t\t   struct sd_lb_stats *sds,\n\t\t\t\t   struct sched_group *sg,\n\t\t\t\t   struct sg_lb_stats *sgs)\n{\n\tstruct sg_lb_stats *busiest = &sds->busiest_stat;\n\n\t/* Make sure that there is at least one task to pull */\n\tif (!sgs->sum_h_nr_running)\n\t\treturn false;\n\n\t/*\n\t * Don't try to pull misfit tasks we can't help.\n\t * We can use max_capacity here as reduction in capacity on some\n\t * CPUs in the group should either be possible to resolve\n\t * internally or be covered by avg_load imbalance (eventually).\n\t */\n\tif (sgs->group_type == group_misfit_task &&\n\t    (!group_smaller_max_cpu_capacity(sg, sds->local) ||\n\t     sds->local_stat.group_type != group_has_spare))\n\t\treturn false;\n\n\tif (sgs->group_type > busiest->group_type)\n\t\treturn true;\n\n\tif (sgs->group_type < busiest->group_type)\n\t\treturn false;\n\n\t/*\n\t * The candidate and the current busiest group are the same type of\n\t * group. Let check which one is the busiest according to the type.\n\t */\n\n\tswitch (sgs->group_type) {\n\tcase group_overloaded:\n\t\t/* Select the overloaded group with highest avg_load. */\n\t\tif (sgs->avg_load <= busiest->avg_load)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase group_imbalanced:\n\t\t/*\n\t\t * Select the 1st imbalanced group as we don't have any way to\n\t\t * choose one more than another.\n\t\t */\n\t\treturn false;\n\n\tcase group_asym_packing:\n\t\t/* Prefer to move from lowest priority CPU's work */\n\t\tif (sched_asym_prefer(sg->asym_prefer_cpu, sds->busiest->asym_prefer_cpu))\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase group_misfit_task:\n\t\t/*\n\t\t * If we have more than one misfit sg go with the biggest\n\t\t * misfit.\n\t\t */\n\t\tif (sgs->group_misfit_task_load < busiest->group_misfit_task_load)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase group_fully_busy:\n\t\t/*\n\t\t * Select the fully busy group with highest avg_load. In\n\t\t * theory, there is no need to pull task from such kind of\n\t\t * group because tasks have all compute capacity that they need\n\t\t * but we can still improve the overall throughput by reducing\n\t\t * contention when accessing shared HW resources.\n\t\t *\n\t\t * XXX for now avg_load is not computed and always 0 so we\n\t\t * select the 1st one.\n\t\t */\n\t\tif (sgs->avg_load <= busiest->avg_load)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase group_has_spare:\n\t\t/*\n\t\t * Select not overloaded group with lowest number of idle cpus\n\t\t * and highest number of running tasks. We could also compare\n\t\t * the spare capacity which is more stable but it can end up\n\t\t * that the group has less spare capacity but finally more idle\n\t\t * CPUs which means less opportunity to pull tasks.\n\t\t */\n\t\tif (sgs->idle_cpus > busiest->idle_cpus)\n\t\t\treturn false;\n\t\telse if ((sgs->idle_cpus == busiest->idle_cpus) &&\n\t\t\t (sgs->sum_nr_running <= busiest->sum_nr_running))\n\t\t\treturn false;\n\n\t\tbreak;\n\t}\n\n\t/*\n\t * Candidate sg has no more than one task per CPU and has higher\n\t * per-CPU capacity. Migrating tasks to less capable CPUs may harm\n\t * throughput. Maximize throughput, power/energy consequences are not\n\t * considered.\n\t */\n\tif ((env->sd->flags & SD_ASYM_CPUCAPACITY) &&\n\t    (sgs->group_type <= group_fully_busy) &&\n\t    (group_smaller_min_cpu_capacity(sds->local, sg)))\n\t\treturn false;\n\n\treturn true;\n}\n\n#ifdef CONFIG_NUMA_BALANCING\nstatic inline enum fbq_type fbq_classify_group(struct sg_lb_stats *sgs)\n{\n\tif (sgs->sum_h_nr_running > sgs->nr_numa_running)\n\t\treturn regular;\n\tif (sgs->sum_h_nr_running > sgs->nr_preferred_running)\n\t\treturn remote;\n\treturn all;\n}\n\nstatic inline enum fbq_type fbq_classify_rq(struct rq *rq)\n{\n\tif (rq->nr_running > rq->nr_numa_running)\n\t\treturn regular;\n\tif (rq->nr_running > rq->nr_preferred_running)\n\t\treturn remote;\n\treturn all;\n}\n#else\nstatic inline enum fbq_type fbq_classify_group(struct sg_lb_stats *sgs)\n{\n\treturn all;\n}\n\nstatic inline enum fbq_type fbq_classify_rq(struct rq *rq)\n{\n\treturn regular;\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n\nstruct sg_lb_stats;\n\n/*\n * task_running_on_cpu - return 1 if @p is running on @cpu.\n */\n\nstatic unsigned int task_running_on_cpu(int cpu, struct task_struct *p)\n{\n\t/* Task has no contribution or is new */\n\tif (cpu != task_cpu(p) || !READ_ONCE(p->se.avg.last_update_time))\n\t\treturn 0;\n\n\tif (task_on_rq_queued(p))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * idle_cpu_without - would a given CPU be idle without p ?\n * @cpu: the processor on which idleness is tested.\n * @p: task which should be ignored.\n *\n * Return: 1 if the CPU would be idle. 0 otherwise.\n */\nstatic int idle_cpu_without(int cpu, struct task_struct *p)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (rq->curr != rq->idle && rq->curr != p)\n\t\treturn 0;\n\n\t/*\n\t * rq->nr_running can't be used but an updated version without the\n\t * impact of p on cpu must be used instead. The updated nr_running\n\t * be computed and tested before calling idle_cpu_without().\n\t */\n\n#ifdef CONFIG_SMP\n\tif (rq->ttwu_pending)\n\t\treturn 0;\n#endif\n\n\treturn 1;\n}\n\n/*\n * update_sg_wakeup_stats - Update sched_group's statistics for wakeup.\n * @sd: The sched_domain level to look for idlest group.\n * @group: sched_group whose statistics are to be updated.\n * @sgs: variable to hold the statistics for this group.\n * @p: The task for which we look for the idlest group/CPU.\n */\nstatic inline void update_sg_wakeup_stats(struct sched_domain *sd,\n\t\t\t\t\t  struct sched_group *group,\n\t\t\t\t\t  struct sg_lb_stats *sgs,\n\t\t\t\t\t  struct task_struct *p)\n{\n\tint i, nr_running;\n\n\tmemset(sgs, 0, sizeof(*sgs));\n\n\tfor_each_cpu(i, sched_group_span(group)) {\n\t\tstruct rq *rq = cpu_rq(i);\n\t\tunsigned int local;\n\n\t\tsgs->group_load += cpu_load_without(rq, p);\n\t\tsgs->group_util += cpu_util_without(i, p);\n\t\tsgs->group_runnable += cpu_runnable_without(rq, p);\n\t\tlocal = task_running_on_cpu(i, p);\n\t\tsgs->sum_h_nr_running += rq->cfs.h_nr_running - local;\n\n\t\tnr_running = rq->nr_running - local;\n\t\tsgs->sum_nr_running += nr_running;\n\n\t\t/*\n\t\t * No need to call idle_cpu_without() if nr_running is not 0\n\t\t */\n\t\tif (!nr_running && idle_cpu_without(i, p))\n\t\t\tsgs->idle_cpus++;\n\n\t}\n\n\t/* Check if task fits in the group */\n\tif (sd->flags & SD_ASYM_CPUCAPACITY &&\n\t    !task_fits_capacity(p, group->sgc->max_capacity)) {\n\t\tsgs->group_misfit_task_load = 1;\n\t}\n\n\tsgs->group_capacity = group->sgc->capacity;\n\n\tsgs->group_weight = group->group_weight;\n\n\tsgs->group_type = group_classify(sd->imbalance_pct, group, sgs);\n\n\t/*\n\t * Computing avg_load makes sense only when group is fully busy or\n\t * overloaded\n\t */\n\tif (sgs->group_type == group_fully_busy ||\n\t\tsgs->group_type == group_overloaded)\n\t\tsgs->avg_load = (sgs->group_load * SCHED_CAPACITY_SCALE) /\n\t\t\t\tsgs->group_capacity;\n}\n\nstatic bool update_pick_idlest(struct sched_group *idlest,\n\t\t\t       struct sg_lb_stats *idlest_sgs,\n\t\t\t       struct sched_group *group,\n\t\t\t       struct sg_lb_stats *sgs)\n{\n\tif (sgs->group_type < idlest_sgs->group_type)\n\t\treturn true;\n\n\tif (sgs->group_type > idlest_sgs->group_type)\n\t\treturn false;\n\n\t/*\n\t * The candidate and the current idlest group are the same type of\n\t * group. Let check which one is the idlest according to the type.\n\t */\n\n\tswitch (sgs->group_type) {\n\tcase group_overloaded:\n\tcase group_fully_busy:\n\t\t/* Select the group with lowest avg_load. */\n\t\tif (idlest_sgs->avg_load <= sgs->avg_load)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase group_imbalanced:\n\tcase group_asym_packing:\n\t\t/* Those types are not used in the slow wakeup path */\n\t\treturn false;\n\n\tcase group_misfit_task:\n\t\t/* Select group with the highest max capacity */\n\t\tif (idlest->sgc->max_capacity >= group->sgc->max_capacity)\n\t\t\treturn false;\n\t\tbreak;\n\n\tcase group_has_spare:\n\t\t/* Select group with most idle CPUs */\n\t\tif (idlest_sgs->idle_cpus > sgs->idle_cpus)\n\t\t\treturn false;\n\n\t\t/* Select group with lowest group_util */\n\t\tif (idlest_sgs->idle_cpus == sgs->idle_cpus &&\n\t\t\tidlest_sgs->group_util <= sgs->group_util)\n\t\t\treturn false;\n\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\n/*\n * Allow a NUMA imbalance if busy CPUs is less than 25% of the domain.\n * This is an approximation as the number of running tasks may not be\n * related to the number of busy CPUs due to sched_setaffinity.\n */\nstatic inline bool allow_numa_imbalance(int dst_running, int dst_weight)\n{\n\treturn (dst_running < (dst_weight >> 2));\n}\n\n/*\n * find_idlest_group() finds and returns the least busy CPU group within the\n * domain.\n *\n * Assumes p is allowed on at least one CPU in sd.\n */\nstatic struct sched_group *\nfind_idlest_group(struct sched_domain *sd, struct task_struct *p, int this_cpu)\n{\n\tstruct sched_group *idlest = NULL, *local = NULL, *group = sd->groups;\n\tstruct sg_lb_stats local_sgs, tmp_sgs;\n\tstruct sg_lb_stats *sgs;\n\tunsigned long imbalance;\n\tstruct sg_lb_stats idlest_sgs = {\n\t\t\t.avg_load = UINT_MAX,\n\t\t\t.group_type = group_overloaded,\n\t};\n\n\tdo {\n\t\tint local_group;\n\n\t\t/* Skip over this group if it has no CPUs allowed */\n\t\tif (!cpumask_intersects(sched_group_span(group),\n\t\t\t\t\tp->cpus_ptr))\n\t\t\tcontinue;\n\n\t\tlocal_group = cpumask_test_cpu(this_cpu,\n\t\t\t\t\t       sched_group_span(group));\n\n\t\tif (local_group) {\n\t\t\tsgs = &local_sgs;\n\t\t\tlocal = group;\n\t\t} else {\n\t\t\tsgs = &tmp_sgs;\n\t\t}\n\n\t\tupdate_sg_wakeup_stats(sd, group, sgs, p);\n\n\t\tif (!local_group && update_pick_idlest(idlest, &idlest_sgs, group, sgs)) {\n\t\t\tidlest = group;\n\t\t\tidlest_sgs = *sgs;\n\t\t}\n\n\t} while (group = group->next, group != sd->groups);\n\n\n\t/* There is no idlest group to push tasks to */\n\tif (!idlest)\n\t\treturn NULL;\n\n\t/* The local group has been skipped because of CPU affinity */\n\tif (!local)\n\t\treturn idlest;\n\n\t/*\n\t * If the local group is idler than the selected idlest group\n\t * don't try and push the task.\n\t */\n\tif (local_sgs.group_type < idlest_sgs.group_type)\n\t\treturn NULL;\n\n\t/*\n\t * If the local group is busier than the selected idlest group\n\t * try and push the task.\n\t */\n\tif (local_sgs.group_type > idlest_sgs.group_type)\n\t\treturn idlest;\n\n\tswitch (local_sgs.group_type) {\n\tcase group_overloaded:\n\tcase group_fully_busy:\n\n\t\t/* Calculate allowed imbalance based on load */\n\t\timbalance = scale_load_down(NICE_0_LOAD) *\n\t\t\t\t(sd->imbalance_pct-100) / 100;\n\n\t\t/*\n\t\t * When comparing groups across NUMA domains, it's possible for\n\t\t * the local domain to be very lightly loaded relative to the\n\t\t * remote domains but \"imbalance\" skews the comparison making\n\t\t * remote CPUs look much more favourable. When considering\n\t\t * cross-domain, add imbalance to the load on the remote node\n\t\t * and consider staying local.\n\t\t */\n\n\t\tif ((sd->flags & SD_NUMA) &&\n\t\t    ((idlest_sgs.avg_load + imbalance) >= local_sgs.avg_load))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * If the local group is less loaded than the selected\n\t\t * idlest group don't try and push any tasks.\n\t\t */\n\t\tif (idlest_sgs.avg_load >= (local_sgs.avg_load + imbalance))\n\t\t\treturn NULL;\n\n\t\tif (100 * local_sgs.avg_load <= sd->imbalance_pct * idlest_sgs.avg_load)\n\t\t\treturn NULL;\n\t\tbreak;\n\n\tcase group_imbalanced:\n\tcase group_asym_packing:\n\t\t/* Those type are not used in the slow wakeup path */\n\t\treturn NULL;\n\n\tcase group_misfit_task:\n\t\t/* Select group with the highest max capacity */\n\t\tif (local->sgc->max_capacity >= idlest->sgc->max_capacity)\n\t\t\treturn NULL;\n\t\tbreak;\n\n\tcase group_has_spare:\n\t\tif (sd->flags & SD_NUMA) {\n#ifdef CONFIG_NUMA_BALANCING\n\t\t\tint idlest_cpu;\n\t\t\t/*\n\t\t\t * If there is spare capacity at NUMA, try to select\n\t\t\t * the preferred node\n\t\t\t */\n\t\t\tif (cpu_to_node(this_cpu) == p->numa_preferred_nid)\n\t\t\t\treturn NULL;\n\n\t\t\tidlest_cpu = cpumask_first(sched_group_span(idlest));\n\t\t\tif (cpu_to_node(idlest_cpu) == p->numa_preferred_nid)\n\t\t\t\treturn idlest;\n#endif\n\t\t\t/*\n\t\t\t * Otherwise, keep the task on this node to stay close\n\t\t\t * its wakeup source and improve locality. If there is\n\t\t\t * a real need of migration, periodic load balance will\n\t\t\t * take care of it.\n\t\t\t */\n\t\t\tif (allow_numa_imbalance(local_sgs.sum_nr_running, sd->span_weight))\n\t\t\t\treturn NULL;\n\t\t}\n\n\t\t/*\n\t\t * Select group with highest number of idle CPUs. We could also\n\t\t * compare the utilization which is more stable but it can end\n\t\t * up that the group has less spare capacity but finally more\n\t\t * idle CPUs which means more opportunity to run task.\n\t\t */\n\t\tif (local_sgs.idle_cpus >= idlest_sgs.idle_cpus)\n\t\t\treturn NULL;\n\t\tbreak;\n\t}\n\n\treturn idlest;\n}\n\n/**\n * update_sd_lb_stats - Update sched_domain's statistics for load balancing.\n * @env: The load balancing environment.\n * @sds: variable to hold the statistics for this sched_domain.\n */\n\nstatic inline void update_sd_lb_stats(struct lb_env *env, struct sd_lb_stats *sds)\n{\n\tstruct sched_domain *child = env->sd->child;\n\tstruct sched_group *sg = env->sd->groups;\n\tstruct sg_lb_stats *local = &sds->local_stat;\n\tstruct sg_lb_stats tmp_sgs;\n\tint sg_status = 0;\n\n#ifdef CONFIG_NO_HZ_COMMON\n\tif (env->idle == CPU_NEWLY_IDLE && READ_ONCE(nohz.has_blocked))\n\t\tenv->flags |= LBF_NOHZ_STATS;\n#endif\n\n\tdo {\n\t\tstruct sg_lb_stats *sgs = &tmp_sgs;\n\t\tint local_group;\n\n\t\tlocal_group = cpumask_test_cpu(env->dst_cpu, sched_group_span(sg));\n\t\tif (local_group) {\n\t\t\tsds->local = sg;\n\t\t\tsgs = local;\n\n\t\t\tif (env->idle != CPU_NEWLY_IDLE ||\n\t\t\t    time_after_eq(jiffies, sg->sgc->next_update))\n\t\t\t\tupdate_group_capacity(env->sd, env->dst_cpu);\n\t\t}\n\n\t\tupdate_sg_lb_stats(env, sg, sgs, &sg_status);\n\n\t\tif (local_group)\n\t\t\tgoto next_group;\n\n\n\t\tif (update_sd_pick_busiest(env, sds, sg, sgs)) {\n\t\t\tsds->busiest = sg;\n\t\t\tsds->busiest_stat = *sgs;\n\t\t}\n\nnext_group:\n\t\t/* Now, start updating sd_lb_stats */\n\t\tsds->total_load += sgs->group_load;\n\t\tsds->total_capacity += sgs->group_capacity;\n\n\t\tsg = sg->next;\n\t} while (sg != env->sd->groups);\n\n\t/* Tag domain that child domain prefers tasks go to siblings first */\n\tsds->prefer_sibling = child && child->flags & SD_PREFER_SIBLING;\n\n#ifdef CONFIG_NO_HZ_COMMON\n\tif ((env->flags & LBF_NOHZ_AGAIN) &&\n\t    cpumask_subset(nohz.idle_cpus_mask, sched_domain_span(env->sd))) {\n\n\t\tWRITE_ONCE(nohz.next_blocked,\n\t\t\t   jiffies + msecs_to_jiffies(LOAD_AVG_PERIOD));\n\t}\n#endif\n\n\tif (env->sd->flags & SD_NUMA)\n\t\tenv->fbq_type = fbq_classify_group(&sds->busiest_stat);\n\n\tif (!env->sd->parent) {\n\t\tstruct root_domain *rd = env->dst_rq->rd;\n\n\t\t/* update overload indicator if we are at root domain */\n\t\tWRITE_ONCE(rd->overload, sg_status & SG_OVERLOAD);\n\n\t\t/* Update over-utilization (tipping point, U >= 0) indicator */\n\t\tWRITE_ONCE(rd->overutilized, sg_status & SG_OVERUTILIZED);\n\t\ttrace_sched_overutilized_tp(rd, sg_status & SG_OVERUTILIZED);\n\t} else if (sg_status & SG_OVERUTILIZED) {\n\t\tstruct root_domain *rd = env->dst_rq->rd;\n\n\t\tWRITE_ONCE(rd->overutilized, SG_OVERUTILIZED);\n\t\ttrace_sched_overutilized_tp(rd, SG_OVERUTILIZED);\n\t}\n}\n\n#define NUMA_IMBALANCE_MIN 2\n\nstatic inline long adjust_numa_imbalance(int imbalance,\n\t\t\t\tint dst_running, int dst_weight)\n{\n\tif (!allow_numa_imbalance(dst_running, dst_weight))\n\t\treturn imbalance;\n\n\t/*\n\t * Allow a small imbalance based on a simple pair of communicating\n\t * tasks that remain local when the destination is lightly loaded.\n\t */\n\tif (imbalance <= NUMA_IMBALANCE_MIN)\n\t\treturn 0;\n\n\treturn imbalance;\n}\n\n/**\n * calculate_imbalance - Calculate the amount of imbalance present within the\n *\t\t\t groups of a given sched_domain during load balance.\n * @env: load balance environment\n * @sds: statistics of the sched_domain whose imbalance is to be calculated.\n */\nstatic inline void calculate_imbalance(struct lb_env *env, struct sd_lb_stats *sds)\n{\n\tstruct sg_lb_stats *local, *busiest;\n\n\tlocal = &sds->local_stat;\n\tbusiest = &sds->busiest_stat;\n\n\tif (busiest->group_type == group_misfit_task) {\n\t\t/* Set imbalance to allow misfit tasks to be balanced. */\n\t\tenv->migration_type = migrate_misfit;\n\t\tenv->imbalance = 1;\n\t\treturn;\n\t}\n\n\tif (busiest->group_type == group_asym_packing) {\n\t\t/*\n\t\t * In case of asym capacity, we will try to migrate all load to\n\t\t * the preferred CPU.\n\t\t */\n\t\tenv->migration_type = migrate_task;\n\t\tenv->imbalance = busiest->sum_h_nr_running;\n\t\treturn;\n\t}\n\n\tif (busiest->group_type == group_imbalanced) {\n\t\t/*\n\t\t * In the group_imb case we cannot rely on group-wide averages\n\t\t * to ensure CPU-load equilibrium, try to move any task to fix\n\t\t * the imbalance. The next load balance will take care of\n\t\t * balancing back the system.\n\t\t */\n\t\tenv->migration_type = migrate_task;\n\t\tenv->imbalance = 1;\n\t\treturn;\n\t}\n\n\t/*\n\t * Try to use spare capacity of local group without overloading it or\n\t * emptying busiest.\n\t */\n\tif (local->group_type == group_has_spare) {\n\t\tif ((busiest->group_type > group_fully_busy) &&\n\t\t    !(env->sd->flags & SD_SHARE_PKG_RESOURCES)) {\n\t\t\t/*\n\t\t\t * If busiest is overloaded, try to fill spare\n\t\t\t * capacity. This might end up creating spare capacity\n\t\t\t * in busiest or busiest still being overloaded but\n\t\t\t * there is no simple way to directly compute the\n\t\t\t * amount of load to migrate in order to balance the\n\t\t\t * system.\n\t\t\t */\n\t\t\tenv->migration_type = migrate_util;\n\t\t\tenv->imbalance = max(local->group_capacity, local->group_util) -\n\t\t\t\t\t local->group_util;\n\n\t\t\t/*\n\t\t\t * In some cases, the group's utilization is max or even\n\t\t\t * higher than capacity because of migrations but the\n\t\t\t * local CPU is (newly) idle. There is at least one\n\t\t\t * waiting task in this overloaded busiest group. Let's\n\t\t\t * try to pull it.\n\t\t\t */\n\t\t\tif (env->idle != CPU_NOT_IDLE && env->imbalance == 0) {\n\t\t\t\tenv->migration_type = migrate_task;\n\t\t\t\tenv->imbalance = 1;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (busiest->group_weight == 1 || sds->prefer_sibling) {\n\t\t\tunsigned int nr_diff = busiest->sum_nr_running;\n\t\t\t/*\n\t\t\t * When prefer sibling, evenly spread running tasks on\n\t\t\t * groups.\n\t\t\t */\n\t\t\tenv->migration_type = migrate_task;\n\t\t\tlsub_positive(&nr_diff, local->sum_nr_running);\n\t\t\tenv->imbalance = nr_diff >> 1;\n\t\t} else {\n\n\t\t\t/*\n\t\t\t * If there is no overload, we just want to even the number of\n\t\t\t * idle cpus.\n\t\t\t */\n\t\t\tenv->migration_type = migrate_task;\n\t\t\tenv->imbalance = max_t(long, 0, (local->idle_cpus -\n\t\t\t\t\t\t busiest->idle_cpus) >> 1);\n\t\t}\n\n\t\t/* Consider allowing a small imbalance between NUMA groups */\n\t\tif (env->sd->flags & SD_NUMA) {\n\t\t\tenv->imbalance = adjust_numa_imbalance(env->imbalance,\n\t\t\t\tbusiest->sum_nr_running, busiest->group_weight);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Local is fully busy but has to take more load to relieve the\n\t * busiest group\n\t */\n\tif (local->group_type < group_overloaded) {\n\t\t/*\n\t\t * Local will become overloaded so the avg_load metrics are\n\t\t * finally needed.\n\t\t */\n\n\t\tlocal->avg_load = (local->group_load * SCHED_CAPACITY_SCALE) /\n\t\t\t\t  local->group_capacity;\n\n\t\tsds->avg_load = (sds->total_load * SCHED_CAPACITY_SCALE) /\n\t\t\t\tsds->total_capacity;\n\t\t/*\n\t\t * If the local group is more loaded than the selected\n\t\t * busiest group don't try to pull any tasks.\n\t\t */\n\t\tif (local->avg_load >= busiest->avg_load) {\n\t\t\tenv->imbalance = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Both group are or will become overloaded and we're trying to get all\n\t * the CPUs to the average_load, so we don't want to push ourselves\n\t * above the average load, nor do we wish to reduce the max loaded CPU\n\t * below the average load. At the same time, we also don't want to\n\t * reduce the group load below the group capacity. Thus we look for\n\t * the minimum possible imbalance.\n\t */\n\tenv->migration_type = migrate_load;\n\tenv->imbalance = min(\n\t\t(busiest->avg_load - sds->avg_load) * busiest->group_capacity,\n\t\t(sds->avg_load - local->avg_load) * local->group_capacity\n\t) / SCHED_CAPACITY_SCALE;\n}\n\n/******* find_busiest_group() helpers end here *********************/\n\n/*\n * Decision matrix according to the local and busiest group type:\n *\n * busiest \\ local has_spare fully_busy misfit asym imbalanced overloaded\n * has_spare        nr_idle   balanced   N/A    N/A  balanced   balanced\n * fully_busy       nr_idle   nr_idle    N/A    N/A  balanced   balanced\n * misfit_task      force     N/A        N/A    N/A  force      force\n * asym_packing     force     force      N/A    N/A  force      force\n * imbalanced       force     force      N/A    N/A  force      force\n * overloaded       force     force      N/A    N/A  force      avg_load\n *\n * N/A :      Not Applicable because already filtered while updating\n *            statistics.\n * balanced : The system is balanced for these 2 groups.\n * force :    Calculate the imbalance as load migration is probably needed.\n * avg_load : Only if imbalance is significant enough.\n * nr_idle :  dst_cpu is not busy and the number of idle CPUs is quite\n *            different in groups.\n */\n\n/**\n * find_busiest_group - Returns the busiest group within the sched_domain\n * if there is an imbalance.\n *\n * Also calculates the amount of runnable load which should be moved\n * to restore balance.\n *\n * @env: The load balancing environment.\n *\n * Return:\t- The busiest group if imbalance exists.\n */\nstatic struct sched_group *find_busiest_group(struct lb_env *env)\n{\n\tstruct sg_lb_stats *local, *busiest;\n\tstruct sd_lb_stats sds;\n\n\tinit_sd_lb_stats(&sds);\n\n\t/*\n\t * Compute the various statistics relevant for load balancing at\n\t * this level.\n\t */\n\tupdate_sd_lb_stats(env, &sds);\n\n\tif (sched_energy_enabled()) {\n\t\tstruct root_domain *rd = env->dst_rq->rd;\n\n\t\tif (rcu_dereference(rd->pd) && !READ_ONCE(rd->overutilized))\n\t\t\tgoto out_balanced;\n\t}\n\n\tlocal = &sds.local_stat;\n\tbusiest = &sds.busiest_stat;\n\n\t/* There is no busy sibling group to pull tasks from */\n\tif (!sds.busiest)\n\t\tgoto out_balanced;\n\n\t/* Misfit tasks should be dealt with regardless of the avg load */\n\tif (busiest->group_type == group_misfit_task)\n\t\tgoto force_balance;\n\n\t/* ASYM feature bypasses nice load balance check */\n\tif (busiest->group_type == group_asym_packing)\n\t\tgoto force_balance;\n\n\t/*\n\t * If the busiest group is imbalanced the below checks don't\n\t * work because they assume all things are equal, which typically\n\t * isn't true due to cpus_ptr constraints and the like.\n\t */\n\tif (busiest->group_type == group_imbalanced)\n\t\tgoto force_balance;\n\n\t/*\n\t * If the local group is busier than the selected busiest group\n\t * don't try and pull any tasks.\n\t */\n\tif (local->group_type > busiest->group_type)\n\t\tgoto out_balanced;\n\n\t/*\n\t * When groups are overloaded, use the avg_load to ensure fairness\n\t * between tasks.\n\t */\n\tif (local->group_type == group_overloaded) {\n\t\t/*\n\t\t * If the local group is more loaded than the selected\n\t\t * busiest group don't try to pull any tasks.\n\t\t */\n\t\tif (local->avg_load >= busiest->avg_load)\n\t\t\tgoto out_balanced;\n\n\t\t/* XXX broken for overlapping NUMA groups */\n\t\tsds.avg_load = (sds.total_load * SCHED_CAPACITY_SCALE) /\n\t\t\t\tsds.total_capacity;\n\n\t\t/*\n\t\t * Don't pull any tasks if this group is already above the\n\t\t * domain average load.\n\t\t */\n\t\tif (local->avg_load >= sds.avg_load)\n\t\t\tgoto out_balanced;\n\n\t\t/*\n\t\t * If the busiest group is more loaded, use imbalance_pct to be\n\t\t * conservative.\n\t\t */\n\t\tif (100 * busiest->avg_load <=\n\t\t\t\tenv->sd->imbalance_pct * local->avg_load)\n\t\t\tgoto out_balanced;\n\t}\n\n\t/* Try to move all excess tasks to child's sibling domain */\n\tif (sds.prefer_sibling && local->group_type == group_has_spare &&\n\t    busiest->sum_nr_running > local->sum_nr_running + 1)\n\t\tgoto force_balance;\n\n\tif (busiest->group_type != group_overloaded) {\n\t\tif (env->idle == CPU_NOT_IDLE)\n\t\t\t/*\n\t\t\t * If the busiest group is not overloaded (and as a\n\t\t\t * result the local one too) but this CPU is already\n\t\t\t * busy, let another idle CPU try to pull task.\n\t\t\t */\n\t\t\tgoto out_balanced;\n\n\t\tif (busiest->group_weight > 1 &&\n\t\t    local->idle_cpus <= (busiest->idle_cpus + 1))\n\t\t\t/*\n\t\t\t * If the busiest group is not overloaded\n\t\t\t * and there is no imbalance between this and busiest\n\t\t\t * group wrt idle CPUs, it is balanced. The imbalance\n\t\t\t * becomes significant if the diff is greater than 1\n\t\t\t * otherwise we might end up to just move the imbalance\n\t\t\t * on another group. Of course this applies only if\n\t\t\t * there is more than 1 CPU per group.\n\t\t\t */\n\t\t\tgoto out_balanced;\n\n\t\tif (busiest->sum_h_nr_running == 1)\n\t\t\t/*\n\t\t\t * busiest doesn't have any tasks waiting to run\n\t\t\t */\n\t\t\tgoto out_balanced;\n\t}\n\nforce_balance:\n\t/* Looks like there is an imbalance. Compute it */\n\tcalculate_imbalance(env, &sds);\n\treturn env->imbalance ? sds.busiest : NULL;\n\nout_balanced:\n\tenv->imbalance = 0;\n\treturn NULL;\n}\n\n/*\n * find_busiest_queue - find the busiest runqueue among the CPUs in the group.\n */\nstatic struct rq *find_busiest_queue(struct lb_env *env,\n\t\t\t\t     struct sched_group *group)\n{\n\tstruct rq *busiest = NULL, *rq;\n\tunsigned long busiest_util = 0, busiest_load = 0, busiest_capacity = 1;\n\tunsigned int busiest_nr = 0;\n\tint i;\n\n\tfor_each_cpu_and(i, sched_group_span(group), env->cpus) {\n\t\tunsigned long capacity, load, util;\n\t\tunsigned int nr_running;\n\t\tenum fbq_type rt;\n\n\t\trq = cpu_rq(i);\n\t\trt = fbq_classify_rq(rq);\n\n\t\t/*\n\t\t * We classify groups/runqueues into three groups:\n\t\t *  - regular: there are !numa tasks\n\t\t *  - remote:  there are numa tasks that run on the 'wrong' node\n\t\t *  - all:     there is no distinction\n\t\t *\n\t\t * In order to avoid migrating ideally placed numa tasks,\n\t\t * ignore those when there's better options.\n\t\t *\n\t\t * If we ignore the actual busiest queue to migrate another\n\t\t * task, the next balance pass can still reduce the busiest\n\t\t * queue by moving tasks around inside the node.\n\t\t *\n\t\t * If we cannot move enough load due to this classification\n\t\t * the next pass will adjust the group classification and\n\t\t * allow migration of more tasks.\n\t\t *\n\t\t * Both cases only affect the total convergence complexity.\n\t\t */\n\t\tif (rt > env->fbq_type)\n\t\t\tcontinue;\n\n\t\tnr_running = rq->cfs.h_nr_running;\n\t\tif (!nr_running)\n\t\t\tcontinue;\n\n\t\tcapacity = capacity_of(i);\n\n\t\t/*\n\t\t * For ASYM_CPUCAPACITY domains, don't pick a CPU that could\n\t\t * eventually lead to active_balancing high->low capacity.\n\t\t * Higher per-CPU capacity is considered better than balancing\n\t\t * average load.\n\t\t */\n\t\tif (env->sd->flags & SD_ASYM_CPUCAPACITY &&\n\t\t    capacity_of(env->dst_cpu) < capacity &&\n\t\t    nr_running == 1)\n\t\t\tcontinue;\n\n\t\tswitch (env->migration_type) {\n\t\tcase migrate_load:\n\t\t\t/*\n\t\t\t * When comparing with load imbalance, use cpu_load()\n\t\t\t * which is not scaled with the CPU capacity.\n\t\t\t */\n\t\t\tload = cpu_load(rq);\n\n\t\t\tif (nr_running == 1 && load > env->imbalance &&\n\t\t\t    !check_cpu_capacity(rq, env->sd))\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * For the load comparisons with the other CPUs,\n\t\t\t * consider the cpu_load() scaled with the CPU\n\t\t\t * capacity, so that the load can be moved away\n\t\t\t * from the CPU that is potentially running at a\n\t\t\t * lower capacity.\n\t\t\t *\n\t\t\t * Thus we're looking for max(load_i / capacity_i),\n\t\t\t * crosswise multiplication to rid ourselves of the\n\t\t\t * division works out to:\n\t\t\t * load_i * capacity_j > load_j * capacity_i;\n\t\t\t * where j is our previous maximum.\n\t\t\t */\n\t\t\tif (load * busiest_capacity > busiest_load * capacity) {\n\t\t\t\tbusiest_load = load;\n\t\t\t\tbusiest_capacity = capacity;\n\t\t\t\tbusiest = rq;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase migrate_util:\n\t\t\tutil = cpu_util(cpu_of(rq));\n\n\t\t\t/*\n\t\t\t * Don't try to pull utilization from a CPU with one\n\t\t\t * running task. Whatever its utilization, we will fail\n\t\t\t * detach the task.\n\t\t\t */\n\t\t\tif (nr_running <= 1)\n\t\t\t\tcontinue;\n\n\t\t\tif (busiest_util < util) {\n\t\t\t\tbusiest_util = util;\n\t\t\t\tbusiest = rq;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase migrate_task:\n\t\t\tif (busiest_nr < nr_running) {\n\t\t\t\tbusiest_nr = nr_running;\n\t\t\t\tbusiest = rq;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase migrate_misfit:\n\t\t\t/*\n\t\t\t * For ASYM_CPUCAPACITY domains with misfit tasks we\n\t\t\t * simply seek the \"biggest\" misfit task.\n\t\t\t */\n\t\t\tif (rq->misfit_task_load > busiest_load) {\n\t\t\t\tbusiest_load = rq->misfit_task_load;\n\t\t\t\tbusiest = rq;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\t}\n\n\treturn busiest;\n}\n\n/*\n * Max backoff if we encounter pinned tasks. Pretty arbitrary value, but\n * so long as it is large enough.\n */\n#define MAX_PINNED_INTERVAL\t512\n\nstatic inline bool\nasym_active_balance(struct lb_env *env)\n{\n\t/*\n\t * ASYM_PACKING needs to force migrate tasks from busy but\n\t * lower priority CPUs in order to pack all tasks in the\n\t * highest priority CPUs.\n\t */\n\treturn env->idle != CPU_NOT_IDLE && (env->sd->flags & SD_ASYM_PACKING) &&\n\t       sched_asym_prefer(env->dst_cpu, env->src_cpu);\n}\n\nstatic inline bool\nimbalanced_active_balance(struct lb_env *env)\n{\n\tstruct sched_domain *sd = env->sd;\n\n\t/*\n\t * The imbalanced case includes the case of pinned tasks preventing a fair\n\t * distribution of the load on the system but also the even distribution of the\n\t * threads on a system with spare capacity\n\t */\n\tif ((env->migration_type == migrate_task) &&\n\t    (sd->nr_balance_failed > sd->cache_nice_tries+2))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int need_active_balance(struct lb_env *env)\n{\n\tstruct sched_domain *sd = env->sd;\n\n\tif (asym_active_balance(env))\n\t\treturn 1;\n\n\tif (imbalanced_active_balance(env))\n\t\treturn 1;\n\n\t/*\n\t * The dst_cpu is idle and the src_cpu CPU has only 1 CFS task.\n\t * It's worth migrating the task if the src_cpu's capacity is reduced\n\t * because of other sched_class or IRQs if more capacity stays\n\t * available on dst_cpu.\n\t */\n\tif ((env->idle != CPU_NOT_IDLE) &&\n\t    (env->src_rq->cfs.h_nr_running == 1)) {\n\t\tif ((check_cpu_capacity(env->src_rq, sd)) &&\n\t\t    (capacity_of(env->src_cpu)*sd->imbalance_pct < capacity_of(env->dst_cpu)*100))\n\t\t\treturn 1;\n\t}\n\n\tif (env->migration_type == migrate_misfit)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int active_load_balance_cpu_stop(void *data);\n\nstatic int should_we_balance(struct lb_env *env)\n{\n\tstruct sched_group *sg = env->sd->groups;\n\tint cpu;\n\n\t/*\n\t * Ensure the balancing environment is consistent; can happen\n\t * when the softirq triggers 'during' hotplug.\n\t */\n\tif (!cpumask_test_cpu(env->dst_cpu, env->cpus))\n\t\treturn 0;\n\n\t/*\n\t * In the newly idle case, we will allow all the CPUs\n\t * to do the newly idle load balance.\n\t */\n\tif (env->idle == CPU_NEWLY_IDLE)\n\t\treturn 1;\n\n\t/* Try to find first idle CPU */\n\tfor_each_cpu_and(cpu, group_balance_mask(sg), env->cpus) {\n\t\tif (!idle_cpu(cpu))\n\t\t\tcontinue;\n\n\t\t/* Are we the first idle CPU? */\n\t\treturn cpu == env->dst_cpu;\n\t}\n\n\t/* Are we the first CPU of this group ? */\n\treturn group_balance_cpu(sg) == env->dst_cpu;\n}\n\n/*\n * Check this_cpu to ensure it is balanced within domain. Attempt to move\n * tasks if there is an imbalance.\n */\nstatic int load_balance(int this_cpu, struct rq *this_rq,\n\t\t\tstruct sched_domain *sd, enum cpu_idle_type idle,\n\t\t\tint *continue_balancing)\n{\n\tint ld_moved, cur_ld_moved, active_balance = 0;\n\tstruct sched_domain *sd_parent = sd->parent;\n\tstruct sched_group *group;\n\tstruct rq *busiest;\n\tstruct rq_flags rf;\n\tstruct cpumask *cpus = this_cpu_cpumask_var_ptr(load_balance_mask);\n\n\tstruct lb_env env = {\n\t\t.sd\t\t= sd,\n\t\t.dst_cpu\t= this_cpu,\n\t\t.dst_rq\t\t= this_rq,\n\t\t.dst_grpmask    = sched_group_span(sd->groups),\n\t\t.idle\t\t= idle,\n\t\t.loop_break\t= sched_nr_migrate_break,\n\t\t.cpus\t\t= cpus,\n\t\t.fbq_type\t= all,\n\t\t.tasks\t\t= LIST_HEAD_INIT(env.tasks),\n\t};\n\n\tcpumask_and(cpus, sched_domain_span(sd), cpu_active_mask);\n\n\tschedstat_inc(sd->lb_count[idle]);\n\nredo:\n\tif (!should_we_balance(&env)) {\n\t\t*continue_balancing = 0;\n\t\tgoto out_balanced;\n\t}\n\n\tgroup = find_busiest_group(&env);\n\tif (!group) {\n\t\tschedstat_inc(sd->lb_nobusyg[idle]);\n\t\tgoto out_balanced;\n\t}\n\n\tbusiest = find_busiest_queue(&env, group);\n\tif (!busiest) {\n\t\tschedstat_inc(sd->lb_nobusyq[idle]);\n\t\tgoto out_balanced;\n\t}\n\n\tBUG_ON(busiest == env.dst_rq);\n\n\tschedstat_add(sd->lb_imbalance[idle], env.imbalance);\n\n\tenv.src_cpu = busiest->cpu;\n\tenv.src_rq = busiest;\n\n\tld_moved = 0;\n\t/* Clear this flag as soon as we find a pullable task */\n\tenv.flags |= LBF_ALL_PINNED;\n\tif (busiest->nr_running > 1) {\n\t\t/*\n\t\t * Attempt to move tasks. If find_busiest_group has found\n\t\t * an imbalance but busiest->nr_running <= 1, the group is\n\t\t * still unbalanced. ld_moved simply stays zero, so it is\n\t\t * correctly treated as an imbalance.\n\t\t */\n\t\tenv.loop_max  = min(sysctl_sched_nr_migrate, busiest->nr_running);\n\nmore_balance:\n\t\trq_lock_irqsave(busiest, &rf);\n\t\tupdate_rq_clock(busiest);\n\n\t\t/*\n\t\t * cur_ld_moved - load moved in current iteration\n\t\t * ld_moved     - cumulative load moved across iterations\n\t\t */\n\t\tcur_ld_moved = detach_tasks(&env);\n\n\t\t/*\n\t\t * We've detached some tasks from busiest_rq. Every\n\t\t * task is masked \"TASK_ON_RQ_MIGRATING\", so we can safely\n\t\t * unlock busiest->lock, and we are able to be sure\n\t\t * that nobody can manipulate the tasks in parallel.\n\t\t * See task_rq_lock() family for the details.\n\t\t */\n\n\t\trq_unlock(busiest, &rf);\n\n\t\tif (cur_ld_moved) {\n\t\t\tattach_tasks(&env);\n\t\t\tld_moved += cur_ld_moved;\n\t\t}\n\n\t\tlocal_irq_restore(rf.flags);\n\n\t\tif (env.flags & LBF_NEED_BREAK) {\n\t\t\tenv.flags &= ~LBF_NEED_BREAK;\n\t\t\tgoto more_balance;\n\t\t}\n\n\t\t/*\n\t\t * Revisit (affine) tasks on src_cpu that couldn't be moved to\n\t\t * us and move them to an alternate dst_cpu in our sched_group\n\t\t * where they can run. The upper limit on how many times we\n\t\t * iterate on same src_cpu is dependent on number of CPUs in our\n\t\t * sched_group.\n\t\t *\n\t\t * This changes load balance semantics a bit on who can move\n\t\t * load to a given_cpu. In addition to the given_cpu itself\n\t\t * (or a ilb_cpu acting on its behalf where given_cpu is\n\t\t * nohz-idle), we now have balance_cpu in a position to move\n\t\t * load to given_cpu. In rare situations, this may cause\n\t\t * conflicts (balance_cpu and given_cpu/ilb_cpu deciding\n\t\t * _independently_ and at _same_ time to move some load to\n\t\t * given_cpu) causing exceess load to be moved to given_cpu.\n\t\t * This however should not happen so much in practice and\n\t\t * moreover subsequent load balance cycles should correct the\n\t\t * excess load moved.\n\t\t */\n\t\tif ((env.flags & LBF_DST_PINNED) && env.imbalance > 0) {\n\n\t\t\t/* Prevent to re-select dst_cpu via env's CPUs */\n\t\t\t__cpumask_clear_cpu(env.dst_cpu, env.cpus);\n\n\t\t\tenv.dst_rq\t = cpu_rq(env.new_dst_cpu);\n\t\t\tenv.dst_cpu\t = env.new_dst_cpu;\n\t\t\tenv.flags\t&= ~LBF_DST_PINNED;\n\t\t\tenv.loop\t = 0;\n\t\t\tenv.loop_break\t = sched_nr_migrate_break;\n\n\t\t\t/*\n\t\t\t * Go back to \"more_balance\" rather than \"redo\" since we\n\t\t\t * need to continue with same src_cpu.\n\t\t\t */\n\t\t\tgoto more_balance;\n\t\t}\n\n\t\t/*\n\t\t * We failed to reach balance because of affinity.\n\t\t */\n\t\tif (sd_parent) {\n\t\t\tint *group_imbalance = &sd_parent->groups->sgc->imbalance;\n\n\t\t\tif ((env.flags & LBF_SOME_PINNED) && env.imbalance > 0)\n\t\t\t\t*group_imbalance = 1;\n\t\t}\n\n\t\t/* All tasks on this runqueue were pinned by CPU affinity */\n\t\tif (unlikely(env.flags & LBF_ALL_PINNED)) {\n\t\t\t__cpumask_clear_cpu(cpu_of(busiest), cpus);\n\t\t\t/*\n\t\t\t * Attempting to continue load balancing at the current\n\t\t\t * sched_domain level only makes sense if there are\n\t\t\t * active CPUs remaining as possible busiest CPUs to\n\t\t\t * pull load from which are not contained within the\n\t\t\t * destination group that is receiving any migrated\n\t\t\t * load.\n\t\t\t */\n\t\t\tif (!cpumask_subset(cpus, env.dst_grpmask)) {\n\t\t\t\tenv.loop = 0;\n\t\t\t\tenv.loop_break = sched_nr_migrate_break;\n\t\t\t\tgoto redo;\n\t\t\t}\n\t\t\tgoto out_all_pinned;\n\t\t}\n\t}\n\n\tif (!ld_moved) {\n\t\tschedstat_inc(sd->lb_failed[idle]);\n\t\t/*\n\t\t * Increment the failure counter only on periodic balance.\n\t\t * We do not want newidle balance, which can be very\n\t\t * frequent, pollute the failure counter causing\n\t\t * excessive cache_hot migrations and active balances.\n\t\t */\n\t\tif (idle != CPU_NEWLY_IDLE)\n\t\t\tsd->nr_balance_failed++;\n\n\t\tif (need_active_balance(&env)) {\n\t\t\tunsigned long flags;\n\n\t\t\traw_spin_lock_irqsave(&busiest->lock, flags);\n\n\t\t\t/*\n\t\t\t * Don't kick the active_load_balance_cpu_stop,\n\t\t\t * if the curr task on busiest CPU can't be\n\t\t\t * moved to this_cpu:\n\t\t\t */\n\t\t\tif (!cpumask_test_cpu(this_cpu, busiest->curr->cpus_ptr)) {\n\t\t\t\traw_spin_unlock_irqrestore(&busiest->lock,\n\t\t\t\t\t\t\t    flags);\n\t\t\t\tgoto out_one_pinned;\n\t\t\t}\n\n\t\t\t/* Record that we found at least one task that could run on this_cpu */\n\t\t\tenv.flags &= ~LBF_ALL_PINNED;\n\n\t\t\t/*\n\t\t\t * ->active_balance synchronizes accesses to\n\t\t\t * ->active_balance_work.  Once set, it's cleared\n\t\t\t * only after active load balance is finished.\n\t\t\t */\n\t\t\tif (!busiest->active_balance) {\n\t\t\t\tbusiest->active_balance = 1;\n\t\t\t\tbusiest->push_cpu = this_cpu;\n\t\t\t\tactive_balance = 1;\n\t\t\t}\n\t\t\traw_spin_unlock_irqrestore(&busiest->lock, flags);\n\n\t\t\tif (active_balance) {\n\t\t\t\tstop_one_cpu_nowait(cpu_of(busiest),\n\t\t\t\t\tactive_load_balance_cpu_stop, busiest,\n\t\t\t\t\t&busiest->active_balance_work);\n\t\t\t}\n\n\t\t\t/* We've kicked active balancing, force task migration. */\n\t\t\tsd->nr_balance_failed = sd->cache_nice_tries+1;\n\t\t}\n\t} else {\n\t\tsd->nr_balance_failed = 0;\n\t}\n\n\tif (likely(!active_balance) || need_active_balance(&env)) {\n\t\t/* We were unbalanced, so reset the balancing interval */\n\t\tsd->balance_interval = sd->min_interval;\n\t}\n\n\tgoto out;\n\nout_balanced:\n\t/*\n\t * We reach balance although we may have faced some affinity\n\t * constraints. Clear the imbalance flag only if other tasks got\n\t * a chance to move and fix the imbalance.\n\t */\n\tif (sd_parent && !(env.flags & LBF_ALL_PINNED)) {\n\t\tint *group_imbalance = &sd_parent->groups->sgc->imbalance;\n\n\t\tif (*group_imbalance)\n\t\t\t*group_imbalance = 0;\n\t}\n\nout_all_pinned:\n\t/*\n\t * We reach balance because all tasks are pinned at this level so\n\t * we can't migrate them. Let the imbalance flag set so parent level\n\t * can try to migrate them.\n\t */\n\tschedstat_inc(sd->lb_balanced[idle]);\n\n\tsd->nr_balance_failed = 0;\n\nout_one_pinned:\n\tld_moved = 0;\n\n\t/*\n\t * newidle_balance() disregards balance intervals, so we could\n\t * repeatedly reach this code, which would lead to balance_interval\n\t * skyrocketting in a short amount of time. Skip the balance_interval\n\t * increase logic to avoid that.\n\t */\n\tif (env.idle == CPU_NEWLY_IDLE)\n\t\tgoto out;\n\n\t/* tune up the balancing interval */\n\tif ((env.flags & LBF_ALL_PINNED &&\n\t     sd->balance_interval < MAX_PINNED_INTERVAL) ||\n\t    sd->balance_interval < sd->max_interval)\n\t\tsd->balance_interval *= 2;\nout:\n\treturn ld_moved;\n}\n\nstatic inline unsigned long\nget_sd_balance_interval(struct sched_domain *sd, int cpu_busy)\n{\n\tunsigned long interval = sd->balance_interval;\n\n\tif (cpu_busy)\n\t\tinterval *= sd->busy_factor;\n\n\t/* scale ms to jiffies */\n\tinterval = msecs_to_jiffies(interval);\n\n\t/*\n\t * Reduce likelihood of busy balancing at higher domains racing with\n\t * balancing at lower domains by preventing their balancing periods\n\t * from being multiples of each other.\n\t */\n\tif (cpu_busy)\n\t\tinterval -= 1;\n\n\tinterval = clamp(interval, 1UL, max_load_balance_interval);\n\n\treturn interval;\n}\n\nstatic inline void\nupdate_next_balance(struct sched_domain *sd, unsigned long *next_balance)\n{\n\tunsigned long interval, next;\n\n\t/* used by idle balance, so cpu_busy = 0 */\n\tinterval = get_sd_balance_interval(sd, 0);\n\tnext = sd->last_balance + interval;\n\n\tif (time_after(*next_balance, next))\n\t\t*next_balance = next;\n}\n\n/*\n * active_load_balance_cpu_stop is run by the CPU stopper. It pushes\n * running tasks off the busiest CPU onto idle CPUs. It requires at\n * least 1 task to be running on each physical CPU where possible, and\n * avoids physical / logical imbalances.\n */\nstatic int active_load_balance_cpu_stop(void *data)\n{\n\tstruct rq *busiest_rq = data;\n\tint busiest_cpu = cpu_of(busiest_rq);\n\tint target_cpu = busiest_rq->push_cpu;\n\tstruct rq *target_rq = cpu_rq(target_cpu);\n\tstruct sched_domain *sd;\n\tstruct task_struct *p = NULL;\n\tstruct rq_flags rf;\n\n\trq_lock_irq(busiest_rq, &rf);\n\t/*\n\t * Between queueing the stop-work and running it is a hole in which\n\t * CPUs can become inactive. We should not move tasks from or to\n\t * inactive CPUs.\n\t */\n\tif (!cpu_active(busiest_cpu) || !cpu_active(target_cpu))\n\t\tgoto out_unlock;\n\n\t/* Make sure the requested CPU hasn't gone down in the meantime: */\n\tif (unlikely(busiest_cpu != smp_processor_id() ||\n\t\t     !busiest_rq->active_balance))\n\t\tgoto out_unlock;\n\n\t/* Is there any task to move? */\n\tif (busiest_rq->nr_running <= 1)\n\t\tgoto out_unlock;\n\n\t/*\n\t * This condition is \"impossible\", if it occurs\n\t * we need to fix it. Originally reported by\n\t * Bjorn Helgaas on a 128-CPU setup.\n\t */\n\tBUG_ON(busiest_rq == target_rq);\n\n\t/* Search for an sd spanning us and the target CPU. */\n\trcu_read_lock();\n\tfor_each_domain(target_cpu, sd) {\n\t\tif (cpumask_test_cpu(busiest_cpu, sched_domain_span(sd)))\n\t\t\tbreak;\n\t}\n\n\tif (likely(sd)) {\n\t\tstruct lb_env env = {\n\t\t\t.sd\t\t= sd,\n\t\t\t.dst_cpu\t= target_cpu,\n\t\t\t.dst_rq\t\t= target_rq,\n\t\t\t.src_cpu\t= busiest_rq->cpu,\n\t\t\t.src_rq\t\t= busiest_rq,\n\t\t\t.idle\t\t= CPU_IDLE,\n\t\t\t/*\n\t\t\t * can_migrate_task() doesn't need to compute new_dst_cpu\n\t\t\t * for active balancing. Since we have CPU_IDLE, but no\n\t\t\t * @dst_grpmask we need to make that test go away with lying\n\t\t\t * about DST_PINNED.\n\t\t\t */\n\t\t\t.flags\t\t= LBF_DST_PINNED,\n\t\t};\n\n\t\tschedstat_inc(sd->alb_count);\n\t\tupdate_rq_clock(busiest_rq);\n\n\t\tp = detach_one_task(&env);\n\t\tif (p) {\n\t\t\tschedstat_inc(sd->alb_pushed);\n\t\t\t/* Active balancing done, reset the failure counter. */\n\t\t\tsd->nr_balance_failed = 0;\n\t\t} else {\n\t\t\tschedstat_inc(sd->alb_failed);\n\t\t}\n\t}\n\trcu_read_unlock();\nout_unlock:\n\tbusiest_rq->active_balance = 0;\n\trq_unlock(busiest_rq, &rf);\n\n\tif (p)\n\t\tattach_one_task(target_rq, p);\n\n\tlocal_irq_enable();\n\n\treturn 0;\n}\n\nstatic DEFINE_SPINLOCK(balancing);\n\n/*\n * Scale the max load_balance interval with the number of CPUs in the system.\n * This trades load-balance latency on larger machines for less cross talk.\n */\nvoid update_max_interval(void)\n{\n\tmax_load_balance_interval = HZ*num_online_cpus()/10;\n}\n\n/*\n * It checks each scheduling domain to see if it is due to be balanced,\n * and initiates a balancing operation if so.\n *\n * Balancing parameters are set up in init_sched_domains.\n */\nstatic void rebalance_domains(struct rq *rq, enum cpu_idle_type idle)\n{\n\tint continue_balancing = 1;\n\tint cpu = rq->cpu;\n\tint busy = idle != CPU_IDLE && !sched_idle_cpu(cpu);\n\tunsigned long interval;\n\tstruct sched_domain *sd;\n\t/* Earliest time when we have to do rebalance again */\n\tunsigned long next_balance = jiffies + 60*HZ;\n\tint update_next_balance = 0;\n\tint need_serialize, need_decay = 0;\n\tu64 max_cost = 0;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\t/*\n\t\t * Decay the newidle max times here because this is a regular\n\t\t * visit to all the domains. Decay ~1% per second.\n\t\t */\n\t\tif (time_after(jiffies, sd->next_decay_max_lb_cost)) {\n\t\t\tsd->max_newidle_lb_cost =\n\t\t\t\t(sd->max_newidle_lb_cost * 253) / 256;\n\t\t\tsd->next_decay_max_lb_cost = jiffies + HZ;\n\t\t\tneed_decay = 1;\n\t\t}\n\t\tmax_cost += sd->max_newidle_lb_cost;\n\n\t\t/*\n\t\t * Stop the load balance at this level. There is another\n\t\t * CPU in our sched group which is doing load balancing more\n\t\t * actively.\n\t\t */\n\t\tif (!continue_balancing) {\n\t\t\tif (need_decay)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tinterval = get_sd_balance_interval(sd, busy);\n\n\t\tneed_serialize = sd->flags & SD_SERIALIZE;\n\t\tif (need_serialize) {\n\t\t\tif (!spin_trylock(&balancing))\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (time_after_eq(jiffies, sd->last_balance + interval)) {\n\t\t\tif (load_balance(cpu, rq, sd, idle, &continue_balancing)) {\n\t\t\t\t/*\n\t\t\t\t * The LBF_DST_PINNED logic could have changed\n\t\t\t\t * env->dst_cpu, so we can't know our idle\n\t\t\t\t * state even if we migrated tasks. Update it.\n\t\t\t\t */\n\t\t\t\tidle = idle_cpu(cpu) ? CPU_IDLE : CPU_NOT_IDLE;\n\t\t\t\tbusy = idle != CPU_IDLE && !sched_idle_cpu(cpu);\n\t\t\t}\n\t\t\tsd->last_balance = jiffies;\n\t\t\tinterval = get_sd_balance_interval(sd, busy);\n\t\t}\n\t\tif (need_serialize)\n\t\t\tspin_unlock(&balancing);\nout:\n\t\tif (time_after(next_balance, sd->last_balance + interval)) {\n\t\t\tnext_balance = sd->last_balance + interval;\n\t\t\tupdate_next_balance = 1;\n\t\t}\n\t}\n\tif (need_decay) {\n\t\t/*\n\t\t * Ensure the rq-wide value also decays but keep it at a\n\t\t * reasonable floor to avoid funnies with rq->avg_idle.\n\t\t */\n\t\trq->max_idle_balance_cost =\n\t\t\tmax((u64)sysctl_sched_migration_cost, max_cost);\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * next_balance will be updated only when there is a need.\n\t * When the cpu is attached to null domain for ex, it will not be\n\t * updated.\n\t */\n\tif (likely(update_next_balance)) {\n\t\trq->next_balance = next_balance;\n\n#ifdef CONFIG_NO_HZ_COMMON\n\t\t/*\n\t\t * If this CPU has been elected to perform the nohz idle\n\t\t * balance. Other idle CPUs have already rebalanced with\n\t\t * nohz_idle_balance() and nohz.next_balance has been\n\t\t * updated accordingly. This CPU is now running the idle load\n\t\t * balance for itself and we need to update the\n\t\t * nohz.next_balance accordingly.\n\t\t */\n\t\tif ((idle == CPU_IDLE) && time_after(nohz.next_balance, rq->next_balance))\n\t\t\tnohz.next_balance = rq->next_balance;\n#endif\n\t}\n}\n\nstatic inline int on_null_domain(struct rq *rq)\n{\n\treturn unlikely(!rcu_dereference_sched(rq->sd));\n}\n\n#ifdef CONFIG_NO_HZ_COMMON\n/*\n * idle load balancing details\n * - When one of the busy CPUs notice that there may be an idle rebalancing\n *   needed, they will kick the idle load balancer, which then does idle\n *   load balancing for all the idle CPUs.\n * - HK_FLAG_MISC CPUs are used for this task, because HK_FLAG_SCHED not set\n *   anywhere yet.\n */\n\nstatic inline int find_new_ilb(void)\n{\n\tint ilb;\n\n\tfor_each_cpu_and(ilb, nohz.idle_cpus_mask,\n\t\t\t      housekeeping_cpumask(HK_FLAG_MISC)) {\n\n\t\tif (ilb == smp_processor_id())\n\t\t\tcontinue;\n\n\t\tif (idle_cpu(ilb))\n\t\t\treturn ilb;\n\t}\n\n\treturn nr_cpu_ids;\n}\n\n/*\n * Kick a CPU to do the nohz balancing, if it is time for it. We pick any\n * idle CPU in the HK_FLAG_MISC housekeeping set (if there is one).\n */\nstatic void kick_ilb(unsigned int flags)\n{\n\tint ilb_cpu;\n\n\t/*\n\t * Increase nohz.next_balance only when if full ilb is triggered but\n\t * not if we only update stats.\n\t */\n\tif (flags & NOHZ_BALANCE_KICK)\n\t\tnohz.next_balance = jiffies+1;\n\n\tilb_cpu = find_new_ilb();\n\n\tif (ilb_cpu >= nr_cpu_ids)\n\t\treturn;\n\n\t/*\n\t * Access to rq::nohz_csd is serialized by NOHZ_KICK_MASK; he who sets\n\t * the first flag owns it; cleared by nohz_csd_func().\n\t */\n\tflags = atomic_fetch_or(flags, nohz_flags(ilb_cpu));\n\tif (flags & NOHZ_KICK_MASK)\n\t\treturn;\n\n\t/*\n\t * This way we generate an IPI on the target CPU which\n\t * is idle. And the softirq performing nohz idle load balance\n\t * will be run before returning from the IPI.\n\t */\n\tsmp_call_function_single_async(ilb_cpu, &cpu_rq(ilb_cpu)->nohz_csd);\n}\n\n/*\n * Current decision point for kicking the idle load balancer in the presence\n * of idle CPUs in the system.\n */\nstatic void nohz_balancer_kick(struct rq *rq)\n{\n\tunsigned long now = jiffies;\n\tstruct sched_domain_shared *sds;\n\tstruct sched_domain *sd;\n\tint nr_busy, i, cpu = rq->cpu;\n\tunsigned int flags = 0;\n\n\tif (unlikely(rq->idle_balance))\n\t\treturn;\n\n\t/*\n\t * We may be recently in ticked or tickless idle mode. At the first\n\t * busy tick after returning from idle, we will update the busy stats.\n\t */\n\tnohz_balance_exit_idle(rq);\n\n\t/*\n\t * None are in tickless mode and hence no need for NOHZ idle load\n\t * balancing.\n\t */\n\tif (likely(!atomic_read(&nohz.nr_cpus)))\n\t\treturn;\n\n\tif (READ_ONCE(nohz.has_blocked) &&\n\t    time_after(now, READ_ONCE(nohz.next_blocked)))\n\t\tflags = NOHZ_STATS_KICK;\n\n\tif (time_before(now, nohz.next_balance))\n\t\tgoto out;\n\n\tif (rq->nr_running >= 2) {\n\t\tflags = NOHZ_KICK_MASK;\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\n\tsd = rcu_dereference(rq->sd);\n\tif (sd) {\n\t\t/*\n\t\t * If there's a CFS task and the current CPU has reduced\n\t\t * capacity; kick the ILB to see if there's a better CPU to run\n\t\t * on.\n\t\t */\n\t\tif (rq->cfs.h_nr_running >= 1 && check_cpu_capacity(rq, sd)) {\n\t\t\tflags = NOHZ_KICK_MASK;\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tsd = rcu_dereference(per_cpu(sd_asym_packing, cpu));\n\tif (sd) {\n\t\t/*\n\t\t * When ASYM_PACKING; see if there's a more preferred CPU\n\t\t * currently idle; in which case, kick the ILB to move tasks\n\t\t * around.\n\t\t */\n\t\tfor_each_cpu_and(i, sched_domain_span(sd), nohz.idle_cpus_mask) {\n\t\t\tif (sched_asym_prefer(i, cpu)) {\n\t\t\t\tflags = NOHZ_KICK_MASK;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tsd = rcu_dereference(per_cpu(sd_asym_cpucapacity, cpu));\n\tif (sd) {\n\t\t/*\n\t\t * When ASYM_CPUCAPACITY; see if there's a higher capacity CPU\n\t\t * to run the misfit task on.\n\t\t */\n\t\tif (check_misfit_status(rq, sd)) {\n\t\t\tflags = NOHZ_KICK_MASK;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t/*\n\t\t * For asymmetric systems, we do not want to nicely balance\n\t\t * cache use, instead we want to embrace asymmetry and only\n\t\t * ensure tasks have enough CPU capacity.\n\t\t *\n\t\t * Skip the LLC logic because it's not relevant in that case.\n\t\t */\n\t\tgoto unlock;\n\t}\n\n\tsds = rcu_dereference(per_cpu(sd_llc_shared, cpu));\n\tif (sds) {\n\t\t/*\n\t\t * If there is an imbalance between LLC domains (IOW we could\n\t\t * increase the overall cache use), we need some less-loaded LLC\n\t\t * domain to pull some load. Likewise, we may need to spread\n\t\t * load within the current LLC domain (e.g. packed SMT cores but\n\t\t * other CPUs are idle). We can't really know from here how busy\n\t\t * the others are - so just get a nohz balance going if it looks\n\t\t * like this LLC domain has tasks we could move.\n\t\t */\n\t\tnr_busy = atomic_read(&sds->nr_busy_cpus);\n\t\tif (nr_busy > 1) {\n\t\t\tflags = NOHZ_KICK_MASK;\n\t\t\tgoto unlock;\n\t\t}\n\t}\nunlock:\n\trcu_read_unlock();\nout:\n\tif (flags)\n\t\tkick_ilb(flags);\n}\n\nstatic void set_cpu_sd_state_busy(int cpu)\n{\n\tstruct sched_domain *sd;\n\n\trcu_read_lock();\n\tsd = rcu_dereference(per_cpu(sd_llc, cpu));\n\n\tif (!sd || !sd->nohz_idle)\n\t\tgoto unlock;\n\tsd->nohz_idle = 0;\n\n\tatomic_inc(&sd->shared->nr_busy_cpus);\nunlock:\n\trcu_read_unlock();\n}\n\nvoid nohz_balance_exit_idle(struct rq *rq)\n{\n\tSCHED_WARN_ON(rq != this_rq());\n\n\tif (likely(!rq->nohz_tick_stopped))\n\t\treturn;\n\n\trq->nohz_tick_stopped = 0;\n\tcpumask_clear_cpu(rq->cpu, nohz.idle_cpus_mask);\n\tatomic_dec(&nohz.nr_cpus);\n\n\tset_cpu_sd_state_busy(rq->cpu);\n}\n\nstatic void set_cpu_sd_state_idle(int cpu)\n{\n\tstruct sched_domain *sd;\n\n\trcu_read_lock();\n\tsd = rcu_dereference(per_cpu(sd_llc, cpu));\n\n\tif (!sd || sd->nohz_idle)\n\t\tgoto unlock;\n\tsd->nohz_idle = 1;\n\n\tatomic_dec(&sd->shared->nr_busy_cpus);\nunlock:\n\trcu_read_unlock();\n}\n\n/*\n * This routine will record that the CPU is going idle with tick stopped.\n * This info will be used in performing idle load balancing in the future.\n */\nvoid nohz_balance_enter_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tSCHED_WARN_ON(cpu != smp_processor_id());\n\n\t/* If this CPU is going down, then nothing needs to be done: */\n\tif (!cpu_active(cpu))\n\t\treturn;\n\n\t/* Spare idle load balancing on CPUs that don't want to be disturbed: */\n\tif (!housekeeping_cpu(cpu, HK_FLAG_SCHED))\n\t\treturn;\n\n\t/*\n\t * Can be set safely without rq->lock held\n\t * If a clear happens, it will have evaluated last additions because\n\t * rq->lock is held during the check and the clear\n\t */\n\trq->has_blocked_load = 1;\n\n\t/*\n\t * The tick is still stopped but load could have been added in the\n\t * meantime. We set the nohz.has_blocked flag to trig a check of the\n\t * *_avg. The CPU is already part of nohz.idle_cpus_mask so the clear\n\t * of nohz.has_blocked can only happen after checking the new load\n\t */\n\tif (rq->nohz_tick_stopped)\n\t\tgoto out;\n\n\t/* If we're a completely isolated CPU, we don't play: */\n\tif (on_null_domain(rq))\n\t\treturn;\n\n\trq->nohz_tick_stopped = 1;\n\n\tcpumask_set_cpu(cpu, nohz.idle_cpus_mask);\n\tatomic_inc(&nohz.nr_cpus);\n\n\t/*\n\t * Ensures that if nohz_idle_balance() fails to observe our\n\t * @idle_cpus_mask store, it must observe the @has_blocked\n\t * store.\n\t */\n\tsmp_mb__after_atomic();\n\n\tset_cpu_sd_state_idle(cpu);\n\nout:\n\t/*\n\t * Each time a cpu enter idle, we assume that it has blocked load and\n\t * enable the periodic update of the load of idle cpus\n\t */\n\tWRITE_ONCE(nohz.has_blocked, 1);\n}\n\n/*\n * Internal function that runs load balance for all idle cpus. The load balance\n * can be a simple update of blocked load or a complete load balance with\n * tasks movement depending of flags.\n * The function returns false if the loop has stopped before running\n * through all idle CPUs.\n */\nstatic bool _nohz_idle_balance(struct rq *this_rq, unsigned int flags,\n\t\t\t       enum cpu_idle_type idle)\n{\n\t/* Earliest time when we have to do rebalance again */\n\tunsigned long now = jiffies;\n\tunsigned long next_balance = now + 60*HZ;\n\tbool has_blocked_load = false;\n\tint update_next_balance = 0;\n\tint this_cpu = this_rq->cpu;\n\tint balance_cpu;\n\tint ret = false;\n\tstruct rq *rq;\n\n\tSCHED_WARN_ON((flags & NOHZ_KICK_MASK) == NOHZ_BALANCE_KICK);\n\n\t/*\n\t * We assume there will be no idle load after this update and clear\n\t * the has_blocked flag. If a cpu enters idle in the mean time, it will\n\t * set the has_blocked flag and trig another update of idle load.\n\t * Because a cpu that becomes idle, is added to idle_cpus_mask before\n\t * setting the flag, we are sure to not clear the state and not\n\t * check the load of an idle cpu.\n\t */\n\tWRITE_ONCE(nohz.has_blocked, 0);\n\n\t/*\n\t * Ensures that if we miss the CPU, we must see the has_blocked\n\t * store from nohz_balance_enter_idle().\n\t */\n\tsmp_mb();\n\n\tfor_each_cpu(balance_cpu, nohz.idle_cpus_mask) {\n\t\tif (balance_cpu == this_cpu || !idle_cpu(balance_cpu))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If this CPU gets work to do, stop the load balancing\n\t\t * work being done for other CPUs. Next load\n\t\t * balancing owner will pick it up.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\thas_blocked_load = true;\n\t\t\tgoto abort;\n\t\t}\n\n\t\trq = cpu_rq(balance_cpu);\n\n\t\thas_blocked_load |= update_nohz_stats(rq, true);\n\n\t\t/*\n\t\t * If time for next balance is due,\n\t\t * do the balance.\n\t\t */\n\t\tif (time_after_eq(jiffies, rq->next_balance)) {\n\t\t\tstruct rq_flags rf;\n\n\t\t\trq_lock_irqsave(rq, &rf);\n\t\t\tupdate_rq_clock(rq);\n\t\t\trq_unlock_irqrestore(rq, &rf);\n\n\t\t\tif (flags & NOHZ_BALANCE_KICK)\n\t\t\t\trebalance_domains(rq, CPU_IDLE);\n\t\t}\n\n\t\tif (time_after(next_balance, rq->next_balance)) {\n\t\t\tnext_balance = rq->next_balance;\n\t\t\tupdate_next_balance = 1;\n\t\t}\n\t}\n\n\t/*\n\t * next_balance will be updated only when there is a need.\n\t * When the CPU is attached to null domain for ex, it will not be\n\t * updated.\n\t */\n\tif (likely(update_next_balance))\n\t\tnohz.next_balance = next_balance;\n\n\t/* Newly idle CPU doesn't need an update */\n\tif (idle != CPU_NEWLY_IDLE) {\n\t\tupdate_blocked_averages(this_cpu);\n\t\thas_blocked_load |= this_rq->has_blocked_load;\n\t}\n\n\tif (flags & NOHZ_BALANCE_KICK)\n\t\trebalance_domains(this_rq, CPU_IDLE);\n\n\tWRITE_ONCE(nohz.next_blocked,\n\t\tnow + msecs_to_jiffies(LOAD_AVG_PERIOD));\n\n\t/* The full idle balance loop has been done */\n\tret = true;\n\nabort:\n\t/* There is still blocked load, enable periodic update */\n\tif (has_blocked_load)\n\t\tWRITE_ONCE(nohz.has_blocked, 1);\n\n\treturn ret;\n}\n\n/*\n * In CONFIG_NO_HZ_COMMON case, the idle balance kickee will do the\n * rebalancing for all the cpus for whom scheduler ticks are stopped.\n */\nstatic bool nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle)\n{\n\tunsigned int flags = this_rq->nohz_idle_balance;\n\n\tif (!flags)\n\t\treturn false;\n\n\tthis_rq->nohz_idle_balance = 0;\n\n\tif (idle != CPU_IDLE)\n\t\treturn false;\n\n\t_nohz_idle_balance(this_rq, flags, idle);\n\n\treturn true;\n}\n\nstatic void nohz_newidle_balance(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu;\n\n\t/*\n\t * This CPU doesn't want to be disturbed by scheduler\n\t * housekeeping\n\t */\n\tif (!housekeeping_cpu(this_cpu, HK_FLAG_SCHED))\n\t\treturn;\n\n\t/* Will wake up very soon. No time for doing anything else*/\n\tif (this_rq->avg_idle < sysctl_sched_migration_cost)\n\t\treturn;\n\n\t/* Don't need to update blocked load of idle CPUs*/\n\tif (!READ_ONCE(nohz.has_blocked) ||\n\t    time_before(jiffies, READ_ONCE(nohz.next_blocked)))\n\t\treturn;\n\n\traw_spin_unlock(&this_rq->lock);\n\t/*\n\t * This CPU is going to be idle and blocked load of idle CPUs\n\t * need to be updated. Run the ilb locally as it is a good\n\t * candidate for ilb instead of waking up another idle CPU.\n\t * Kick an normal ilb if we failed to do the update.\n\t */\n\tif (!_nohz_idle_balance(this_rq, NOHZ_STATS_KICK, CPU_NEWLY_IDLE))\n\t\tkick_ilb(NOHZ_STATS_KICK);\n\traw_spin_lock(&this_rq->lock);\n}\n\n#else /* !CONFIG_NO_HZ_COMMON */\nstatic inline void nohz_balancer_kick(struct rq *rq) { }\n\nstatic inline bool nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle)\n{\n\treturn false;\n}\n\nstatic inline void nohz_newidle_balance(struct rq *this_rq) { }\n#endif /* CONFIG_NO_HZ_COMMON */\n\n/*\n * newidle_balance is called by schedule() if this_cpu is about to become\n * idle. Attempts to pull tasks from other CPUs.\n *\n * Returns:\n *   < 0 - we released the lock and there are !fair tasks present\n *     0 - failed, no new tasks\n *   > 0 - success, new (fair) tasks present\n */\nstatic int newidle_balance(struct rq *this_rq, struct rq_flags *rf)\n{\n\tunsigned long next_balance = jiffies + HZ;\n\tint this_cpu = this_rq->cpu;\n\tstruct sched_domain *sd;\n\tint pulled_task = 0;\n\tu64 curr_cost = 0;\n\n\tupdate_misfit_status(NULL, this_rq);\n\t/*\n\t * We must set idle_stamp _before_ calling idle_balance(), such that we\n\t * measure the duration of idle_balance() as idle time.\n\t */\n\tthis_rq->idle_stamp = rq_clock(this_rq);\n\n\t/*\n\t * Do not pull tasks towards !active CPUs...\n\t */\n\tif (!cpu_active(this_cpu))\n\t\treturn 0;\n\n\t/*\n\t * This is OK, because current is on_cpu, which avoids it being picked\n\t * for load-balance and preemption/IRQs are still disabled avoiding\n\t * further scheduler activity on it and we're being very careful to\n\t * re-start the picking loop.\n\t */\n\trq_unpin_lock(this_rq, rf);\n\n\tif (this_rq->avg_idle < sysctl_sched_migration_cost ||\n\t    !READ_ONCE(this_rq->rd->overload)) {\n\n\t\trcu_read_lock();\n\t\tsd = rcu_dereference_check_sched_domain(this_rq->sd);\n\t\tif (sd)\n\t\t\tupdate_next_balance(sd, &next_balance);\n\t\trcu_read_unlock();\n\n\t\tnohz_newidle_balance(this_rq);\n\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock(&this_rq->lock);\n\n\tupdate_blocked_averages(this_cpu);\n\trcu_read_lock();\n\tfor_each_domain(this_cpu, sd) {\n\t\tint continue_balancing = 1;\n\t\tu64 t0, domain_cost;\n\n\t\tif (this_rq->avg_idle < curr_cost + sd->max_newidle_lb_cost) {\n\t\t\tupdate_next_balance(sd, &next_balance);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sd->flags & SD_BALANCE_NEWIDLE) {\n\t\t\tt0 = sched_clock_cpu(this_cpu);\n\n\t\t\tpulled_task = load_balance(this_cpu, this_rq,\n\t\t\t\t\t\t   sd, CPU_NEWLY_IDLE,\n\t\t\t\t\t\t   &continue_balancing);\n\n\t\t\tdomain_cost = sched_clock_cpu(this_cpu) - t0;\n\t\t\tif (domain_cost > sd->max_newidle_lb_cost)\n\t\t\t\tsd->max_newidle_lb_cost = domain_cost;\n\n\t\t\tcurr_cost += domain_cost;\n\t\t}\n\n\t\tupdate_next_balance(sd, &next_balance);\n\n\t\t/*\n\t\t * Stop searching for tasks to pull if there are\n\t\t * now runnable tasks on this rq.\n\t\t */\n\t\tif (pulled_task || this_rq->nr_running > 0)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\traw_spin_lock(&this_rq->lock);\n\n\tif (curr_cost > this_rq->max_idle_balance_cost)\n\t\tthis_rq->max_idle_balance_cost = curr_cost;\n\nout:\n\t/*\n\t * While browsing the domains, we released the rq lock, a task could\n\t * have been enqueued in the meantime. Since we're not going idle,\n\t * pretend we pulled a task.\n\t */\n\tif (this_rq->cfs.h_nr_running && !pulled_task)\n\t\tpulled_task = 1;\n\n\t/* Move the next balance forward */\n\tif (time_after(this_rq->next_balance, next_balance))\n\t\tthis_rq->next_balance = next_balance;\n\n\t/* Is there a task of a high priority class? */\n\tif (this_rq->nr_running != this_rq->cfs.h_nr_running)\n\t\tpulled_task = -1;\n\n\tif (pulled_task)\n\t\tthis_rq->idle_stamp = 0;\n\n\trq_repin_lock(this_rq, rf);\n\n\treturn pulled_task;\n}\n\n/*\n * run_rebalance_domains is triggered when needed from the scheduler tick.\n * Also triggered for nohz idle balancing (with nohz_balancing_kick set).\n */\nstatic __latent_entropy void run_rebalance_domains(struct softirq_action *h)\n{\n\tstruct rq *this_rq = this_rq();\n\tenum cpu_idle_type idle = this_rq->idle_balance ?\n\t\t\t\t\t\tCPU_IDLE : CPU_NOT_IDLE;\n\n\t/*\n\t * If this CPU has a pending nohz_balance_kick, then do the\n\t * balancing on behalf of the other idle CPUs whose ticks are\n\t * stopped. Do nohz_idle_balance *before* rebalance_domains to\n\t * give the idle CPUs a chance to load balance. Else we may\n\t * load balance only within the local sched_domain hierarchy\n\t * and abort nohz_idle_balance altogether if we pull some load.\n\t */\n\tif (nohz_idle_balance(this_rq, idle))\n\t\treturn;\n\n\t/* normal load balance */\n\tupdate_blocked_averages(this_rq->cpu);\n\trebalance_domains(this_rq, idle);\n}\n\n/*\n * Trigger the SCHED_SOFTIRQ if it is time to do periodic load balancing.\n */\nvoid trigger_load_balance(struct rq *rq)\n{\n\t/*\n\t * Don't need to rebalance while attached to NULL domain or\n\t * runqueue CPU is not active\n\t */\n\tif (unlikely(on_null_domain(rq) || !cpu_active(cpu_of(rq))))\n\t\treturn;\n\n\tif (time_after_eq(jiffies, rq->next_balance))\n\t\traise_softirq(SCHED_SOFTIRQ);\n\n\tnohz_balancer_kick(rq);\n}\n\nstatic void rq_online_fair(struct rq *rq)\n{\n\tupdate_sysctl();\n\n\tupdate_runtime_enabled(rq);\n}\n\nstatic void rq_offline_fair(struct rq *rq)\n{\n\tupdate_sysctl();\n\n\t/* Ensure any throttled groups are reachable by pick_next_task */\n\tunthrottle_offline_cfs_rqs(rq);\n}\n\n#endif /* CONFIG_SMP */\n\n/*\n * scheduler tick hitting a task of our scheduling class.\n *\n * NOTE: This function can be called remotely by the tick offload that\n * goes along full dynticks. Therefore no local assumption can be made\n * and everything must be accessed through the @rq and @curr passed in\n * parameters.\n */\nstatic void task_tick_fair(struct rq *rq, struct task_struct *curr, int queued)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &curr->se;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\t\tentity_tick(cfs_rq, se, queued);\n\t}\n\n\tif (static_branch_unlikely(&sched_numa_balancing))\n\t\ttask_tick_numa(rq, curr);\n\n\tupdate_misfit_status(curr, rq);\n\tupdate_overutilized_status(task_rq(curr));\n}\n\n/*\n * called on fork with the child task as argument from the parent's context\n *  - child not yet on the tasklist\n *  - preemption disabled\n */\nstatic void task_fork_fair(struct task_struct *p)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->se, *curr;\n\tstruct rq *rq = this_rq();\n\tstruct rq_flags rf;\n\n\trq_lock(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tcfs_rq = task_cfs_rq(current);\n\tcurr = cfs_rq->curr;\n\tif (curr) {\n\t\tupdate_curr(cfs_rq);\n\t\tse->vruntime = curr->vruntime;\n\t}\n\tplace_entity(cfs_rq, se, 1);\n\n\tif (sysctl_sched_child_runs_first && curr && entity_before(curr, se)) {\n\t\t/*\n\t\t * Upon rescheduling, sched_class::put_prev_task() will place\n\t\t * 'current' within the tree based on its new key value.\n\t\t */\n\t\tswap(curr->vruntime, se->vruntime);\n\t\tresched_curr(rq);\n\t}\n\n\tse->vruntime -= cfs_rq->min_vruntime;\n\trq_unlock(rq, &rf);\n}\n\n/*\n * Priority of the task has changed. Check to see if we preempt\n * the current task.\n */\nstatic void\nprio_changed_fair(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tif (!task_on_rq_queued(p))\n\t\treturn;\n\n\tif (rq->cfs.nr_running == 1)\n\t\treturn;\n\n\t/*\n\t * Reschedule if we are currently running on this runqueue and\n\t * our priority decreased, or if we are not currently running on\n\t * this runqueue and our priority is higher than the current's\n\t */\n\tif (task_current(rq, p)) {\n\t\tif (p->prio > oldprio)\n\t\t\tresched_curr(rq);\n\t} else\n\t\tcheck_preempt_curr(rq, p, 0);\n}\n\nstatic inline bool vruntime_normalized(struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\n\t/*\n\t * In both the TASK_ON_RQ_QUEUED and TASK_ON_RQ_MIGRATING cases,\n\t * the dequeue_entity(.flags=0) will already have normalized the\n\t * vruntime.\n\t */\n\tif (p->on_rq)\n\t\treturn true;\n\n\t/*\n\t * When !on_rq, vruntime of the task has usually NOT been normalized.\n\t * But there are some cases where it has already been normalized:\n\t *\n\t * - A forked child which is waiting for being woken up by\n\t *   wake_up_new_task().\n\t * - A task which has been woken up by try_to_wake_up() and\n\t *   waiting for actually being woken up by sched_ttwu_pending().\n\t */\n\tif (!se->sum_exec_runtime ||\n\t    (p->state == TASK_WAKING && p->sched_remote_wakeup))\n\t\treturn true;\n\n\treturn false;\n}\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n/*\n * Propagate the changes of the sched_entity across the tg tree to make it\n * visible to the root\n */\nstatic void propagate_entity_cfs_rq(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq;\n\n\t/* Start to propagate at parent */\n\tse = se->parent;\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tif (cfs_rq_throttled(cfs_rq))\n\t\t\tbreak;\n\n\t\tupdate_load_avg(cfs_rq, se, UPDATE_TG);\n\t}\n}\n#else\nstatic void propagate_entity_cfs_rq(struct sched_entity *se) { }\n#endif\n\nstatic void detach_entity_cfs_rq(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n\t/* Catch up with the cfs_rq and remove our load when we leave */\n\tupdate_load_avg(cfs_rq, se, 0);\n\tdetach_entity_load_avg(cfs_rq, se);\n\tupdate_tg_load_avg(cfs_rq);\n\tpropagate_entity_cfs_rq(se);\n}\n\nstatic void attach_entity_cfs_rq(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t/*\n\t * Since the real-depth could have been changed (only FAIR\n\t * class maintain depth value), reset depth properly.\n\t */\n\tse->depth = se->parent ? se->parent->depth + 1 : 0;\n#endif\n\n\t/* Synchronize entity with its cfs_rq */\n\tupdate_load_avg(cfs_rq, se, sched_feat(ATTACH_AGE_LOAD) ? 0 : SKIP_AGE_LOAD);\n\tattach_entity_load_avg(cfs_rq, se);\n\tupdate_tg_load_avg(cfs_rq);\n\tpropagate_entity_cfs_rq(se);\n}\n\nstatic void detach_task_cfs_rq(struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n\tif (!vruntime_normalized(p)) {\n\t\t/*\n\t\t * Fix up our vruntime so that the current sleep doesn't\n\t\t * cause 'unlimited' sleep bonus.\n\t\t */\n\t\tplace_entity(cfs_rq, se, 0);\n\t\tse->vruntime -= cfs_rq->min_vruntime;\n\t}\n\n\tdetach_entity_cfs_rq(se);\n}\n\nstatic void attach_task_cfs_rq(struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n\tattach_entity_cfs_rq(se);\n\n\tif (!vruntime_normalized(p))\n\t\tse->vruntime += cfs_rq->min_vruntime;\n}\n\nstatic void switched_from_fair(struct rq *rq, struct task_struct *p)\n{\n\tdetach_task_cfs_rq(p);\n}\n\nstatic void switched_to_fair(struct rq *rq, struct task_struct *p)\n{\n\tattach_task_cfs_rq(p);\n\n\tif (task_on_rq_queued(p)) {\n\t\t/*\n\t\t * We were most likely switched from sched_rt, so\n\t\t * kick off the schedule if running, otherwise just see\n\t\t * if we can still preempt the current task.\n\t\t */\n\t\tif (task_current(rq, p))\n\t\t\tresched_curr(rq);\n\t\telse\n\t\t\tcheck_preempt_curr(rq, p, 0);\n\t}\n}\n\n/* Account for a task changing its policy or group.\n *\n * This routine is mostly called to set cfs_rq->curr field when a task\n * migrates between groups/classes.\n */\nstatic void set_next_task_fair(struct rq *rq, struct task_struct *p, bool first)\n{\n\tstruct sched_entity *se = &p->se;\n\n#ifdef CONFIG_SMP\n\tif (task_on_rq_queued(p)) {\n\t\t/*\n\t\t * Move the next running task to the front of the list, so our\n\t\t * cfs_tasks list becomes MRU one.\n\t\t */\n\t\tlist_move(&se->group_node, &rq->cfs_tasks);\n\t}\n#endif\n\n\tfor_each_sched_entity(se) {\n\t\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n\t\tset_next_entity(cfs_rq, se);\n\t\t/* ensure bandwidth has been allocated on our new cfs_rq */\n\t\taccount_cfs_rq_runtime(cfs_rq, 0);\n\t}\n}\n\nvoid init_cfs_rq(struct cfs_rq *cfs_rq)\n{\n\tcfs_rq->tasks_timeline = RB_ROOT_CACHED;\n\tcfs_rq->min_vruntime = (u64)(-(1LL << 20));\n#ifndef CONFIG_64BIT\n\tcfs_rq->min_vruntime_copy = cfs_rq->min_vruntime;\n#endif\n#ifdef CONFIG_SMP\n\traw_spin_lock_init(&cfs_rq->removed.lock);\n#endif\n}\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\nstatic void task_set_group_fair(struct task_struct *p)\n{\n\tstruct sched_entity *se = &p->se;\n\n\tset_task_rq(p, task_cpu(p));\n\tse->depth = se->parent ? se->parent->depth + 1 : 0;\n}\n\nstatic void task_move_group_fair(struct task_struct *p)\n{\n\tdetach_task_cfs_rq(p);\n\tset_task_rq(p, task_cpu(p));\n\n#ifdef CONFIG_SMP\n\t/* Tell se's cfs_rq has been changed -- migrated */\n\tp->se.avg.last_update_time = 0;\n#endif\n\tattach_task_cfs_rq(p);\n}\n\nstatic void task_change_group_fair(struct task_struct *p, int type)\n{\n\tswitch (type) {\n\tcase TASK_SET_GROUP:\n\t\ttask_set_group_fair(p);\n\t\tbreak;\n\n\tcase TASK_MOVE_GROUP:\n\t\ttask_move_group_fair(p);\n\t\tbreak;\n\t}\n}\n\nvoid free_fair_sched_group(struct task_group *tg)\n{\n\tint i;\n\n\tdestroy_cfs_bandwidth(tg_cfs_bandwidth(tg));\n\n\tfor_each_possible_cpu(i) {\n\t\tif (tg->cfs_rq)\n\t\t\tkfree(tg->cfs_rq[i]);\n\t\tif (tg->se)\n\t\t\tkfree(tg->se[i]);\n\t}\n\n\tkfree(tg->cfs_rq);\n\tkfree(tg->se);\n}\n\nint alloc_fair_sched_group(struct task_group *tg, struct task_group *parent)\n{\n\tstruct sched_entity *se;\n\tstruct cfs_rq *cfs_rq;\n\tint i;\n\n\ttg->cfs_rq = kcalloc(nr_cpu_ids, sizeof(cfs_rq), GFP_KERNEL);\n\tif (!tg->cfs_rq)\n\t\tgoto err;\n\ttg->se = kcalloc(nr_cpu_ids, sizeof(se), GFP_KERNEL);\n\tif (!tg->se)\n\t\tgoto err;\n\n\ttg->shares = NICE_0_LOAD;\n\n\tinit_cfs_bandwidth(tg_cfs_bandwidth(tg));\n\n\tfor_each_possible_cpu(i) {\n\t\tcfs_rq = kzalloc_node(sizeof(struct cfs_rq),\n\t\t\t\t      GFP_KERNEL, cpu_to_node(i));\n\t\tif (!cfs_rq)\n\t\t\tgoto err;\n\n\t\tse = kzalloc_node(sizeof(struct sched_entity),\n\t\t\t\t  GFP_KERNEL, cpu_to_node(i));\n\t\tif (!se)\n\t\t\tgoto err_free_rq;\n\n\t\tinit_cfs_rq(cfs_rq);\n\t\tinit_tg_cfs_entry(tg, cfs_rq, se, i, parent->se[i]);\n\t\tinit_entity_runnable_average(se);\n\t}\n\n\treturn 1;\n\nerr_free_rq:\n\tkfree(cfs_rq);\nerr:\n\treturn 0;\n}\n\nvoid online_fair_sched_group(struct task_group *tg)\n{\n\tstruct sched_entity *se;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\trq = cpu_rq(i);\n\t\tse = tg->se[i];\n\t\trq_lock_irq(rq, &rf);\n\t\tupdate_rq_clock(rq);\n\t\tattach_entity_cfs_rq(se);\n\t\tsync_throttle(tg, i);\n\t\trq_unlock_irq(rq, &rf);\n\t}\n}\n\nvoid unregister_fair_sched_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\tstruct rq *rq;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (tg->se[cpu])\n\t\t\tremove_entity_load_avg(tg->se[cpu]);\n\n\t\t/*\n\t\t * Only empty task groups can be destroyed; so we can speculatively\n\t\t * check on_list without danger of it being re-added.\n\t\t */\n\t\tif (!tg->cfs_rq[cpu]->on_list)\n\t\t\tcontinue;\n\n\t\trq = cpu_rq(cpu);\n\n\t\traw_spin_lock_irqsave(&rq->lock, flags);\n\t\tlist_del_leaf_cfs_rq(tg->cfs_rq[cpu]);\n\t\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\t}\n}\n\nvoid init_tg_cfs_entry(struct task_group *tg, struct cfs_rq *cfs_rq,\n\t\t\tstruct sched_entity *se, int cpu,\n\t\t\tstruct sched_entity *parent)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tcfs_rq->tg = tg;\n\tcfs_rq->rq = rq;\n\tinit_cfs_rq_runtime(cfs_rq);\n\n\ttg->cfs_rq[cpu] = cfs_rq;\n\ttg->se[cpu] = se;\n\n\t/* se could be NULL for root_task_group */\n\tif (!se)\n\t\treturn;\n\n\tif (!parent) {\n\t\tse->cfs_rq = &rq->cfs;\n\t\tse->depth = 0;\n\t} else {\n\t\tse->cfs_rq = parent->my_q;\n\t\tse->depth = parent->depth + 1;\n\t}\n\n\tse->my_q = cfs_rq;\n\t/* guarantee group entities always have weight */\n\tupdate_load_set(&se->load, NICE_0_LOAD);\n\tse->parent = parent;\n}\n\nstatic DEFINE_MUTEX(shares_mutex);\n\nint sched_group_set_shares(struct task_group *tg, unsigned long shares)\n{\n\tint i;\n\n\t/*\n\t * We can't change the weight of the root cgroup.\n\t */\n\tif (!tg->se[0])\n\t\treturn -EINVAL;\n\n\tshares = clamp(shares, scale_load(MIN_SHARES), scale_load(MAX_SHARES));\n\n\tmutex_lock(&shares_mutex);\n\tif (tg->shares == shares)\n\t\tgoto done;\n\n\ttg->shares = shares;\n\tfor_each_possible_cpu(i) {\n\t\tstruct rq *rq = cpu_rq(i);\n\t\tstruct sched_entity *se = tg->se[i];\n\t\tstruct rq_flags rf;\n\n\t\t/* Propagate contribution to hierarchy */\n\t\trq_lock_irqsave(rq, &rf);\n\t\tupdate_rq_clock(rq);\n\t\tfor_each_sched_entity(se) {\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, UPDATE_TG);\n\t\t\tupdate_cfs_group(se);\n\t\t}\n\t\trq_unlock_irqrestore(rq, &rf);\n\t}\n\ndone:\n\tmutex_unlock(&shares_mutex);\n\treturn 0;\n}\n#else /* CONFIG_FAIR_GROUP_SCHED */\n\nvoid free_fair_sched_group(struct task_group *tg) { }\n\nint alloc_fair_sched_group(struct task_group *tg, struct task_group *parent)\n{\n\treturn 1;\n}\n\nvoid online_fair_sched_group(struct task_group *tg) { }\n\nvoid unregister_fair_sched_group(struct task_group *tg) { }\n\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n\nstatic unsigned int get_rr_interval_fair(struct rq *rq, struct task_struct *task)\n{\n\tstruct sched_entity *se = &task->se;\n\tunsigned int rr_interval = 0;\n\n\t/*\n\t * Time slice is 0 for SCHED_OTHER tasks that are on an otherwise\n\t * idle runqueue:\n\t */\n\tif (rq->cfs.load.weight)\n\t\trr_interval = NS_TO_JIFFIES(sched_slice(cfs_rq_of(se), se));\n\n\treturn rr_interval;\n}\n\n/*\n * All the scheduling class methods:\n */\nDEFINE_SCHED_CLASS(fair) = {\n\n\t.enqueue_task\t\t= enqueue_task_fair,\n\t.dequeue_task\t\t= dequeue_task_fair,\n\t.yield_task\t\t= yield_task_fair,\n\t.yield_to_task\t\t= yield_to_task_fair,\n\n\t.check_preempt_curr\t= check_preempt_wakeup,\n\n\t.pick_next_task\t\t= __pick_next_task_fair,\n\t.put_prev_task\t\t= put_prev_task_fair,\n\t.set_next_task          = set_next_task_fair,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_fair,\n\t.select_task_rq\t\t= select_task_rq_fair,\n\t.migrate_task_rq\t= migrate_task_rq_fair,\n\n\t.rq_online\t\t= rq_online_fair,\n\t.rq_offline\t\t= rq_offline_fair,\n\n\t.task_dead\t\t= task_dead_fair,\n\t.set_cpus_allowed\t= set_cpus_allowed_common,\n#endif\n\n\t.task_tick\t\t= task_tick_fair,\n\t.task_fork\t\t= task_fork_fair,\n\n\t.prio_changed\t\t= prio_changed_fair,\n\t.switched_from\t\t= switched_from_fair,\n\t.switched_to\t\t= switched_to_fair,\n\n\t.get_rr_interval\t= get_rr_interval_fair,\n\n\t.update_curr\t\t= update_curr_fair,\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t.task_change_group\t= task_change_group_fair,\n#endif\n\n#ifdef CONFIG_UCLAMP_TASK\n\t.uclamp_enabled\t\t= 1,\n#endif\n};\n\n#ifdef CONFIG_SCHED_DEBUG\nvoid print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}\n\n#ifdef CONFIG_NUMA_BALANCING\nvoid show_numa_stats(struct task_struct *p, struct seq_file *m)\n{\n\tint node;\n\tunsigned long tsf = 0, tpf = 0, gsf = 0, gpf = 0;\n\tstruct numa_group *ng;\n\n\trcu_read_lock();\n\tng = rcu_dereference(p->numa_group);\n\tfor_each_online_node(node) {\n\t\tif (p->numa_faults) {\n\t\t\ttsf = p->numa_faults[task_faults_idx(NUMA_MEM, node, 0)];\n\t\t\ttpf = p->numa_faults[task_faults_idx(NUMA_MEM, node, 1)];\n\t\t}\n\t\tif (ng) {\n\t\t\tgsf = ng->faults[task_faults_idx(NUMA_MEM, node, 0)],\n\t\t\tgpf = ng->faults[task_faults_idx(NUMA_MEM, node, 1)];\n\t\t}\n\t\tprint_numa_stats(m, node, tsf, tpf, gsf, gpf);\n\t}\n\trcu_read_unlock();\n}\n#endif /* CONFIG_NUMA_BALANCING */\n#endif /* CONFIG_SCHED_DEBUG */\n\n__init void init_sched_fair_class(void)\n{\n#ifdef CONFIG_SMP\n\topen_softirq(SCHED_SOFTIRQ, run_rebalance_domains);\n\n#ifdef CONFIG_NO_HZ_COMMON\n\tnohz.next_balance = jiffies;\n\tnohz.next_blocked = jiffies;\n\tzalloc_cpumask_var(&nohz.idle_cpus_mask, GFP_NOWAIT);\n#endif\n#endif /* SMP */\n\n}\n\n/*\n * Helper functions to facilitate extracting info from tracepoints.\n */\n\nconst struct sched_avg *sched_trace_cfs_rq_avg(struct cfs_rq *cfs_rq)\n{\n#ifdef CONFIG_SMP\n\treturn cfs_rq ? &cfs_rq->avg : NULL;\n#else\n\treturn NULL;\n#endif\n}\nEXPORT_SYMBOL_GPL(sched_trace_cfs_rq_avg);\n\nchar *sched_trace_cfs_rq_path(struct cfs_rq *cfs_rq, char *str, int len)\n{\n\tif (!cfs_rq) {\n\t\tif (str)\n\t\t\tstrlcpy(str, \"(null)\", len);\n\t\telse\n\t\t\treturn NULL;\n\t}\n\n\tcfs_rq_tg_path(cfs_rq, str, len);\n\treturn str;\n}\nEXPORT_SYMBOL_GPL(sched_trace_cfs_rq_path);\n\nint sched_trace_cfs_rq_cpu(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq ? cpu_of(rq_of(cfs_rq)) : -1;\n}\nEXPORT_SYMBOL_GPL(sched_trace_cfs_rq_cpu);\n\nconst struct sched_avg *sched_trace_rq_avg_rt(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq ? &rq->avg_rt : NULL;\n#else\n\treturn NULL;\n#endif\n}\nEXPORT_SYMBOL_GPL(sched_trace_rq_avg_rt);\n\nconst struct sched_avg *sched_trace_rq_avg_dl(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq ? &rq->avg_dl : NULL;\n#else\n\treturn NULL;\n#endif\n}\nEXPORT_SYMBOL_GPL(sched_trace_rq_avg_dl);\n\nconst struct sched_avg *sched_trace_rq_avg_irq(struct rq *rq)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_HAVE_SCHED_AVG_IRQ)\n\treturn rq ? &rq->avg_irq : NULL;\n#else\n\treturn NULL;\n#endif\n}\nEXPORT_SYMBOL_GPL(sched_trace_rq_avg_irq);\n\nint sched_trace_rq_cpu(struct rq *rq)\n{\n\treturn rq ? cpu_of(rq) : -1;\n}\nEXPORT_SYMBOL_GPL(sched_trace_rq_cpu);\n\nint sched_trace_rq_cpu_capacity(struct rq *rq)\n{\n\treturn rq ?\n#ifdef CONFIG_SMP\n\t\trq->cpu_capacity\n#else\n\t\tSCHED_CAPACITY_SCALE\n#endif\n\t\t: -1;\n}\nEXPORT_SYMBOL_GPL(sched_trace_rq_cpu_capacity);\n\nconst struct cpumask *sched_trace_rd_span(struct root_domain *rd)\n{\n#ifdef CONFIG_SMP\n\treturn rd ? rd->span : NULL;\n#else\n\treturn NULL;\n#endif\n}\nEXPORT_SYMBOL_GPL(sched_trace_rd_span);\n\nint sched_trace_rq_nr_running(struct rq *rq)\n{\n        return rq ? rq->nr_running : -1;\n}\nEXPORT_SYMBOL_GPL(sched_trace_rq_nr_running);\n"}, "1": {"id": 1, "path": "/src/kernel/sched/sched.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n/*\n * Scheduler internal types and methods:\n */\n#include <linux/sched.h>\n\n#include <linux/sched/autogroup.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/init.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/user.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/xacct.h>\n\n#include <uapi/linux/sched/types.h>\n\n#include <linux/binfmts.h>\n#include <linux/blkdev.h>\n#include <linux/compat.h>\n#include <linux/context_tracking.h>\n#include <linux/cpufreq.h>\n#include <linux/cpuidle.h>\n#include <linux/cpuset.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/delayacct.h>\n#include <linux/energy_model.h>\n#include <linux/init_task.h>\n#include <linux/kprobes.h>\n#include <linux/kthread.h>\n#include <linux/membarrier.h>\n#include <linux/migrate.h>\n#include <linux/mmu_context.h>\n#include <linux/nmi.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/profile.h>\n#include <linux/psi.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/security.h>\n#include <linux/stop_machine.h>\n#include <linux/suspend.h>\n#include <linux/swait.h>\n#include <linux/syscalls.h>\n#include <linux/task_work.h>\n#include <linux/tsacct_kern.h>\n\n#include <asm/tlb.h>\n\n#ifdef CONFIG_PARAVIRT\n# include <asm/paravirt.h>\n#endif\n\n#include \"cpupri.h\"\n#include \"cpudeadline.h\"\n\n#include <trace/events/sched.h>\n\n#ifdef CONFIG_SCHED_DEBUG\n# define SCHED_WARN_ON(x)\tWARN_ONCE(x, #x)\n#else\n# define SCHED_WARN_ON(x)\t({ (void)(x), 0; })\n#endif\n\nstruct rq;\nstruct cpuidle_state;\n\n/* task_struct::on_rq states: */\n#define TASK_ON_RQ_QUEUED\t1\n#define TASK_ON_RQ_MIGRATING\t2\n\nextern __read_mostly int scheduler_running;\n\nextern unsigned long calc_load_update;\nextern atomic_long_t calc_load_tasks;\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern long calc_load_fold_active(struct rq *this_rq, long adjust);\n\nextern void call_trace_sched_update_nr_running(struct rq *rq, int count);\n/*\n * Helpers for converting nanosecond timing to jiffy resolution\n */\n#define NS_TO_JIFFIES(TIME)\t((unsigned long)(TIME) / (NSEC_PER_SEC / HZ))\n\n/*\n * Increase resolution of nice-level calculations for 64-bit architectures.\n * The extra resolution improves shares distribution and load balancing of\n * low-weight task groups (eg. nice +19 on an autogroup), deeper taskgroup\n * hierarchies, especially on larger systems. This is not a user-visible change\n * and does not change the user-interface for setting shares/weights.\n *\n * We increase resolution only if we have enough bits to allow this increased\n * resolution (i.e. 64-bit). The costs for increasing resolution when 32-bit\n * are pretty high and the returns do not justify the increased costs.\n *\n * Really only required when CONFIG_FAIR_GROUP_SCHED=y is also set, but to\n * increase coverage and consistency always enable it on 64-bit platforms.\n */\n#ifdef CONFIG_64BIT\n# define NICE_0_LOAD_SHIFT\t(SCHED_FIXEDPOINT_SHIFT + SCHED_FIXEDPOINT_SHIFT)\n# define scale_load(w)\t\t((w) << SCHED_FIXEDPOINT_SHIFT)\n# define scale_load_down(w) \\\n({ \\\n\tunsigned long __w = (w); \\\n\tif (__w) \\\n\t\t__w = max(2UL, __w >> SCHED_FIXEDPOINT_SHIFT); \\\n\t__w; \\\n})\n#else\n# define NICE_0_LOAD_SHIFT\t(SCHED_FIXEDPOINT_SHIFT)\n# define scale_load(w)\t\t(w)\n# define scale_load_down(w)\t(w)\n#endif\n\n/*\n * Task weight (visible to users) and its load (invisible to users) have\n * independent resolution, but they should be well calibrated. We use\n * scale_load() and scale_load_down(w) to convert between them. The\n * following must be true:\n *\n *  scale_load(sched_prio_to_weight[USER_PRIO(NICE_TO_PRIO(0))]) == NICE_0_LOAD\n *\n */\n#define NICE_0_LOAD\t\t(1L << NICE_0_LOAD_SHIFT)\n\n/*\n * Single value that decides SCHED_DEADLINE internal math precision.\n * 10 -> just above 1us\n * 9  -> just above 0.5us\n */\n#define DL_SCALE\t\t10\n\n/*\n * Single value that denotes runtime == period, ie unlimited time.\n */\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline int idle_policy(int policy)\n{\n\treturn policy == SCHED_IDLE;\n}\nstatic inline int fair_policy(int policy)\n{\n\treturn policy == SCHED_NORMAL || policy == SCHED_BATCH;\n}\n\nstatic inline int rt_policy(int policy)\n{\n\treturn policy == SCHED_FIFO || policy == SCHED_RR;\n}\n\nstatic inline int dl_policy(int policy)\n{\n\treturn policy == SCHED_DEADLINE;\n}\nstatic inline bool valid_policy(int policy)\n{\n\treturn idle_policy(policy) || fair_policy(policy) ||\n\t\trt_policy(policy) || dl_policy(policy);\n}\n\nstatic inline int task_has_idle_policy(struct task_struct *p)\n{\n\treturn idle_policy(p->policy);\n}\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->policy);\n}\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}\n\n#define cap_scale(v, s) ((v)*(s) >> SCHED_CAPACITY_SHIFT)\n\nstatic inline void update_avg(u64 *avg, u64 sample)\n{\n\ts64 diff = sample - *avg;\n\t*avg += diff / 8;\n}\n\n/*\n * !! For sched_setattr_nocheck() (kernel) only !!\n *\n * This is actually gross. :(\n *\n * It is used to make schedutil kworker(s) higher priority than SCHED_DEADLINE\n * tasks, but still be able to sleep. We need this on platforms that cannot\n * atomically change clock frequency. Remove once fast switching will be\n * available on such platforms.\n *\n * SUGOV stands for SchedUtil GOVernor.\n */\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}\n\n/*\n * Tells if entity @a should preempt entity @b.\n */\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}\n\n/*\n * This is the priority-queue data structure of the RT scheduling class:\n */\nstruct rt_prio_array {\n\tDECLARE_BITMAP(bitmap, MAX_RT_PRIO+1); /* include 1 bit for delimiter */\n\tstruct list_head queue[MAX_RT_PRIO];\n};\n\nstruct rt_bandwidth {\n\t/* nests inside the rq lock: */\n\traw_spinlock_t\t\trt_runtime_lock;\n\tktime_t\t\t\trt_period;\n\tu64\t\t\trt_runtime;\n\tstruct hrtimer\t\trt_period_timer;\n\tunsigned int\t\trt_period_active;\n};\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstruct dl_bandwidth {\n\traw_spinlock_t\t\tdl_runtime_lock;\n\tu64\t\t\tdl_runtime;\n\tu64\t\t\tdl_period;\n};\n\nstatic inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}\n\n/*\n * To keep the bandwidth of -deadline tasks under control\n * we need some place where:\n *  - store the maximum -deadline bandwidth of each cpu;\n *  - cache the fraction of bandwidth that is currently allocated in\n *    each root domain;\n *\n * This is all done in the data structure below. It is similar to the\n * one used for RT-throttling (rt_bandwidth), with the main difference\n * that, since here we are only interested in admission control, we\n * do not decrease any runtime while the group \"executes\", neither we\n * need a timer to replenish it.\n *\n * With respect to SMP, bandwidth is given on a per root domain basis,\n * meaning that:\n *  - bw (< 100%) is the deadline bandwidth of each CPU;\n *  - total_bw is the currently allocated bandwidth in each root domain;\n */\nstruct dl_bw {\n\traw_spinlock_t\t\tlock;\n\tu64\t\t\tbw;\n\tu64\t\t\ttotal_bw;\n};\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}\n\nstatic inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}\n\n/*\n * Verify the fitness of task @p to run on @cpu taking into account the\n * CPU original capacity and the runtime/deadline ratio of the task.\n *\n * The function will return true if the CPU original capacity of the\n * @cpu scaled by SCHED_CAPACITY_SCALE >= runtime/deadline ratio of the\n * task and false otherwise.\n */\nstatic inline bool dl_task_fits_capacity(struct task_struct *p, int cpu)\n{\n\tunsigned long cap = arch_scale_cpu_capacity(cpu);\n\n\treturn cap_scale(p->dl.dl_deadline, cap) >= p->dl.dl_runtime;\n}\n\nextern void init_dl_bw(struct dl_bw *dl_b);\nextern int  sched_dl_global_validate(void);\nextern void sched_dl_do_global(void);\nextern int  sched_dl_overflow(struct task_struct *p, int policy, const struct sched_attr *attr);\nextern void __setparam_dl(struct task_struct *p, const struct sched_attr *attr);\nextern void __getparam_dl(struct task_struct *p, struct sched_attr *attr);\nextern bool __checkparam_dl(const struct sched_attr *attr);\nextern bool dl_param_changed(struct task_struct *p, const struct sched_attr *attr);\nextern int  dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed);\nextern int  dl_cpuset_cpumask_can_shrink(const struct cpumask *cur, const struct cpumask *trial);\nextern bool dl_cpu_busy(unsigned int cpu);\n\n#ifdef CONFIG_CGROUP_SCHED\n\n#include <linux/cgroup.h>\n#include <linux/psi.h>\n\nstruct cfs_rq;\nstruct rt_rq;\n\nextern struct list_head task_groups;\n\nstruct cfs_bandwidth {\n#ifdef CONFIG_CFS_BANDWIDTH\n\traw_spinlock_t\t\tlock;\n\tktime_t\t\t\tperiod;\n\tu64\t\t\tquota;\n\tu64\t\t\truntime;\n\ts64\t\t\thierarchical_quota;\n\n\tu8\t\t\tidle;\n\tu8\t\t\tperiod_active;\n\tu8\t\t\tslack_started;\n\tstruct hrtimer\t\tperiod_timer;\n\tstruct hrtimer\t\tslack_timer;\n\tstruct list_head\tthrottled_cfs_rq;\n\n\t/* Statistics: */\n\tint\t\t\tnr_periods;\n\tint\t\t\tnr_throttled;\n\tu64\t\t\tthrottled_time;\n#endif\n};\n\n/* Task group related information */\nstruct task_group {\n\tstruct cgroup_subsys_state css;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t/* schedulable entities of this group on each CPU */\n\tstruct sched_entity\t**se;\n\t/* runqueue \"owned\" by this group on each CPU */\n\tstruct cfs_rq\t\t**cfs_rq;\n\tunsigned long\t\tshares;\n\n#ifdef\tCONFIG_SMP\n\t/*\n\t * load_avg can be heavily contended at clock tick time, so put\n\t * it in its own cacheline separated from the fields above which\n\t * will also be accessed at each tick.\n\t */\n\tatomic_long_t\t\tload_avg ____cacheline_aligned;\n#endif\n#endif\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\tstruct sched_rt_entity\t**rt_se;\n\tstruct rt_rq\t\t**rt_rq;\n\n\tstruct rt_bandwidth\trt_bandwidth;\n#endif\n\n\tstruct rcu_head\t\trcu;\n\tstruct list_head\tlist;\n\n\tstruct task_group\t*parent;\n\tstruct list_head\tsiblings;\n\tstruct list_head\tchildren;\n\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tstruct autogroup\t*autogroup;\n#endif\n\n\tstruct cfs_bandwidth\tcfs_bandwidth;\n\n#ifdef CONFIG_UCLAMP_TASK_GROUP\n\t/* The two decimal precision [%] value requested from user-space */\n\tunsigned int\t\tuclamp_pct[UCLAMP_CNT];\n\t/* Clamp values requested for a task group */\n\tstruct uclamp_se\tuclamp_req[UCLAMP_CNT];\n\t/* Effective clamp values used for a task group */\n\tstruct uclamp_se\tuclamp[UCLAMP_CNT];\n#endif\n\n};\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n#define ROOT_TASK_GROUP_LOAD\tNICE_0_LOAD\n\n/*\n * A weight of 0 or 1 can cause arithmetics problems.\n * A weight of a cfs_rq is the sum of weights of which entities\n * are queued on this cfs_rq, so a weight of a entity should not be\n * too large, so as the shares value of a task group.\n * (The default weight is 1024 - so there's no practical\n *  limitation from this.)\n */\n#define MIN_SHARES\t\t(1UL <<  1)\n#define MAX_SHARES\t\t(1UL << 18)\n#endif\n\ntypedef int (*tg_visitor)(struct task_group *, void *);\n\nextern int walk_tg_tree_from(struct task_group *from,\n\t\t\t     tg_visitor down, tg_visitor up, void *data);\n\n/*\n * Iterate the full tree, calling @down when first entering a node and @up when\n * leaving it for the final time.\n *\n * Caller must hold rcu_lock or sufficient equivalent.\n */\nstatic inline int walk_tg_tree(tg_visitor down, tg_visitor up, void *data)\n{\n\treturn walk_tg_tree_from(&root_task_group, down, up, data);\n}\n\nextern int tg_nop(struct task_group *tg, void *data);\n\nextern void free_fair_sched_group(struct task_group *tg);\nextern int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent);\nextern void online_fair_sched_group(struct task_group *tg);\nextern void unregister_fair_sched_group(struct task_group *tg);\nextern void init_tg_cfs_entry(struct task_group *tg, struct cfs_rq *cfs_rq,\n\t\t\tstruct sched_entity *se, int cpu,\n\t\t\tstruct sched_entity *parent);\nextern void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b);\n\nextern void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b);\nextern void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b);\nextern void unthrottle_cfs_rq(struct cfs_rq *cfs_rq);\n\nextern void free_rt_sched_group(struct task_group *tg);\nextern int alloc_rt_sched_group(struct task_group *tg, struct task_group *parent);\nextern void init_tg_rt_entry(struct task_group *tg, struct rt_rq *rt_rq,\n\t\tstruct sched_rt_entity *rt_se, int cpu,\n\t\tstruct sched_rt_entity *parent);\nextern int sched_group_set_rt_runtime(struct task_group *tg, long rt_runtime_us);\nextern int sched_group_set_rt_period(struct task_group *tg, u64 rt_period_us);\nextern long sched_group_rt_runtime(struct task_group *tg);\nextern long sched_group_rt_period(struct task_group *tg);\nextern int sched_rt_can_attach(struct task_group *tg, struct task_struct *tsk);\n\nextern struct task_group *sched_create_group(struct task_group *parent);\nextern void sched_online_group(struct task_group *tg,\n\t\t\t       struct task_group *parent);\nextern void sched_destroy_group(struct task_group *tg);\nextern void sched_offline_group(struct task_group *tg);\n\nextern void sched_move_task(struct task_struct *tsk);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\nextern int sched_group_set_shares(struct task_group *tg, unsigned long shares);\n\n#ifdef CONFIG_SMP\nextern void set_task_rq_fair(struct sched_entity *se,\n\t\t\t     struct cfs_rq *prev, struct cfs_rq *next);\n#else /* !CONFIG_SMP */\nstatic inline void set_task_rq_fair(struct sched_entity *se,\n\t\t\t     struct cfs_rq *prev, struct cfs_rq *next) { }\n#endif /* CONFIG_SMP */\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n#else /* CONFIG_CGROUP_SCHED */\n\nstruct cfs_bandwidth { };\n\n#endif\t/* CONFIG_CGROUP_SCHED */\n\n/* CFS-related fields in a runqueue */\nstruct cfs_rq {\n\tstruct load_weight\tload;\n\tunsigned int\t\tnr_running;\n\tunsigned int\t\th_nr_running;      /* SCHED_{NORMAL,BATCH,IDLE} */\n\tunsigned int\t\tidle_h_nr_running; /* SCHED_IDLE */\n\n\tu64\t\t\texec_clock;\n\tu64\t\t\tmin_vruntime;\n#ifndef CONFIG_64BIT\n\tu64\t\t\tmin_vruntime_copy;\n#endif\n\n\tstruct rb_root_cached\ttasks_timeline;\n\n\t/*\n\t * 'curr' points to currently running entity on this cfs_rq.\n\t * It is set to NULL otherwise (i.e when none are currently running).\n\t */\n\tstruct sched_entity\t*curr;\n\tstruct sched_entity\t*next;\n\tstruct sched_entity\t*last;\n\tstruct sched_entity\t*skip;\n\n#ifdef\tCONFIG_SCHED_DEBUG\n\tunsigned int\t\tnr_spread_over;\n#endif\n\n#ifdef CONFIG_SMP\n\t/*\n\t * CFS load tracking\n\t */\n\tstruct sched_avg\tavg;\n#ifndef CONFIG_64BIT\n\tu64\t\t\tload_last_update_time_copy;\n#endif\n\tstruct {\n\t\traw_spinlock_t\tlock ____cacheline_aligned;\n\t\tint\t\tnr;\n\t\tunsigned long\tload_avg;\n\t\tunsigned long\tutil_avg;\n\t\tunsigned long\trunnable_avg;\n\t} removed;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tunsigned long\t\ttg_load_avg_contrib;\n\tlong\t\t\tpropagate;\n\tlong\t\t\tprop_runnable_sum;\n\n\t/*\n\t *   h_load = weight * f(tg)\n\t *\n\t * Where f(tg) is the recursive weight fraction assigned to\n\t * this group.\n\t */\n\tunsigned long\t\th_load;\n\tu64\t\t\tlast_h_load_update;\n\tstruct sched_entity\t*h_load_next;\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tstruct rq\t\t*rq;\t/* CPU runqueue to which this cfs_rq is attached */\n\n\t/*\n\t * leaf cfs_rqs are those that hold tasks (lowest schedulable entity in\n\t * a hierarchy). Non-leaf lrqs hold other higher schedulable entities\n\t * (like users, containers etc.)\n\t *\n\t * leaf_cfs_rq_list ties together list of leaf cfs_rq's in a CPU.\n\t * This list is used during load balance.\n\t */\n\tint\t\t\ton_list;\n\tstruct list_head\tleaf_cfs_rq_list;\n\tstruct task_group\t*tg;\t/* group that \"owns\" this runqueue */\n\n#ifdef CONFIG_CFS_BANDWIDTH\n\tint\t\t\truntime_enabled;\n\ts64\t\t\truntime_remaining;\n\n\tu64\t\t\tthrottled_clock;\n\tu64\t\t\tthrottled_clock_task;\n\tu64\t\t\tthrottled_clock_task_time;\n\tint\t\t\tthrottled;\n\tint\t\t\tthrottle_count;\n\tstruct list_head\tthrottled_list;\n#endif /* CONFIG_CFS_BANDWIDTH */\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n};\n\nstatic inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}\n\n/* RT IPI pull logic requires IRQ_WORK */\n#if defined(CONFIG_IRQ_WORK) && defined(CONFIG_SMP)\n# define HAVE_RT_PUSH_IPI\n#endif\n\n/* Real-Time classes' related field in a runqueue: */\nstruct rt_rq {\n\tstruct rt_prio_array\tactive;\n\tunsigned int\t\trt_nr_running;\n\tunsigned int\t\trr_nr_running;\n#if defined CONFIG_SMP || defined CONFIG_RT_GROUP_SCHED\n\tstruct {\n\t\tint\t\tcurr; /* highest queued rt task prio */\n#ifdef CONFIG_SMP\n\t\tint\t\tnext; /* next highest */\n#endif\n\t} highest_prio;\n#endif\n#ifdef CONFIG_SMP\n\tunsigned long\t\trt_nr_migratory;\n\tunsigned long\t\trt_nr_total;\n\tint\t\t\toverloaded;\n\tstruct plist_head\tpushable_tasks;\n\n#endif /* CONFIG_SMP */\n\tint\t\t\trt_queued;\n\n\tint\t\t\trt_throttled;\n\tu64\t\t\trt_time;\n\tu64\t\t\trt_runtime;\n\t/* Nests inside the rq lock: */\n\traw_spinlock_t\t\trt_runtime_lock;\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\tunsigned long\t\trt_nr_boosted;\n\n\tstruct rq\t\t*rq;\n\tstruct task_group\t*tg;\n#endif\n};\n\nstatic inline bool rt_rq_is_runnable(struct rt_rq *rt_rq)\n{\n\treturn rt_rq->rt_queued && rt_rq->rt_nr_running;\n}\n\n/* Deadline class' related fields in a runqueue */\nstruct dl_rq {\n\t/* runqueue is an rbtree, ordered by deadline */\n\tstruct rb_root_cached\troot;\n\n\tunsigned long\t\tdl_nr_running;\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Deadline values of the currently executing and the\n\t * earliest ready task on this rq. Caching these facilitates\n\t * the decision whether or not a ready but not running task\n\t * should migrate somewhere else.\n\t */\n\tstruct {\n\t\tu64\t\tcurr;\n\t\tu64\t\tnext;\n\t} earliest_dl;\n\n\tunsigned long\t\tdl_nr_migratory;\n\tint\t\t\toverloaded;\n\n\t/*\n\t * Tasks on this rq that can be pushed away. They are kept in\n\t * an rb-tree, ordered by tasks' deadlines, with caching\n\t * of the leftmost (earliest deadline) element.\n\t */\n\tstruct rb_root_cached\tpushable_dl_tasks_root;\n#else\n\tstruct dl_bw\t\tdl_bw;\n#endif\n\t/*\n\t * \"Active utilization\" for this runqueue: increased when a\n\t * task wakes up (becomes TASK_RUNNING) and decreased when a\n\t * task blocks\n\t */\n\tu64\t\t\trunning_bw;\n\n\t/*\n\t * Utilization of the tasks \"assigned\" to this runqueue (including\n\t * the tasks that are in runqueue and the tasks that executed on this\n\t * CPU and blocked). Increased when a task moves to this runqueue, and\n\t * decreased when the task moves away (migrates, changes scheduling\n\t * policy, or terminates).\n\t * This is needed to compute the \"inactive utilization\" for the\n\t * runqueue (inactive utilization = this_bw - running_bw).\n\t */\n\tu64\t\t\tthis_bw;\n\tu64\t\t\textra_bw;\n\n\t/*\n\t * Inverse of the fraction of CPU utilization that can be reclaimed\n\t * by the GRUB algorithm.\n\t */\n\tu64\t\t\tbw_ratio;\n};\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n/* An entity is a task if it doesn't \"own\" a runqueue */\n#define entity_is_task(se)\t(!se->my_q)\n\nstatic inline void se_update_runnable(struct sched_entity *se)\n{\n\tif (!entity_is_task(se))\n\t\tse->runnable_weight = se->my_q->h_nr_running;\n}\n\nstatic inline long se_runnable(struct sched_entity *se)\n{\n\tif (entity_is_task(se))\n\t\treturn !!se->on_rq;\n\telse\n\t\treturn se->runnable_weight;\n}\n\n#else\n#define entity_is_task(se)\t1\n\nstatic inline void se_update_runnable(struct sched_entity *se) {}\n\nstatic inline long se_runnable(struct sched_entity *se)\n{\n\treturn !!se->on_rq;\n}\n#endif\n\n#ifdef CONFIG_SMP\n/*\n * XXX we want to get rid of these helpers and use the full load resolution.\n */\nstatic inline long se_weight(struct sched_entity *se)\n{\n\treturn scale_load_down(se->load.weight);\n}\n\n\nstatic inline bool sched_asym_prefer(int a, int b)\n{\n\treturn arch_asym_cpu_priority(a) > arch_asym_cpu_priority(b);\n}\n\nstruct perf_domain {\n\tstruct em_perf_domain *em_pd;\n\tstruct perf_domain *next;\n\tstruct rcu_head rcu;\n};\n\n/* Scheduling group status flags */\n#define SG_OVERLOAD\t\t0x1 /* More than one runnable task on a CPU. */\n#define SG_OVERUTILIZED\t\t0x2 /* One or more CPUs are over-utilized. */\n\n/*\n * We add the notion of a root-domain which will be used to define per-domain\n * variables. Each exclusive cpuset essentially defines an island domain by\n * fully partitioning the member CPUs from any other cpuset. Whenever a new\n * exclusive cpuset is created, we also create and attach a new root-domain\n * object.\n *\n */\nstruct root_domain {\n\tatomic_t\t\trefcount;\n\tatomic_t\t\trto_count;\n\tstruct rcu_head\t\trcu;\n\tcpumask_var_t\t\tspan;\n\tcpumask_var_t\t\tonline;\n\n\t/*\n\t * Indicate pullable load on at least one CPU, e.g:\n\t * - More than one runnable task\n\t * - Running task is misfit\n\t */\n\tint\t\t\toverload;\n\n\t/* Indicate one or more cpus over-utilized (tipping point) */\n\tint\t\t\toverutilized;\n\n\t/*\n\t * The bit corresponding to a CPU gets set here if such CPU has more\n\t * than one runnable -deadline task (as it is below for RT tasks).\n\t */\n\tcpumask_var_t\t\tdlo_mask;\n\tatomic_t\t\tdlo_count;\n\tstruct dl_bw\t\tdl_bw;\n\tstruct cpudl\t\tcpudl;\n\n\t/*\n\t * Indicate whether a root_domain's dl_bw has been checked or\n\t * updated. It's monotonously increasing value.\n\t *\n\t * Also, some corner cases, like 'wrap around' is dangerous, but given\n\t * that u64 is 'big enough'. So that shouldn't be a concern.\n\t */\n\tu64 visit_gen;\n\n#ifdef HAVE_RT_PUSH_IPI\n\t/*\n\t * For IPI pull requests, loop across the rto_mask.\n\t */\n\tstruct irq_work\t\trto_push_work;\n\traw_spinlock_t\t\trto_lock;\n\t/* These are only updated and read within rto_lock */\n\tint\t\t\trto_loop;\n\tint\t\t\trto_cpu;\n\t/* These atomics are updated outside of a lock */\n\tatomic_t\t\trto_loop_next;\n\tatomic_t\t\trto_loop_start;\n#endif\n\t/*\n\t * The \"RT overload\" flag: it gets set if a CPU has more than\n\t * one runnable RT task.\n\t */\n\tcpumask_var_t\t\trto_mask;\n\tstruct cpupri\t\tcpupri;\n\n\tunsigned long\t\tmax_cpu_capacity;\n\n\t/*\n\t * NULL-terminated list of performance domains intersecting with the\n\t * CPUs of the rd. Protected by RCU.\n\t */\n\tstruct perf_domain __rcu *pd;\n};\n\nextern void init_defrootdomain(void);\nextern int sched_init_domains(const struct cpumask *cpu_map);\nextern void rq_attach_root(struct rq *rq, struct root_domain *rd);\nextern void sched_get_rd(struct root_domain *rd);\nextern void sched_put_rd(struct root_domain *rd);\n\n#ifdef HAVE_RT_PUSH_IPI\nextern void rto_push_irq_work_func(struct irq_work *work);\n#endif\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_UCLAMP_TASK\n/*\n * struct uclamp_bucket - Utilization clamp bucket\n * @value: utilization clamp value for tasks on this clamp bucket\n * @tasks: number of RUNNABLE tasks on this clamp bucket\n *\n * Keep track of how many tasks are RUNNABLE for a given utilization\n * clamp value.\n */\nstruct uclamp_bucket {\n\tunsigned long value : bits_per(SCHED_CAPACITY_SCALE);\n\tunsigned long tasks : BITS_PER_LONG - bits_per(SCHED_CAPACITY_SCALE);\n};\n\n/*\n * struct uclamp_rq - rq's utilization clamp\n * @value: currently active clamp values for a rq\n * @bucket: utilization clamp buckets affecting a rq\n *\n * Keep track of RUNNABLE tasks on a rq to aggregate their clamp values.\n * A clamp value is affecting a rq when there is at least one task RUNNABLE\n * (or actually running) with that value.\n *\n * There are up to UCLAMP_CNT possible different clamp values, currently there\n * are only two: minimum utilization and maximum utilization.\n *\n * All utilization clamping values are MAX aggregated, since:\n * - for util_min: we want to run the CPU at least at the max of the minimum\n *   utilization required by its currently RUNNABLE tasks.\n * - for util_max: we want to allow the CPU to run up to the max of the\n *   maximum utilization allowed by its currently RUNNABLE tasks.\n *\n * Since on each system we expect only a limited number of different\n * utilization clamp values (UCLAMP_BUCKETS), use a simple array to track\n * the metrics required to compute all the per-rq utilization clamp values.\n */\nstruct uclamp_rq {\n\tunsigned int value;\n\tstruct uclamp_bucket bucket[UCLAMP_BUCKETS];\n};\n\nDECLARE_STATIC_KEY_FALSE(sched_uclamp_used);\n#endif /* CONFIG_UCLAMP_TASK */\n\n/*\n * This is the main, per-CPU runqueue data structure.\n *\n * Locking rule: those places that want to lock multiple runqueues\n * (such as the load balancing or the thread migration code), lock\n * acquire operations must be ordered by ascending &runqueue.\n */\nstruct rq {\n\t/* runqueue lock: */\n\traw_spinlock_t\t\tlock;\n\n\t/*\n\t * nr_running and cpu_load should be in the same cacheline because\n\t * remote CPUs use both these fields when doing load calculation.\n\t */\n\tunsigned int\t\tnr_running;\n#ifdef CONFIG_NUMA_BALANCING\n\tunsigned int\t\tnr_numa_running;\n\tunsigned int\t\tnr_preferred_running;\n\tunsigned int\t\tnuma_migrate_on;\n#endif\n#ifdef CONFIG_NO_HZ_COMMON\n#ifdef CONFIG_SMP\n\tunsigned long\t\tlast_blocked_load_update_tick;\n\tunsigned int\t\thas_blocked_load;\n\tcall_single_data_t\tnohz_csd;\n#endif /* CONFIG_SMP */\n\tunsigned int\t\tnohz_tick_stopped;\n\tatomic_t\t\tnohz_flags;\n#endif /* CONFIG_NO_HZ_COMMON */\n\n#ifdef CONFIG_SMP\n\tunsigned int\t\tttwu_pending;\n#endif\n\tu64\t\t\tnr_switches;\n\n#ifdef CONFIG_UCLAMP_TASK\n\t/* Utilization clamp values based on CPU's RUNNABLE tasks */\n\tstruct uclamp_rq\tuclamp[UCLAMP_CNT] ____cacheline_aligned;\n\tunsigned int\t\tuclamp_flags;\n#define UCLAMP_FLAG_IDLE 0x01\n#endif\n\n\tstruct cfs_rq\t\tcfs;\n\tstruct rt_rq\t\trt;\n\tstruct dl_rq\t\tdl;\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t/* list of leaf cfs_rq on this CPU: */\n\tstruct list_head\tleaf_cfs_rq_list;\n\tstruct list_head\t*tmp_alone_branch;\n#endif /* CONFIG_FAIR_GROUP_SCHED */\n\n\t/*\n\t * This is part of a global counter where only the total sum\n\t * over all CPUs matters. A task can increase this counter on\n\t * one CPU and if it got migrated afterwards it may decrease\n\t * it on another CPU. Always updated under the runqueue lock:\n\t */\n\tunsigned long\t\tnr_uninterruptible;\n\n\tstruct task_struct __rcu\t*curr;\n\tstruct task_struct\t*idle;\n\tstruct task_struct\t*stop;\n\tunsigned long\t\tnext_balance;\n\tstruct mm_struct\t*prev_mm;\n\n\tunsigned int\t\tclock_update_flags;\n\tu64\t\t\tclock;\n\t/* Ensure that all clocks are in the same cache line */\n\tu64\t\t\tclock_task ____cacheline_aligned;\n\tu64\t\t\tclock_pelt;\n\tunsigned long\t\tlost_idle_time;\n\n\tatomic_t\t\tnr_iowait;\n\n#ifdef CONFIG_MEMBARRIER\n\tint membarrier_state;\n#endif\n\n#ifdef CONFIG_SMP\n\tstruct root_domain\t\t*rd;\n\tstruct sched_domain __rcu\t*sd;\n\n\tunsigned long\t\tcpu_capacity;\n\tunsigned long\t\tcpu_capacity_orig;\n\n\tstruct callback_head\t*balance_callback;\n\tunsigned char\t\tbalance_push;\n\n\tunsigned char\t\tnohz_idle_balance;\n\tunsigned char\t\tidle_balance;\n\n\tunsigned long\t\tmisfit_task_load;\n\n\t/* For active balancing */\n\tint\t\t\tactive_balance;\n\tint\t\t\tpush_cpu;\n\tstruct cpu_stop_work\tactive_balance_work;\n\n\t/* CPU of this runqueue: */\n\tint\t\t\tcpu;\n\tint\t\t\tonline;\n\n\tstruct list_head cfs_tasks;\n\n\tstruct sched_avg\tavg_rt;\n\tstruct sched_avg\tavg_dl;\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\n\tstruct sched_avg\tavg_irq;\n#endif\n#ifdef CONFIG_SCHED_THERMAL_PRESSURE\n\tstruct sched_avg\tavg_thermal;\n#endif\n\tu64\t\t\tidle_stamp;\n\tu64\t\t\tavg_idle;\n\n\t/* This is used to determine avg_idle's max value */\n\tu64\t\t\tmax_idle_balance_cost;\n\n#ifdef CONFIG_HOTPLUG_CPU\n\tstruct rcuwait\t\thotplug_wait;\n#endif\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\n\tu64\t\t\tprev_irq_time;\n#endif\n#ifdef CONFIG_PARAVIRT\n\tu64\t\t\tprev_steal_time;\n#endif\n#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING\n\tu64\t\t\tprev_steal_time_rq;\n#endif\n\n\t/* calc_load related fields */\n\tunsigned long\t\tcalc_load_update;\n\tlong\t\t\tcalc_load_active;\n\n#ifdef CONFIG_SCHED_HRTICK\n#ifdef CONFIG_SMP\n\tcall_single_data_t\thrtick_csd;\n#endif\n\tstruct hrtimer\t\thrtick_timer;\n#endif\n\n#ifdef CONFIG_SCHEDSTATS\n\t/* latency stats */\n\tstruct sched_info\trq_sched_info;\n\tunsigned long long\trq_cpu_time;\n\t/* could above be rq->cfs_rq.exec_clock + rq->rt_rq.rt_runtime ? */\n\n\t/* sys_sched_yield() stats */\n\tunsigned int\t\tyld_count;\n\n\t/* schedule() stats */\n\tunsigned int\t\tsched_count;\n\tunsigned int\t\tsched_goidle;\n\n\t/* try_to_wake_up() stats */\n\tunsigned int\t\tttwu_count;\n\tunsigned int\t\tttwu_local;\n#endif\n\n#ifdef CONFIG_CPU_IDLE\n\t/* Must be inspected within a rcu lock section */\n\tstruct cpuidle_state\t*idle_state;\n#endif\n\n#ifdef CONFIG_SMP\n\tunsigned int\t\tnr_pinned;\n#endif\n\tunsigned int\t\tpush_busy;\n\tstruct cpu_stop_work\tpush_work;\n};\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\n/* CPU runqueue to which this cfs_rq is attached */\nstatic inline struct rq *rq_of(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->rq;\n}\n\n#else\n\nstatic inline struct rq *rq_of(struct cfs_rq *cfs_rq)\n{\n\treturn container_of(cfs_rq, struct rq, cfs);\n}\n#endif\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}\n\n#define MDF_PUSH\t0x01\n\nstatic inline bool is_migration_disabled(struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->migration_disabled;\n#else\n\treturn false;\n#endif\n}\n\n#ifdef CONFIG_SCHED_SMT\nextern void __update_idle_core(struct rq *rq);\n\nstatic inline void update_idle_core(struct rq *rq)\n{\n\tif (static_branch_unlikely(&sched_smt_present))\n\t\t__update_idle_core(rq);\n}\n\n#else\nstatic inline void update_idle_core(struct rq *rq) { }\n#endif\n\nDECLARE_PER_CPU_SHARED_ALIGNED(struct rq, runqueues);\n\n#define cpu_rq(cpu)\t\t(&per_cpu(runqueues, (cpu)))\n#define this_rq()\t\tthis_cpu_ptr(&runqueues)\n#define task_rq(p)\t\tcpu_rq(task_cpu(p))\n#define cpu_curr(cpu)\t\t(cpu_rq(cpu)->curr)\n#define raw_rq()\t\traw_cpu_ptr(&runqueues)\n\nextern void update_rq_clock(struct rq *rq);\n\nstatic inline u64 __rq_clock_broken(struct rq *rq)\n{\n\treturn READ_ONCE(rq->clock);\n}\n\n/*\n * rq::clock_update_flags bits\n *\n * %RQCF_REQ_SKIP - will request skipping of clock update on the next\n *  call to __schedule(). This is an optimisation to avoid\n *  neighbouring rq clock updates.\n *\n * %RQCF_ACT_SKIP - is set from inside of __schedule() when skipping is\n *  in effect and calls to update_rq_clock() are being ignored.\n *\n * %RQCF_UPDATED - is a debug flag that indicates whether a call has been\n *  made to update_rq_clock() since the last time rq::lock was pinned.\n *\n * If inside of __schedule(), clock_update_flags will have been\n * shifted left (a left shift is a cheap operation for the fast path\n * to promote %RQCF_REQ_SKIP to %RQCF_ACT_SKIP), so you must use,\n *\n *\tif (rq-clock_update_flags >= RQCF_UPDATED)\n *\n * to check if %RQCF_UPADTED is set. It'll never be shifted more than\n * one position though, because the next rq_unpin_lock() will shift it\n * back.\n */\n#define RQCF_REQ_SKIP\t\t0x01\n#define RQCF_ACT_SKIP\t\t0x02\n#define RQCF_UPDATED\t\t0x04\n\nstatic inline void assert_clock_updated(struct rq *rq)\n{\n\t/*\n\t * The only reason for not seeing a clock update since the\n\t * last rq_pin_lock() is if we're currently skipping updates.\n\t */\n\tSCHED_WARN_ON(rq->clock_update_flags < RQCF_ACT_SKIP);\n}\n\nstatic inline u64 rq_clock(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock;\n}\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}\n\n/**\n * By default the decay is the default pelt decay period.\n * The decay shift can change the decay period in\n * multiples of 32.\n *  Decay shift\t\tDecay period(ms)\n *\t0\t\t\t32\n *\t1\t\t\t64\n *\t2\t\t\t128\n *\t3\t\t\t256\n *\t4\t\t\t512\n */\nextern int sched_thermal_decay_shift;\n\nstatic inline u64 rq_clock_thermal(struct rq *rq)\n{\n\treturn rq_clock_task(rq) >> sched_thermal_decay_shift;\n}\n\nstatic inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}\n\n/*\n * See rt task throttling, which is the only time a skip\n * request is cancelled.\n */\nstatic inline void rq_clock_cancel_skipupdate(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\trq->clock_update_flags &= ~RQCF_REQ_SKIP;\n}\n\nstruct rq_flags {\n\tunsigned long flags;\n\tstruct pin_cookie cookie;\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * A copy of (rq::clock_update_flags & RQCF_UPDATED) for the\n\t * current pin context is stashed here in case it needs to be\n\t * restored in rq_repin_lock().\n\t */\n\tunsigned int clock_update_flags;\n#endif\n};\n\nextern struct callback_head balance_push_callback;\n\n/*\n * Lockdep annotation that avoids accidental unlocks; it's like a\n * sticky/continuous lockdep_assert_held().\n *\n * This avoids code that has access to 'struct rq *rq' (basically everything in\n * the scheduler) from accidentally unlocking the rq if they do not also have a\n * copy of the (on-stack) 'struct rq_flags rf'.\n *\n * Also see Documentation/locking/lockdep-design.rst.\n */\nstatic inline void rq_pin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\trf->cookie = lockdep_pin_lock(&rq->lock);\n\n#ifdef CONFIG_SCHED_DEBUG\n\trq->clock_update_flags &= (RQCF_REQ_SKIP|RQCF_ACT_SKIP);\n\trf->clock_update_flags = 0;\n#ifdef CONFIG_SMP\n\tSCHED_WARN_ON(rq->balance_callback && rq->balance_callback != &balance_push_callback);\n#endif\n#endif\n}\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}\n\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\n\nstatic inline void __task_rq_unlock(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n}\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}\n\nstatic inline void\nrq_lock_irqsave(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irqsave(&rq->lock, rf->flags);\n\trq_pin_lock(rq, rf);\n}\n\nstatic inline void\nrq_lock_irq(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock_irq(&rq->lock);\n\trq_pin_lock(rq, rf);\n}\n\nstatic inline void\nrq_lock(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock(&rq->lock);\n\trq_pin_lock(rq, rf);\n}\n\nstatic inline void\nrq_relock(struct rq *rq, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\traw_spin_lock(&rq->lock);\n\trq_repin_lock(rq, rf);\n}\n\nstatic inline void\nrq_unlock_irqrestore(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irqrestore(&rq->lock, rf->flags);\n}\n\nstatic inline void\nrq_unlock_irq(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock_irq(&rq->lock);\n}\n\nstatic inline void\nrq_unlock(struct rq *rq, struct rq_flags *rf)\n\t__releases(rq->lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n}\n\nstatic inline struct rq *\nthis_rq_lock_irq(struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlocal_irq_disable();\n\trq = this_rq();\n\trq_lock(rq, rf);\n\treturn rq;\n}\n\n#ifdef CONFIG_NUMA\nenum numa_topology_type {\n\tNUMA_DIRECT,\n\tNUMA_GLUELESS_MESH,\n\tNUMA_BACKPLANE,\n};\nextern enum numa_topology_type sched_numa_topology_type;\nextern int sched_max_numa_distance;\nextern bool find_numa_distance(int distance);\nextern void sched_init_numa(void);\nextern void sched_domains_numa_masks_set(unsigned int cpu);\nextern void sched_domains_numa_masks_clear(unsigned int cpu);\nextern int sched_numa_find_closest(const struct cpumask *cpus, int cpu);\n#else\nstatic inline void sched_init_numa(void) { }\nstatic inline void sched_domains_numa_masks_set(unsigned int cpu) { }\nstatic inline void sched_domains_numa_masks_clear(unsigned int cpu) { }\nstatic inline int sched_numa_find_closest(const struct cpumask *cpus, int cpu)\n{\n\treturn nr_cpu_ids;\n}\n#endif\n\n#ifdef CONFIG_NUMA_BALANCING\n/* The regions in numa_faults array from task_struct */\nenum numa_faults_stats {\n\tNUMA_MEM = 0,\n\tNUMA_CPU,\n\tNUMA_MEMBUF,\n\tNUMA_CPUBUF\n};\nextern void sched_setnuma(struct task_struct *p, int node);\nextern int migrate_task_to(struct task_struct *p, int cpu);\nextern int migrate_swap(struct task_struct *p, struct task_struct *t,\n\t\t\tint cpu, int scpu);\nextern void init_numa_balancing(unsigned long clone_flags, struct task_struct *p);\n#else\nstatic inline void\ninit_numa_balancing(unsigned long clone_flags, struct task_struct *p)\n{\n}\n#endif /* CONFIG_NUMA_BALANCING */\n\n#ifdef CONFIG_SMP\n\nstatic inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tif (unlikely(head->next || rq->balance_callback == &balance_push_callback))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}\n\n#define rcu_dereference_check_sched_domain(p) \\\n\trcu_dereference_check((p), \\\n\t\t\t      lockdep_is_held(&sched_domains_mutex))\n\n/*\n * The domain tree (rq->sd) is protected by RCU's quiescent state transition.\n * See destroy_sched_domains: call_rcu for details.\n *\n * The domain tree of any CPU may only be accessed from within\n * preempt-disabled sections.\n */\n#define for_each_domain(cpu, __sd) \\\n\tfor (__sd = rcu_dereference_check_sched_domain(cpu_rq(cpu)->sd); \\\n\t\t\t__sd; __sd = __sd->parent)\n\n/**\n * highest_flag_domain - Return highest sched_domain containing flag.\n * @cpu:\tThe CPU whose highest level of sched domain is to\n *\t\tbe returned.\n * @flag:\tThe flag to check for the highest sched_domain\n *\t\tfor the given CPU.\n *\n * Returns the highest sched_domain of a CPU which contains the given flag.\n */\nstatic inline struct sched_domain *highest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd, *hsd = NULL;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (!(sd->flags & flag))\n\t\t\tbreak;\n\t\thsd = sd;\n\t}\n\n\treturn hsd;\n}\n\nstatic inline struct sched_domain *lowest_flag_domain(int cpu, int flag)\n{\n\tstruct sched_domain *sd;\n\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & flag)\n\t\t\tbreak;\n\t}\n\n\treturn sd;\n}\n\nDECLARE_PER_CPU(struct sched_domain __rcu *, sd_llc);\nDECLARE_PER_CPU(int, sd_llc_size);\nDECLARE_PER_CPU(int, sd_llc_id);\nDECLARE_PER_CPU(struct sched_domain_shared __rcu *, sd_llc_shared);\nDECLARE_PER_CPU(struct sched_domain __rcu *, sd_numa);\nDECLARE_PER_CPU(struct sched_domain __rcu *, sd_asym_packing);\nDECLARE_PER_CPU(struct sched_domain __rcu *, sd_asym_cpucapacity);\nextern struct static_key_false sched_asym_cpucapacity;\n\nstruct sched_group_capacity {\n\tatomic_t\t\tref;\n\t/*\n\t * CPU capacity of this group, SCHED_CAPACITY_SCALE being max capacity\n\t * for a single CPU.\n\t */\n\tunsigned long\t\tcapacity;\n\tunsigned long\t\tmin_capacity;\t\t/* Min per-CPU capacity in group */\n\tunsigned long\t\tmax_capacity;\t\t/* Max per-CPU capacity in group */\n\tunsigned long\t\tnext_update;\n\tint\t\t\timbalance;\t\t/* XXX unrelated to capacity but shared group state */\n\n#ifdef CONFIG_SCHED_DEBUG\n\tint\t\t\tid;\n#endif\n\n\tunsigned long\t\tcpumask[];\t\t/* Balance mask */\n};\n\nstruct sched_group {\n\tstruct sched_group\t*next;\t\t\t/* Must be a circular list */\n\tatomic_t\t\tref;\n\n\tunsigned int\t\tgroup_weight;\n\tstruct sched_group_capacity *sgc;\n\tint\t\t\tasym_prefer_cpu;\t/* CPU of highest priority in group */\n\n\t/*\n\t * The CPUs this group covers.\n\t *\n\t * NOTE: this field is variable length. (Allocated dynamically\n\t * by attaching extra space to the end of the structure,\n\t * depending on how many CPUs the kernel has booted up with)\n\t */\n\tunsigned long\t\tcpumask[];\n};\n\nstatic inline struct cpumask *sched_group_span(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->cpumask);\n}\n\n/*\n * See build_balance_mask().\n */\nstatic inline struct cpumask *group_balance_mask(struct sched_group *sg)\n{\n\treturn to_cpumask(sg->sgc->cpumask);\n}\n\n/**\n * group_first_cpu - Returns the first CPU in the cpumask of a sched_group.\n * @group: The group whose first CPU is to be returned.\n */\nstatic inline unsigned int group_first_cpu(struct sched_group *group)\n{\n\treturn cpumask_first(sched_group_span(group));\n}\n\nextern int group_balance_cpu(struct sched_group *sg);\n\n#if defined(CONFIG_SCHED_DEBUG) && defined(CONFIG_SYSCTL)\nvoid register_sched_domain_sysctl(void);\nvoid dirty_sched_domain_sysctl(int cpu);\nvoid unregister_sched_domain_sysctl(void);\n#else\nstatic inline void register_sched_domain_sysctl(void)\n{\n}\nstatic inline void dirty_sched_domain_sysctl(int cpu)\n{\n}\nstatic inline void unregister_sched_domain_sysctl(void)\n{\n}\n#endif\n\nextern void flush_smp_call_function_from_idle(void);\n\n#else /* !CONFIG_SMP: */\nstatic inline void flush_smp_call_function_from_idle(void) { }\n#endif\n\n#include \"stats.h\"\n#include \"autogroup.h\"\n\n#ifdef CONFIG_CGROUP_SCHED\n\n/*\n * Return the group to which this tasks belongs.\n *\n * We cannot use task_css() and friends because the cgroup subsystem\n * changes that value before the cgroup_subsys::attach() method is called,\n * therefore we cannot pin it and might observe the wrong value.\n *\n * The same is true for autogroup's p->signal->autogroup->tg, the autogroup\n * core changes this before calling sched_move_task().\n *\n * Instead we use a 'copy' which is updated from sched_move_task() while\n * holding both task_struct::pi_lock and rq::lock.\n */\nstatic inline struct task_group *task_group(struct task_struct *p)\n{\n\treturn p->sched_task_group;\n}\n\n/* Change a task's cfs_rq and parent entity if it moves across CPUs/groups */\nstatic inline void set_task_rq(struct task_struct *p, unsigned int cpu)\n{\n#if defined(CONFIG_FAIR_GROUP_SCHED) || defined(CONFIG_RT_GROUP_SCHED)\n\tstruct task_group *tg = task_group(p);\n#endif\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tset_task_rq_fair(&p->se, p->se.cfs_rq, tg->cfs_rq[cpu]);\n\tp->se.cfs_rq = tg->cfs_rq[cpu];\n\tp->se.parent = tg->se[cpu];\n#endif\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\tp->rt.rt_rq  = tg->rt_rq[cpu];\n\tp->rt.parent = tg->rt_se[cpu];\n#endif\n}\n\n#else /* CONFIG_CGROUP_SCHED */\n\nstatic inline void set_task_rq(struct task_struct *p, unsigned int cpu) { }\nstatic inline struct task_group *task_group(struct task_struct *p)\n{\n\treturn NULL;\n}\n\n#endif /* CONFIG_CGROUP_SCHED */\n\nstatic inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)\n{\n\tset_task_rq(p, cpu);\n#ifdef CONFIG_SMP\n\t/*\n\t * After ->cpu is set up to a new value, task_rq_lock(p, ...) can be\n\t * successfully executed on another CPU. We must ensure that updates of\n\t * per-task data have been completed by this moment.\n\t */\n\tsmp_wmb();\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n\tWRITE_ONCE(p->cpu, cpu);\n#else\n\tWRITE_ONCE(task_thread_info(p)->cpu, cpu);\n#endif\n\tp->wake_cpu = cpu;\n#endif\n}\n\n/*\n * Tunables that become constants when CONFIG_SCHED_DEBUG is off:\n */\n#ifdef CONFIG_SCHED_DEBUG\n# include <linux/static_key.h>\n# define const_debug __read_mostly\n#else\n# define const_debug const\n#endif\n\n#define SCHED_FEAT(name, enabled)\t\\\n\t__SCHED_FEAT_##name ,\n\nenum {\n#include \"features.h\"\n\t__SCHED_FEAT_NR,\n};\n\n#undef SCHED_FEAT\n\n#ifdef CONFIG_SCHED_DEBUG\n\n/*\n * To support run-time toggling of sched features, all the translation units\n * (but core.c) reference the sysctl_sched_features defined in core.c.\n */\nextern const_debug unsigned int sysctl_sched_features;\n\n#ifdef CONFIG_JUMP_LABEL\n#define SCHED_FEAT(name, enabled)\t\t\t\t\t\\\nstatic __always_inline bool static_branch_##name(struct static_key *key) \\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn static_key_##enabled(key);\t\t\t\t\\\n}\n\n#include \"features.h\"\n#undef SCHED_FEAT\n\nextern struct static_key sched_feat_keys[__SCHED_FEAT_NR];\n#define sched_feat(x) (static_branch_##x(&sched_feat_keys[__SCHED_FEAT_##x]))\n\n#else /* !CONFIG_JUMP_LABEL */\n\n#define sched_feat(x) (sysctl_sched_features & (1UL << __SCHED_FEAT_##x))\n\n#endif /* CONFIG_JUMP_LABEL */\n\n#else /* !SCHED_DEBUG */\n\n/*\n * Each translation unit has its own copy of sysctl_sched_features to allow\n * constants propagation at compile time and compiler optimization based on\n * features default.\n */\n#define SCHED_FEAT(name, enabled)\t\\\n\t(1UL << __SCHED_FEAT_##name) * enabled |\nstatic const_debug __maybe_unused unsigned int sysctl_sched_features =\n#include \"features.h\"\n\t0;\n#undef SCHED_FEAT\n\n#define sched_feat(x) !!(sysctl_sched_features & (1UL << __SCHED_FEAT_##x))\n\n#endif /* SCHED_DEBUG */\n\nextern struct static_key_false sched_numa_balancing;\nextern struct static_key_false sched_schedstats;\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}\n\nstatic inline int task_on_rq_migrating(struct task_struct *p)\n{\n\treturn READ_ONCE(p->on_rq) == TASK_ON_RQ_MIGRATING;\n}\n\n/* Wake flags. The first three directly map to some SD flag value */\n#define WF_EXEC     0x02 /* Wakeup after exec; maps to SD_BALANCE_EXEC */\n#define WF_FORK     0x04 /* Wakeup after fork; maps to SD_BALANCE_FORK */\n#define WF_TTWU     0x08 /* Wakeup;            maps to SD_BALANCE_WAKE */\n\n#define WF_SYNC     0x10 /* Waker goes to sleep after wakeup */\n#define WF_MIGRATED 0x20 /* Internal use, task got migrated */\n#define WF_ON_CPU   0x40 /* Wakee is on_cpu */\n\n#ifdef CONFIG_SMP\nstatic_assert(WF_EXEC == SD_BALANCE_EXEC);\nstatic_assert(WF_FORK == SD_BALANCE_FORK);\nstatic_assert(WF_TTWU == SD_BALANCE_WAKE);\n#endif\n\n/*\n * To aid in avoiding the subversion of \"niceness\" due to uneven distribution\n * of tasks with abnormal \"nice\" values across CPUs the contribution that\n * each task makes to its run queue's load is weighted according to its\n * scheduling class and \"nice\" value. For SCHED_NORMAL tasks this is just a\n * scaled version of the new time slice allocation that they receive on time\n * slice expiry etc.\n */\n\n#define WEIGHT_IDLEPRIO\t\t3\n#define WMULT_IDLEPRIO\t\t1431655765\n\nextern const int\t\tsched_prio_to_weight[40];\nextern const u32\t\tsched_prio_to_wmult[40];\n\n/*\n * {de,en}queue flags:\n *\n * DEQUEUE_SLEEP  - task is no longer runnable\n * ENQUEUE_WAKEUP - task just became runnable\n *\n * SAVE/RESTORE - an otherwise spurious dequeue/enqueue, done to ensure tasks\n *                are in a known state which allows modification. Such pairs\n *                should preserve as much state as possible.\n *\n * MOVE - paired with SAVE/RESTORE, explicitly does not preserve the location\n *        in the runqueue.\n *\n * ENQUEUE_HEAD      - place at front of runqueue (tail if not specified)\n * ENQUEUE_REPLENISH - CBS (replenish runtime and postpone deadline)\n * ENQUEUE_MIGRATED  - the task was migrated during wakeup\n *\n */\n\n#define DEQUEUE_SLEEP\t\t0x01\n#define DEQUEUE_SAVE\t\t0x02 /* Matches ENQUEUE_RESTORE */\n#define DEQUEUE_MOVE\t\t0x04 /* Matches ENQUEUE_MOVE */\n#define DEQUEUE_NOCLOCK\t\t0x08 /* Matches ENQUEUE_NOCLOCK */\n\n#define ENQUEUE_WAKEUP\t\t0x01\n#define ENQUEUE_RESTORE\t\t0x02\n#define ENQUEUE_MOVE\t\t0x04\n#define ENQUEUE_NOCLOCK\t\t0x08\n\n#define ENQUEUE_HEAD\t\t0x10\n#define ENQUEUE_REPLENISH\t0x20\n#ifdef CONFIG_SMP\n#define ENQUEUE_MIGRATED\t0x40\n#else\n#define ENQUEUE_MIGRATED\t0x00\n#endif\n\n#define RETRY_TASK\t\t((void *)-1UL)\n\nstruct sched_class {\n\n#ifdef CONFIG_UCLAMP_TASK\n\tint uclamp_enabled;\n#endif\n\n\tvoid (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n\tvoid (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n\tvoid (*yield_task)   (struct rq *rq);\n\tbool (*yield_to_task)(struct rq *rq, struct task_struct *p);\n\n\tvoid (*check_preempt_curr)(struct rq *rq, struct task_struct *p, int flags);\n\n\tstruct task_struct *(*pick_next_task)(struct rq *rq);\n\n\tvoid (*put_prev_task)(struct rq *rq, struct task_struct *p);\n\tvoid (*set_next_task)(struct rq *rq, struct task_struct *p, bool first);\n\n#ifdef CONFIG_SMP\n\tint (*balance)(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\n\tint  (*select_task_rq)(struct task_struct *p, int task_cpu, int flags);\n\tvoid (*migrate_task_rq)(struct task_struct *p, int new_cpu);\n\n\tvoid (*task_woken)(struct rq *this_rq, struct task_struct *task);\n\n\tvoid (*set_cpus_allowed)(struct task_struct *p,\n\t\t\t\t const struct cpumask *newmask,\n\t\t\t\t u32 flags);\n\n\tvoid (*rq_online)(struct rq *rq);\n\tvoid (*rq_offline)(struct rq *rq);\n\n\tstruct rq *(*find_lock_rq)(struct task_struct *p, struct rq *rq);\n#endif\n\n\tvoid (*task_tick)(struct rq *rq, struct task_struct *p, int queued);\n\tvoid (*task_fork)(struct task_struct *p);\n\tvoid (*task_dead)(struct task_struct *p);\n\n\t/*\n\t * The switched_from() call is allowed to drop rq->lock, therefore we\n\t * cannot assume the switched_from/switched_to pair is serliazed by\n\t * rq->lock. They are however serialized by p->pi_lock.\n\t */\n\tvoid (*switched_from)(struct rq *this_rq, struct task_struct *task);\n\tvoid (*switched_to)  (struct rq *this_rq, struct task_struct *task);\n\tvoid (*prio_changed) (struct rq *this_rq, struct task_struct *task,\n\t\t\t      int oldprio);\n\n\tunsigned int (*get_rr_interval)(struct rq *rq,\n\t\t\t\t\tstruct task_struct *task);\n\n\tvoid (*update_curr)(struct rq *rq);\n\n#define TASK_SET_GROUP\t\t0\n#define TASK_MOVE_GROUP\t\t1\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\tvoid (*task_change_group)(struct task_struct *p, int type);\n#endif\n};\n\nstatic inline void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tWARN_ON_ONCE(rq->curr != prev);\n\tprev->sched_class->put_prev_task(rq, prev);\n}\n\nstatic inline void set_next_task(struct rq *rq, struct task_struct *next)\n{\n\tWARN_ON_ONCE(rq->curr != next);\n\tnext->sched_class->set_next_task(rq, next, false);\n}\n\n\n/*\n * Helper to define a sched_class instance; each one is placed in a separate\n * section which is ordered by the linker script:\n *\n *   include/asm-generic/vmlinux.lds.h\n *\n * Also enforce alignment on the instance, not the type, to guarantee layout.\n */\n#define DEFINE_SCHED_CLASS(name) \\\nconst struct sched_class name##_sched_class \\\n\t__aligned(__alignof__(struct sched_class)) \\\n\t__section(\"__\" #name \"_sched_class\")\n\n/* Defined in include/asm-generic/vmlinux.lds.h */\nextern struct sched_class __begin_sched_classes[];\nextern struct sched_class __end_sched_classes[];\n\n#define sched_class_highest (__end_sched_classes - 1)\n#define sched_class_lowest  (__begin_sched_classes - 1)\n\n#define for_class_range(class, _from, _to) \\\n\tfor (class = (_from); class != (_to); class--)\n\n#define for_each_class(class) \\\n\tfor_class_range(class, sched_class_highest, sched_class_lowest)\n\nextern const struct sched_class stop_sched_class;\nextern const struct sched_class dl_sched_class;\nextern const struct sched_class rt_sched_class;\nextern const struct sched_class fair_sched_class;\nextern const struct sched_class idle_sched_class;\n\nstatic inline bool sched_stop_runnable(struct rq *rq)\n{\n\treturn rq->stop && task_on_rq_queued(rq->stop);\n}\n\nstatic inline bool sched_dl_runnable(struct rq *rq)\n{\n\treturn rq->dl.dl_nr_running > 0;\n}\n\nstatic inline bool sched_rt_runnable(struct rq *rq)\n{\n\treturn rq->rt.rt_queued > 0;\n}\n\nstatic inline bool sched_fair_runnable(struct rq *rq)\n{\n\treturn rq->cfs.nr_running > 0;\n}\n\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\n\n#define SCA_CHECK\t\t0x01\n#define SCA_MIGRATE_DISABLE\t0x02\n#define SCA_MIGRATE_ENABLE\t0x04\n\n#ifdef CONFIG_SMP\n\nextern void update_group_capacity(struct sched_domain *sd, int cpu);\n\nextern void trigger_load_balance(struct rq *rq);\n\nextern void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask, u32 flags);\n\nstatic inline struct task_struct *get_push_task(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->push_busy)\n\t\treturn NULL;\n\n\tif (p->nr_cpus_allowed == 1)\n\t\treturn NULL;\n\n\trq->push_busy = true;\n\treturn get_task_struct(p);\n}\n\nextern int push_cpu_stop(void *arg);\n\n#endif\n\n#ifdef CONFIG_CPU_IDLE\nstatic inline void idle_set_state(struct rq *rq,\n\t\t\t\t  struct cpuidle_state *idle_state)\n{\n\trq->idle_state = idle_state;\n}\n\nstatic inline struct cpuidle_state *idle_get_state(struct rq *rq)\n{\n\tSCHED_WARN_ON(!rcu_read_lock_held());\n\n\treturn rq->idle_state;\n}\n#else\nstatic inline void idle_set_state(struct rq *rq,\n\t\t\t\t  struct cpuidle_state *idle_state)\n{\n}\n\nstatic inline struct cpuidle_state *idle_get_state(struct rq *rq)\n{\n\treturn NULL;\n}\n#endif\n\nextern void schedule_idle(void);\n\nextern void sysrq_sched_debug_show(void);\nextern void sched_init_granularity(void);\nextern void update_max_interval(void);\n\nextern void init_sched_dl_class(void);\nextern void init_sched_rt_class(void);\nextern void init_sched_fair_class(void);\n\nextern void reweight_task(struct task_struct *p, int prio);\n\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nextern struct rt_bandwidth def_rt_bandwidth;\nextern void init_rt_bandwidth(struct rt_bandwidth *rt_b, u64 period, u64 runtime);\n\nextern struct dl_bandwidth def_dl_bandwidth;\nextern void init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime);\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\n\n#define BW_SHIFT\t\t20\n#define BW_UNIT\t\t\t(1 << BW_SHIFT)\n#define RATIO_SHIFT\t\t8\n#define MAX_BW_BITS\t\t(64 - BW_SHIFT)\n#define MAX_BW\t\t\t((1ULL << MAX_BW_BITS) - 1)\nunsigned long to_ratio(u64 period, u64 runtime);\n\nextern void init_entity_runnable_average(struct sched_entity *se);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\n#ifdef CONFIG_NO_HZ_FULL\nextern bool sched_can_stop_tick(struct rq *rq);\nextern int __init sched_tick_offload_init(void);\n\n/*\n * Tick may be needed by tasks in the runqueue depending on their policy and\n * requirements. If tick is needed, lets send the target an IPI to kick it out of\n * nohz mode if necessary.\n */\nstatic inline void sched_update_tick_dependency(struct rq *rq)\n{\n\tint cpu = cpu_of(rq);\n\n\tif (!tick_nohz_full_cpu(cpu))\n\t\treturn;\n\n\tif (sched_can_stop_tick(rq))\n\t\ttick_nohz_dep_clear_cpu(cpu, TICK_DEP_BIT_SCHED);\n\telse\n\t\ttick_nohz_dep_set_cpu(cpu, TICK_DEP_BIT_SCHED);\n}\n#else\nstatic inline int sched_tick_offload_init(void) { return 0; }\nstatic inline void sched_update_tick_dependency(struct rq *rq) { }\n#endif\n\nstatic inline void add_nr_running(struct rq *rq, unsigned count)\n{\n\tunsigned prev_nr = rq->nr_running;\n\n\trq->nr_running = prev_nr + count;\n\tif (trace_sched_update_nr_running_tp_enabled()) {\n\t\tcall_trace_sched_update_nr_running(rq, count);\n\t}\n\n#ifdef CONFIG_SMP\n\tif (prev_nr < 2 && rq->nr_running >= 2) {\n\t\tif (!READ_ONCE(rq->rd->overload))\n\t\t\tWRITE_ONCE(rq->rd->overload, 1);\n\t}\n#endif\n\n\tsched_update_tick_dependency(rq);\n}\n\nstatic inline void sub_nr_running(struct rq *rq, unsigned count)\n{\n\trq->nr_running -= count;\n\tif (trace_sched_update_nr_running_tp_enabled()) {\n\t\tcall_trace_sched_update_nr_running(rq, -count);\n\t}\n\n\t/* Check if we still need preemption */\n\tsched_update_tick_dependency(rq);\n}\n\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\n\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nextern const_debug unsigned int sysctl_sched_nr_migrate;\nextern const_debug unsigned int sysctl_sched_migration_cost;\n\n#ifdef CONFIG_SCHED_HRTICK\n\n/*\n * Use hrtick when:\n *  - enabled by features\n *  - hrtimer is actually high res\n */\nstatic inline int hrtick_enabled(struct rq *rq)\n{\n\tif (!sched_feat(HRTICK))\n\t\treturn 0;\n\tif (!cpu_active(cpu_of(rq)))\n\t\treturn 0;\n\treturn hrtimer_is_hres_active(&rq->hrtick_timer);\n}\n\nvoid hrtick_start(struct rq *rq, u64 delay);\n\n#else\n\nstatic inline int hrtick_enabled(struct rq *rq)\n{\n\treturn 0;\n}\n\n#endif /* CONFIG_SCHED_HRTICK */\n\n#ifndef arch_scale_freq_tick\nstatic __always_inline\nvoid arch_scale_freq_tick(void)\n{\n}\n#endif\n\n#ifndef arch_scale_freq_capacity\n/**\n * arch_scale_freq_capacity - get the frequency scale factor of a given CPU.\n * @cpu: the CPU in question.\n *\n * Return: the frequency scale factor normalized against SCHED_CAPACITY_SCALE, i.e.\n *\n *     f_curr\n *     ------ * SCHED_CAPACITY_SCALE\n *     f_max\n */\nstatic __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}\n#endif\n\n#ifdef CONFIG_SMP\n#ifdef CONFIG_PREEMPTION\n\nstatic inline void double_rq_lock(struct rq *rq1, struct rq *rq2);\n\n/*\n * fair double_lock_balance: Safely acquires both rq->locks in a fair\n * way at the expense of forcing extra atomic operations in all\n * invocations.  This assures that the double_lock is acquired using the\n * same underlying policy as the spinlock_t on this architecture, which\n * reduces latency compared to the unfair variant below.  However, it\n * also adds more overhead and therefore may reduce throughput.\n */\nstatic inline int _double_lock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(this_rq->lock)\n\t__acquires(busiest->lock)\n\t__acquires(this_rq->lock)\n{\n\traw_spin_unlock(&this_rq->lock);\n\tdouble_rq_lock(this_rq, busiest);\n\n\treturn 1;\n}\n\n#else\n/*\n * Unfair double_lock_balance: Optimizes throughput at the expense of\n * latency by eliminating extra atomic operations when the locks are\n * already in proper order on entry.  This favors lower CPU-ids and will\n * grant the double lock to lower CPUs over higher ids under contention,\n * regardless of entry order into the function.\n */\nstatic inline int _double_lock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(this_rq->lock)\n\t__acquires(busiest->lock)\n\t__acquires(this_rq->lock)\n{\n\tint ret = 0;\n\n\tif (unlikely(!raw_spin_trylock(&busiest->lock))) {\n\t\tif (busiest < this_rq) {\n\t\t\traw_spin_unlock(&this_rq->lock);\n\t\t\traw_spin_lock(&busiest->lock);\n\t\t\traw_spin_lock_nested(&this_rq->lock,\n\t\t\t\t\t      SINGLE_DEPTH_NESTING);\n\t\t\tret = 1;\n\t\t} else\n\t\t\traw_spin_lock_nested(&busiest->lock,\n\t\t\t\t\t      SINGLE_DEPTH_NESTING);\n\t}\n\treturn ret;\n}\n\n#endif /* CONFIG_PREEMPTION */\n\n/*\n * double_lock_balance - lock the busiest runqueue, this_rq is locked already.\n */\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}\n\nstatic inline void double_lock(spinlock_t *l1, spinlock_t *l2)\n{\n\tif (l1 > l2)\n\t\tswap(l1, l2);\n\n\tspin_lock(l1);\n\tspin_lock_nested(l2, SINGLE_DEPTH_NESTING);\n}\n\nstatic inline void double_lock_irq(spinlock_t *l1, spinlock_t *l2)\n{\n\tif (l1 > l2)\n\t\tswap(l1, l2);\n\n\tspin_lock_irq(l1);\n\tspin_lock_nested(l2, SINGLE_DEPTH_NESTING);\n}\n\nstatic inline void double_raw_lock(raw_spinlock_t *l1, raw_spinlock_t *l2)\n{\n\tif (l1 > l2)\n\t\tswap(l1, l2);\n\n\traw_spin_lock(l1);\n\traw_spin_lock_nested(l2, SINGLE_DEPTH_NESTING);\n}\n\n/*\n * double_rq_lock - safely lock two runqueues\n *\n * Note this does not disable interrupts like task_rq_lock,\n * you need to do so manually before calling.\n */\nstatic inline void double_rq_lock(struct rq *rq1, struct rq *rq2)\n\t__acquires(rq1->lock)\n\t__acquires(rq2->lock)\n{\n\tBUG_ON(!irqs_disabled());\n\tif (rq1 == rq2) {\n\t\traw_spin_lock(&rq1->lock);\n\t\t__acquire(rq2->lock);\t/* Fake it out ;) */\n\t} else {\n\t\tif (rq1 < rq2) {\n\t\t\traw_spin_lock(&rq1->lock);\n\t\t\traw_spin_lock_nested(&rq2->lock, SINGLE_DEPTH_NESTING);\n\t\t} else {\n\t\t\traw_spin_lock(&rq2->lock);\n\t\t\traw_spin_lock_nested(&rq1->lock, SINGLE_DEPTH_NESTING);\n\t\t}\n\t}\n}\n\n/*\n * double_rq_unlock - safely unlock two runqueues\n *\n * Note this does not restore interrupts like task_rq_unlock,\n * you need to do so manually after calling.\n */\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\traw_spin_unlock(&rq1->lock);\n\tif (rq1 != rq2)\n\t\traw_spin_unlock(&rq2->lock);\n\telse\n\t\t__release(rq2->lock);\n}\n\nextern void set_rq_online (struct rq *rq);\nextern void set_rq_offline(struct rq *rq);\nextern bool sched_smp_initialized;\n\n#else /* CONFIG_SMP */\n\n/*\n * double_rq_lock - safely lock two runqueues\n *\n * Note this does not disable interrupts like task_rq_lock,\n * you need to do so manually before calling.\n */\nstatic inline void double_rq_lock(struct rq *rq1, struct rq *rq2)\n\t__acquires(rq1->lock)\n\t__acquires(rq2->lock)\n{\n\tBUG_ON(!irqs_disabled());\n\tBUG_ON(rq1 != rq2);\n\traw_spin_lock(&rq1->lock);\n\t__acquire(rq2->lock);\t/* Fake it out ;) */\n}\n\n/*\n * double_rq_unlock - safely unlock two runqueues\n *\n * Note this does not restore interrupts like task_rq_unlock,\n * you need to do so manually after calling.\n */\nstatic inline void double_rq_unlock(struct rq *rq1, struct rq *rq2)\n\t__releases(rq1->lock)\n\t__releases(rq2->lock)\n{\n\tBUG_ON(rq1 != rq2);\n\traw_spin_unlock(&rq1->lock);\n\t__release(rq2->lock);\n}\n\n#endif\n\nextern struct sched_entity *__pick_first_entity(struct cfs_rq *cfs_rq);\nextern struct sched_entity *__pick_last_entity(struct cfs_rq *cfs_rq);\n\n#ifdef\tCONFIG_SCHED_DEBUG\nextern bool sched_debug_enabled;\n\nextern void print_cfs_stats(struct seq_file *m, int cpu);\nextern void print_rt_stats(struct seq_file *m, int cpu);\nextern void print_dl_stats(struct seq_file *m, int cpu);\nextern void print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq);\nextern void print_rt_rq(struct seq_file *m, int cpu, struct rt_rq *rt_rq);\nextern void print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq);\n#ifdef CONFIG_NUMA_BALANCING\nextern void\nshow_numa_stats(struct task_struct *p, struct seq_file *m);\nextern void\nprint_numa_stats(struct seq_file *m, int node, unsigned long tsf,\n\tunsigned long tpf, unsigned long gsf, unsigned long gpf);\n#endif /* CONFIG_NUMA_BALANCING */\n#endif /* CONFIG_SCHED_DEBUG */\n\nextern void init_cfs_rq(struct cfs_rq *cfs_rq);\nextern void init_rt_rq(struct rt_rq *rt_rq);\nextern void init_dl_rq(struct dl_rq *dl_rq);\n\nextern void cfs_bandwidth_usage_inc(void);\nextern void cfs_bandwidth_usage_dec(void);\n\n#ifdef CONFIG_NO_HZ_COMMON\n#define NOHZ_BALANCE_KICK_BIT\t0\n#define NOHZ_STATS_KICK_BIT\t1\n\n#define NOHZ_BALANCE_KICK\tBIT(NOHZ_BALANCE_KICK_BIT)\n#define NOHZ_STATS_KICK\t\tBIT(NOHZ_STATS_KICK_BIT)\n\n#define NOHZ_KICK_MASK\t(NOHZ_BALANCE_KICK | NOHZ_STATS_KICK)\n\n#define nohz_flags(cpu)\t(&cpu_rq(cpu)->nohz_flags)\n\nextern void nohz_balance_exit_idle(struct rq *rq);\n#else\nstatic inline void nohz_balance_exit_idle(struct rq *rq) { }\n#endif\n\n\n#ifdef CONFIG_SMP\nstatic inline\nvoid __dl_update(struct dl_bw *dl_b, s64 bw)\n{\n\tstruct root_domain *rd = container_of(dl_b, struct root_domain, dl_bw);\n\tint i;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask) {\n\t\tstruct rq *rq = cpu_rq(i);\n\n\t\trq->dl.extra_bw += bw;\n\t}\n}\n#else\nstatic inline\nvoid __dl_update(struct dl_bw *dl_b, s64 bw)\n{\n\tstruct dl_rq *dl = container_of(dl_b, struct dl_rq, dl_bw);\n\n\tdl->extra_bw += bw;\n}\n#endif\n\n\n#ifdef CONFIG_IRQ_TIME_ACCOUNTING\nstruct irqtime {\n\tu64\t\t\ttotal;\n\tu64\t\t\ttick_delta;\n\tu64\t\t\tirq_start_time;\n\tstruct u64_stats_sync\tsync;\n};\n\nDECLARE_PER_CPU(struct irqtime, cpu_irqtime);\n\n/*\n * Returns the irqtime minus the softirq time computed by ksoftirqd.\n * Otherwise ksoftirqd's sum_exec_runtime is substracted its own runtime\n * and never move forward.\n */\nstatic inline u64 irq_time_read(int cpu)\n{\n\tstruct irqtime *irqtime = &per_cpu(cpu_irqtime, cpu);\n\tunsigned int seq;\n\tu64 total;\n\n\tdo {\n\t\tseq = __u64_stats_fetch_begin(&irqtime->sync);\n\t\ttotal = irqtime->total;\n\t} while (__u64_stats_fetch_retry(&irqtime->sync, seq));\n\n\treturn total;\n}\n#endif /* CONFIG_IRQ_TIME_ACCOUNTING */\n\n#ifdef CONFIG_CPU_FREQ\nDECLARE_PER_CPU(struct update_util_data __rcu *, cpufreq_update_util_data);\n\n/**\n * cpufreq_update_util - Take a note about CPU utilization changes.\n * @rq: Runqueue to carry out the update for.\n * @flags: Update reason flags.\n *\n * This function is called by the scheduler on the CPU whose utilization is\n * being updated.\n *\n * It can only be called from RCU-sched read-side critical sections.\n *\n * The way cpufreq is currently arranged requires it to evaluate the CPU\n * performance state (frequency/voltage) on a regular basis to prevent it from\n * being stuck in a completely inadequate performance level for too long.\n * That is not guaranteed to happen if the updates are only triggered from CFS\n * and DL, though, because they may not be coming in if only RT tasks are\n * active all the time (or there are RT tasks only).\n *\n * As a workaround for that issue, this function is called periodically by the\n * RT sched class to trigger extra cpufreq updates to prevent it from stalling,\n * but that really is a band-aid.  Going forward it should be replaced with\n * solutions targeted more specifically at RT tasks.\n */\nstatic inline void cpufreq_update_util(struct rq *rq, unsigned int flags)\n{\n\tstruct update_util_data *data;\n\n\tdata = rcu_dereference_sched(*per_cpu_ptr(&cpufreq_update_util_data,\n\t\t\t\t\t\t  cpu_of(rq)));\n\tif (data)\n\t\tdata->func(data, rq_clock(rq), flags);\n}\n#else\nstatic inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}\n#endif /* CONFIG_CPU_FREQ */\n\n#ifdef CONFIG_UCLAMP_TASK\nunsigned long uclamp_eff_value(struct task_struct *p, enum uclamp_id clamp_id);\n\n/**\n * uclamp_rq_util_with - clamp @util with @rq and @p effective uclamp values.\n * @rq:\t\tThe rq to clamp against. Must not be NULL.\n * @util:\tThe util value to clamp.\n * @p:\t\tThe task to clamp against. Can be NULL if you want to clamp\n *\t\tagainst @rq only.\n *\n * Clamps the passed @util to the max(@rq, @p) effective uclamp values.\n *\n * If sched_uclamp_used static key is disabled, then just return the util\n * without any clamping since uclamp aggregation at the rq level in the fast\n * path is disabled, rendering this operation a NOP.\n *\n * Use uclamp_eff_value() if you don't care about uclamp values at rq level. It\n * will return the correct effective uclamp value of the task even if the\n * static key is disabled.\n */\nstatic __always_inline\nunsigned long uclamp_rq_util_with(struct rq *rq, unsigned long util,\n\t\t\t\t  struct task_struct *p)\n{\n\tunsigned long min_util;\n\tunsigned long max_util;\n\n\tif (!static_branch_likely(&sched_uclamp_used))\n\t\treturn util;\n\n\tmin_util = READ_ONCE(rq->uclamp[UCLAMP_MIN].value);\n\tmax_util = READ_ONCE(rq->uclamp[UCLAMP_MAX].value);\n\n\tif (p) {\n\t\tmin_util = max(min_util, uclamp_eff_value(p, UCLAMP_MIN));\n\t\tmax_util = max(max_util, uclamp_eff_value(p, UCLAMP_MAX));\n\t}\n\n\t/*\n\t * Since CPU's {min,max}_util clamps are MAX aggregated considering\n\t * RUNNABLE tasks with _different_ clamps, we can end up with an\n\t * inversion. Fix it now when the clamps are applied.\n\t */\n\tif (unlikely(min_util >= max_util))\n\t\treturn min_util;\n\n\treturn clamp(util, min_util, max_util);\n}\n\n/*\n * When uclamp is compiled in, the aggregation at rq level is 'turned off'\n * by default in the fast path and only gets turned on once userspace performs\n * an operation that requires it.\n *\n * Returns true if userspace opted-in to use uclamp and aggregation at rq level\n * hence is active.\n */\nstatic inline bool uclamp_is_used(void)\n{\n\treturn static_branch_likely(&sched_uclamp_used);\n}\n#else /* CONFIG_UCLAMP_TASK */\nstatic inline\nunsigned long uclamp_rq_util_with(struct rq *rq, unsigned long util,\n\t\t\t\t  struct task_struct *p)\n{\n\treturn util;\n}\n\nstatic inline bool uclamp_is_used(void)\n{\n\treturn false;\n}\n#endif /* CONFIG_UCLAMP_TASK */\n\n#ifdef arch_scale_freq_capacity\n# ifndef arch_scale_freq_invariant\n#  define arch_scale_freq_invariant()\ttrue\n# endif\n#else\n# define arch_scale_freq_invariant()\tfalse\n#endif\n\n#ifdef CONFIG_SMP\nstatic inline unsigned long capacity_orig_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity_orig;\n}\n\n/**\n * enum cpu_util_type - CPU utilization type\n * @FREQUENCY_UTIL:\tUtilization used to select frequency\n * @ENERGY_UTIL:\tUtilization used during energy calculation\n *\n * The utilization signals of all scheduling classes (CFS/RT/DL) and IRQ time\n * need to be aggregated differently depending on the usage made of them. This\n * enum is used within effective_cpu_util() to differentiate the types of\n * utilization expected by the callers, and adjust the aggregation accordingly.\n */\nenum cpu_util_type {\n\tFREQUENCY_UTIL,\n\tENERGY_UTIL,\n};\n\nunsigned long effective_cpu_util(int cpu, unsigned long util_cfs,\n\t\t\t\t unsigned long max, enum cpu_util_type type,\n\t\t\t\t struct task_struct *p);\n\nstatic inline unsigned long cpu_bw_dl(struct rq *rq)\n{\n\treturn (rq->dl.running_bw * SCHED_CAPACITY_SCALE) >> BW_SHIFT;\n}\n\nstatic inline unsigned long cpu_util_dl(struct rq *rq)\n{\n\treturn READ_ONCE(rq->avg_dl.util_avg);\n}\n\nstatic inline unsigned long cpu_util_cfs(struct rq *rq)\n{\n\tunsigned long util = READ_ONCE(rq->cfs.avg.util_avg);\n\n\tif (sched_feat(UTIL_EST)) {\n\t\tutil = max_t(unsigned long, util,\n\t\t\t     READ_ONCE(rq->cfs.avg.util_est.enqueued));\n\t}\n\n\treturn util;\n}\n\nstatic inline unsigned long cpu_util_rt(struct rq *rq)\n{\n\treturn READ_ONCE(rq->avg_rt.util_avg);\n}\n#endif\n\n#ifdef CONFIG_HAVE_SCHED_AVG_IRQ\nstatic inline unsigned long cpu_util_irq(struct rq *rq)\n{\n\treturn rq->avg_irq.util_avg;\n}\n\nstatic inline\nunsigned long scale_irq_capacity(unsigned long util, unsigned long irq, unsigned long max)\n{\n\tutil *= (max - irq);\n\tutil /= max;\n\n\treturn util;\n\n}\n#else\nstatic inline unsigned long cpu_util_irq(struct rq *rq)\n{\n\treturn 0;\n}\n\nstatic inline\nunsigned long scale_irq_capacity(unsigned long util, unsigned long irq, unsigned long max)\n{\n\treturn util;\n}\n#endif\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\n#define perf_domain_span(pd) (to_cpumask(((pd)->em_pd->cpus)))\n\nDECLARE_STATIC_KEY_FALSE(sched_energy_present);\n\nstatic inline bool sched_energy_enabled(void)\n{\n\treturn static_branch_unlikely(&sched_energy_present);\n}\n\n#else /* ! (CONFIG_ENERGY_MODEL && CONFIG_CPU_FREQ_GOV_SCHEDUTIL) */\n\n#define perf_domain_span(pd) NULL\nstatic inline bool sched_energy_enabled(void) { return false; }\n\n#endif /* CONFIG_ENERGY_MODEL && CONFIG_CPU_FREQ_GOV_SCHEDUTIL */\n\n#ifdef CONFIG_MEMBARRIER\n/*\n * The scheduler provides memory barriers required by membarrier between:\n * - prior user-space memory accesses and store to rq->membarrier_state,\n * - store to rq->membarrier_state and following user-space memory accesses.\n * In the same way it provides those guarantees around store to rq->curr.\n */\nstatic inline void membarrier_switch_mm(struct rq *rq,\n\t\t\t\t\tstruct mm_struct *prev_mm,\n\t\t\t\t\tstruct mm_struct *next_mm)\n{\n\tint membarrier_state;\n\n\tif (prev_mm == next_mm)\n\t\treturn;\n\n\tmembarrier_state = atomic_read(&next_mm->membarrier_state);\n\tif (READ_ONCE(rq->membarrier_state) == membarrier_state)\n\t\treturn;\n\n\tWRITE_ONCE(rq->membarrier_state, membarrier_state);\n}\n#else\nstatic inline void membarrier_switch_mm(struct rq *rq,\n\t\t\t\t\tstruct mm_struct *prev_mm,\n\t\t\t\t\tstruct mm_struct *next_mm)\n{\n}\n#endif\n\n#ifdef CONFIG_SMP\nstatic inline bool is_per_cpu_kthread(struct task_struct *p)\n{\n\tif (!(p->flags & PF_KTHREAD))\n\t\treturn false;\n\n\tif (p->nr_cpus_allowed != 1)\n\t\treturn false;\n\n\treturn true;\n}\n#endif\n\nvoid swake_up_all_locked(struct swait_queue_head *q);\nvoid __prepare_to_swait(struct swait_queue_head *q, struct swait_queue *wait);\n"}, "2": {"id": 2, "path": "/src/include/linux/stddef.h", "content": "/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _LINUX_STDDEF_H\n#define _LINUX_STDDEF_H\n\n#include <uapi/linux/stddef.h>\n\n#undef NULL\n#define NULL ((void *)0)\n\nenum {\n\tfalse\t= 0,\n\ttrue\t= 1\n};\n\n#undef offsetof\n#ifdef __compiler_offsetof\n#define offsetof(TYPE, MEMBER)\t__compiler_offsetof(TYPE, MEMBER)\n#else\n#define offsetof(TYPE, MEMBER)\t((size_t)&((TYPE *)0)->MEMBER)\n#endif\n\n/**\n * sizeof_field(TYPE, MEMBER)\n *\n * @TYPE: The structure containing the field of interest\n * @MEMBER: The field to return the size of\n */\n#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))\n\n/**\n * offsetofend(TYPE, MEMBER)\n *\n * @TYPE: The type of the structure\n * @MEMBER: The member within the structure to get the end offset of\n */\n#define offsetofend(TYPE, MEMBER) \\\n\t(offsetof(TYPE, MEMBER)\t+ sizeof_field(TYPE, MEMBER))\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 0, "line": 7183}, "message": "Calling 'pick_next_task_fair'"}, {"location": {"col": 7, "file": 0, "line": 7046}, "message": "Calling 'sched_fair_runnable'"}, {"location": {"col": 9, "file": 1, "line": 1938}, "message": "Assuming field 'nr_running' is > 0"}, {"location": {"col": 2, "file": 1, "line": 1938}, "message": "Returning without writing to 'rq->cfs.tasks_timeline.rb_leftmost', which participates in a condition later"}, {"location": {"col": 2, "file": 1, "line": 1938}, "message": "Returning without writing to 'rq->cfs.next', which participates in a condition later"}, {"location": {"col": 7, "file": 0, "line": 7046}, "message": "Returning from 'sched_fair_runnable'"}, {"location": {"col": 2, "file": 0, "line": 7046}, "message": "Taking false branch"}, {"location": {"col": 7, "file": 0, "line": 7050}, "message": "'prev' is null"}, {"location": {"col": 12, "file": 0, "line": 7050}, "message": "Left side of '||' is true"}, {"location": {"col": 3, "file": 0, "line": 7051}, "message": "Control jumps to line 7127"}, {"location": {"col": 6, "file": 0, "line": 7127}, "message": "'prev' is null"}, {"location": {"col": 2, "file": 0, "line": 7127}, "message": "Taking false branch"}, {"location": {"col": 33, "file": 0, "line": 7131}, "message": "Passing null pointer value via 2nd parameter 'curr'"}, {"location": {"col": 14, "file": 2, "line": 8}, "message": "expanded from macro 'NULL'"}, {"location": {"col": 8, "file": 0, "line": 7131}, "message": "Calling 'pick_next_entity'"}, {"location": {"col": 30, "file": 0, "line": 4459}, "message": "Calling '__pick_first_entity'"}, {"location": {"col": 6, "file": 0, "line": 614}, "message": "Assuming 'left' is null"}, {"location": {"col": 2, "file": 0, "line": 614}, "message": "Taking true branch"}, {"location": {"col": 3, "file": 0, "line": 615}, "message": "Returning without writing to 'cfs_rq->next', which participates in a condition later"}, {"location": {"col": 3, "file": 0, "line": 615}, "message": "Returning null pointer, which participates in a condition later"}, {"location": {"col": 30, "file": 0, "line": 4459}, "message": "Returning from '__pick_first_entity'"}, {"location": {"col": 7, "file": 0, "line": 4466}, "message": "'left' is null"}, {"location": {"col": 12, "file": 0, "line": 4466}, "message": "Left side of '||' is true"}, {"location": {"col": 3, "file": 0, "line": 4467}, "message": "Null pointer value stored to 'left'"}, {"location": {"col": 6, "file": 0, "line": 4475}, "message": "Assuming 'se' is not equal to field 'skip'"}, {"location": {"col": 2, "file": 0, "line": 4475}, "message": "Taking false branch"}, {"location": {"col": 6, "file": 0, "line": 4490}, "message": "Assuming field 'next' is non-null"}, {"location": {"col": 6, "file": 0, "line": 4490}, "message": "Left side of '&&' is true"}, {"location": {"col": 58, "file": 0, "line": 4490}, "message": "Passing null pointer value via 2nd parameter 'se'"}, {"location": {"col": 22, "file": 0, "line": 4490}, "message": "Calling 'wakeup_preempt_entity'"}, {"location": {"col": 37, "file": 0, "line": 6909}, "message": "Access to field 'vruntime' results in a dereference of a null pointer (loaded from variable 'se')"}, {"location": {"col": 37, "file": 0, "line": 6909}, "message": "Access to field 'vruntime' results in a dereference of a null pointer (loaded from variable 'se')"}], "macros": [], "notes": [], "path": "/src/kernel/sched/fair.c", "reportHash": "4f4bc9a780ae459440344a5ecfcedae7", "checkerName": "clang-analyzer-core.NullDereference", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
