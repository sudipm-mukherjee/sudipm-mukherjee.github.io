<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/md/raid10.c", "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * raid10.c : Multiple Devices driver for Linux\n *\n * Copyright (C) 2000-2004 Neil Brown\n *\n * RAID-10 support for md.\n *\n * Base on code in raid1.c.  See raid1.c for further copyright information.\n */\n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/ratelimit.h>\n#include <linux/kthread.h>\n#include <linux/raid/md_p.h>\n#include <trace/events/block.h>\n#include \"md.h\"\n#include \"raid10.h\"\n#include \"raid0.h\"\n#include \"md-bitmap.h\"\n\n/*\n * RAID10 provides a combination of RAID0 and RAID1 functionality.\n * The layout of data is defined by\n *    chunk_size\n *    raid_disks\n *    near_copies (stored in low byte of layout)\n *    far_copies (stored in second byte of layout)\n *    far_offset (stored in bit 16 of layout )\n *    use_far_sets (stored in bit 17 of layout )\n *    use_far_sets_bugfixed (stored in bit 18 of layout )\n *\n * The data to be stored is divided into chunks using chunksize.  Each device\n * is divided into far_copies sections.   In each section, chunks are laid out\n * in a style similar to raid0, but near_copies copies of each chunk is stored\n * (each on a different drive).  The starting device for each section is offset\n * near_copies from the starting device of the previous section.  Thus there\n * are (near_copies * far_copies) of each chunk, and each is on a different\n * drive.  near_copies and far_copies must be at least one, and their product\n * is at most raid_disks.\n *\n * If far_offset is true, then the far_copies are handled a bit differently.\n * The copies are still in different stripes, but instead of being very far\n * apart on disk, there are adjacent stripes.\n *\n * The far and offset algorithms are handled slightly differently if\n * 'use_far_sets' is true.  In this case, the array's devices are grouped into\n * sets that are (near_copies * far_copies) in size.  The far copied stripes\n * are still shifted by 'near_copies' devices, but this shifting stays confined\n * to the set rather than the entire array.  This is done to improve the number\n * of device combinations that can fail without causing the array to fail.\n * Example 'far' algorithm w/o 'use_far_sets' (each letter represents a chunk\n * on a device):\n *    A B C D    A B C D E\n *      ...         ...\n *    D A B C    E A B C D\n * Example 'far' algorithm w/ 'use_far_sets' enabled (sets illustrated w/ []'s):\n *    [A B] [C D]    [A B] [C D E]\n *    |...| |...|    |...| | ... |\n *    [B A] [D C]    [B A] [E C D]\n */\n\nstatic void allow_barrier(struct r10conf *conf);\nstatic void lower_barrier(struct r10conf *conf);\nstatic int _enough(struct r10conf *conf, int previous, int ignore);\nstatic int enough(struct r10conf *conf, int ignore);\nstatic sector_t reshape_request(struct mddev *mddev, sector_t sector_nr,\n\t\t\t\tint *skipped);\nstatic void reshape_request_write(struct mddev *mddev, struct r10bio *r10_bio);\nstatic void end_reshape_write(struct bio *bio);\nstatic void end_reshape(struct r10conf *conf);\n\n#define raid10_log(md, fmt, args...)\t\t\t\t\\\n\tdo { if ((md)->queue) blk_add_trace_msg((md)->queue, \"raid10 \" fmt, ##args); } while (0)\n\n#include \"raid1-10.c\"\n\n/*\n * for resync bio, r10bio pointer can be retrieved from the per-bio\n * 'struct resync_pages'.\n */\nstatic inline struct r10bio *get_resync_r10bio(struct bio *bio)\n{\n\treturn get_resync_pages(bio)->raid_bio;\n}\n\nstatic void * r10bio_pool_alloc(gfp_t gfp_flags, void *data)\n{\n\tstruct r10conf *conf = data;\n\tint size = offsetof(struct r10bio, devs[conf->geo.raid_disks]);\n\n\t/* allocate a r10bio with room for raid_disks entries in the\n\t * bios array */\n\treturn kzalloc(size, gfp_flags);\n}\n\n#define RESYNC_SECTORS (RESYNC_BLOCK_SIZE >> 9)\n/* amount of memory to reserve for resync requests */\n#define RESYNC_WINDOW (1024*1024)\n/* maximum number of concurrent requests, memory permitting */\n#define RESYNC_DEPTH (32*1024*1024/RESYNC_BLOCK_SIZE)\n#define CLUSTER_RESYNC_WINDOW (32 * RESYNC_WINDOW)\n#define CLUSTER_RESYNC_WINDOW_SECTORS (CLUSTER_RESYNC_WINDOW >> 9)\n\n/*\n * When performing a resync, we need to read and compare, so\n * we need as many pages are there are copies.\n * When performing a recovery, we need 2 bios, one for read,\n * one for write (we recover only one drive per r10buf)\n *\n */\nstatic void * r10buf_pool_alloc(gfp_t gfp_flags, void *data)\n{\n\tstruct r10conf *conf = data;\n\tstruct r10bio *r10_bio;\n\tstruct bio *bio;\n\tint j;\n\tint nalloc, nalloc_rp;\n\tstruct resync_pages *rps;\n\n\tr10_bio = r10bio_pool_alloc(gfp_flags, conf);\n\tif (!r10_bio)\n\t\treturn NULL;\n\n\tif (test_bit(MD_RECOVERY_SYNC, &conf->mddev->recovery) ||\n\t    test_bit(MD_RECOVERY_RESHAPE, &conf->mddev->recovery))\n\t\tnalloc = conf->copies; /* resync */\n\telse\n\t\tnalloc = 2; /* recovery */\n\n\t/* allocate once for all bios */\n\tif (!conf->have_replacement)\n\t\tnalloc_rp = nalloc;\n\telse\n\t\tnalloc_rp = nalloc * 2;\n\trps = kmalloc_array(nalloc_rp, sizeof(struct resync_pages), gfp_flags);\n\tif (!rps)\n\t\tgoto out_free_r10bio;\n\n\t/*\n\t * Allocate bios.\n\t */\n\tfor (j = nalloc ; j-- ; ) {\n\t\tbio = bio_kmalloc(gfp_flags, RESYNC_PAGES);\n\t\tif (!bio)\n\t\t\tgoto out_free_bio;\n\t\tr10_bio->devs[j].bio = bio;\n\t\tif (!conf->have_replacement)\n\t\t\tcontinue;\n\t\tbio = bio_kmalloc(gfp_flags, RESYNC_PAGES);\n\t\tif (!bio)\n\t\t\tgoto out_free_bio;\n\t\tr10_bio->devs[j].repl_bio = bio;\n\t}\n\t/*\n\t * Allocate RESYNC_PAGES data pages and attach them\n\t * where needed.\n\t */\n\tfor (j = 0; j < nalloc; j++) {\n\t\tstruct bio *rbio = r10_bio->devs[j].repl_bio;\n\t\tstruct resync_pages *rp, *rp_repl;\n\n\t\trp = &rps[j];\n\t\tif (rbio)\n\t\t\trp_repl = &rps[nalloc + j];\n\n\t\tbio = r10_bio->devs[j].bio;\n\n\t\tif (!j || test_bit(MD_RECOVERY_SYNC,\n\t\t\t\t   &conf->mddev->recovery)) {\n\t\t\tif (resync_alloc_pages(rp, gfp_flags))\n\t\t\t\tgoto out_free_pages;\n\t\t} else {\n\t\t\tmemcpy(rp, &rps[0], sizeof(*rp));\n\t\t\tresync_get_all_pages(rp);\n\t\t}\n\n\t\trp->raid_bio = r10_bio;\n\t\tbio->bi_private = rp;\n\t\tif (rbio) {\n\t\t\tmemcpy(rp_repl, rp, sizeof(*rp));\n\t\t\trbio->bi_private = rp_repl;\n\t\t}\n\t}\n\n\treturn r10_bio;\n\nout_free_pages:\n\twhile (--j >= 0)\n\t\tresync_free_pages(&rps[j]);\n\n\tj = 0;\nout_free_bio:\n\tfor ( ; j < nalloc; j++) {\n\t\tif (r10_bio->devs[j].bio)\n\t\t\tbio_put(r10_bio->devs[j].bio);\n\t\tif (r10_bio->devs[j].repl_bio)\n\t\t\tbio_put(r10_bio->devs[j].repl_bio);\n\t}\n\tkfree(rps);\nout_free_r10bio:\n\trbio_pool_free(r10_bio, conf);\n\treturn NULL;\n}\n\nstatic void r10buf_pool_free(void *__r10_bio, void *data)\n{\n\tstruct r10conf *conf = data;\n\tstruct r10bio *r10bio = __r10_bio;\n\tint j;\n\tstruct resync_pages *rp = NULL;\n\n\tfor (j = conf->copies; j--; ) {\n\t\tstruct bio *bio = r10bio->devs[j].bio;\n\n\t\tif (bio) {\n\t\t\trp = get_resync_pages(bio);\n\t\t\tresync_free_pages(rp);\n\t\t\tbio_put(bio);\n\t\t}\n\n\t\tbio = r10bio->devs[j].repl_bio;\n\t\tif (bio)\n\t\t\tbio_put(bio);\n\t}\n\n\t/* resync pages array stored in the 1st bio's .bi_private */\n\tkfree(rp);\n\n\trbio_pool_free(r10bio, conf);\n}\n\nstatic void put_all_bios(struct r10conf *conf, struct r10bio *r10_bio)\n{\n\tint i;\n\n\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\tstruct bio **bio = & r10_bio->devs[i].bio;\n\t\tif (!BIO_SPECIAL(*bio))\n\t\t\tbio_put(*bio);\n\t\t*bio = NULL;\n\t\tbio = &r10_bio->devs[i].repl_bio;\n\t\tif (r10_bio->read_slot < 0 && !BIO_SPECIAL(*bio))\n\t\t\tbio_put(*bio);\n\t\t*bio = NULL;\n\t}\n}\n\nstatic void free_r10bio(struct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\n\tput_all_bios(conf, r10_bio);\n\tmempool_free(r10_bio, &conf->r10bio_pool);\n}\n\nstatic void put_buf(struct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\n\tmempool_free(r10_bio, &conf->r10buf_pool);\n\n\tlower_barrier(conf);\n}\n\nstatic void reschedule_retry(struct r10bio *r10_bio)\n{\n\tunsigned long flags;\n\tstruct mddev *mddev = r10_bio->mddev;\n\tstruct r10conf *conf = mddev->private;\n\n\tspin_lock_irqsave(&conf->device_lock, flags);\n\tlist_add(&r10_bio->retry_list, &conf->retry_list);\n\tconf->nr_queued ++;\n\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\n\t/* wake up frozen array... */\n\twake_up(&conf->wait_barrier);\n\n\tmd_wakeup_thread(mddev->thread);\n}\n\n/*\n * raid_end_bio_io() is called when we have finished servicing a mirrored\n * operation and are ready to return a success/failure code to the buffer\n * cache layer.\n */\nstatic void raid_end_bio_io(struct r10bio *r10_bio)\n{\n\tstruct bio *bio = r10_bio->master_bio;\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\n\tif (!test_bit(R10BIO_Uptodate, &r10_bio->state))\n\t\tbio->bi_status = BLK_STS_IOERR;\n\n\tbio_endio(bio);\n\t/*\n\t * Wake up any possible resync thread that waits for the device\n\t * to go idle.\n\t */\n\tallow_barrier(conf);\n\n\tfree_r10bio(r10_bio);\n}\n\n/*\n * Update disk head position estimator based on IRQ completion info.\n */\nstatic inline void update_head_pos(int slot, struct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\n\tconf->mirrors[r10_bio->devs[slot].devnum].head_position =\n\t\tr10_bio->devs[slot].addr + (r10_bio->sectors);\n}\n\n/*\n * Find the disk number which triggered given bio\n */\nstatic int find_bio_disk(struct r10conf *conf, struct r10bio *r10_bio,\n\t\t\t struct bio *bio, int *slotp, int *replp)\n{\n\tint slot;\n\tint repl = 0;\n\n\tfor (slot = 0; slot < conf->geo.raid_disks; slot++) {\n\t\tif (r10_bio->devs[slot].bio == bio)\n\t\t\tbreak;\n\t\tif (r10_bio->devs[slot].repl_bio == bio) {\n\t\t\trepl = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tupdate_head_pos(slot, r10_bio);\n\n\tif (slotp)\n\t\t*slotp = slot;\n\tif (replp)\n\t\t*replp = repl;\n\treturn r10_bio->devs[slot].devnum;\n}\n\nstatic void raid10_end_read_request(struct bio *bio)\n{\n\tint uptodate = !bio->bi_status;\n\tstruct r10bio *r10_bio = bio->bi_private;\n\tint slot;\n\tstruct md_rdev *rdev;\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\n\tslot = r10_bio->read_slot;\n\trdev = r10_bio->devs[slot].rdev;\n\t/*\n\t * this branch is our 'one mirror IO has finished' event handler:\n\t */\n\tupdate_head_pos(slot, r10_bio);\n\n\tif (uptodate) {\n\t\t/*\n\t\t * Set R10BIO_Uptodate in our master bio, so that\n\t\t * we will return a good error code to the higher\n\t\t * levels even if IO on some other mirrored buffer fails.\n\t\t *\n\t\t * The 'master' represents the composite IO operation to\n\t\t * user-side. So if something waits for IO, then it will\n\t\t * wait for the 'master' bio.\n\t\t */\n\t\tset_bit(R10BIO_Uptodate, &r10_bio->state);\n\t} else {\n\t\t/* If all other devices that store this block have\n\t\t * failed, we want to return the error upwards rather\n\t\t * than fail the last device.  Here we redefine\n\t\t * \"uptodate\" to mean \"Don't want to retry\"\n\t\t */\n\t\tif (!_enough(conf, test_bit(R10BIO_Previous, &r10_bio->state),\n\t\t\t     rdev->raid_disk))\n\t\t\tuptodate = 1;\n\t}\n\tif (uptodate) {\n\t\traid_end_bio_io(r10_bio);\n\t\trdev_dec_pending(rdev, conf->mddev);\n\t} else {\n\t\t/*\n\t\t * oops, read error - keep the refcount on the rdev\n\t\t */\n\t\tchar b[BDEVNAME_SIZE];\n\t\tpr_err_ratelimited(\"md/raid10:%s: %s: rescheduling sector %llu\\n\",\n\t\t\t\t   mdname(conf->mddev),\n\t\t\t\t   bdevname(rdev->bdev, b),\n\t\t\t\t   (unsigned long long)r10_bio->sector);\n\t\tset_bit(R10BIO_ReadError, &r10_bio->state);\n\t\treschedule_retry(r10_bio);\n\t}\n}\n\nstatic void close_write(struct r10bio *r10_bio)\n{\n\t/* clear the bitmap if all writes complete successfully */\n\tmd_bitmap_endwrite(r10_bio->mddev->bitmap, r10_bio->sector,\n\t\t\t   r10_bio->sectors,\n\t\t\t   !test_bit(R10BIO_Degraded, &r10_bio->state),\n\t\t\t   0);\n\tmd_write_end(r10_bio->mddev);\n}\n\nstatic void one_write_done(struct r10bio *r10_bio)\n{\n\tif (atomic_dec_and_test(&r10_bio->remaining)) {\n\t\tif (test_bit(R10BIO_WriteError, &r10_bio->state))\n\t\t\treschedule_retry(r10_bio);\n\t\telse {\n\t\t\tclose_write(r10_bio);\n\t\t\tif (test_bit(R10BIO_MadeGood, &r10_bio->state))\n\t\t\t\treschedule_retry(r10_bio);\n\t\t\telse\n\t\t\t\traid_end_bio_io(r10_bio);\n\t\t}\n\t}\n}\n\nstatic void raid10_end_write_request(struct bio *bio)\n{\n\tstruct r10bio *r10_bio = bio->bi_private;\n\tint dev;\n\tint dec_rdev = 1;\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\tint slot, repl;\n\tstruct md_rdev *rdev = NULL;\n\tstruct bio *to_put = NULL;\n\tbool discard_error;\n\n\tdiscard_error = bio->bi_status && bio_op(bio) == REQ_OP_DISCARD;\n\n\tdev = find_bio_disk(conf, r10_bio, bio, &slot, &repl);\n\n\tif (repl)\n\t\trdev = conf->mirrors[dev].replacement;\n\tif (!rdev) {\n\t\tsmp_rmb();\n\t\trepl = 0;\n\t\trdev = conf->mirrors[dev].rdev;\n\t}\n\t/*\n\t * this branch is our 'one mirror IO has finished' event handler:\n\t */\n\tif (bio->bi_status && !discard_error) {\n\t\tif (repl)\n\t\t\t/* Never record new bad blocks to replacement,\n\t\t\t * just fail it.\n\t\t\t */\n\t\t\tmd_error(rdev->mddev, rdev);\n\t\telse {\n\t\t\tset_bit(WriteErrorSeen,\t&rdev->flags);\n\t\t\tif (!test_and_set_bit(WantReplacement, &rdev->flags))\n\t\t\t\tset_bit(MD_RECOVERY_NEEDED,\n\t\t\t\t\t&rdev->mddev->recovery);\n\n\t\t\tdec_rdev = 0;\n\t\t\tif (test_bit(FailFast, &rdev->flags) &&\n\t\t\t    (bio->bi_opf & MD_FAILFAST)) {\n\t\t\t\tmd_error(rdev->mddev, rdev);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * When the device is faulty, it is not necessary to\n\t\t\t * handle write error.\n\t\t\t * For failfast, this is the only remaining device,\n\t\t\t * We need to retry the write without FailFast.\n\t\t\t */\n\t\t\tif (!test_bit(Faulty, &rdev->flags))\n\t\t\t\tset_bit(R10BIO_WriteError, &r10_bio->state);\n\t\t\telse {\n\t\t\t\tr10_bio->devs[slot].bio = NULL;\n\t\t\t\tto_put = bio;\n\t\t\t\tdec_rdev = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Set R10BIO_Uptodate in our master bio, so that\n\t\t * we will return a good error code for to the higher\n\t\t * levels even if IO on some other mirrored buffer fails.\n\t\t *\n\t\t * The 'master' represents the composite IO operation to\n\t\t * user-side. So if something waits for IO, then it will\n\t\t * wait for the 'master' bio.\n\t\t */\n\t\tsector_t first_bad;\n\t\tint bad_sectors;\n\n\t\t/*\n\t\t * Do not set R10BIO_Uptodate if the current device is\n\t\t * rebuilding or Faulty. This is because we cannot use\n\t\t * such device for properly reading the data back (we could\n\t\t * potentially use it, if the current write would have felt\n\t\t * before rdev->recovery_offset, but for simplicity we don't\n\t\t * check this here.\n\t\t */\n\t\tif (test_bit(In_sync, &rdev->flags) &&\n\t\t    !test_bit(Faulty, &rdev->flags))\n\t\t\tset_bit(R10BIO_Uptodate, &r10_bio->state);\n\n\t\t/* Maybe we can clear some bad blocks. */\n\t\tif (is_badblock(rdev,\n\t\t\t\tr10_bio->devs[slot].addr,\n\t\t\t\tr10_bio->sectors,\n\t\t\t\t&first_bad, &bad_sectors) && !discard_error) {\n\t\t\tbio_put(bio);\n\t\t\tif (repl)\n\t\t\t\tr10_bio->devs[slot].repl_bio = IO_MADE_GOOD;\n\t\t\telse\n\t\t\t\tr10_bio->devs[slot].bio = IO_MADE_GOOD;\n\t\t\tdec_rdev = 0;\n\t\t\tset_bit(R10BIO_MadeGood, &r10_bio->state);\n\t\t}\n\t}\n\n\t/*\n\t *\n\t * Let's see if all mirrored write operations have finished\n\t * already.\n\t */\n\tone_write_done(r10_bio);\n\tif (dec_rdev)\n\t\trdev_dec_pending(rdev, conf->mddev);\n\tif (to_put)\n\t\tbio_put(to_put);\n}\n\n/*\n * RAID10 layout manager\n * As well as the chunksize and raid_disks count, there are two\n * parameters: near_copies and far_copies.\n * near_copies * far_copies must be <= raid_disks.\n * Normally one of these will be 1.\n * If both are 1, we get raid0.\n * If near_copies == raid_disks, we get raid1.\n *\n * Chunks are laid out in raid0 style with near_copies copies of the\n * first chunk, followed by near_copies copies of the next chunk and\n * so on.\n * If far_copies > 1, then after 1/far_copies of the array has been assigned\n * as described above, we start again with a device offset of near_copies.\n * So we effectively have another copy of the whole array further down all\n * the drives, but with blocks on different drives.\n * With this layout, and block is never stored twice on the one device.\n *\n * raid10_find_phys finds the sector offset of a given virtual sector\n * on each device that it is on.\n *\n * raid10_find_virt does the reverse mapping, from a device and a\n * sector offset to a virtual address\n */\n\nstatic void __raid10_find_phys(struct geom *geo, struct r10bio *r10bio)\n{\n\tint n,f;\n\tsector_t sector;\n\tsector_t chunk;\n\tsector_t stripe;\n\tint dev;\n\tint slot = 0;\n\tint last_far_set_start, last_far_set_size;\n\n\tlast_far_set_start = (geo->raid_disks / geo->far_set_size) - 1;\n\tlast_far_set_start *= geo->far_set_size;\n\n\tlast_far_set_size = geo->far_set_size;\n\tlast_far_set_size += (geo->raid_disks % geo->far_set_size);\n\n\t/* now calculate first sector/dev */\n\tchunk = r10bio->sector >> geo->chunk_shift;\n\tsector = r10bio->sector & geo->chunk_mask;\n\n\tchunk *= geo->near_copies;\n\tstripe = chunk;\n\tdev = sector_div(stripe, geo->raid_disks);\n\tif (geo->far_offset)\n\t\tstripe *= geo->far_copies;\n\n\tsector += stripe << geo->chunk_shift;\n\n\t/* and calculate all the others */\n\tfor (n = 0; n < geo->near_copies; n++) {\n\t\tint d = dev;\n\t\tint set;\n\t\tsector_t s = sector;\n\t\tr10bio->devs[slot].devnum = d;\n\t\tr10bio->devs[slot].addr = s;\n\t\tslot++;\n\n\t\tfor (f = 1; f < geo->far_copies; f++) {\n\t\t\tset = d / geo->far_set_size;\n\t\t\td += geo->near_copies;\n\n\t\t\tif ((geo->raid_disks % geo->far_set_size) &&\n\t\t\t    (d > last_far_set_start)) {\n\t\t\t\td -= last_far_set_start;\n\t\t\t\td %= last_far_set_size;\n\t\t\t\td += last_far_set_start;\n\t\t\t} else {\n\t\t\t\td %= geo->far_set_size;\n\t\t\t\td += geo->far_set_size * set;\n\t\t\t}\n\t\t\ts += geo->stride;\n\t\t\tr10bio->devs[slot].devnum = d;\n\t\t\tr10bio->devs[slot].addr = s;\n\t\t\tslot++;\n\t\t}\n\t\tdev++;\n\t\tif (dev >= geo->raid_disks) {\n\t\t\tdev = 0;\n\t\t\tsector += (geo->chunk_mask + 1);\n\t\t}\n\t}\n}\n\nstatic void raid10_find_phys(struct r10conf *conf, struct r10bio *r10bio)\n{\n\tstruct geom *geo = &conf->geo;\n\n\tif (conf->reshape_progress != MaxSector &&\n\t    ((r10bio->sector >= conf->reshape_progress) !=\n\t     conf->mddev->reshape_backwards)) {\n\t\tset_bit(R10BIO_Previous, &r10bio->state);\n\t\tgeo = &conf->prev;\n\t} else\n\t\tclear_bit(R10BIO_Previous, &r10bio->state);\n\n\t__raid10_find_phys(geo, r10bio);\n}\n\nstatic sector_t raid10_find_virt(struct r10conf *conf, sector_t sector, int dev)\n{\n\tsector_t offset, chunk, vchunk;\n\t/* Never use conf->prev as this is only called during resync\n\t * or recovery, so reshape isn't happening\n\t */\n\tstruct geom *geo = &conf->geo;\n\tint far_set_start = (dev / geo->far_set_size) * geo->far_set_size;\n\tint far_set_size = geo->far_set_size;\n\tint last_far_set_start;\n\n\tif (geo->raid_disks % geo->far_set_size) {\n\t\tlast_far_set_start = (geo->raid_disks / geo->far_set_size) - 1;\n\t\tlast_far_set_start *= geo->far_set_size;\n\n\t\tif (dev >= last_far_set_start) {\n\t\t\tfar_set_size = geo->far_set_size;\n\t\t\tfar_set_size += (geo->raid_disks % geo->far_set_size);\n\t\t\tfar_set_start = last_far_set_start;\n\t\t}\n\t}\n\n\toffset = sector & geo->chunk_mask;\n\tif (geo->far_offset) {\n\t\tint fc;\n\t\tchunk = sector >> geo->chunk_shift;\n\t\tfc = sector_div(chunk, geo->far_copies);\n\t\tdev -= fc * geo->near_copies;\n\t\tif (dev < far_set_start)\n\t\t\tdev += far_set_size;\n\t} else {\n\t\twhile (sector >= geo->stride) {\n\t\t\tsector -= geo->stride;\n\t\t\tif (dev < (geo->near_copies + far_set_start))\n\t\t\t\tdev += far_set_size - geo->near_copies;\n\t\t\telse\n\t\t\t\tdev -= geo->near_copies;\n\t\t}\n\t\tchunk = sector >> geo->chunk_shift;\n\t}\n\tvchunk = chunk * geo->raid_disks + dev;\n\tsector_div(vchunk, geo->near_copies);\n\treturn (vchunk << geo->chunk_shift) + offset;\n}\n\n/*\n * This routine returns the disk from which the requested read should\n * be done. There is a per-array 'next expected sequential IO' sector\n * number - if this matches on the next IO then we use the last disk.\n * There is also a per-disk 'last know head position' sector that is\n * maintained from IRQ contexts, both the normal and the resync IO\n * completion handlers update this position correctly. If there is no\n * perfect sequential match then we pick the disk whose head is closest.\n *\n * If there are 2 mirrors in the same 2 devices, performance degrades\n * because position is mirror, not device based.\n *\n * The rdev for the device selected will have nr_pending incremented.\n */\n\n/*\n * FIXME: possibly should rethink readbalancing and do it differently\n * depending on near_copies / far_copies geometry.\n */\nstatic struct md_rdev *read_balance(struct r10conf *conf,\n\t\t\t\t    struct r10bio *r10_bio,\n\t\t\t\t    int *max_sectors)\n{\n\tconst sector_t this_sector = r10_bio->sector;\n\tint disk, slot;\n\tint sectors = r10_bio->sectors;\n\tint best_good_sectors;\n\tsector_t new_distance, best_dist;\n\tstruct md_rdev *best_dist_rdev, *best_pending_rdev, *rdev = NULL;\n\tint do_balance;\n\tint best_dist_slot, best_pending_slot;\n\tbool has_nonrot_disk = false;\n\tunsigned int min_pending;\n\tstruct geom *geo = &conf->geo;\n\n\traid10_find_phys(conf, r10_bio);\n\trcu_read_lock();\n\tbest_dist_slot = -1;\n\tmin_pending = UINT_MAX;\n\tbest_dist_rdev = NULL;\n\tbest_pending_rdev = NULL;\n\tbest_dist = MaxSector;\n\tbest_good_sectors = 0;\n\tdo_balance = 1;\n\tclear_bit(R10BIO_FailFast, &r10_bio->state);\n\t/*\n\t * Check if we can balance. We can balance on the whole\n\t * device if no resync is going on (recovery is ok), or below\n\t * the resync window. We take the first readable disk when\n\t * above the resync window.\n\t */\n\tif ((conf->mddev->recovery_cp < MaxSector\n\t     && (this_sector + sectors >= conf->next_resync)) ||\n\t    (mddev_is_clustered(conf->mddev) &&\n\t     md_cluster_ops->area_resyncing(conf->mddev, READ, this_sector,\n\t\t\t\t\t    this_sector + sectors)))\n\t\tdo_balance = 0;\n\n\tfor (slot = 0; slot < conf->copies ; slot++) {\n\t\tsector_t first_bad;\n\t\tint bad_sectors;\n\t\tsector_t dev_sector;\n\t\tunsigned int pending;\n\t\tbool nonrot;\n\n\t\tif (r10_bio->devs[slot].bio == IO_BLOCKED)\n\t\t\tcontinue;\n\t\tdisk = r10_bio->devs[slot].devnum;\n\t\trdev = rcu_dereference(conf->mirrors[disk].replacement);\n\t\tif (rdev == NULL || test_bit(Faulty, &rdev->flags) ||\n\t\t    r10_bio->devs[slot].addr + sectors > rdev->recovery_offset)\n\t\t\trdev = rcu_dereference(conf->mirrors[disk].rdev);\n\t\tif (rdev == NULL ||\n\t\t    test_bit(Faulty, &rdev->flags))\n\t\t\tcontinue;\n\t\tif (!test_bit(In_sync, &rdev->flags) &&\n\t\t    r10_bio->devs[slot].addr + sectors > rdev->recovery_offset)\n\t\t\tcontinue;\n\n\t\tdev_sector = r10_bio->devs[slot].addr;\n\t\tif (is_badblock(rdev, dev_sector, sectors,\n\t\t\t\t&first_bad, &bad_sectors)) {\n\t\t\tif (best_dist < MaxSector)\n\t\t\t\t/* Already have a better slot */\n\t\t\t\tcontinue;\n\t\t\tif (first_bad <= dev_sector) {\n\t\t\t\t/* Cannot read here.  If this is the\n\t\t\t\t * 'primary' device, then we must not read\n\t\t\t\t * beyond 'bad_sectors' from another device.\n\t\t\t\t */\n\t\t\t\tbad_sectors -= (dev_sector - first_bad);\n\t\t\t\tif (!do_balance && sectors > bad_sectors)\n\t\t\t\t\tsectors = bad_sectors;\n\t\t\t\tif (best_good_sectors > sectors)\n\t\t\t\t\tbest_good_sectors = sectors;\n\t\t\t} else {\n\t\t\t\tsector_t good_sectors =\n\t\t\t\t\tfirst_bad - dev_sector;\n\t\t\t\tif (good_sectors > best_good_sectors) {\n\t\t\t\t\tbest_good_sectors = good_sectors;\n\t\t\t\t\tbest_dist_slot = slot;\n\t\t\t\t\tbest_dist_rdev = rdev;\n\t\t\t\t}\n\t\t\t\tif (!do_balance)\n\t\t\t\t\t/* Must read from here */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else\n\t\t\tbest_good_sectors = sectors;\n\n\t\tif (!do_balance)\n\t\t\tbreak;\n\n\t\tnonrot = blk_queue_nonrot(bdev_get_queue(rdev->bdev));\n\t\thas_nonrot_disk |= nonrot;\n\t\tpending = atomic_read(&rdev->nr_pending);\n\t\tif (min_pending > pending && nonrot) {\n\t\t\tmin_pending = pending;\n\t\t\tbest_pending_slot = slot;\n\t\t\tbest_pending_rdev = rdev;\n\t\t}\n\n\t\tif (best_dist_slot >= 0)\n\t\t\t/* At least 2 disks to choose from so failfast is OK */\n\t\t\tset_bit(R10BIO_FailFast, &r10_bio->state);\n\t\t/* This optimisation is debatable, and completely destroys\n\t\t * sequential read speed for 'far copies' arrays.  So only\n\t\t * keep it for 'near' arrays, and review those later.\n\t\t */\n\t\tif (geo->near_copies > 1 && !pending)\n\t\t\tnew_distance = 0;\n\n\t\t/* for far > 1 always use the lowest address */\n\t\telse if (geo->far_copies > 1)\n\t\t\tnew_distance = r10_bio->devs[slot].addr;\n\t\telse\n\t\t\tnew_distance = abs(r10_bio->devs[slot].addr -\n\t\t\t\t\t   conf->mirrors[disk].head_position);\n\n\t\tif (new_distance < best_dist) {\n\t\t\tbest_dist = new_distance;\n\t\t\tbest_dist_slot = slot;\n\t\t\tbest_dist_rdev = rdev;\n\t\t}\n\t}\n\tif (slot >= conf->copies) {\n\t\tif (has_nonrot_disk) {\n\t\t\tslot = best_pending_slot;\n\t\t\trdev = best_pending_rdev;\n\t\t} else {\n\t\t\tslot = best_dist_slot;\n\t\t\trdev = best_dist_rdev;\n\t\t}\n\t}\n\n\tif (slot >= 0) {\n\t\tatomic_inc(&rdev->nr_pending);\n\t\tr10_bio->read_slot = slot;\n\t} else\n\t\trdev = NULL;\n\trcu_read_unlock();\n\t*max_sectors = best_good_sectors;\n\n\treturn rdev;\n}\n\nstatic void flush_pending_writes(struct r10conf *conf)\n{\n\t/* Any writes that have been queued but are awaiting\n\t * bitmap updates get flushed here.\n\t */\n\tspin_lock_irq(&conf->device_lock);\n\n\tif (conf->pending_bio_list.head) {\n\t\tstruct blk_plug plug;\n\t\tstruct bio *bio;\n\n\t\tbio = bio_list_get(&conf->pending_bio_list);\n\t\tconf->pending_count = 0;\n\t\tspin_unlock_irq(&conf->device_lock);\n\n\t\t/*\n\t\t * As this is called in a wait_event() loop (see freeze_array),\n\t\t * current->state might be TASK_UNINTERRUPTIBLE which will\n\t\t * cause a warning when we prepare to wait again.  As it is\n\t\t * rare that this path is taken, it is perfectly safe to force\n\t\t * us to go around the wait_event() loop again, so the warning\n\t\t * is a false-positive. Silence the warning by resetting\n\t\t * thread state\n\t\t */\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\tblk_start_plug(&plug);\n\t\t/* flush any pending bitmap writes to disk\n\t\t * before proceeding w/ I/O */\n\t\tmd_bitmap_unplug(conf->mddev->bitmap);\n\t\twake_up(&conf->wait_barrier);\n\n\t\twhile (bio) { /* submit pending writes */\n\t\t\tstruct bio *next = bio->bi_next;\n\t\t\tstruct md_rdev *rdev = (void*)bio->bi_disk;\n\t\t\tbio->bi_next = NULL;\n\t\t\tbio_set_dev(bio, rdev->bdev);\n\t\t\tif (test_bit(Faulty, &rdev->flags)) {\n\t\t\t\tbio_io_error(bio);\n\t\t\t} else if (unlikely((bio_op(bio) ==  REQ_OP_DISCARD) &&\n\t\t\t\t\t    !blk_queue_discard(bio->bi_disk->queue)))\n\t\t\t\t/* Just ignore it */\n\t\t\t\tbio_endio(bio);\n\t\t\telse\n\t\t\t\tsubmit_bio_noacct(bio);\n\t\t\tbio = next;\n\t\t}\n\t\tblk_finish_plug(&plug);\n\t} else\n\t\tspin_unlock_irq(&conf->device_lock);\n}\n\n/* Barriers....\n * Sometimes we need to suspend IO while we do something else,\n * either some resync/recovery, or reconfigure the array.\n * To do this we raise a 'barrier'.\n * The 'barrier' is a counter that can be raised multiple times\n * to count how many activities are happening which preclude\n * normal IO.\n * We can only raise the barrier if there is no pending IO.\n * i.e. if nr_pending == 0.\n * We choose only to raise the barrier if no-one is waiting for the\n * barrier to go down.  This means that as soon as an IO request\n * is ready, no other operations which require a barrier will start\n * until the IO request has had a chance.\n *\n * So: regular IO calls 'wait_barrier'.  When that returns there\n *    is no backgroup IO happening,  It must arrange to call\n *    allow_barrier when it has finished its IO.\n * backgroup IO calls must call raise_barrier.  Once that returns\n *    there is no normal IO happeing.  It must arrange to call\n *    lower_barrier when the particular background IO completes.\n */\n\nstatic void raise_barrier(struct r10conf *conf, int force)\n{\n\tBUG_ON(force && !conf->barrier);\n\tspin_lock_irq(&conf->resync_lock);\n\n\t/* Wait until no block IO is waiting (unless 'force') */\n\twait_event_lock_irq(conf->wait_barrier, force || !conf->nr_waiting,\n\t\t\t    conf->resync_lock);\n\n\t/* block any new IO from starting */\n\tconf->barrier++;\n\n\t/* Now wait for all pending IO to complete */\n\twait_event_lock_irq(conf->wait_barrier,\n\t\t\t    !atomic_read(&conf->nr_pending) && conf->barrier < RESYNC_DEPTH,\n\t\t\t    conf->resync_lock);\n\n\tspin_unlock_irq(&conf->resync_lock);\n}\n\nstatic void lower_barrier(struct r10conf *conf)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&conf->resync_lock, flags);\n\tconf->barrier--;\n\tspin_unlock_irqrestore(&conf->resync_lock, flags);\n\twake_up(&conf->wait_barrier);\n}\n\nstatic void wait_barrier(struct r10conf *conf)\n{\n\tspin_lock_irq(&conf->resync_lock);\n\tif (conf->barrier) {\n\t\tstruct bio_list *bio_list = current->bio_list;\n\t\tconf->nr_waiting++;\n\t\t/* Wait for the barrier to drop.\n\t\t * However if there are already pending\n\t\t * requests (preventing the barrier from\n\t\t * rising completely), and the\n\t\t * pre-process bio queue isn't empty,\n\t\t * then don't wait, as we need to empty\n\t\t * that queue to get the nr_pending\n\t\t * count down.\n\t\t */\n\t\traid10_log(conf->mddev, \"wait barrier\");\n\t\twait_event_lock_irq(conf->wait_barrier,\n\t\t\t\t    !conf->barrier ||\n\t\t\t\t    (atomic_read(&conf->nr_pending) &&\n\t\t\t\t     bio_list &&\n\t\t\t\t     (!bio_list_empty(&bio_list[0]) ||\n\t\t\t\t      !bio_list_empty(&bio_list[1]))) ||\n\t\t\t\t     /* move on if recovery thread is\n\t\t\t\t      * blocked by us\n\t\t\t\t      */\n\t\t\t\t     (conf->mddev->thread->tsk == current &&\n\t\t\t\t      test_bit(MD_RECOVERY_RUNNING,\n\t\t\t\t\t       &conf->mddev->recovery) &&\n\t\t\t\t      conf->nr_queued > 0),\n\t\t\t\t    conf->resync_lock);\n\t\tconf->nr_waiting--;\n\t\tif (!conf->nr_waiting)\n\t\t\twake_up(&conf->wait_barrier);\n\t}\n\tatomic_inc(&conf->nr_pending);\n\tspin_unlock_irq(&conf->resync_lock);\n}\n\nstatic void allow_barrier(struct r10conf *conf)\n{\n\tif ((atomic_dec_and_test(&conf->nr_pending)) ||\n\t\t\t(conf->array_freeze_pending))\n\t\twake_up(&conf->wait_barrier);\n}\n\nstatic void freeze_array(struct r10conf *conf, int extra)\n{\n\t/* stop syncio and normal IO and wait for everything to\n\t * go quiet.\n\t * We increment barrier and nr_waiting, and then\n\t * wait until nr_pending match nr_queued+extra\n\t * This is called in the context of one normal IO request\n\t * that has failed. Thus any sync request that might be pending\n\t * will be blocked by nr_pending, and we need to wait for\n\t * pending IO requests to complete or be queued for re-try.\n\t * Thus the number queued (nr_queued) plus this request (extra)\n\t * must match the number of pending IOs (nr_pending) before\n\t * we continue.\n\t */\n\tspin_lock_irq(&conf->resync_lock);\n\tconf->array_freeze_pending++;\n\tconf->barrier++;\n\tconf->nr_waiting++;\n\twait_event_lock_irq_cmd(conf->wait_barrier,\n\t\t\t\tatomic_read(&conf->nr_pending) == conf->nr_queued+extra,\n\t\t\t\tconf->resync_lock,\n\t\t\t\tflush_pending_writes(conf));\n\n\tconf->array_freeze_pending--;\n\tspin_unlock_irq(&conf->resync_lock);\n}\n\nstatic void unfreeze_array(struct r10conf *conf)\n{\n\t/* reverse the effect of the freeze */\n\tspin_lock_irq(&conf->resync_lock);\n\tconf->barrier--;\n\tconf->nr_waiting--;\n\twake_up(&conf->wait_barrier);\n\tspin_unlock_irq(&conf->resync_lock);\n}\n\nstatic sector_t choose_data_offset(struct r10bio *r10_bio,\n\t\t\t\t   struct md_rdev *rdev)\n{\n\tif (!test_bit(MD_RECOVERY_RESHAPE, &rdev->mddev->recovery) ||\n\t    test_bit(R10BIO_Previous, &r10_bio->state))\n\t\treturn rdev->data_offset;\n\telse\n\t\treturn rdev->new_data_offset;\n}\n\nstruct raid10_plug_cb {\n\tstruct blk_plug_cb\tcb;\n\tstruct bio_list\t\tpending;\n\tint\t\t\tpending_cnt;\n};\n\nstatic void raid10_unplug(struct blk_plug_cb *cb, bool from_schedule)\n{\n\tstruct raid10_plug_cb *plug = container_of(cb, struct raid10_plug_cb,\n\t\t\t\t\t\t   cb);\n\tstruct mddev *mddev = plug->cb.data;\n\tstruct r10conf *conf = mddev->private;\n\tstruct bio *bio;\n\n\tif (from_schedule || current->bio_list) {\n\t\tspin_lock_irq(&conf->device_lock);\n\t\tbio_list_merge(&conf->pending_bio_list, &plug->pending);\n\t\tconf->pending_count += plug->pending_cnt;\n\t\tspin_unlock_irq(&conf->device_lock);\n\t\twake_up(&conf->wait_barrier);\n\t\tmd_wakeup_thread(mddev->thread);\n\t\tkfree(plug);\n\t\treturn;\n\t}\n\n\t/* we aren't scheduling, so we can do the write-out directly. */\n\tbio = bio_list_get(&plug->pending);\n\tmd_bitmap_unplug(mddev->bitmap);\n\twake_up(&conf->wait_barrier);\n\n\twhile (bio) { /* submit pending writes */\n\t\tstruct bio *next = bio->bi_next;\n\t\tstruct md_rdev *rdev = (void*)bio->bi_disk;\n\t\tbio->bi_next = NULL;\n\t\tbio_set_dev(bio, rdev->bdev);\n\t\tif (test_bit(Faulty, &rdev->flags)) {\n\t\t\tbio_io_error(bio);\n\t\t} else if (unlikely((bio_op(bio) ==  REQ_OP_DISCARD) &&\n\t\t\t\t    !blk_queue_discard(bio->bi_disk->queue)))\n\t\t\t/* Just ignore it */\n\t\t\tbio_endio(bio);\n\t\telse\n\t\t\tsubmit_bio_noacct(bio);\n\t\tbio = next;\n\t}\n\tkfree(plug);\n}\n\n/*\n * 1. Register the new request and wait if the reconstruction thread has put\n * up a bar for new requests. Continue immediately if no resync is active\n * currently.\n * 2. If IO spans the reshape position.  Need to wait for reshape to pass.\n */\nstatic void regular_request_wait(struct mddev *mddev, struct r10conf *conf,\n\t\t\t\t struct bio *bio, sector_t sectors)\n{\n\twait_barrier(conf);\n\twhile (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n\t    bio->bi_iter.bi_sector < conf->reshape_progress &&\n\t    bio->bi_iter.bi_sector + sectors > conf->reshape_progress) {\n\t\traid10_log(conf->mddev, \"wait reshape\");\n\t\tallow_barrier(conf);\n\t\twait_event(conf->wait_barrier,\n\t\t\t   conf->reshape_progress <= bio->bi_iter.bi_sector ||\n\t\t\t   conf->reshape_progress >= bio->bi_iter.bi_sector +\n\t\t\t   sectors);\n\t\twait_barrier(conf);\n\t}\n}\n\nstatic void raid10_read_request(struct mddev *mddev, struct bio *bio,\n\t\t\t\tstruct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = mddev->private;\n\tstruct bio *read_bio;\n\tconst int op = bio_op(bio);\n\tconst unsigned long do_sync = (bio->bi_opf & REQ_SYNC);\n\tint max_sectors;\n\tstruct md_rdev *rdev;\n\tchar b[BDEVNAME_SIZE];\n\tint slot = r10_bio->read_slot;\n\tstruct md_rdev *err_rdev = NULL;\n\tgfp_t gfp = GFP_NOIO;\n\n\tif (slot >= 0 && r10_bio->devs[slot].rdev) {\n\t\t/*\n\t\t * This is an error retry, but we cannot\n\t\t * safely dereference the rdev in the r10_bio,\n\t\t * we must use the one in conf.\n\t\t * If it has already been disconnected (unlikely)\n\t\t * we lose the device name in error messages.\n\t\t */\n\t\tint disk;\n\t\t/*\n\t\t * As we are blocking raid10, it is a little safer to\n\t\t * use __GFP_HIGH.\n\t\t */\n\t\tgfp = GFP_NOIO | __GFP_HIGH;\n\n\t\trcu_read_lock();\n\t\tdisk = r10_bio->devs[slot].devnum;\n\t\terr_rdev = rcu_dereference(conf->mirrors[disk].rdev);\n\t\tif (err_rdev)\n\t\t\tbdevname(err_rdev->bdev, b);\n\t\telse {\n\t\t\tstrcpy(b, \"???\");\n\t\t\t/* This never gets dereferenced */\n\t\t\terr_rdev = r10_bio->devs[slot].rdev;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tregular_request_wait(mddev, conf, bio, r10_bio->sectors);\n\trdev = read_balance(conf, r10_bio, &max_sectors);\n\tif (!rdev) {\n\t\tif (err_rdev) {\n\t\t\tpr_crit_ratelimited(\"md/raid10:%s: %s: unrecoverable I/O read error for block %llu\\n\",\n\t\t\t\t\t    mdname(mddev), b,\n\t\t\t\t\t    (unsigned long long)r10_bio->sector);\n\t\t}\n\t\traid_end_bio_io(r10_bio);\n\t\treturn;\n\t}\n\tif (err_rdev)\n\t\tpr_err_ratelimited(\"md/raid10:%s: %s: redirecting sector %llu to another mirror\\n\",\n\t\t\t\t   mdname(mddev),\n\t\t\t\t   bdevname(rdev->bdev, b),\n\t\t\t\t   (unsigned long long)r10_bio->sector);\n\tif (max_sectors < bio_sectors(bio)) {\n\t\tstruct bio *split = bio_split(bio, max_sectors,\n\t\t\t\t\t      gfp, &conf->bio_split);\n\t\tbio_chain(split, bio);\n\t\tallow_barrier(conf);\n\t\tsubmit_bio_noacct(bio);\n\t\twait_barrier(conf);\n\t\tbio = split;\n\t\tr10_bio->master_bio = bio;\n\t\tr10_bio->sectors = max_sectors;\n\t}\n\tslot = r10_bio->read_slot;\n\n\tread_bio = bio_clone_fast(bio, gfp, &mddev->bio_set);\n\n\tr10_bio->devs[slot].bio = read_bio;\n\tr10_bio->devs[slot].rdev = rdev;\n\n\tread_bio->bi_iter.bi_sector = r10_bio->devs[slot].addr +\n\t\tchoose_data_offset(r10_bio, rdev);\n\tbio_set_dev(read_bio, rdev->bdev);\n\tread_bio->bi_end_io = raid10_end_read_request;\n\tbio_set_op_attrs(read_bio, op, do_sync);\n\tif (test_bit(FailFast, &rdev->flags) &&\n\t    test_bit(R10BIO_FailFast, &r10_bio->state))\n\t        read_bio->bi_opf |= MD_FAILFAST;\n\tread_bio->bi_private = r10_bio;\n\n\tif (mddev->gendisk)\n\t        trace_block_bio_remap(read_bio->bi_disk->queue,\n\t                              read_bio, disk_devt(mddev->gendisk),\n\t                              r10_bio->sector);\n\tsubmit_bio_noacct(read_bio);\n\treturn;\n}\n\nstatic void raid10_write_one_disk(struct mddev *mddev, struct r10bio *r10_bio,\n\t\t\t\t  struct bio *bio, bool replacement,\n\t\t\t\t  int n_copy)\n{\n\tconst int op = bio_op(bio);\n\tconst unsigned long do_sync = (bio->bi_opf & REQ_SYNC);\n\tconst unsigned long do_fua = (bio->bi_opf & REQ_FUA);\n\tunsigned long flags;\n\tstruct blk_plug_cb *cb;\n\tstruct raid10_plug_cb *plug = NULL;\n\tstruct r10conf *conf = mddev->private;\n\tstruct md_rdev *rdev;\n\tint devnum = r10_bio->devs[n_copy].devnum;\n\tstruct bio *mbio;\n\n\tif (replacement) {\n\t\trdev = conf->mirrors[devnum].replacement;\n\t\tif (rdev == NULL) {\n\t\t\t/* Replacement just got moved to main 'rdev' */\n\t\t\tsmp_mb();\n\t\t\trdev = conf->mirrors[devnum].rdev;\n\t\t}\n\t} else\n\t\trdev = conf->mirrors[devnum].rdev;\n\n\tmbio = bio_clone_fast(bio, GFP_NOIO, &mddev->bio_set);\n\tif (replacement)\n\t\tr10_bio->devs[n_copy].repl_bio = mbio;\n\telse\n\t\tr10_bio->devs[n_copy].bio = mbio;\n\n\tmbio->bi_iter.bi_sector\t= (r10_bio->devs[n_copy].addr +\n\t\t\t\t   choose_data_offset(r10_bio, rdev));\n\tbio_set_dev(mbio, rdev->bdev);\n\tmbio->bi_end_io\t= raid10_end_write_request;\n\tbio_set_op_attrs(mbio, op, do_sync | do_fua);\n\tif (!replacement && test_bit(FailFast,\n\t\t\t\t     &conf->mirrors[devnum].rdev->flags)\n\t\t\t && enough(conf, devnum))\n\t\tmbio->bi_opf |= MD_FAILFAST;\n\tmbio->bi_private = r10_bio;\n\n\tif (conf->mddev->gendisk)\n\t\ttrace_block_bio_remap(mbio->bi_disk->queue,\n\t\t\t\t      mbio, disk_devt(conf->mddev->gendisk),\n\t\t\t\t      r10_bio->sector);\n\t/* flush_pending_writes() needs access to the rdev so...*/\n\tmbio->bi_disk = (void *)rdev;\n\n\tatomic_inc(&r10_bio->remaining);\n\n\tcb = blk_check_plugged(raid10_unplug, mddev, sizeof(*plug));\n\tif (cb)\n\t\tplug = container_of(cb, struct raid10_plug_cb, cb);\n\telse\n\t\tplug = NULL;\n\tif (plug) {\n\t\tbio_list_add(&plug->pending, mbio);\n\t\tplug->pending_cnt++;\n\t} else {\n\t\tspin_lock_irqsave(&conf->device_lock, flags);\n\t\tbio_list_add(&conf->pending_bio_list, mbio);\n\t\tconf->pending_count++;\n\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\t\tmd_wakeup_thread(mddev->thread);\n\t}\n}\n\nstatic void wait_blocked_dev(struct mddev *mddev, struct r10bio *r10_bio)\n{\n\tint i;\n\tstruct r10conf *conf = mddev->private;\n\tstruct md_rdev *blocked_rdev;\n\nretry_wait:\n\tblocked_rdev = NULL;\n\trcu_read_lock();\n\tfor (i = 0; i < conf->copies; i++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev);\n\t\tstruct md_rdev *rrdev = rcu_dereference(\n\t\t\tconf->mirrors[i].replacement);\n\t\tif (rdev == rrdev)\n\t\t\trrdev = NULL;\n\t\tif (rdev && unlikely(test_bit(Blocked, &rdev->flags))) {\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\tblocked_rdev = rdev;\n\t\t\tbreak;\n\t\t}\n\t\tif (rrdev && unlikely(test_bit(Blocked, &rrdev->flags))) {\n\t\t\tatomic_inc(&rrdev->nr_pending);\n\t\t\tblocked_rdev = rrdev;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rdev && test_bit(WriteErrorSeen, &rdev->flags)) {\n\t\t\tsector_t first_bad;\n\t\t\tsector_t dev_sector = r10_bio->devs[i].addr;\n\t\t\tint bad_sectors;\n\t\t\tint is_bad;\n\n\t\t\t/* Discard request doesn't care the write result\n\t\t\t * so it doesn't need to wait blocked disk here.\n\t\t\t */\n\t\t\tif (!r10_bio->sectors)\n\t\t\t\tcontinue;\n\n\t\t\tis_bad = is_badblock(rdev, dev_sector, r10_bio->sectors,\n\t\t\t\t\t     &first_bad, &bad_sectors);\n\t\t\tif (is_bad < 0) {\n\t\t\t\t/* Mustn't write here until the bad block\n\t\t\t\t * is acknowledged\n\t\t\t\t */\n\t\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\t\tset_bit(BlockedBadBlocks, &rdev->flags);\n\t\t\t\tblocked_rdev = rdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (unlikely(blocked_rdev)) {\n\t\t/* Have to wait for this device to get unblocked, then retry */\n\t\tallow_barrier(conf);\n\t\traid10_log(conf->mddev, \"%s wait rdev %d blocked\",\n\t\t\t\t__func__, blocked_rdev->raid_disk);\n\t\tmd_wait_for_blocked_rdev(blocked_rdev, mddev);\n\t\twait_barrier(conf);\n\t\tgoto retry_wait;\n\t}\n}\n\nstatic void raid10_write_request(struct mddev *mddev, struct bio *bio,\n\t\t\t\t struct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = mddev->private;\n\tint i;\n\tsector_t sectors;\n\tint max_sectors;\n\n\tif ((mddev_is_clustered(mddev) &&\n\t     md_cluster_ops->area_resyncing(mddev, WRITE,\n\t\t\t\t\t    bio->bi_iter.bi_sector,\n\t\t\t\t\t    bio_end_sector(bio)))) {\n\t\tDEFINE_WAIT(w);\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(&conf->wait_barrier,\n\t\t\t\t\t&w, TASK_IDLE);\n\t\t\tif (!md_cluster_ops->area_resyncing(mddev, WRITE,\n\t\t\t\t bio->bi_iter.bi_sector, bio_end_sector(bio)))\n\t\t\t\tbreak;\n\t\t\tschedule();\n\t\t}\n\t\tfinish_wait(&conf->wait_barrier, &w);\n\t}\n\n\tsectors = r10_bio->sectors;\n\tregular_request_wait(mddev, conf, bio, sectors);\n\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n\t    (mddev->reshape_backwards\n\t     ? (bio->bi_iter.bi_sector < conf->reshape_safe &&\n\t\tbio->bi_iter.bi_sector + sectors > conf->reshape_progress)\n\t     : (bio->bi_iter.bi_sector + sectors > conf->reshape_safe &&\n\t\tbio->bi_iter.bi_sector < conf->reshape_progress))) {\n\t\t/* Need to update reshape_position in metadata */\n\t\tmddev->reshape_position = conf->reshape_progress;\n\t\tset_mask_bits(&mddev->sb_flags, 0,\n\t\t\t      BIT(MD_SB_CHANGE_DEVS) | BIT(MD_SB_CHANGE_PENDING));\n\t\tmd_wakeup_thread(mddev->thread);\n\t\traid10_log(conf->mddev, \"wait reshape metadata\");\n\t\twait_event(mddev->sb_wait,\n\t\t\t   !test_bit(MD_SB_CHANGE_PENDING, &mddev->sb_flags));\n\n\t\tconf->reshape_safe = mddev->reshape_position;\n\t}\n\n\tif (conf->pending_count >= max_queued_requests) {\n\t\tmd_wakeup_thread(mddev->thread);\n\t\traid10_log(mddev, \"wait queued\");\n\t\twait_event(conf->wait_barrier,\n\t\t\t   conf->pending_count < max_queued_requests);\n\t}\n\t/* first select target devices under rcu_lock and\n\t * inc refcount on their rdev.  Record them by setting\n\t * bios[x] to bio\n\t * If there are known/acknowledged bad blocks on any device\n\t * on which we have seen a write error, we want to avoid\n\t * writing to those blocks.  This potentially requires several\n\t * writes to write around the bad blocks.  Each set of writes\n\t * gets its own r10_bio with a set of bios attached.\n\t */\n\n\tr10_bio->read_slot = -1; /* make sure repl_bio gets freed */\n\traid10_find_phys(conf, r10_bio);\n\n\twait_blocked_dev(mddev, r10_bio);\n\n\trcu_read_lock();\n\tmax_sectors = r10_bio->sectors;\n\n\tfor (i = 0;  i < conf->copies; i++) {\n\t\tint d = r10_bio->devs[i].devnum;\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\tstruct md_rdev *rrdev = rcu_dereference(\n\t\t\tconf->mirrors[d].replacement);\n\t\tif (rdev == rrdev)\n\t\t\trrdev = NULL;\n\t\tif (rdev && (test_bit(Faulty, &rdev->flags)))\n\t\t\trdev = NULL;\n\t\tif (rrdev && (test_bit(Faulty, &rrdev->flags)))\n\t\t\trrdev = NULL;\n\n\t\tr10_bio->devs[i].bio = NULL;\n\t\tr10_bio->devs[i].repl_bio = NULL;\n\n\t\tif (!rdev && !rrdev) {\n\t\t\tset_bit(R10BIO_Degraded, &r10_bio->state);\n\t\t\tcontinue;\n\t\t}\n\t\tif (rdev && test_bit(WriteErrorSeen, &rdev->flags)) {\n\t\t\tsector_t first_bad;\n\t\t\tsector_t dev_sector = r10_bio->devs[i].addr;\n\t\t\tint bad_sectors;\n\t\t\tint is_bad;\n\n\t\t\tis_bad = is_badblock(rdev, dev_sector, max_sectors,\n\t\t\t\t\t     &first_bad, &bad_sectors);\n\t\t\tif (is_bad && first_bad <= dev_sector) {\n\t\t\t\t/* Cannot write here at all */\n\t\t\t\tbad_sectors -= (dev_sector - first_bad);\n\t\t\t\tif (bad_sectors < max_sectors)\n\t\t\t\t\t/* Mustn't write more than bad_sectors\n\t\t\t\t\t * to other devices yet\n\t\t\t\t\t */\n\t\t\t\t\tmax_sectors = bad_sectors;\n\t\t\t\t/* We don't set R10BIO_Degraded as that\n\t\t\t\t * only applies if the disk is missing,\n\t\t\t\t * so it might be re-added, and we want to\n\t\t\t\t * know to recover this chunk.\n\t\t\t\t * In this case the device is here, and the\n\t\t\t\t * fact that this chunk is not in-sync is\n\t\t\t\t * recorded in the bad block log.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (is_bad) {\n\t\t\t\tint good_sectors = first_bad - dev_sector;\n\t\t\t\tif (good_sectors < max_sectors)\n\t\t\t\t\tmax_sectors = good_sectors;\n\t\t\t}\n\t\t}\n\t\tif (rdev) {\n\t\t\tr10_bio->devs[i].bio = bio;\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t}\n\t\tif (rrdev) {\n\t\t\tr10_bio->devs[i].repl_bio = bio;\n\t\t\tatomic_inc(&rrdev->nr_pending);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (max_sectors < r10_bio->sectors)\n\t\tr10_bio->sectors = max_sectors;\n\n\tif (r10_bio->sectors < bio_sectors(bio)) {\n\t\tstruct bio *split = bio_split(bio, r10_bio->sectors,\n\t\t\t\t\t      GFP_NOIO, &conf->bio_split);\n\t\tbio_chain(split, bio);\n\t\tallow_barrier(conf);\n\t\tsubmit_bio_noacct(bio);\n\t\twait_barrier(conf);\n\t\tbio = split;\n\t\tr10_bio->master_bio = bio;\n\t}\n\n\tatomic_set(&r10_bio->remaining, 1);\n\tmd_bitmap_startwrite(mddev->bitmap, r10_bio->sector, r10_bio->sectors, 0);\n\n\tfor (i = 0; i < conf->copies; i++) {\n\t\tif (r10_bio->devs[i].bio)\n\t\t\traid10_write_one_disk(mddev, r10_bio, bio, false, i);\n\t\tif (r10_bio->devs[i].repl_bio)\n\t\t\traid10_write_one_disk(mddev, r10_bio, bio, true, i);\n\t}\n\tone_write_done(r10_bio);\n}\n\nstatic void __make_request(struct mddev *mddev, struct bio *bio, int sectors)\n{\n\tstruct r10conf *conf = mddev->private;\n\tstruct r10bio *r10_bio;\n\n\tr10_bio = mempool_alloc(&conf->r10bio_pool, GFP_NOIO);\n\n\tr10_bio->master_bio = bio;\n\tr10_bio->sectors = sectors;\n\n\tr10_bio->mddev = mddev;\n\tr10_bio->sector = bio->bi_iter.bi_sector;\n\tr10_bio->state = 0;\n\tr10_bio->read_slot = -1;\n\tmemset(r10_bio->devs, 0, sizeof(r10_bio->devs[0]) * conf->geo.raid_disks);\n\n\tif (bio_data_dir(bio) == READ)\n\t\traid10_read_request(mddev, bio, r10_bio);\n\telse\n\t\traid10_write_request(mddev, bio, r10_bio);\n}\n\nstatic struct bio *raid10_split_bio(struct r10conf *conf,\n\t\t\tstruct bio *bio, sector_t sectors, bool want_first)\n{\n\tstruct bio *split;\n\n\tsplit = bio_split(bio, sectors,\tGFP_NOIO, &conf->bio_split);\n\tbio_chain(split, bio);\n\tallow_barrier(conf);\n\tif (want_first) {\n\t\tsubmit_bio_noacct(bio);\n\t\tbio = split;\n\t} else\n\t\tsubmit_bio_noacct(split);\n\twait_barrier(conf);\n\n\treturn bio;\n}\n\nstatic void raid_end_discard_bio(struct r10bio *r10bio)\n{\n\tstruct r10conf *conf = r10bio->mddev->private;\n\tstruct r10bio *first_r10bio;\n\n\twhile (atomic_dec_and_test(&r10bio->remaining)) {\n\n\t\tallow_barrier(conf);\n\n\t\tif (!test_bit(R10BIO_Discard, &r10bio->state)) {\n\t\t\tfirst_r10bio = (struct r10bio *)r10bio->master_bio;\n\t\t\tfree_r10bio(r10bio);\n\t\t\tr10bio = first_r10bio;\n\t\t} else {\n\t\t\tmd_write_end(r10bio->mddev);\n\t\t\tbio_endio(r10bio->master_bio);\n\t\t\tfree_r10bio(r10bio);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void raid10_end_discard_request(struct bio *bio)\n{\n\tstruct r10bio *r10_bio = bio->bi_private;\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\tstruct md_rdev *rdev = NULL;\n\tint dev;\n\tint slot, repl;\n\n\t/*\n\t * We don't care the return value of discard bio\n\t */\n\tif (!test_bit(R10BIO_Uptodate, &r10_bio->state))\n\t\tset_bit(R10BIO_Uptodate, &r10_bio->state);\n\n\tdev = find_bio_disk(conf, r10_bio, bio, &slot, &repl);\n\tif (repl)\n\t\trdev = conf->mirrors[dev].replacement;\n\tif (!rdev) {\n\t\t/* raid10_remove_disk uses smp_mb to make sure rdev is set to\n\t\t * replacement before setting replacement to NULL. It can read\n\t\t * rdev first without barrier protect even replacment is NULL\n\t\t */\n\t\tsmp_rmb();\n\t\trdev = conf->mirrors[dev].rdev;\n\t}\n\n\traid_end_discard_bio(r10_bio);\n\trdev_dec_pending(rdev, conf->mddev);\n}\n\n/* There are some limitations to handle discard bio\n * 1st, the discard size is bigger than stripe_size*2.\n * 2st, if the discard bio spans reshape progress, we use the old way to\n * handle discard bio\n */\nstatic int raid10_handle_discard(struct mddev *mddev, struct bio *bio)\n{\n\tstruct r10conf *conf = mddev->private;\n\tstruct geom *geo = &conf->geo;\n\tstruct r10bio *r10_bio, *first_r10bio;\n\tint far_copies = geo->far_copies;\n\tbool first_copy = true;\n\n\tint disk;\n\tsector_t chunk;\n\tunsigned int stripe_size;\n\tsector_t split_size;\n\n\tsector_t bio_start, bio_end;\n\tsector_t first_stripe_index, last_stripe_index;\n\tsector_t start_disk_offset;\n\tunsigned int start_disk_index;\n\tsector_t end_disk_offset;\n\tunsigned int end_disk_index;\n\tunsigned int remainder;\n\n\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))\n\t\treturn -EAGAIN;\n\n\twait_barrier(conf);\n\n\t/* Check reshape again to avoid reshape happens after checking\n\t * MD_RECOVERY_RESHAPE and before wait_barrier\n\t */\n\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))\n\t\tgoto out;\n\n\tstripe_size = geo->raid_disks << geo->chunk_shift;\n\tbio_start = bio->bi_iter.bi_sector;\n\tbio_end = bio_end_sector(bio);\n\n\t/* Maybe one discard bio is smaller than strip size or across one stripe\n\t * and discard region is larger than one stripe size. For far offset layout,\n\t * if the discard region is not aligned with stripe size, there is hole\n\t * when we submit discard bio to member disk. For simplicity, we only\n\t * handle discard bio which discard region is bigger than stripe_size*2\n\t */\n\tif (bio_sectors(bio) < stripe_size*2)\n\t\tgoto out;\n\n\t/* For far and far offset layout, if bio is not aligned with stripe size,\n\t * it splits the part that is not aligned with strip size.\n\t */\n\tdiv_u64_rem(bio_start, stripe_size, &remainder);\n\tif ((far_copies > 1) && remainder) {\n\t\tsplit_size = stripe_size - remainder;\n\t\tbio = raid10_split_bio(conf, bio, split_size, false);\n\t}\n\tdiv_u64_rem(bio_end, stripe_size, &remainder);\n\tif ((far_copies > 1) && remainder) {\n\t\tsplit_size = bio_sectors(bio) - remainder;\n\t\tbio = raid10_split_bio(conf, bio, split_size, true);\n\t}\n\n\tbio_start = bio->bi_iter.bi_sector;\n\tbio_end = bio_end_sector(bio);\n\n\t/* raid10 uses chunk as the unit to store data. It's similar like raid0.\n\t * One stripe contains the chunks from all member disk (one chunk from\n\t * one disk at the same HBA address). For layout detail, see 'man md 4'\n\t */\n\tchunk = bio_start >> geo->chunk_shift;\n\tchunk *= geo->near_copies;\n\tfirst_stripe_index = chunk;\n\tstart_disk_index = sector_div(first_stripe_index, geo->raid_disks);\n\tif (geo->far_offset)\n\t\tfirst_stripe_index *= geo->far_copies;\n\tstart_disk_offset = (bio_start & geo->chunk_mask) +\n\t\t\t\t(first_stripe_index << geo->chunk_shift);\n\n\tchunk = bio_end >> geo->chunk_shift;\n\tchunk *= geo->near_copies;\n\tlast_stripe_index = chunk;\n\tend_disk_index = sector_div(last_stripe_index, geo->raid_disks);\n\tif (geo->far_offset)\n\t\tlast_stripe_index *= geo->far_copies;\n\tend_disk_offset = (bio_end & geo->chunk_mask) +\n\t\t\t\t(last_stripe_index << geo->chunk_shift);\n\nretry_discard:\n\tr10_bio = mempool_alloc(&conf->r10bio_pool, GFP_NOIO);\n\tr10_bio->mddev = mddev;\n\tr10_bio->state = 0;\n\tr10_bio->sectors = 0;\n\tmemset(r10_bio->devs, 0, sizeof(r10_bio->devs[0]) * geo->raid_disks);\n\twait_blocked_dev(mddev, r10_bio);\n\n\t/* For far layout it needs more than one r10bio to cover all regions.\n\t * Inspired by raid10_sync_request, we can use the first r10bio->master_bio\n\t * to record the discard bio. Other r10bio->master_bio record the first\n\t * r10bio. The first r10bio only release after all other r10bios finish.\n\t * The discard bio returns only first r10bio finishes\n\t */\n\tif (first_copy) {\n\t\tr10_bio->master_bio = bio;\n\t\tset_bit(R10BIO_Discard, &r10_bio->state);\n\t\tfirst_copy = false;\n\t\tfirst_r10bio = r10_bio;\n\t} else\n\t\tr10_bio->master_bio = (struct bio *)first_r10bio;\n\n\trcu_read_lock();\n\tfor (disk = 0; disk < geo->raid_disks; disk++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[disk].rdev);\n\t\tstruct md_rdev *rrdev = rcu_dereference(\n\t\t\tconf->mirrors[disk].replacement);\n\n\t\tr10_bio->devs[disk].bio = NULL;\n\t\tr10_bio->devs[disk].repl_bio = NULL;\n\n\t\tif (rdev && (test_bit(Faulty, &rdev->flags)))\n\t\t\trdev = NULL;\n\t\tif (rrdev && (test_bit(Faulty, &rrdev->flags)))\n\t\t\trrdev = NULL;\n\t\tif (!rdev && !rrdev)\n\t\t\tcontinue;\n\n\t\tif (rdev) {\n\t\t\tr10_bio->devs[disk].bio = bio;\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t}\n\t\tif (rrdev) {\n\t\t\tr10_bio->devs[disk].repl_bio = bio;\n\t\t\tatomic_inc(&rrdev->nr_pending);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tatomic_set(&r10_bio->remaining, 1);\n\tfor (disk = 0; disk < geo->raid_disks; disk++) {\n\t\tsector_t dev_start, dev_end;\n\t\tstruct bio *mbio, *rbio = NULL;\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[disk].rdev);\n\t\tstruct md_rdev *rrdev = rcu_dereference(\n\t\t\tconf->mirrors[disk].replacement);\n\n\t\t/*\n\t\t * Now start to calculate the start and end address for each disk.\n\t\t * The space between dev_start and dev_end is the discard region.\n\t\t *\n\t\t * For dev_start, it needs to consider three conditions:\n\t\t * 1st, the disk is before start_disk, you can imagine the disk in\n\t\t * the next stripe. So the dev_start is the start address of next\n\t\t * stripe.\n\t\t * 2st, the disk is after start_disk, it means the disk is at the\n\t\t * same stripe of first disk\n\t\t * 3st, the first disk itself, we can use start_disk_offset directly\n\t\t */\n\t\tif (disk < start_disk_index)\n\t\t\tdev_start = (first_stripe_index + 1) * mddev->chunk_sectors;\n\t\telse if (disk > start_disk_index)\n\t\t\tdev_start = first_stripe_index * mddev->chunk_sectors;\n\t\telse\n\t\t\tdev_start = start_disk_offset;\n\n\t\tif (disk < end_disk_index)\n\t\t\tdev_end = (last_stripe_index + 1) * mddev->chunk_sectors;\n\t\telse if (disk > end_disk_index)\n\t\t\tdev_end = last_stripe_index * mddev->chunk_sectors;\n\t\telse\n\t\t\tdev_end = end_disk_offset;\n\n\t\t/* It only handles discard bio which size is >= stripe size, so\n\t\t * dev_end > dev_start all the time\n\t\t */\n\t\tif (r10_bio->devs[disk].bio) {\n\t\t\tmbio = bio_clone_fast(bio, GFP_NOIO, &mddev->bio_set);\n\t\t\tmbio->bi_end_io = raid10_end_discard_request;\n\t\t\tmbio->bi_private = r10_bio;\n\t\t\tr10_bio->devs[disk].bio = mbio;\n\t\t\tr10_bio->devs[disk].devnum = disk;\n\t\t\tatomic_inc(&r10_bio->remaining);\n\t\t\tmd_submit_discard_bio(mddev, rdev, mbio,\n\t\t\t\t\tdev_start + choose_data_offset(r10_bio, rdev),\n\t\t\t\t\tdev_end - dev_start);\n\t\t\tbio_endio(mbio);\n\t\t}\n\t\tif (r10_bio->devs[disk].repl_bio) {\n\t\t\trbio = bio_clone_fast(bio, GFP_NOIO, &mddev->bio_set);\n\t\t\trbio->bi_end_io = raid10_end_discard_request;\n\t\t\trbio->bi_private = r10_bio;\n\t\t\tr10_bio->devs[disk].repl_bio = rbio;\n\t\t\tr10_bio->devs[disk].devnum = disk;\n\t\t\tatomic_inc(&r10_bio->remaining);\n\t\t\tmd_submit_discard_bio(mddev, rrdev, rbio,\n\t\t\t\t\tdev_start + choose_data_offset(r10_bio, rrdev),\n\t\t\t\t\tdev_end - dev_start);\n\t\t\tbio_endio(rbio);\n\t\t}\n\t}\n\n\tif (!geo->far_offset && --far_copies) {\n\t\tfirst_stripe_index += geo->stride >> geo->chunk_shift;\n\t\tstart_disk_offset += geo->stride;\n\t\tlast_stripe_index += geo->stride >> geo->chunk_shift;\n\t\tend_disk_offset += geo->stride;\n\t\tatomic_inc(&first_r10bio->remaining);\n\t\traid_end_discard_bio(r10_bio);\n\t\twait_barrier(conf);\n\t\tgoto retry_discard;\n\t}\n\n\traid_end_discard_bio(r10_bio);\n\n\treturn 0;\nout:\n\tallow_barrier(conf);\n\treturn -EAGAIN;\n}\n\nstatic bool raid10_make_request(struct mddev *mddev, struct bio *bio)\n{\n\tstruct r10conf *conf = mddev->private;\n\tsector_t chunk_mask = (conf->geo.chunk_mask & conf->prev.chunk_mask);\n\tint chunk_sects = chunk_mask + 1;\n\tint sectors = bio_sectors(bio);\n\n\tif (unlikely(bio->bi_opf & REQ_PREFLUSH)\n\t    && md_flush_request(mddev, bio))\n\t\treturn true;\n\n\tif (!md_write_start(mddev, bio))\n\t\treturn false;\n\n\tif (unlikely(bio_op(bio) == REQ_OP_DISCARD))\n\t\tif (!raid10_handle_discard(mddev, bio))\n\t\t\treturn true;\n\n\t/*\n\t * If this request crosses a chunk boundary, we need to split\n\t * it.\n\t */\n\tif (unlikely((bio->bi_iter.bi_sector & chunk_mask) +\n\t\t     sectors > chunk_sects\n\t\t     && (conf->geo.near_copies < conf->geo.raid_disks\n\t\t\t || conf->prev.near_copies <\n\t\t\t conf->prev.raid_disks)))\n\t\tsectors = chunk_sects -\n\t\t\t(bio->bi_iter.bi_sector &\n\t\t\t (chunk_sects - 1));\n\t__make_request(mddev, bio, sectors);\n\n\t/* In case raid10d snuck in to freeze_array */\n\twake_up(&conf->wait_barrier);\n\treturn true;\n}\n\nstatic void raid10_status(struct seq_file *seq, struct mddev *mddev)\n{\n\tstruct r10conf *conf = mddev->private;\n\tint i;\n\n\tif (conf->geo.near_copies < conf->geo.raid_disks)\n\t\tseq_printf(seq, \" %dK chunks\", mddev->chunk_sectors / 2);\n\tif (conf->geo.near_copies > 1)\n\t\tseq_printf(seq, \" %d near-copies\", conf->geo.near_copies);\n\tif (conf->geo.far_copies > 1) {\n\t\tif (conf->geo.far_offset)\n\t\t\tseq_printf(seq, \" %d offset-copies\", conf->geo.far_copies);\n\t\telse\n\t\t\tseq_printf(seq, \" %d far-copies\", conf->geo.far_copies);\n\t\tif (conf->geo.far_set_size != conf->geo.raid_disks)\n\t\t\tseq_printf(seq, \" %d devices per set\", conf->geo.far_set_size);\n\t}\n\tseq_printf(seq, \" [%d/%d] [\", conf->geo.raid_disks,\n\t\t\t\t\tconf->geo.raid_disks - mddev->degraded);\n\trcu_read_lock();\n\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev);\n\t\tseq_printf(seq, \"%s\", rdev && test_bit(In_sync, &rdev->flags) ? \"U\" : \"_\");\n\t}\n\trcu_read_unlock();\n\tseq_printf(seq, \"]\");\n}\n\n/* check if there are enough drives for\n * every block to appear on atleast one.\n * Don't consider the device numbered 'ignore'\n * as we might be about to remove it.\n */\nstatic int _enough(struct r10conf *conf, int previous, int ignore)\n{\n\tint first = 0;\n\tint has_enough = 0;\n\tint disks, ncopies;\n\tif (previous) {\n\t\tdisks = conf->prev.raid_disks;\n\t\tncopies = conf->prev.near_copies;\n\t} else {\n\t\tdisks = conf->geo.raid_disks;\n\t\tncopies = conf->geo.near_copies;\n\t}\n\n\trcu_read_lock();\n\tdo {\n\t\tint n = conf->copies;\n\t\tint cnt = 0;\n\t\tint this = first;\n\t\twhile (n--) {\n\t\t\tstruct md_rdev *rdev;\n\t\t\tif (this != ignore &&\n\t\t\t    (rdev = rcu_dereference(conf->mirrors[this].rdev)) &&\n\t\t\t    test_bit(In_sync, &rdev->flags))\n\t\t\t\tcnt++;\n\t\t\tthis = (this+1) % disks;\n\t\t}\n\t\tif (cnt == 0)\n\t\t\tgoto out;\n\t\tfirst = (first + ncopies) % disks;\n\t} while (first != 0);\n\thas_enough = 1;\nout:\n\trcu_read_unlock();\n\treturn has_enough;\n}\n\nstatic int enough(struct r10conf *conf, int ignore)\n{\n\t/* when calling 'enough', both 'prev' and 'geo' must\n\t * be stable.\n\t * This is ensured if ->reconfig_mutex or ->device_lock\n\t * is held.\n\t */\n\treturn _enough(conf, 0, ignore) &&\n\t\t_enough(conf, 1, ignore);\n}\n\nstatic void raid10_error(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tchar b[BDEVNAME_SIZE];\n\tstruct r10conf *conf = mddev->private;\n\tunsigned long flags;\n\n\t/*\n\t * If it is not operational, then we have already marked it as dead\n\t * else if it is the last working disks with \"fail_last_dev == false\",\n\t * ignore the error, let the next level up know.\n\t * else mark the drive as failed\n\t */\n\tspin_lock_irqsave(&conf->device_lock, flags);\n\tif (test_bit(In_sync, &rdev->flags) && !mddev->fail_last_dev\n\t    && !enough(conf, rdev->raid_disk)) {\n\t\t/*\n\t\t * Don't fail the drive, just return an IO error.\n\t\t */\n\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\t\treturn;\n\t}\n\tif (test_and_clear_bit(In_sync, &rdev->flags))\n\t\tmddev->degraded++;\n\t/*\n\t * If recovery is running, make sure it aborts.\n\t */\n\tset_bit(MD_RECOVERY_INTR, &mddev->recovery);\n\tset_bit(Blocked, &rdev->flags);\n\tset_bit(Faulty, &rdev->flags);\n\tset_mask_bits(&mddev->sb_flags, 0,\n\t\t      BIT(MD_SB_CHANGE_DEVS) | BIT(MD_SB_CHANGE_PENDING));\n\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\tpr_crit(\"md/raid10:%s: Disk failure on %s, disabling device.\\n\"\n\t\t\"md/raid10:%s: Operation continuing on %d devices.\\n\",\n\t\tmdname(mddev), bdevname(rdev->bdev, b),\n\t\tmdname(mddev), conf->geo.raid_disks - mddev->degraded);\n}\n\nstatic void print_conf(struct r10conf *conf)\n{\n\tint i;\n\tstruct md_rdev *rdev;\n\n\tpr_debug(\"RAID10 conf printout:\\n\");\n\tif (!conf) {\n\t\tpr_debug(\"(!conf)\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\" --- wd:%d rd:%d\\n\", conf->geo.raid_disks - conf->mddev->degraded,\n\t\t conf->geo.raid_disks);\n\n\t/* This is only called with ->reconfix_mutex held, so\n\t * rcu protection of rdev is not needed */\n\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\trdev = conf->mirrors[i].rdev;\n\t\tif (rdev)\n\t\t\tpr_debug(\" disk %d, wo:%d, o:%d, dev:%s\\n\",\n\t\t\t\t i, !test_bit(In_sync, &rdev->flags),\n\t\t\t\t !test_bit(Faulty, &rdev->flags),\n\t\t\t\t bdevname(rdev->bdev,b));\n\t}\n}\n\nstatic void close_sync(struct r10conf *conf)\n{\n\twait_barrier(conf);\n\tallow_barrier(conf);\n\n\tmempool_exit(&conf->r10buf_pool);\n}\n\nstatic int raid10_spare_active(struct mddev *mddev)\n{\n\tint i;\n\tstruct r10conf *conf = mddev->private;\n\tstruct raid10_info *tmp;\n\tint count = 0;\n\tunsigned long flags;\n\n\t/*\n\t * Find all non-in_sync disks within the RAID10 configuration\n\t * and mark them in_sync\n\t */\n\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\ttmp = conf->mirrors + i;\n\t\tif (tmp->replacement\n\t\t    && tmp->replacement->recovery_offset == MaxSector\n\t\t    && !test_bit(Faulty, &tmp->replacement->flags)\n\t\t    && !test_and_set_bit(In_sync, &tmp->replacement->flags)) {\n\t\t\t/* Replacement has just become active */\n\t\t\tif (!tmp->rdev\n\t\t\t    || !test_and_clear_bit(In_sync, &tmp->rdev->flags))\n\t\t\t\tcount++;\n\t\t\tif (tmp->rdev) {\n\t\t\t\t/* Replaced device not technically faulty,\n\t\t\t\t * but we need to be sure it gets removed\n\t\t\t\t * and never re-added.\n\t\t\t\t */\n\t\t\t\tset_bit(Faulty, &tmp->rdev->flags);\n\t\t\t\tsysfs_notify_dirent_safe(\n\t\t\t\t\ttmp->rdev->sysfs_state);\n\t\t\t}\n\t\t\tsysfs_notify_dirent_safe(tmp->replacement->sysfs_state);\n\t\t} else if (tmp->rdev\n\t\t\t   && tmp->rdev->recovery_offset == MaxSector\n\t\t\t   && !test_bit(Faulty, &tmp->rdev->flags)\n\t\t\t   && !test_and_set_bit(In_sync, &tmp->rdev->flags)) {\n\t\t\tcount++;\n\t\t\tsysfs_notify_dirent_safe(tmp->rdev->sysfs_state);\n\t\t}\n\t}\n\tspin_lock_irqsave(&conf->device_lock, flags);\n\tmddev->degraded -= count;\n\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\n\tprint_conf(conf);\n\treturn count;\n}\n\nstatic int raid10_add_disk(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct r10conf *conf = mddev->private;\n\tint err = -EEXIST;\n\tint mirror;\n\tint first = 0;\n\tint last = conf->geo.raid_disks - 1;\n\n\tif (mddev->recovery_cp < MaxSector)\n\t\t/* only hot-add to in-sync arrays, as recovery is\n\t\t * very different from resync\n\t\t */\n\t\treturn -EBUSY;\n\tif (rdev->saved_raid_disk < 0 && !_enough(conf, 1, -1))\n\t\treturn -EINVAL;\n\n\tif (md_integrity_add_rdev(rdev, mddev))\n\t\treturn -ENXIO;\n\n\tif (rdev->raid_disk >= 0)\n\t\tfirst = last = rdev->raid_disk;\n\n\tif (rdev->saved_raid_disk >= first &&\n\t    rdev->saved_raid_disk < conf->geo.raid_disks &&\n\t    conf->mirrors[rdev->saved_raid_disk].rdev == NULL)\n\t\tmirror = rdev->saved_raid_disk;\n\telse\n\t\tmirror = first;\n\tfor ( ; mirror <= last ; mirror++) {\n\t\tstruct raid10_info *p = &conf->mirrors[mirror];\n\t\tif (p->recovery_disabled == mddev->recovery_disabled)\n\t\t\tcontinue;\n\t\tif (p->rdev) {\n\t\t\tif (!test_bit(WantReplacement, &p->rdev->flags) ||\n\t\t\t    p->replacement != NULL)\n\t\t\t\tcontinue;\n\t\t\tclear_bit(In_sync, &rdev->flags);\n\t\t\tset_bit(Replacement, &rdev->flags);\n\t\t\trdev->raid_disk = mirror;\n\t\t\terr = 0;\n\t\t\tif (mddev->gendisk)\n\t\t\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t\t\t  rdev->data_offset << 9);\n\t\t\tconf->fullsync = 1;\n\t\t\trcu_assign_pointer(p->replacement, rdev);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mddev->gendisk)\n\t\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t\t  rdev->data_offset << 9);\n\n\t\tp->head_position = 0;\n\t\tp->recovery_disabled = mddev->recovery_disabled - 1;\n\t\trdev->raid_disk = mirror;\n\t\terr = 0;\n\t\tif (rdev->saved_raid_disk != mirror)\n\t\t\tconf->fullsync = 1;\n\t\trcu_assign_pointer(p->rdev, rdev);\n\t\tbreak;\n\t}\n\tif (mddev->queue && blk_queue_discard(bdev_get_queue(rdev->bdev)))\n\t\tblk_queue_flag_set(QUEUE_FLAG_DISCARD, mddev->queue);\n\n\tprint_conf(conf);\n\treturn err;\n}\n\nstatic int raid10_remove_disk(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tstruct r10conf *conf = mddev->private;\n\tint err = 0;\n\tint number = rdev->raid_disk;\n\tstruct md_rdev **rdevp;\n\tstruct raid10_info *p = conf->mirrors + number;\n\n\tprint_conf(conf);\n\tif (rdev == p->rdev)\n\t\trdevp = &p->rdev;\n\telse if (rdev == p->replacement)\n\t\trdevp = &p->replacement;\n\telse\n\t\treturn 0;\n\n\tif (test_bit(In_sync, &rdev->flags) ||\n\t    atomic_read(&rdev->nr_pending)) {\n\t\terr = -EBUSY;\n\t\tgoto abort;\n\t}\n\t/* Only remove non-faulty devices if recovery\n\t * is not possible.\n\t */\n\tif (!test_bit(Faulty, &rdev->flags) &&\n\t    mddev->recovery_disabled != p->recovery_disabled &&\n\t    (!p->replacement || p->replacement == rdev) &&\n\t    number < conf->geo.raid_disks &&\n\t    enough(conf, -1)) {\n\t\terr = -EBUSY;\n\t\tgoto abort;\n\t}\n\t*rdevp = NULL;\n\tif (!test_bit(RemoveSynchronized, &rdev->flags)) {\n\t\tsynchronize_rcu();\n\t\tif (atomic_read(&rdev->nr_pending)) {\n\t\t\t/* lost the race, try later */\n\t\t\terr = -EBUSY;\n\t\t\t*rdevp = rdev;\n\t\t\tgoto abort;\n\t\t}\n\t}\n\tif (p->replacement) {\n\t\t/* We must have just cleared 'rdev' */\n\t\tp->rdev = p->replacement;\n\t\tclear_bit(Replacement, &p->replacement->flags);\n\t\tsmp_mb(); /* Make sure other CPUs may see both as identical\n\t\t\t   * but will never see neither -- if they are careful.\n\t\t\t   */\n\t\tp->replacement = NULL;\n\t}\n\n\tclear_bit(WantReplacement, &rdev->flags);\n\terr = md_integrity_register(mddev);\n\nabort:\n\n\tprint_conf(conf);\n\treturn err;\n}\n\nstatic void __end_sync_read(struct r10bio *r10_bio, struct bio *bio, int d)\n{\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\n\tif (!bio->bi_status)\n\t\tset_bit(R10BIO_Uptodate, &r10_bio->state);\n\telse\n\t\t/* The write handler will notice the lack of\n\t\t * R10BIO_Uptodate and record any errors etc\n\t\t */\n\t\tatomic_add(r10_bio->sectors,\n\t\t\t   &conf->mirrors[d].rdev->corrected_errors);\n\n\t/* for reconstruct, we always reschedule after a read.\n\t * for resync, only after all reads\n\t */\n\trdev_dec_pending(conf->mirrors[d].rdev, conf->mddev);\n\tif (test_bit(R10BIO_IsRecover, &r10_bio->state) ||\n\t    atomic_dec_and_test(&r10_bio->remaining)) {\n\t\t/* we have read all the blocks,\n\t\t * do the comparison in process context in raid10d\n\t\t */\n\t\treschedule_retry(r10_bio);\n\t}\n}\n\nstatic void end_sync_read(struct bio *bio)\n{\n\tstruct r10bio *r10_bio = get_resync_r10bio(bio);\n\tstruct r10conf *conf = r10_bio->mddev->private;\n\tint d = find_bio_disk(conf, r10_bio, bio, NULL, NULL);\n\n\t__end_sync_read(r10_bio, bio, d);\n}\n\nstatic void end_reshape_read(struct bio *bio)\n{\n\t/* reshape read bio isn't allocated from r10buf_pool */\n\tstruct r10bio *r10_bio = bio->bi_private;\n\n\t__end_sync_read(r10_bio, bio, r10_bio->read_slot);\n}\n\nstatic void end_sync_request(struct r10bio *r10_bio)\n{\n\tstruct mddev *mddev = r10_bio->mddev;\n\n\twhile (atomic_dec_and_test(&r10_bio->remaining)) {\n\t\tif (r10_bio->master_bio == NULL) {\n\t\t\t/* the primary of several recovery bios */\n\t\t\tsector_t s = r10_bio->sectors;\n\t\t\tif (test_bit(R10BIO_MadeGood, &r10_bio->state) ||\n\t\t\t    test_bit(R10BIO_WriteError, &r10_bio->state))\n\t\t\t\treschedule_retry(r10_bio);\n\t\t\telse\n\t\t\t\tput_buf(r10_bio);\n\t\t\tmd_done_sync(mddev, s, 1);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct r10bio *r10_bio2 = (struct r10bio *)r10_bio->master_bio;\n\t\t\tif (test_bit(R10BIO_MadeGood, &r10_bio->state) ||\n\t\t\t    test_bit(R10BIO_WriteError, &r10_bio->state))\n\t\t\t\treschedule_retry(r10_bio);\n\t\t\telse\n\t\t\t\tput_buf(r10_bio);\n\t\t\tr10_bio = r10_bio2;\n\t\t}\n\t}\n}\n\nstatic void end_sync_write(struct bio *bio)\n{\n\tstruct r10bio *r10_bio = get_resync_r10bio(bio);\n\tstruct mddev *mddev = r10_bio->mddev;\n\tstruct r10conf *conf = mddev->private;\n\tint d;\n\tsector_t first_bad;\n\tint bad_sectors;\n\tint slot;\n\tint repl;\n\tstruct md_rdev *rdev = NULL;\n\n\td = find_bio_disk(conf, r10_bio, bio, &slot, &repl);\n\tif (repl)\n\t\trdev = conf->mirrors[d].replacement;\n\telse\n\t\trdev = conf->mirrors[d].rdev;\n\n\tif (bio->bi_status) {\n\t\tif (repl)\n\t\t\tmd_error(mddev, rdev);\n\t\telse {\n\t\t\tset_bit(WriteErrorSeen, &rdev->flags);\n\t\t\tif (!test_and_set_bit(WantReplacement, &rdev->flags))\n\t\t\t\tset_bit(MD_RECOVERY_NEEDED,\n\t\t\t\t\t&rdev->mddev->recovery);\n\t\t\tset_bit(R10BIO_WriteError, &r10_bio->state);\n\t\t}\n\t} else if (is_badblock(rdev,\n\t\t\t     r10_bio->devs[slot].addr,\n\t\t\t     r10_bio->sectors,\n\t\t\t     &first_bad, &bad_sectors))\n\t\tset_bit(R10BIO_MadeGood, &r10_bio->state);\n\n\trdev_dec_pending(rdev, mddev);\n\n\tend_sync_request(r10_bio);\n}\n\n/*\n * Note: sync and recover and handled very differently for raid10\n * This code is for resync.\n * For resync, we read through virtual addresses and read all blocks.\n * If there is any error, we schedule a write.  The lowest numbered\n * drive is authoritative.\n * However requests come for physical address, so we need to map.\n * For every physical address there are raid_disks/copies virtual addresses,\n * which is always are least one, but is not necessarly an integer.\n * This means that a physical address can span multiple chunks, so we may\n * have to submit multiple io requests for a single sync request.\n */\n/*\n * We check if all blocks are in-sync and only write to blocks that\n * aren't in sync\n */\nstatic void sync_request_write(struct mddev *mddev, struct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = mddev->private;\n\tint i, first;\n\tstruct bio *tbio, *fbio;\n\tint vcnt;\n\tstruct page **tpages, **fpages;\n\n\tatomic_set(&r10_bio->remaining, 1);\n\n\t/* find the first device with a block */\n\tfor (i=0; i<conf->copies; i++)\n\t\tif (!r10_bio->devs[i].bio->bi_status)\n\t\t\tbreak;\n\n\tif (i == conf->copies)\n\t\tgoto done;\n\n\tfirst = i;\n\tfbio = r10_bio->devs[i].bio;\n\tfbio->bi_iter.bi_size = r10_bio->sectors << 9;\n\tfbio->bi_iter.bi_idx = 0;\n\tfpages = get_resync_pages(fbio)->pages;\n\n\tvcnt = (r10_bio->sectors + (PAGE_SIZE >> 9) - 1) >> (PAGE_SHIFT - 9);\n\t/* now find blocks with errors */\n\tfor (i=0 ; i < conf->copies ; i++) {\n\t\tint  j, d;\n\t\tstruct md_rdev *rdev;\n\t\tstruct resync_pages *rp;\n\n\t\ttbio = r10_bio->devs[i].bio;\n\n\t\tif (tbio->bi_end_io != end_sync_read)\n\t\t\tcontinue;\n\t\tif (i == first)\n\t\t\tcontinue;\n\n\t\ttpages = get_resync_pages(tbio)->pages;\n\t\td = r10_bio->devs[i].devnum;\n\t\trdev = conf->mirrors[d].rdev;\n\t\tif (!r10_bio->devs[i].bio->bi_status) {\n\t\t\t/* We know that the bi_io_vec layout is the same for\n\t\t\t * both 'first' and 'i', so we just compare them.\n\t\t\t * All vec entries are PAGE_SIZE;\n\t\t\t */\n\t\t\tint sectors = r10_bio->sectors;\n\t\t\tfor (j = 0; j < vcnt; j++) {\n\t\t\t\tint len = PAGE_SIZE;\n\t\t\t\tif (sectors < (len / 512))\n\t\t\t\t\tlen = sectors * 512;\n\t\t\t\tif (memcmp(page_address(fpages[j]),\n\t\t\t\t\t   page_address(tpages[j]),\n\t\t\t\t\t   len))\n\t\t\t\t\tbreak;\n\t\t\t\tsectors -= len/512;\n\t\t\t}\n\t\t\tif (j == vcnt)\n\t\t\t\tcontinue;\n\t\t\tatomic64_add(r10_bio->sectors, &mddev->resync_mismatches);\n\t\t\tif (test_bit(MD_RECOVERY_CHECK, &mddev->recovery))\n\t\t\t\t/* Don't fix anything. */\n\t\t\t\tcontinue;\n\t\t} else if (test_bit(FailFast, &rdev->flags)) {\n\t\t\t/* Just give up on this device */\n\t\t\tmd_error(rdev->mddev, rdev);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Ok, we need to write this bio, either to correct an\n\t\t * inconsistency or to correct an unreadable block.\n\t\t * First we need to fixup bv_offset, bv_len and\n\t\t * bi_vecs, as the read request might have corrupted these\n\t\t */\n\t\trp = get_resync_pages(tbio);\n\t\tbio_reset(tbio);\n\n\t\tmd_bio_reset_resync_pages(tbio, rp, fbio->bi_iter.bi_size);\n\n\t\trp->raid_bio = r10_bio;\n\t\ttbio->bi_private = rp;\n\t\ttbio->bi_iter.bi_sector = r10_bio->devs[i].addr;\n\t\ttbio->bi_end_io = end_sync_write;\n\t\tbio_set_op_attrs(tbio, REQ_OP_WRITE, 0);\n\n\t\tbio_copy_data(tbio, fbio);\n\n\t\tatomic_inc(&conf->mirrors[d].rdev->nr_pending);\n\t\tatomic_inc(&r10_bio->remaining);\n\t\tmd_sync_acct(conf->mirrors[d].rdev->bdev, bio_sectors(tbio));\n\n\t\tif (test_bit(FailFast, &conf->mirrors[d].rdev->flags))\n\t\t\ttbio->bi_opf |= MD_FAILFAST;\n\t\ttbio->bi_iter.bi_sector += conf->mirrors[d].rdev->data_offset;\n\t\tbio_set_dev(tbio, conf->mirrors[d].rdev->bdev);\n\t\tsubmit_bio_noacct(tbio);\n\t}\n\n\t/* Now write out to any replacement devices\n\t * that are active\n\t */\n\tfor (i = 0; i < conf->copies; i++) {\n\t\tint d;\n\n\t\ttbio = r10_bio->devs[i].repl_bio;\n\t\tif (!tbio || !tbio->bi_end_io)\n\t\t\tcontinue;\n\t\tif (r10_bio->devs[i].bio->bi_end_io != end_sync_write\n\t\t    && r10_bio->devs[i].bio != fbio)\n\t\t\tbio_copy_data(tbio, fbio);\n\t\td = r10_bio->devs[i].devnum;\n\t\tatomic_inc(&r10_bio->remaining);\n\t\tmd_sync_acct(conf->mirrors[d].replacement->bdev,\n\t\t\t     bio_sectors(tbio));\n\t\tsubmit_bio_noacct(tbio);\n\t}\n\ndone:\n\tif (atomic_dec_and_test(&r10_bio->remaining)) {\n\t\tmd_done_sync(mddev, r10_bio->sectors, 1);\n\t\tput_buf(r10_bio);\n\t}\n}\n\n/*\n * Now for the recovery code.\n * Recovery happens across physical sectors.\n * We recover all non-is_sync drives by finding the virtual address of\n * each, and then choose a working drive that also has that virt address.\n * There is a separate r10_bio for each non-in_sync drive.\n * Only the first two slots are in use. The first for reading,\n * The second for writing.\n *\n */\nstatic void fix_recovery_read_error(struct r10bio *r10_bio)\n{\n\t/* We got a read error during recovery.\n\t * We repeat the read in smaller page-sized sections.\n\t * If a read succeeds, write it to the new device or record\n\t * a bad block if we cannot.\n\t * If a read fails, record a bad block on both old and\n\t * new devices.\n\t */\n\tstruct mddev *mddev = r10_bio->mddev;\n\tstruct r10conf *conf = mddev->private;\n\tstruct bio *bio = r10_bio->devs[0].bio;\n\tsector_t sect = 0;\n\tint sectors = r10_bio->sectors;\n\tint idx = 0;\n\tint dr = r10_bio->devs[0].devnum;\n\tint dw = r10_bio->devs[1].devnum;\n\tstruct page **pages = get_resync_pages(bio)->pages;\n\n\twhile (sectors) {\n\t\tint s = sectors;\n\t\tstruct md_rdev *rdev;\n\t\tsector_t addr;\n\t\tint ok;\n\n\t\tif (s > (PAGE_SIZE>>9))\n\t\t\ts = PAGE_SIZE >> 9;\n\n\t\trdev = conf->mirrors[dr].rdev;\n\t\taddr = r10_bio->devs[0].addr + sect,\n\t\tok = sync_page_io(rdev,\n\t\t\t\t  addr,\n\t\t\t\t  s << 9,\n\t\t\t\t  pages[idx],\n\t\t\t\t  REQ_OP_READ, 0, false);\n\t\tif (ok) {\n\t\t\trdev = conf->mirrors[dw].rdev;\n\t\t\taddr = r10_bio->devs[1].addr + sect;\n\t\t\tok = sync_page_io(rdev,\n\t\t\t\t\t  addr,\n\t\t\t\t\t  s << 9,\n\t\t\t\t\t  pages[idx],\n\t\t\t\t\t  REQ_OP_WRITE, 0, false);\n\t\t\tif (!ok) {\n\t\t\t\tset_bit(WriteErrorSeen, &rdev->flags);\n\t\t\t\tif (!test_and_set_bit(WantReplacement,\n\t\t\t\t\t\t      &rdev->flags))\n\t\t\t\t\tset_bit(MD_RECOVERY_NEEDED,\n\t\t\t\t\t\t&rdev->mddev->recovery);\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\t/* We don't worry if we cannot set a bad block -\n\t\t\t * it really is bad so there is no loss in not\n\t\t\t * recording it yet\n\t\t\t */\n\t\t\trdev_set_badblocks(rdev, addr, s, 0);\n\n\t\t\tif (rdev != conf->mirrors[dw].rdev) {\n\t\t\t\t/* need bad block on destination too */\n\t\t\t\tstruct md_rdev *rdev2 = conf->mirrors[dw].rdev;\n\t\t\t\taddr = r10_bio->devs[1].addr + sect;\n\t\t\t\tok = rdev_set_badblocks(rdev2, addr, s, 0);\n\t\t\t\tif (!ok) {\n\t\t\t\t\t/* just abort the recovery */\n\t\t\t\t\tpr_notice(\"md/raid10:%s: recovery aborted due to read error\\n\",\n\t\t\t\t\t\t  mdname(mddev));\n\n\t\t\t\t\tconf->mirrors[dw].recovery_disabled\n\t\t\t\t\t\t= mddev->recovery_disabled;\n\t\t\t\t\tset_bit(MD_RECOVERY_INTR,\n\t\t\t\t\t\t&mddev->recovery);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsectors -= s;\n\t\tsect += s;\n\t\tidx++;\n\t}\n}\n\nstatic void recovery_request_write(struct mddev *mddev, struct r10bio *r10_bio)\n{\n\tstruct r10conf *conf = mddev->private;\n\tint d;\n\tstruct bio *wbio, *wbio2;\n\n\tif (!test_bit(R10BIO_Uptodate, &r10_bio->state)) {\n\t\tfix_recovery_read_error(r10_bio);\n\t\tend_sync_request(r10_bio);\n\t\treturn;\n\t}\n\n\t/*\n\t * share the pages with the first bio\n\t * and submit the write request\n\t */\n\td = r10_bio->devs[1].devnum;\n\twbio = r10_bio->devs[1].bio;\n\twbio2 = r10_bio->devs[1].repl_bio;\n\t/* Need to test wbio2->bi_end_io before we call\n\t * submit_bio_noacct as if the former is NULL,\n\t * the latter is free to free wbio2.\n\t */\n\tif (wbio2 && !wbio2->bi_end_io)\n\t\twbio2 = NULL;\n\tif (wbio->bi_end_io) {\n\t\tatomic_inc(&conf->mirrors[d].rdev->nr_pending);\n\t\tmd_sync_acct(conf->mirrors[d].rdev->bdev, bio_sectors(wbio));\n\t\tsubmit_bio_noacct(wbio);\n\t}\n\tif (wbio2) {\n\t\tatomic_inc(&conf->mirrors[d].replacement->nr_pending);\n\t\tmd_sync_acct(conf->mirrors[d].replacement->bdev,\n\t\t\t     bio_sectors(wbio2));\n\t\tsubmit_bio_noacct(wbio2);\n\t}\n}\n\n/*\n * Used by fix_read_error() to decay the per rdev read_errors.\n * We halve the read error count for every hour that has elapsed\n * since the last recorded read error.\n *\n */\nstatic void check_decay_read_errors(struct mddev *mddev, struct md_rdev *rdev)\n{\n\tlong cur_time_mon;\n\tunsigned long hours_since_last;\n\tunsigned int read_errors = atomic_read(&rdev->read_errors);\n\n\tcur_time_mon = ktime_get_seconds();\n\n\tif (rdev->last_read_error == 0) {\n\t\t/* first time we've seen a read error */\n\t\trdev->last_read_error = cur_time_mon;\n\t\treturn;\n\t}\n\n\thours_since_last = (long)(cur_time_mon -\n\t\t\t    rdev->last_read_error) / 3600;\n\n\trdev->last_read_error = cur_time_mon;\n\n\t/*\n\t * if hours_since_last is > the number of bits in read_errors\n\t * just set read errors to 0. We do this to avoid\n\t * overflowing the shift of read_errors by hours_since_last.\n\t */\n\tif (hours_since_last >= 8 * sizeof(read_errors))\n\t\tatomic_set(&rdev->read_errors, 0);\n\telse\n\t\tatomic_set(&rdev->read_errors, read_errors >> hours_since_last);\n}\n\nstatic int r10_sync_page_io(struct md_rdev *rdev, sector_t sector,\n\t\t\t    int sectors, struct page *page, int rw)\n{\n\tsector_t first_bad;\n\tint bad_sectors;\n\n\tif (is_badblock(rdev, sector, sectors, &first_bad, &bad_sectors)\n\t    && (rw == READ || test_bit(WriteErrorSeen, &rdev->flags)))\n\t\treturn -1;\n\tif (sync_page_io(rdev, sector, sectors << 9, page, rw, 0, false))\n\t\t/* success */\n\t\treturn 1;\n\tif (rw == WRITE) {\n\t\tset_bit(WriteErrorSeen, &rdev->flags);\n\t\tif (!test_and_set_bit(WantReplacement, &rdev->flags))\n\t\t\tset_bit(MD_RECOVERY_NEEDED,\n\t\t\t\t&rdev->mddev->recovery);\n\t}\n\t/* need to record an error - either for the block or the device */\n\tif (!rdev_set_badblocks(rdev, sector, sectors, 0))\n\t\tmd_error(rdev->mddev, rdev);\n\treturn 0;\n}\n\n/*\n * This is a kernel thread which:\n *\n *\t1.\tRetries failed read operations on working mirrors.\n *\t2.\tUpdates the raid superblock when problems encounter.\n *\t3.\tPerforms writes following reads for array synchronising.\n */\n\nstatic void fix_read_error(struct r10conf *conf, struct mddev *mddev, struct r10bio *r10_bio)\n{\n\tint sect = 0; /* Offset from r10_bio->sector */\n\tint sectors = r10_bio->sectors;\n\tstruct md_rdev *rdev;\n\tint max_read_errors = atomic_read(&mddev->max_corr_read_errors);\n\tint d = r10_bio->devs[r10_bio->read_slot].devnum;\n\n\t/* still own a reference to this rdev, so it cannot\n\t * have been cleared recently.\n\t */\n\trdev = conf->mirrors[d].rdev;\n\n\tif (test_bit(Faulty, &rdev->flags))\n\t\t/* drive has already been failed, just ignore any\n\t\t   more fix_read_error() attempts */\n\t\treturn;\n\n\tcheck_decay_read_errors(mddev, rdev);\n\tatomic_inc(&rdev->read_errors);\n\tif (atomic_read(&rdev->read_errors) > max_read_errors) {\n\t\tchar b[BDEVNAME_SIZE];\n\t\tbdevname(rdev->bdev, b);\n\n\t\tpr_notice(\"md/raid10:%s: %s: Raid device exceeded read_error threshold [cur %d:max %d]\\n\",\n\t\t\t  mdname(mddev), b,\n\t\t\t  atomic_read(&rdev->read_errors), max_read_errors);\n\t\tpr_notice(\"md/raid10:%s: %s: Failing raid device\\n\",\n\t\t\t  mdname(mddev), b);\n\t\tmd_error(mddev, rdev);\n\t\tr10_bio->devs[r10_bio->read_slot].bio = IO_BLOCKED;\n\t\treturn;\n\t}\n\n\twhile(sectors) {\n\t\tint s = sectors;\n\t\tint sl = r10_bio->read_slot;\n\t\tint success = 0;\n\t\tint start;\n\n\t\tif (s > (PAGE_SIZE>>9))\n\t\t\ts = PAGE_SIZE >> 9;\n\n\t\trcu_read_lock();\n\t\tdo {\n\t\t\tsector_t first_bad;\n\t\t\tint bad_sectors;\n\n\t\t\td = r10_bio->devs[sl].devnum;\n\t\t\trdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tif (rdev &&\n\t\t\t    test_bit(In_sync, &rdev->flags) &&\n\t\t\t    !test_bit(Faulty, &rdev->flags) &&\n\t\t\t    is_badblock(rdev, r10_bio->devs[sl].addr + sect, s,\n\t\t\t\t\t&first_bad, &bad_sectors) == 0) {\n\t\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\t\trcu_read_unlock();\n\t\t\t\tsuccess = sync_page_io(rdev,\n\t\t\t\t\t\t       r10_bio->devs[sl].addr +\n\t\t\t\t\t\t       sect,\n\t\t\t\t\t\t       s<<9,\n\t\t\t\t\t\t       conf->tmppage,\n\t\t\t\t\t\t       REQ_OP_READ, 0, false);\n\t\t\t\trdev_dec_pending(rdev, mddev);\n\t\t\t\trcu_read_lock();\n\t\t\t\tif (success)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsl++;\n\t\t\tif (sl == conf->copies)\n\t\t\t\tsl = 0;\n\t\t} while (!success && sl != r10_bio->read_slot);\n\t\trcu_read_unlock();\n\n\t\tif (!success) {\n\t\t\t/* Cannot read from anywhere, just mark the block\n\t\t\t * as bad on the first device to discourage future\n\t\t\t * reads.\n\t\t\t */\n\t\t\tint dn = r10_bio->devs[r10_bio->read_slot].devnum;\n\t\t\trdev = conf->mirrors[dn].rdev;\n\n\t\t\tif (!rdev_set_badblocks(\n\t\t\t\t    rdev,\n\t\t\t\t    r10_bio->devs[r10_bio->read_slot].addr\n\t\t\t\t    + sect,\n\t\t\t\t    s, 0)) {\n\t\t\t\tmd_error(mddev, rdev);\n\t\t\t\tr10_bio->devs[r10_bio->read_slot].bio\n\t\t\t\t\t= IO_BLOCKED;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tstart = sl;\n\t\t/* write it back and re-read */\n\t\trcu_read_lock();\n\t\twhile (sl != r10_bio->read_slot) {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tif (sl==0)\n\t\t\t\tsl = conf->copies;\n\t\t\tsl--;\n\t\t\td = r10_bio->devs[sl].devnum;\n\t\t\trdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tif (!rdev ||\n\t\t\t    test_bit(Faulty, &rdev->flags) ||\n\t\t\t    !test_bit(In_sync, &rdev->flags))\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\tif (r10_sync_page_io(rdev,\n\t\t\t\t\t     r10_bio->devs[sl].addr +\n\t\t\t\t\t     sect,\n\t\t\t\t\t     s, conf->tmppage, WRITE)\n\t\t\t    == 0) {\n\t\t\t\t/* Well, this device is dead */\n\t\t\t\tpr_notice(\"md/raid10:%s: read correction write failed (%d sectors at %llu on %s)\\n\",\n\t\t\t\t\t  mdname(mddev), s,\n\t\t\t\t\t  (unsigned long long)(\n\t\t\t\t\t\t  sect +\n\t\t\t\t\t\t  choose_data_offset(r10_bio,\n\t\t\t\t\t\t\t\t     rdev)),\n\t\t\t\t\t  bdevname(rdev->bdev, b));\n\t\t\t\tpr_notice(\"md/raid10:%s: %s: failing drive\\n\",\n\t\t\t\t\t  mdname(mddev),\n\t\t\t\t\t  bdevname(rdev->bdev, b));\n\t\t\t}\n\t\t\trdev_dec_pending(rdev, mddev);\n\t\t\trcu_read_lock();\n\t\t}\n\t\tsl = start;\n\t\twhile (sl != r10_bio->read_slot) {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tif (sl==0)\n\t\t\t\tsl = conf->copies;\n\t\t\tsl--;\n\t\t\td = r10_bio->devs[sl].devnum;\n\t\t\trdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tif (!rdev ||\n\t\t\t    test_bit(Faulty, &rdev->flags) ||\n\t\t\t    !test_bit(In_sync, &rdev->flags))\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\tswitch (r10_sync_page_io(rdev,\n\t\t\t\t\t     r10_bio->devs[sl].addr +\n\t\t\t\t\t     sect,\n\t\t\t\t\t     s, conf->tmppage,\n\t\t\t\t\t\t READ)) {\n\t\t\tcase 0:\n\t\t\t\t/* Well, this device is dead */\n\t\t\t\tpr_notice(\"md/raid10:%s: unable to read back corrected sectors (%d sectors at %llu on %s)\\n\",\n\t\t\t\t       mdname(mddev), s,\n\t\t\t\t       (unsigned long long)(\n\t\t\t\t\t       sect +\n\t\t\t\t\t       choose_data_offset(r10_bio, rdev)),\n\t\t\t\t       bdevname(rdev->bdev, b));\n\t\t\t\tpr_notice(\"md/raid10:%s: %s: failing drive\\n\",\n\t\t\t\t       mdname(mddev),\n\t\t\t\t       bdevname(rdev->bdev, b));\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tpr_info(\"md/raid10:%s: read error corrected (%d sectors at %llu on %s)\\n\",\n\t\t\t\t       mdname(mddev), s,\n\t\t\t\t       (unsigned long long)(\n\t\t\t\t\t       sect +\n\t\t\t\t\t       choose_data_offset(r10_bio, rdev)),\n\t\t\t\t       bdevname(rdev->bdev, b));\n\t\t\t\tatomic_add(s, &rdev->corrected_errors);\n\t\t\t}\n\n\t\t\trdev_dec_pending(rdev, mddev);\n\t\t\trcu_read_lock();\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tsectors -= s;\n\t\tsect += s;\n\t}\n}\n\nstatic int narrow_write_error(struct r10bio *r10_bio, int i)\n{\n\tstruct bio *bio = r10_bio->master_bio;\n\tstruct mddev *mddev = r10_bio->mddev;\n\tstruct r10conf *conf = mddev->private;\n\tstruct md_rdev *rdev = conf->mirrors[r10_bio->devs[i].devnum].rdev;\n\t/* bio has the data to be written to slot 'i' where\n\t * we just recently had a write error.\n\t * We repeatedly clone the bio and trim down to one block,\n\t * then try the write.  Where the write fails we record\n\t * a bad block.\n\t * It is conceivable that the bio doesn't exactly align with\n\t * blocks.  We must handle this.\n\t *\n\t * We currently own a reference to the rdev.\n\t */\n\n\tint block_sectors;\n\tsector_t sector;\n\tint sectors;\n\tint sect_to_write = r10_bio->sectors;\n\tint ok = 1;\n\n\tif (rdev->badblocks.shift < 0)\n\t\treturn 0;\n\n\tblock_sectors = roundup(1 << rdev->badblocks.shift,\n\t\t\t\tbdev_logical_block_size(rdev->bdev) >> 9);\n\tsector = r10_bio->sector;\n\tsectors = ((r10_bio->sector + block_sectors)\n\t\t   & ~(sector_t)(block_sectors - 1))\n\t\t- sector;\n\n\twhile (sect_to_write) {\n\t\tstruct bio *wbio;\n\t\tsector_t wsector;\n\t\tif (sectors > sect_to_write)\n\t\t\tsectors = sect_to_write;\n\t\t/* Write at 'sector' for 'sectors' */\n\t\twbio = bio_clone_fast(bio, GFP_NOIO, &mddev->bio_set);\n\t\tbio_trim(wbio, sector - bio->bi_iter.bi_sector, sectors);\n\t\twsector = r10_bio->devs[i].addr + (sector - r10_bio->sector);\n\t\twbio->bi_iter.bi_sector = wsector +\n\t\t\t\t   choose_data_offset(r10_bio, rdev);\n\t\tbio_set_dev(wbio, rdev->bdev);\n\t\tbio_set_op_attrs(wbio, REQ_OP_WRITE, 0);\n\n\t\tif (submit_bio_wait(wbio) < 0)\n\t\t\t/* Failure! */\n\t\t\tok = rdev_set_badblocks(rdev, wsector,\n\t\t\t\t\t\tsectors, 0)\n\t\t\t\t&& ok;\n\n\t\tbio_put(wbio);\n\t\tsect_to_write -= sectors;\n\t\tsector += sectors;\n\t\tsectors = block_sectors;\n\t}\n\treturn ok;\n}\n\nstatic void handle_read_error(struct mddev *mddev, struct r10bio *r10_bio)\n{\n\tint slot = r10_bio->read_slot;\n\tstruct bio *bio;\n\tstruct r10conf *conf = mddev->private;\n\tstruct md_rdev *rdev = r10_bio->devs[slot].rdev;\n\n\t/* we got a read error. Maybe the drive is bad.  Maybe just\n\t * the block and we can fix it.\n\t * We freeze all other IO, and try reading the block from\n\t * other devices.  When we find one, we re-write\n\t * and check it that fixes the read error.\n\t * This is all done synchronously while the array is\n\t * frozen.\n\t */\n\tbio = r10_bio->devs[slot].bio;\n\tbio_put(bio);\n\tr10_bio->devs[slot].bio = NULL;\n\n\tif (mddev->ro)\n\t\tr10_bio->devs[slot].bio = IO_BLOCKED;\n\telse if (!test_bit(FailFast, &rdev->flags)) {\n\t\tfreeze_array(conf, 1);\n\t\tfix_read_error(conf, mddev, r10_bio);\n\t\tunfreeze_array(conf);\n\t} else\n\t\tmd_error(mddev, rdev);\n\n\trdev_dec_pending(rdev, mddev);\n\tallow_barrier(conf);\n\tr10_bio->state = 0;\n\traid10_read_request(mddev, r10_bio->master_bio, r10_bio);\n}\n\nstatic void handle_write_completed(struct r10conf *conf, struct r10bio *r10_bio)\n{\n\t/* Some sort of write request has finished and it\n\t * succeeded in writing where we thought there was a\n\t * bad block.  So forget the bad block.\n\t * Or possibly if failed and we need to record\n\t * a bad block.\n\t */\n\tint m;\n\tstruct md_rdev *rdev;\n\n\tif (test_bit(R10BIO_IsSync, &r10_bio->state) ||\n\t    test_bit(R10BIO_IsRecover, &r10_bio->state)) {\n\t\tfor (m = 0; m < conf->copies; m++) {\n\t\t\tint dev = r10_bio->devs[m].devnum;\n\t\t\trdev = conf->mirrors[dev].rdev;\n\t\t\tif (r10_bio->devs[m].bio == NULL ||\n\t\t\t\tr10_bio->devs[m].bio->bi_end_io == NULL)\n\t\t\t\tcontinue;\n\t\t\tif (!r10_bio->devs[m].bio->bi_status) {\n\t\t\t\trdev_clear_badblocks(\n\t\t\t\t\trdev,\n\t\t\t\t\tr10_bio->devs[m].addr,\n\t\t\t\t\tr10_bio->sectors, 0);\n\t\t\t} else {\n\t\t\t\tif (!rdev_set_badblocks(\n\t\t\t\t\t    rdev,\n\t\t\t\t\t    r10_bio->devs[m].addr,\n\t\t\t\t\t    r10_bio->sectors, 0))\n\t\t\t\t\tmd_error(conf->mddev, rdev);\n\t\t\t}\n\t\t\trdev = conf->mirrors[dev].replacement;\n\t\t\tif (r10_bio->devs[m].repl_bio == NULL ||\n\t\t\t\tr10_bio->devs[m].repl_bio->bi_end_io == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (!r10_bio->devs[m].repl_bio->bi_status) {\n\t\t\t\trdev_clear_badblocks(\n\t\t\t\t\trdev,\n\t\t\t\t\tr10_bio->devs[m].addr,\n\t\t\t\t\tr10_bio->sectors, 0);\n\t\t\t} else {\n\t\t\t\tif (!rdev_set_badblocks(\n\t\t\t\t\t    rdev,\n\t\t\t\t\t    r10_bio->devs[m].addr,\n\t\t\t\t\t    r10_bio->sectors, 0))\n\t\t\t\t\tmd_error(conf->mddev, rdev);\n\t\t\t}\n\t\t}\n\t\tput_buf(r10_bio);\n\t} else {\n\t\tbool fail = false;\n\t\tfor (m = 0; m < conf->copies; m++) {\n\t\t\tint dev = r10_bio->devs[m].devnum;\n\t\t\tstruct bio *bio = r10_bio->devs[m].bio;\n\t\t\trdev = conf->mirrors[dev].rdev;\n\t\t\tif (bio == IO_MADE_GOOD) {\n\t\t\t\trdev_clear_badblocks(\n\t\t\t\t\trdev,\n\t\t\t\t\tr10_bio->devs[m].addr,\n\t\t\t\t\tr10_bio->sectors, 0);\n\t\t\t\trdev_dec_pending(rdev, conf->mddev);\n\t\t\t} else if (bio != NULL && bio->bi_status) {\n\t\t\t\tfail = true;\n\t\t\t\tif (!narrow_write_error(r10_bio, m)) {\n\t\t\t\t\tmd_error(conf->mddev, rdev);\n\t\t\t\t\tset_bit(R10BIO_Degraded,\n\t\t\t\t\t\t&r10_bio->state);\n\t\t\t\t}\n\t\t\t\trdev_dec_pending(rdev, conf->mddev);\n\t\t\t}\n\t\t\tbio = r10_bio->devs[m].repl_bio;\n\t\t\trdev = conf->mirrors[dev].replacement;\n\t\t\tif (rdev && bio == IO_MADE_GOOD) {\n\t\t\t\trdev_clear_badblocks(\n\t\t\t\t\trdev,\n\t\t\t\t\tr10_bio->devs[m].addr,\n\t\t\t\t\tr10_bio->sectors, 0);\n\t\t\t\trdev_dec_pending(rdev, conf->mddev);\n\t\t\t}\n\t\t}\n\t\tif (fail) {\n\t\t\tspin_lock_irq(&conf->device_lock);\n\t\t\tlist_add(&r10_bio->retry_list, &conf->bio_end_io_list);\n\t\t\tconf->nr_queued++;\n\t\t\tspin_unlock_irq(&conf->device_lock);\n\t\t\t/*\n\t\t\t * In case freeze_array() is waiting for condition\n\t\t\t * nr_pending == nr_queued + extra to be true.\n\t\t\t */\n\t\t\twake_up(&conf->wait_barrier);\n\t\t\tmd_wakeup_thread(conf->mddev->thread);\n\t\t} else {\n\t\t\tif (test_bit(R10BIO_WriteError,\n\t\t\t\t     &r10_bio->state))\n\t\t\t\tclose_write(r10_bio);\n\t\t\traid_end_bio_io(r10_bio);\n\t\t}\n\t}\n}\n\nstatic void raid10d(struct md_thread *thread)\n{\n\tstruct mddev *mddev = thread->mddev;\n\tstruct r10bio *r10_bio;\n\tunsigned long flags;\n\tstruct r10conf *conf = mddev->private;\n\tstruct list_head *head = &conf->retry_list;\n\tstruct blk_plug plug;\n\n\tmd_check_recovery(mddev);\n\n\tif (!list_empty_careful(&conf->bio_end_io_list) &&\n\t    !test_bit(MD_SB_CHANGE_PENDING, &mddev->sb_flags)) {\n\t\tLIST_HEAD(tmp);\n\t\tspin_lock_irqsave(&conf->device_lock, flags);\n\t\tif (!test_bit(MD_SB_CHANGE_PENDING, &mddev->sb_flags)) {\n\t\t\twhile (!list_empty(&conf->bio_end_io_list)) {\n\t\t\t\tlist_move(conf->bio_end_io_list.prev, &tmp);\n\t\t\t\tconf->nr_queued--;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\t\twhile (!list_empty(&tmp)) {\n\t\t\tr10_bio = list_first_entry(&tmp, struct r10bio,\n\t\t\t\t\t\t   retry_list);\n\t\t\tlist_del(&r10_bio->retry_list);\n\t\t\tif (mddev->degraded)\n\t\t\t\tset_bit(R10BIO_Degraded, &r10_bio->state);\n\n\t\t\tif (test_bit(R10BIO_WriteError,\n\t\t\t\t     &r10_bio->state))\n\t\t\t\tclose_write(r10_bio);\n\t\t\traid_end_bio_io(r10_bio);\n\t\t}\n\t}\n\n\tblk_start_plug(&plug);\n\tfor (;;) {\n\n\t\tflush_pending_writes(conf);\n\n\t\tspin_lock_irqsave(&conf->device_lock, flags);\n\t\tif (list_empty(head)) {\n\t\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tr10_bio = list_entry(head->prev, struct r10bio, retry_list);\n\t\tlist_del(head->prev);\n\t\tconf->nr_queued--;\n\t\tspin_unlock_irqrestore(&conf->device_lock, flags);\n\n\t\tmddev = r10_bio->mddev;\n\t\tconf = mddev->private;\n\t\tif (test_bit(R10BIO_MadeGood, &r10_bio->state) ||\n\t\t    test_bit(R10BIO_WriteError, &r10_bio->state))\n\t\t\thandle_write_completed(conf, r10_bio);\n\t\telse if (test_bit(R10BIO_IsReshape, &r10_bio->state))\n\t\t\treshape_request_write(mddev, r10_bio);\n\t\telse if (test_bit(R10BIO_IsSync, &r10_bio->state))\n\t\t\tsync_request_write(mddev, r10_bio);\n\t\telse if (test_bit(R10BIO_IsRecover, &r10_bio->state))\n\t\t\trecovery_request_write(mddev, r10_bio);\n\t\telse if (test_bit(R10BIO_ReadError, &r10_bio->state))\n\t\t\thandle_read_error(mddev, r10_bio);\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\n\t\tcond_resched();\n\t\tif (mddev->sb_flags & ~(1<<MD_SB_CHANGE_PENDING))\n\t\t\tmd_check_recovery(mddev);\n\t}\n\tblk_finish_plug(&plug);\n}\n\nstatic int init_resync(struct r10conf *conf)\n{\n\tint ret, buffs, i;\n\n\tbuffs = RESYNC_WINDOW / RESYNC_BLOCK_SIZE;\n\tBUG_ON(mempool_initialized(&conf->r10buf_pool));\n\tconf->have_replacement = 0;\n\tfor (i = 0; i < conf->geo.raid_disks; i++)\n\t\tif (conf->mirrors[i].replacement)\n\t\t\tconf->have_replacement = 1;\n\tret = mempool_init(&conf->r10buf_pool, buffs,\n\t\t\t   r10buf_pool_alloc, r10buf_pool_free, conf);\n\tif (ret)\n\t\treturn ret;\n\tconf->next_resync = 0;\n\treturn 0;\n}\n\nstatic struct r10bio *raid10_alloc_init_r10buf(struct r10conf *conf)\n{\n\tstruct r10bio *r10bio = mempool_alloc(&conf->r10buf_pool, GFP_NOIO);\n\tstruct rsync_pages *rp;\n\tstruct bio *bio;\n\tint nalloc;\n\tint i;\n\n\tif (test_bit(MD_RECOVERY_SYNC, &conf->mddev->recovery) ||\n\t    test_bit(MD_RECOVERY_RESHAPE, &conf->mddev->recovery))\n\t\tnalloc = conf->copies; /* resync */\n\telse\n\t\tnalloc = 2; /* recovery */\n\n\tfor (i = 0; i < nalloc; i++) {\n\t\tbio = r10bio->devs[i].bio;\n\t\trp = bio->bi_private;\n\t\tbio_reset(bio);\n\t\tbio->bi_private = rp;\n\t\tbio = r10bio->devs[i].repl_bio;\n\t\tif (bio) {\n\t\t\trp = bio->bi_private;\n\t\t\tbio_reset(bio);\n\t\t\tbio->bi_private = rp;\n\t\t}\n\t}\n\treturn r10bio;\n}\n\n/*\n * Set cluster_sync_high since we need other nodes to add the\n * range [cluster_sync_low, cluster_sync_high] to suspend list.\n */\nstatic void raid10_set_cluster_sync_high(struct r10conf *conf)\n{\n\tsector_t window_size;\n\tint extra_chunk, chunks;\n\n\t/*\n\t * First, here we define \"stripe\" as a unit which across\n\t * all member devices one time, so we get chunks by use\n\t * raid_disks / near_copies. Otherwise, if near_copies is\n\t * close to raid_disks, then resync window could increases\n\t * linearly with the increase of raid_disks, which means\n\t * we will suspend a really large IO window while it is not\n\t * necessary. If raid_disks is not divisible by near_copies,\n\t * an extra chunk is needed to ensure the whole \"stripe\" is\n\t * covered.\n\t */\n\n\tchunks = conf->geo.raid_disks / conf->geo.near_copies;\n\tif (conf->geo.raid_disks % conf->geo.near_copies == 0)\n\t\textra_chunk = 0;\n\telse\n\t\textra_chunk = 1;\n\twindow_size = (chunks + extra_chunk) * conf->mddev->chunk_sectors;\n\n\t/*\n\t * At least use a 32M window to align with raid1's resync window\n\t */\n\twindow_size = (CLUSTER_RESYNC_WINDOW_SECTORS > window_size) ?\n\t\t\tCLUSTER_RESYNC_WINDOW_SECTORS : window_size;\n\n\tconf->cluster_sync_high = conf->cluster_sync_low + window_size;\n}\n\n/*\n * perform a \"sync\" on one \"block\"\n *\n * We need to make sure that no normal I/O request - particularly write\n * requests - conflict with active sync requests.\n *\n * This is achieved by tracking pending requests and a 'barrier' concept\n * that can be installed to exclude normal IO requests.\n *\n * Resync and recovery are handled very differently.\n * We differentiate by looking at MD_RECOVERY_SYNC in mddev->recovery.\n *\n * For resync, we iterate over virtual addresses, read all copies,\n * and update if there are differences.  If only one copy is live,\n * skip it.\n * For recovery, we iterate over physical addresses, read a good\n * value for each non-in_sync drive, and over-write.\n *\n * So, for recovery we may have several outstanding complex requests for a\n * given address, one for each out-of-sync device.  We model this by allocating\n * a number of r10_bio structures, one for each out-of-sync device.\n * As we setup these structures, we collect all bio's together into a list\n * which we then process collectively to add pages, and then process again\n * to pass to submit_bio_noacct.\n *\n * The r10_bio structures are linked using a borrowed master_bio pointer.\n * This link is counted in ->remaining.  When the r10_bio that points to NULL\n * has its remaining count decremented to 0, the whole complex operation\n * is complete.\n *\n */\n\nstatic sector_t raid10_sync_request(struct mddev *mddev, sector_t sector_nr,\n\t\t\t     int *skipped)\n{\n\tstruct r10conf *conf = mddev->private;\n\tstruct r10bio *r10_bio;\n\tstruct bio *biolist = NULL, *bio;\n\tsector_t max_sector, nr_sectors;\n\tint i;\n\tint max_sync;\n\tsector_t sync_blocks;\n\tsector_t sectors_skipped = 0;\n\tint chunks_skipped = 0;\n\tsector_t chunk_mask = conf->geo.chunk_mask;\n\tint page_idx = 0;\n\n\tif (!mempool_initialized(&conf->r10buf_pool))\n\t\tif (init_resync(conf))\n\t\t\treturn 0;\n\n\t/*\n\t * Allow skipping a full rebuild for incremental assembly\n\t * of a clean array, like RAID1 does.\n\t */\n\tif (mddev->bitmap == NULL &&\n\t    mddev->recovery_cp == MaxSector &&\n\t    mddev->reshape_position == MaxSector &&\n\t    !test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&\n\t    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery) &&\n\t    !test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&\n\t    conf->fullsync == 0) {\n\t\t*skipped = 1;\n\t\treturn mddev->dev_sectors - sector_nr;\n\t}\n\n skipped:\n\tmax_sector = mddev->dev_sectors;\n\tif (test_bit(MD_RECOVERY_SYNC, &mddev->recovery) ||\n\t    test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))\n\t\tmax_sector = mddev->resync_max_sectors;\n\tif (sector_nr >= max_sector) {\n\t\tconf->cluster_sync_low = 0;\n\t\tconf->cluster_sync_high = 0;\n\n\t\t/* If we aborted, we need to abort the\n\t\t * sync on the 'current' bitmap chucks (there can\n\t\t * be several when recovering multiple devices).\n\t\t * as we may have started syncing it but not finished.\n\t\t * We can find the current address in\n\t\t * mddev->curr_resync, but for recovery,\n\t\t * we need to convert that to several\n\t\t * virtual addresses.\n\t\t */\n\t\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery)) {\n\t\t\tend_reshape(conf);\n\t\t\tclose_sync(conf);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (mddev->curr_resync < max_sector) { /* aborted */\n\t\t\tif (test_bit(MD_RECOVERY_SYNC, &mddev->recovery))\n\t\t\t\tmd_bitmap_end_sync(mddev->bitmap, mddev->curr_resync,\n\t\t\t\t\t\t   &sync_blocks, 1);\n\t\t\telse for (i = 0; i < conf->geo.raid_disks; i++) {\n\t\t\t\tsector_t sect =\n\t\t\t\t\traid10_find_virt(conf, mddev->curr_resync, i);\n\t\t\t\tmd_bitmap_end_sync(mddev->bitmap, sect,\n\t\t\t\t\t\t   &sync_blocks, 1);\n\t\t\t}\n\t\t} else {\n\t\t\t/* completed sync */\n\t\t\tif ((!mddev->bitmap || conf->fullsync)\n\t\t\t    && conf->have_replacement\n\t\t\t    && test_bit(MD_RECOVERY_SYNC, &mddev->recovery)) {\n\t\t\t\t/* Completed a full sync so the replacements\n\t\t\t\t * are now fully recovered.\n\t\t\t\t */\n\t\t\t\trcu_read_lock();\n\t\t\t\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\t\t\t\tstruct md_rdev *rdev =\n\t\t\t\t\t\trcu_dereference(conf->mirrors[i].replacement);\n\t\t\t\t\tif (rdev)\n\t\t\t\t\t\trdev->recovery_offset = MaxSector;\n\t\t\t\t}\n\t\t\t\trcu_read_unlock();\n\t\t\t}\n\t\t\tconf->fullsync = 0;\n\t\t}\n\t\tmd_bitmap_close_sync(mddev->bitmap);\n\t\tclose_sync(conf);\n\t\t*skipped = 1;\n\t\treturn sectors_skipped;\n\t}\n\n\tif (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))\n\t\treturn reshape_request(mddev, sector_nr, skipped);\n\n\tif (chunks_skipped >= conf->geo.raid_disks) {\n\t\t/* if there has been nothing to do on any drive,\n\t\t * then there is nothing to do at all..\n\t\t */\n\t\t*skipped = 1;\n\t\treturn (max_sector - sector_nr) + sectors_skipped;\n\t}\n\n\tif (max_sector > mddev->resync_max)\n\t\tmax_sector = mddev->resync_max; /* Don't do IO beyond here */\n\n\t/* make sure whole request will fit in a chunk - if chunks\n\t * are meaningful\n\t */\n\tif (conf->geo.near_copies < conf->geo.raid_disks &&\n\t    max_sector > (sector_nr | chunk_mask))\n\t\tmax_sector = (sector_nr | chunk_mask) + 1;\n\n\t/*\n\t * If there is non-resync activity waiting for a turn, then let it\n\t * though before starting on this new sync request.\n\t */\n\tif (conf->nr_waiting)\n\t\tschedule_timeout_uninterruptible(1);\n\n\t/* Again, very different code for resync and recovery.\n\t * Both must result in an r10bio with a list of bios that\n\t * have bi_end_io, bi_sector, bi_disk set,\n\t * and bi_private set to the r10bio.\n\t * For recovery, we may actually create several r10bios\n\t * with 2 bios in each, that correspond to the bios in the main one.\n\t * In this case, the subordinate r10bios link back through a\n\t * borrowed master_bio pointer, and the counter in the master\n\t * includes a ref from each subordinate.\n\t */\n\t/* First, we decide what to do and set ->bi_end_io\n\t * To end_sync_read if we want to read, and\n\t * end_sync_write if we will want to write.\n\t */\n\n\tmax_sync = RESYNC_PAGES << (PAGE_SHIFT-9);\n\tif (!test_bit(MD_RECOVERY_SYNC, &mddev->recovery)) {\n\t\t/* recovery... the complicated one */\n\t\tint j;\n\t\tr10_bio = NULL;\n\n\t\tfor (i = 0 ; i < conf->geo.raid_disks; i++) {\n\t\t\tint still_degraded;\n\t\t\tstruct r10bio *rb2;\n\t\t\tsector_t sect;\n\t\t\tint must_sync;\n\t\t\tint any_working;\n\t\t\tint need_recover = 0;\n\t\t\tint need_replace = 0;\n\t\t\tstruct raid10_info *mirror = &conf->mirrors[i];\n\t\t\tstruct md_rdev *mrdev, *mreplace;\n\n\t\t\trcu_read_lock();\n\t\t\tmrdev = rcu_dereference(mirror->rdev);\n\t\t\tmreplace = rcu_dereference(mirror->replacement);\n\n\t\t\tif (mrdev != NULL &&\n\t\t\t    !test_bit(Faulty, &mrdev->flags) &&\n\t\t\t    !test_bit(In_sync, &mrdev->flags))\n\t\t\t\tneed_recover = 1;\n\t\t\tif (mreplace != NULL &&\n\t\t\t    !test_bit(Faulty, &mreplace->flags))\n\t\t\t\tneed_replace = 1;\n\n\t\t\tif (!need_recover && !need_replace) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstill_degraded = 0;\n\t\t\t/* want to reconstruct this device */\n\t\t\trb2 = r10_bio;\n\t\t\tsect = raid10_find_virt(conf, sector_nr, i);\n\t\t\tif (sect >= mddev->resync_max_sectors) {\n\t\t\t\t/* last stripe is not complete - don't\n\t\t\t\t * try to recover this sector.\n\t\t\t\t */\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mreplace && test_bit(Faulty, &mreplace->flags))\n\t\t\t\tmreplace = NULL;\n\t\t\t/* Unless we are doing a full sync, or a replacement\n\t\t\t * we only need to recover the block if it is set in\n\t\t\t * the bitmap\n\t\t\t */\n\t\t\tmust_sync = md_bitmap_start_sync(mddev->bitmap, sect,\n\t\t\t\t\t\t\t &sync_blocks, 1);\n\t\t\tif (sync_blocks < max_sync)\n\t\t\t\tmax_sync = sync_blocks;\n\t\t\tif (!must_sync &&\n\t\t\t    mreplace == NULL &&\n\t\t\t    !conf->fullsync) {\n\t\t\t\t/* yep, skip the sync_blocks here, but don't assume\n\t\t\t\t * that there will never be anything to do here\n\t\t\t\t */\n\t\t\t\tchunks_skipped = -1;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&mrdev->nr_pending);\n\t\t\tif (mreplace)\n\t\t\t\tatomic_inc(&mreplace->nr_pending);\n\t\t\trcu_read_unlock();\n\n\t\t\tr10_bio = raid10_alloc_init_r10buf(conf);\n\t\t\tr10_bio->state = 0;\n\t\t\traise_barrier(conf, rb2 != NULL);\n\t\t\tatomic_set(&r10_bio->remaining, 0);\n\n\t\t\tr10_bio->master_bio = (struct bio*)rb2;\n\t\t\tif (rb2)\n\t\t\t\tatomic_inc(&rb2->remaining);\n\t\t\tr10_bio->mddev = mddev;\n\t\t\tset_bit(R10BIO_IsRecover, &r10_bio->state);\n\t\t\tr10_bio->sector = sect;\n\n\t\t\traid10_find_phys(conf, r10_bio);\n\n\t\t\t/* Need to check if the array will still be\n\t\t\t * degraded\n\t\t\t */\n\t\t\trcu_read_lock();\n\t\t\tfor (j = 0; j < conf->geo.raid_disks; j++) {\n\t\t\t\tstruct md_rdev *rdev = rcu_dereference(\n\t\t\t\t\tconf->mirrors[j].rdev);\n\t\t\t\tif (rdev == NULL || test_bit(Faulty, &rdev->flags)) {\n\t\t\t\t\tstill_degraded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmust_sync = md_bitmap_start_sync(mddev->bitmap, sect,\n\t\t\t\t\t\t\t &sync_blocks, still_degraded);\n\n\t\t\tany_working = 0;\n\t\t\tfor (j=0; j<conf->copies;j++) {\n\t\t\t\tint k;\n\t\t\t\tint d = r10_bio->devs[j].devnum;\n\t\t\t\tsector_t from_addr, to_addr;\n\t\t\t\tstruct md_rdev *rdev =\n\t\t\t\t\trcu_dereference(conf->mirrors[d].rdev);\n\t\t\t\tsector_t sector, first_bad;\n\t\t\t\tint bad_sectors;\n\t\t\t\tif (!rdev ||\n\t\t\t\t    !test_bit(In_sync, &rdev->flags))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* This is where we read from */\n\t\t\t\tany_working = 1;\n\t\t\t\tsector = r10_bio->devs[j].addr;\n\n\t\t\t\tif (is_badblock(rdev, sector, max_sync,\n\t\t\t\t\t\t&first_bad, &bad_sectors)) {\n\t\t\t\t\tif (first_bad > sector)\n\t\t\t\t\t\tmax_sync = first_bad - sector;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbad_sectors -= (sector\n\t\t\t\t\t\t\t\t- first_bad);\n\t\t\t\t\t\tif (max_sync > bad_sectors)\n\t\t\t\t\t\t\tmax_sync = bad_sectors;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbio = r10_bio->devs[0].bio;\n\t\t\t\tbio->bi_next = biolist;\n\t\t\t\tbiolist = bio;\n\t\t\t\tbio->bi_end_io = end_sync_read;\n\t\t\t\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\t\t\t\tif (test_bit(FailFast, &rdev->flags))\n\t\t\t\t\tbio->bi_opf |= MD_FAILFAST;\n\t\t\t\tfrom_addr = r10_bio->devs[j].addr;\n\t\t\t\tbio->bi_iter.bi_sector = from_addr +\n\t\t\t\t\trdev->data_offset;\n\t\t\t\tbio_set_dev(bio, rdev->bdev);\n\t\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\t\t/* and we write to 'i' (if not in_sync) */\n\n\t\t\t\tfor (k=0; k<conf->copies; k++)\n\t\t\t\t\tif (r10_bio->devs[k].devnum == i)\n\t\t\t\t\t\tbreak;\n\t\t\t\tBUG_ON(k == conf->copies);\n\t\t\t\tto_addr = r10_bio->devs[k].addr;\n\t\t\t\tr10_bio->devs[0].devnum = d;\n\t\t\t\tr10_bio->devs[0].addr = from_addr;\n\t\t\t\tr10_bio->devs[1].devnum = i;\n\t\t\t\tr10_bio->devs[1].addr = to_addr;\n\n\t\t\t\tif (need_recover) {\n\t\t\t\t\tbio = r10_bio->devs[1].bio;\n\t\t\t\t\tbio->bi_next = biolist;\n\t\t\t\t\tbiolist = bio;\n\t\t\t\t\tbio->bi_end_io = end_sync_write;\n\t\t\t\t\tbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\n\t\t\t\t\tbio->bi_iter.bi_sector = to_addr\n\t\t\t\t\t\t+ mrdev->data_offset;\n\t\t\t\t\tbio_set_dev(bio, mrdev->bdev);\n\t\t\t\t\tatomic_inc(&r10_bio->remaining);\n\t\t\t\t} else\n\t\t\t\t\tr10_bio->devs[1].bio->bi_end_io = NULL;\n\n\t\t\t\t/* and maybe write to replacement */\n\t\t\t\tbio = r10_bio->devs[1].repl_bio;\n\t\t\t\tif (bio)\n\t\t\t\t\tbio->bi_end_io = NULL;\n\t\t\t\t/* Note: if need_replace, then bio\n\t\t\t\t * cannot be NULL as r10buf_pool_alloc will\n\t\t\t\t * have allocated it.\n\t\t\t\t */\n\t\t\t\tif (!need_replace)\n\t\t\t\t\tbreak;\n\t\t\t\tbio->bi_next = biolist;\n\t\t\t\tbiolist = bio;\n\t\t\t\tbio->bi_end_io = end_sync_write;\n\t\t\t\tbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\n\t\t\t\tbio->bi_iter.bi_sector = to_addr +\n\t\t\t\t\tmreplace->data_offset;\n\t\t\t\tbio_set_dev(bio, mreplace->bdev);\n\t\t\t\tatomic_inc(&r10_bio->remaining);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tif (j == conf->copies) {\n\t\t\t\t/* Cannot recover, so abort the recovery or\n\t\t\t\t * record a bad block */\n\t\t\t\tif (any_working) {\n\t\t\t\t\t/* problem is that there are bad blocks\n\t\t\t\t\t * on other device(s)\n\t\t\t\t\t */\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k = 0; k < conf->copies; k++)\n\t\t\t\t\t\tif (r10_bio->devs[k].devnum == i)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (!test_bit(In_sync,\n\t\t\t\t\t\t      &mrdev->flags)\n\t\t\t\t\t    && !rdev_set_badblocks(\n\t\t\t\t\t\t    mrdev,\n\t\t\t\t\t\t    r10_bio->devs[k].addr,\n\t\t\t\t\t\t    max_sync, 0))\n\t\t\t\t\t\tany_working = 0;\n\t\t\t\t\tif (mreplace &&\n\t\t\t\t\t    !rdev_set_badblocks(\n\t\t\t\t\t\t    mreplace,\n\t\t\t\t\t\t    r10_bio->devs[k].addr,\n\t\t\t\t\t\t    max_sync, 0))\n\t\t\t\t\t\tany_working = 0;\n\t\t\t\t}\n\t\t\t\tif (!any_working)  {\n\t\t\t\t\tif (!test_and_set_bit(MD_RECOVERY_INTR,\n\t\t\t\t\t\t\t      &mddev->recovery))\n\t\t\t\t\t\tpr_warn(\"md/raid10:%s: insufficient working devices for recovery.\\n\",\n\t\t\t\t\t\t       mdname(mddev));\n\t\t\t\t\tmirror->recovery_disabled\n\t\t\t\t\t\t= mddev->recovery_disabled;\n\t\t\t\t}\n\t\t\t\tput_buf(r10_bio);\n\t\t\t\tif (rb2)\n\t\t\t\t\tatomic_dec(&rb2->remaining);\n\t\t\t\tr10_bio = rb2;\n\t\t\t\trdev_dec_pending(mrdev, mddev);\n\t\t\t\tif (mreplace)\n\t\t\t\t\trdev_dec_pending(mreplace, mddev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdev_dec_pending(mrdev, mddev);\n\t\t\tif (mreplace)\n\t\t\t\trdev_dec_pending(mreplace, mddev);\n\t\t\tif (r10_bio->devs[0].bio->bi_opf & MD_FAILFAST) {\n\t\t\t\t/* Only want this if there is elsewhere to\n\t\t\t\t * read from. 'j' is currently the first\n\t\t\t\t * readable copy.\n\t\t\t\t */\n\t\t\t\tint targets = 1;\n\t\t\t\tfor (; j < conf->copies; j++) {\n\t\t\t\t\tint d = r10_bio->devs[j].devnum;\n\t\t\t\t\tif (conf->mirrors[d].rdev &&\n\t\t\t\t\t    test_bit(In_sync,\n\t\t\t\t\t\t      &conf->mirrors[d].rdev->flags))\n\t\t\t\t\t\ttargets++;\n\t\t\t\t}\n\t\t\t\tif (targets == 1)\n\t\t\t\t\tr10_bio->devs[0].bio->bi_opf\n\t\t\t\t\t\t&= ~MD_FAILFAST;\n\t\t\t}\n\t\t}\n\t\tif (biolist == NULL) {\n\t\t\twhile (r10_bio) {\n\t\t\t\tstruct r10bio *rb2 = r10_bio;\n\t\t\t\tr10_bio = (struct r10bio*) rb2->master_bio;\n\t\t\t\trb2->master_bio = NULL;\n\t\t\t\tput_buf(rb2);\n\t\t\t}\n\t\t\tgoto giveup;\n\t\t}\n\t} else {\n\t\t/* resync. Schedule a read for every block at this virt offset */\n\t\tint count = 0;\n\n\t\t/*\n\t\t * Since curr_resync_completed could probably not update in\n\t\t * time, and we will set cluster_sync_low based on it.\n\t\t * Let's check against \"sector_nr + 2 * RESYNC_SECTORS\" for\n\t\t * safety reason, which ensures curr_resync_completed is\n\t\t * updated in bitmap_cond_end_sync.\n\t\t */\n\t\tmd_bitmap_cond_end_sync(mddev->bitmap, sector_nr,\n\t\t\t\t\tmddev_is_clustered(mddev) &&\n\t\t\t\t\t(sector_nr + 2 * RESYNC_SECTORS > conf->cluster_sync_high));\n\n\t\tif (!md_bitmap_start_sync(mddev->bitmap, sector_nr,\n\t\t\t\t\t  &sync_blocks, mddev->degraded) &&\n\t\t    !conf->fullsync && !test_bit(MD_RECOVERY_REQUESTED,\n\t\t\t\t\t\t &mddev->recovery)) {\n\t\t\t/* We can skip this block */\n\t\t\t*skipped = 1;\n\t\t\treturn sync_blocks + sectors_skipped;\n\t\t}\n\t\tif (sync_blocks < max_sync)\n\t\t\tmax_sync = sync_blocks;\n\t\tr10_bio = raid10_alloc_init_r10buf(conf);\n\t\tr10_bio->state = 0;\n\n\t\tr10_bio->mddev = mddev;\n\t\tatomic_set(&r10_bio->remaining, 0);\n\t\traise_barrier(conf, 0);\n\t\tconf->next_resync = sector_nr;\n\n\t\tr10_bio->master_bio = NULL;\n\t\tr10_bio->sector = sector_nr;\n\t\tset_bit(R10BIO_IsSync, &r10_bio->state);\n\t\traid10_find_phys(conf, r10_bio);\n\t\tr10_bio->sectors = (sector_nr | chunk_mask) - sector_nr + 1;\n\n\t\tfor (i = 0; i < conf->copies; i++) {\n\t\t\tint d = r10_bio->devs[i].devnum;\n\t\t\tsector_t first_bad, sector;\n\t\t\tint bad_sectors;\n\t\t\tstruct md_rdev *rdev;\n\n\t\t\tif (r10_bio->devs[i].repl_bio)\n\t\t\t\tr10_bio->devs[i].repl_bio->bi_end_io = NULL;\n\n\t\t\tbio = r10_bio->devs[i].bio;\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\t\t\trcu_read_lock();\n\t\t\trdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tif (rdev == NULL || test_bit(Faulty, &rdev->flags)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsector = r10_bio->devs[i].addr;\n\t\t\tif (is_badblock(rdev, sector, max_sync,\n\t\t\t\t\t&first_bad, &bad_sectors)) {\n\t\t\t\tif (first_bad > sector)\n\t\t\t\t\tmax_sync = first_bad - sector;\n\t\t\t\telse {\n\t\t\t\t\tbad_sectors -= (sector - first_bad);\n\t\t\t\t\tif (max_sync > bad_sectors)\n\t\t\t\t\t\tmax_sync = bad_sectors;\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\tatomic_inc(&r10_bio->remaining);\n\t\t\tbio->bi_next = biolist;\n\t\t\tbiolist = bio;\n\t\t\tbio->bi_end_io = end_sync_read;\n\t\t\tbio_set_op_attrs(bio, REQ_OP_READ, 0);\n\t\t\tif (test_bit(FailFast, &rdev->flags))\n\t\t\t\tbio->bi_opf |= MD_FAILFAST;\n\t\t\tbio->bi_iter.bi_sector = sector + rdev->data_offset;\n\t\t\tbio_set_dev(bio, rdev->bdev);\n\t\t\tcount++;\n\n\t\t\trdev = rcu_dereference(conf->mirrors[d].replacement);\n\t\t\tif (rdev == NULL || test_bit(Faulty, &rdev->flags)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&rdev->nr_pending);\n\n\t\t\t/* Need to set up for writing to the replacement */\n\t\t\tbio = r10_bio->devs[i].repl_bio;\n\t\t\tbio->bi_status = BLK_STS_IOERR;\n\n\t\t\tsector = r10_bio->devs[i].addr;\n\t\t\tbio->bi_next = biolist;\n\t\t\tbiolist = bio;\n\t\t\tbio->bi_end_io = end_sync_write;\n\t\t\tbio_set_op_attrs(bio, REQ_OP_WRITE, 0);\n\t\t\tif (test_bit(FailFast, &rdev->flags))\n\t\t\t\tbio->bi_opf |= MD_FAILFAST;\n\t\t\tbio->bi_iter.bi_sector = sector + rdev->data_offset;\n\t\t\tbio_set_dev(bio, rdev->bdev);\n\t\t\tcount++;\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tif (count < 2) {\n\t\t\tfor (i=0; i<conf->copies; i++) {\n\t\t\t\tint d = r10_bio->devs[i].devnum;\n\t\t\t\tif (r10_bio->devs[i].bio->bi_end_io)\n\t\t\t\t\trdev_dec_pending(conf->mirrors[d].rdev,\n\t\t\t\t\t\t\t mddev);\n\t\t\t\tif (r10_bio->devs[i].repl_bio &&\n\t\t\t\t    r10_bio->devs[i].repl_bio->bi_end_io)\n\t\t\t\t\trdev_dec_pending(\n\t\t\t\t\t\tconf->mirrors[d].replacement,\n\t\t\t\t\t\tmddev);\n\t\t\t}\n\t\t\tput_buf(r10_bio);\n\t\t\tbiolist = NULL;\n\t\t\tgoto giveup;\n\t\t}\n\t}\n\n\tnr_sectors = 0;\n\tif (sector_nr + max_sync < max_sector)\n\t\tmax_sector = sector_nr + max_sync;\n\tdo {\n\t\tstruct page *page;\n\t\tint len = PAGE_SIZE;\n\t\tif (sector_nr + (len>>9) > max_sector)\n\t\t\tlen = (max_sector - sector_nr) << 9;\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tfor (bio= biolist ; bio ; bio=bio->bi_next) {\n\t\t\tstruct resync_pages *rp = get_resync_pages(bio);\n\t\t\tpage = resync_fetch_page(rp, page_idx);\n\t\t\t/*\n\t\t\t * won't fail because the vec table is big enough\n\t\t\t * to hold all these pages\n\t\t\t */\n\t\t\tbio_add_page(bio, page, len, 0);\n\t\t}\n\t\tnr_sectors += len>>9;\n\t\tsector_nr += len>>9;\n\t} while (++page_idx < RESYNC_PAGES);\n\tr10_bio->sectors = nr_sectors;\n\n\tif (mddev_is_clustered(mddev) &&\n\t    test_bit(MD_RECOVERY_SYNC, &mddev->recovery)) {\n\t\t/* It is resync not recovery */\n\t\tif (conf->cluster_sync_high < sector_nr + nr_sectors) {\n\t\t\tconf->cluster_sync_low = mddev->curr_resync_completed;\n\t\t\traid10_set_cluster_sync_high(conf);\n\t\t\t/* Send resync message */\n\t\t\tmd_cluster_ops->resync_info_update(mddev,\n\t\t\t\t\t\tconf->cluster_sync_low,\n\t\t\t\t\t\tconf->cluster_sync_high);\n\t\t}\n\t} else if (mddev_is_clustered(mddev)) {\n\t\t/* This is recovery not resync */\n\t\tsector_t sect_va1, sect_va2;\n\t\tbool broadcast_msg = false;\n\n\t\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\t\t/*\n\t\t\t * sector_nr is a device address for recovery, so we\n\t\t\t * need translate it to array address before compare\n\t\t\t * with cluster_sync_high.\n\t\t\t */\n\t\t\tsect_va1 = raid10_find_virt(conf, sector_nr, i);\n\n\t\t\tif (conf->cluster_sync_high < sect_va1 + nr_sectors) {\n\t\t\t\tbroadcast_msg = true;\n\t\t\t\t/*\n\t\t\t\t * curr_resync_completed is similar as\n\t\t\t\t * sector_nr, so make the translation too.\n\t\t\t\t */\n\t\t\t\tsect_va2 = raid10_find_virt(conf,\n\t\t\t\t\tmddev->curr_resync_completed, i);\n\n\t\t\t\tif (conf->cluster_sync_low == 0 ||\n\t\t\t\t    conf->cluster_sync_low > sect_va2)\n\t\t\t\t\tconf->cluster_sync_low = sect_va2;\n\t\t\t}\n\t\t}\n\t\tif (broadcast_msg) {\n\t\t\traid10_set_cluster_sync_high(conf);\n\t\t\tmd_cluster_ops->resync_info_update(mddev,\n\t\t\t\t\t\tconf->cluster_sync_low,\n\t\t\t\t\t\tconf->cluster_sync_high);\n\t\t}\n\t}\n\n\twhile (biolist) {\n\t\tbio = biolist;\n\t\tbiolist = biolist->bi_next;\n\n\t\tbio->bi_next = NULL;\n\t\tr10_bio = get_resync_r10bio(bio);\n\t\tr10_bio->sectors = nr_sectors;\n\n\t\tif (bio->bi_end_io == end_sync_read) {\n\t\t\tmd_sync_acct_bio(bio, nr_sectors);\n\t\t\tbio->bi_status = 0;\n\t\t\tsubmit_bio_noacct(bio);\n\t\t}\n\t}\n\n\tif (sectors_skipped)\n\t\t/* pretend they weren't skipped, it makes\n\t\t * no important difference in this case\n\t\t */\n\t\tmd_done_sync(mddev, sectors_skipped, 1);\n\n\treturn sectors_skipped + nr_sectors;\n giveup:\n\t/* There is nowhere to write, so all non-sync\n\t * drives must be failed or in resync, all drives\n\t * have a bad block, so try the next chunk...\n\t */\n\tif (sector_nr + max_sync < max_sector)\n\t\tmax_sector = sector_nr + max_sync;\n\n\tsectors_skipped += (max_sector - sector_nr);\n\tchunks_skipped ++;\n\tsector_nr = max_sector;\n\tgoto skipped;\n}\n\nstatic sector_t\nraid10_size(struct mddev *mddev, sector_t sectors, int raid_disks)\n{\n\tsector_t size;\n\tstruct r10conf *conf = mddev->private;\n\n\tif (!raid_disks)\n\t\traid_disks = min(conf->geo.raid_disks,\n\t\t\t\t conf->prev.raid_disks);\n\tif (!sectors)\n\t\tsectors = conf->dev_sectors;\n\n\tsize = sectors >> conf->geo.chunk_shift;\n\tsector_div(size, conf->geo.far_copies);\n\tsize = size * raid_disks;\n\tsector_div(size, conf->geo.near_copies);\n\n\treturn size << conf->geo.chunk_shift;\n}\n\nstatic void calc_sectors(struct r10conf *conf, sector_t size)\n{\n\t/* Calculate the number of sectors-per-device that will\n\t * actually be used, and set conf->dev_sectors and\n\t * conf->stride\n\t */\n\n\tsize = size >> conf->geo.chunk_shift;\n\tsector_div(size, conf->geo.far_copies);\n\tsize = size * conf->geo.raid_disks;\n\tsector_div(size, conf->geo.near_copies);\n\t/* 'size' is now the number of chunks in the array */\n\t/* calculate \"used chunks per device\" */\n\tsize = size * conf->copies;\n\n\t/* We need to round up when dividing by raid_disks to\n\t * get the stride size.\n\t */\n\tsize = DIV_ROUND_UP_SECTOR_T(size, conf->geo.raid_disks);\n\n\tconf->dev_sectors = size << conf->geo.chunk_shift;\n\n\tif (conf->geo.far_offset)\n\t\tconf->geo.stride = 1 << conf->geo.chunk_shift;\n\telse {\n\t\tsector_div(size, conf->geo.far_copies);\n\t\tconf->geo.stride = size << conf->geo.chunk_shift;\n\t}\n}\n\nenum geo_type {geo_new, geo_old, geo_start};\nstatic int setup_geo(struct geom *geo, struct mddev *mddev, enum geo_type new)\n{\n\tint nc, fc, fo;\n\tint layout, chunk, disks;\n\tswitch (new) {\n\tcase geo_old:\n\t\tlayout = mddev->layout;\n\t\tchunk = mddev->chunk_sectors;\n\t\tdisks = mddev->raid_disks - mddev->delta_disks;\n\t\tbreak;\n\tcase geo_new:\n\t\tlayout = mddev->new_layout;\n\t\tchunk = mddev->new_chunk_sectors;\n\t\tdisks = mddev->raid_disks;\n\t\tbreak;\n\tdefault: /* avoid 'may be unused' warnings */\n\tcase geo_start: /* new when starting reshape - raid_disks not\n\t\t\t * updated yet. */\n\t\tlayout = mddev->new_layout;\n\t\tchunk = mddev->new_chunk_sectors;\n\t\tdisks = mddev->raid_disks + mddev->delta_disks;\n\t\tbreak;\n\t}\n\tif (layout >> 19)\n\t\treturn -1;\n\tif (chunk < (PAGE_SIZE >> 9) ||\n\t    !is_power_of_2(chunk))\n\t\treturn -2;\n\tnc = layout & 255;\n\tfc = (layout >> 8) & 255;\n\tfo = layout & (1<<16);\n\tgeo->raid_disks = disks;\n\tgeo->near_copies = nc;\n\tgeo->far_copies = fc;\n\tgeo->far_offset = fo;\n\tswitch (layout >> 17) {\n\tcase 0:\t/* original layout.  simple but not always optimal */\n\t\tgeo->far_set_size = disks;\n\t\tbreak;\n\tcase 1: /* \"improved\" layout which was buggy.  Hopefully no-one is\n\t\t * actually using this, but leave code here just in case.*/\n\t\tgeo->far_set_size = disks/fc;\n\t\tWARN(geo->far_set_size < fc,\n\t\t     \"This RAID10 layout does not provide data safety - please backup and create new array\\n\");\n\t\tbreak;\n\tcase 2: /* \"improved\" layout fixed to match documentation */\n\t\tgeo->far_set_size = fc * nc;\n\t\tbreak;\n\tdefault: /* Not a valid layout */\n\t\treturn -1;\n\t}\n\tgeo->chunk_mask = chunk - 1;\n\tgeo->chunk_shift = ffz(~chunk);\n\treturn nc*fc;\n}\n\nstatic struct r10conf *setup_conf(struct mddev *mddev)\n{\n\tstruct r10conf *conf = NULL;\n\tint err = -EINVAL;\n\tstruct geom geo;\n\tint copies;\n\n\tcopies = setup_geo(&geo, mddev, geo_new);\n\n\tif (copies == -2) {\n\t\tpr_warn(\"md/raid10:%s: chunk size must be at least PAGE_SIZE(%ld) and be a power of 2.\\n\",\n\t\t\tmdname(mddev), PAGE_SIZE);\n\t\tgoto out;\n\t}\n\n\tif (copies < 2 || copies > mddev->raid_disks) {\n\t\tpr_warn(\"md/raid10:%s: unsupported raid10 layout: 0x%8x\\n\",\n\t\t\tmdname(mddev), mddev->new_layout);\n\t\tgoto out;\n\t}\n\n\terr = -ENOMEM;\n\tconf = kzalloc(sizeof(struct r10conf), GFP_KERNEL);\n\tif (!conf)\n\t\tgoto out;\n\n\t/* FIXME calc properly */\n\tconf->mirrors = kcalloc(mddev->raid_disks + max(0, -mddev->delta_disks),\n\t\t\t\tsizeof(struct raid10_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!conf->mirrors)\n\t\tgoto out;\n\n\tconf->tmppage = alloc_page(GFP_KERNEL);\n\tif (!conf->tmppage)\n\t\tgoto out;\n\n\tconf->geo = geo;\n\tconf->copies = copies;\n\terr = mempool_init(&conf->r10bio_pool, NR_RAID_BIOS, r10bio_pool_alloc,\n\t\t\t   rbio_pool_free, conf);\n\tif (err)\n\t\tgoto out;\n\n\terr = bioset_init(&conf->bio_split, BIO_POOL_SIZE, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tcalc_sectors(conf, mddev->dev_sectors);\n\tif (mddev->reshape_position == MaxSector) {\n\t\tconf->prev = conf->geo;\n\t\tconf->reshape_progress = MaxSector;\n\t} else {\n\t\tif (setup_geo(&conf->prev, mddev, geo_old) != conf->copies) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tconf->reshape_progress = mddev->reshape_position;\n\t\tif (conf->prev.far_offset)\n\t\t\tconf->prev.stride = 1 << conf->prev.chunk_shift;\n\t\telse\n\t\t\t/* far_copies must be 1 */\n\t\t\tconf->prev.stride = conf->dev_sectors;\n\t}\n\tconf->reshape_safe = conf->reshape_progress;\n\tspin_lock_init(&conf->device_lock);\n\tINIT_LIST_HEAD(&conf->retry_list);\n\tINIT_LIST_HEAD(&conf->bio_end_io_list);\n\n\tspin_lock_init(&conf->resync_lock);\n\tinit_waitqueue_head(&conf->wait_barrier);\n\tatomic_set(&conf->nr_pending, 0);\n\n\terr = -ENOMEM;\n\tconf->thread = md_register_thread(raid10d, mddev, \"raid10\");\n\tif (!conf->thread)\n\t\tgoto out;\n\n\tconf->mddev = mddev;\n\treturn conf;\n\n out:\n\tif (conf) {\n\t\tmempool_exit(&conf->r10bio_pool);\n\t\tkfree(conf->mirrors);\n\t\tsafe_put_page(conf->tmppage);\n\t\tbioset_exit(&conf->bio_split);\n\t\tkfree(conf);\n\t}\n\treturn ERR_PTR(err);\n}\n\nstatic void raid10_set_io_opt(struct r10conf *conf)\n{\n\tint raid_disks = conf->geo.raid_disks;\n\n\tif (!(conf->geo.raid_disks % conf->geo.near_copies))\n\t\traid_disks /= conf->geo.near_copies;\n\tblk_queue_io_opt(conf->mddev->queue, (conf->mddev->chunk_sectors << 9) *\n\t\t\t raid_disks);\n}\n\nstatic int raid10_run(struct mddev *mddev)\n{\n\tstruct r10conf *conf;\n\tint i, disk_idx;\n\tstruct raid10_info *disk;\n\tstruct md_rdev *rdev;\n\tsector_t size;\n\tsector_t min_offset_diff = 0;\n\tint first = 1;\n\tbool discard_supported = false;\n\n\tif (mddev_init_writes_pending(mddev) < 0)\n\t\treturn -ENOMEM;\n\n\tif (mddev->private == NULL) {\n\t\tconf = setup_conf(mddev);\n\t\tif (IS_ERR(conf))\n\t\t\treturn PTR_ERR(conf);\n\t\tmddev->private = conf;\n\t}\n\tconf = mddev->private;\n\tif (!conf)\n\t\tgoto out;\n\n\tif (mddev_is_clustered(conf->mddev)) {\n\t\tint fc, fo;\n\n\t\tfc = (mddev->layout >> 8) & 255;\n\t\tfo = mddev->layout & (1<<16);\n\t\tif (fc > 1 || fo > 0) {\n\t\t\tpr_err(\"only near layout is supported by clustered\"\n\t\t\t\t\" raid10\\n\");\n\t\t\tgoto out_free_conf;\n\t\t}\n\t}\n\n\tmddev->thread = conf->thread;\n\tconf->thread = NULL;\n\n\tif (mddev->queue) {\n\t\tblk_queue_max_discard_sectors(mddev->queue,\n\t\t\t\t\t      UINT_MAX);\n\t\tblk_queue_max_write_same_sectors(mddev->queue, 0);\n\t\tblk_queue_max_write_zeroes_sectors(mddev->queue, 0);\n\t\tblk_queue_io_min(mddev->queue, mddev->chunk_sectors << 9);\n\t\traid10_set_io_opt(conf);\n\t}\n\n\trdev_for_each(rdev, mddev) {\n\t\tlong long diff;\n\n\t\tdisk_idx = rdev->raid_disk;\n\t\tif (disk_idx < 0)\n\t\t\tcontinue;\n\t\tif (disk_idx >= conf->geo.raid_disks &&\n\t\t    disk_idx >= conf->prev.raid_disks)\n\t\t\tcontinue;\n\t\tdisk = conf->mirrors + disk_idx;\n\n\t\tif (test_bit(Replacement, &rdev->flags)) {\n\t\t\tif (disk->replacement)\n\t\t\t\tgoto out_free_conf;\n\t\t\tdisk->replacement = rdev;\n\t\t} else {\n\t\t\tif (disk->rdev)\n\t\t\t\tgoto out_free_conf;\n\t\t\tdisk->rdev = rdev;\n\t\t}\n\t\tdiff = (rdev->new_data_offset - rdev->data_offset);\n\t\tif (!mddev->reshape_backwards)\n\t\t\tdiff = -diff;\n\t\tif (diff < 0)\n\t\t\tdiff = 0;\n\t\tif (first || diff < min_offset_diff)\n\t\t\tmin_offset_diff = diff;\n\n\t\tif (mddev->gendisk)\n\t\t\tdisk_stack_limits(mddev->gendisk, rdev->bdev,\n\t\t\t\t\t  rdev->data_offset << 9);\n\n\t\tdisk->head_position = 0;\n\n\t\tif (blk_queue_discard(bdev_get_queue(rdev->bdev)))\n\t\t\tdiscard_supported = true;\n\t\tfirst = 0;\n\t}\n\n\tif (mddev->queue) {\n\t\tif (discard_supported)\n\t\t\tblk_queue_flag_set(QUEUE_FLAG_DISCARD,\n\t\t\t\t\t\tmddev->queue);\n\t\telse\n\t\t\tblk_queue_flag_clear(QUEUE_FLAG_DISCARD,\n\t\t\t\t\t\t  mddev->queue);\n\t}\n\t/* need to check that every block has at least one working mirror */\n\tif (!enough(conf, -1)) {\n\t\tpr_err(\"md/raid10:%s: not enough operational mirrors.\\n\",\n\t\t       mdname(mddev));\n\t\tgoto out_free_conf;\n\t}\n\n\tif (conf->reshape_progress != MaxSector) {\n\t\t/* must ensure that shape change is supported */\n\t\tif (conf->geo.far_copies != 1 &&\n\t\t    conf->geo.far_offset == 0)\n\t\t\tgoto out_free_conf;\n\t\tif (conf->prev.far_copies != 1 &&\n\t\t    conf->prev.far_offset == 0)\n\t\t\tgoto out_free_conf;\n\t}\n\n\tmddev->degraded = 0;\n\tfor (i = 0;\n\t     i < conf->geo.raid_disks\n\t\t     || i < conf->prev.raid_disks;\n\t     i++) {\n\n\t\tdisk = conf->mirrors + i;\n\n\t\tif (!disk->rdev && disk->replacement) {\n\t\t\t/* The replacement is all we have - use it */\n\t\t\tdisk->rdev = disk->replacement;\n\t\t\tdisk->replacement = NULL;\n\t\t\tclear_bit(Replacement, &disk->rdev->flags);\n\t\t}\n\n\t\tif (!disk->rdev ||\n\t\t    !test_bit(In_sync, &disk->rdev->flags)) {\n\t\t\tdisk->head_position = 0;\n\t\t\tmddev->degraded++;\n\t\t\tif (disk->rdev &&\n\t\t\t    disk->rdev->saved_raid_disk < 0)\n\t\t\t\tconf->fullsync = 1;\n\t\t}\n\n\t\tif (disk->replacement &&\n\t\t    !test_bit(In_sync, &disk->replacement->flags) &&\n\t\t    disk->replacement->saved_raid_disk < 0) {\n\t\t\tconf->fullsync = 1;\n\t\t}\n\n\t\tdisk->recovery_disabled = mddev->recovery_disabled - 1;\n\t}\n\n\tif (mddev->recovery_cp != MaxSector)\n\t\tpr_notice(\"md/raid10:%s: not clean -- starting background reconstruction\\n\",\n\t\t\t  mdname(mddev));\n\tpr_info(\"md/raid10:%s: active with %d out of %d devices\\n\",\n\t\tmdname(mddev), conf->geo.raid_disks - mddev->degraded,\n\t\tconf->geo.raid_disks);\n\t/*\n\t * Ok, everything is just fine now\n\t */\n\tmddev->dev_sectors = conf->dev_sectors;\n\tsize = raid10_size(mddev, 0, 0);\n\tmd_set_array_sectors(mddev, size);\n\tmddev->resync_max_sectors = size;\n\tset_bit(MD_FAILFAST_SUPPORTED, &mddev->flags);\n\n\tif (md_integrity_register(mddev))\n\t\tgoto out_free_conf;\n\n\tif (conf->reshape_progress != MaxSector) {\n\t\tunsigned long before_length, after_length;\n\n\t\tbefore_length = ((1 << conf->prev.chunk_shift) *\n\t\t\t\t conf->prev.far_copies);\n\t\tafter_length = ((1 << conf->geo.chunk_shift) *\n\t\t\t\tconf->geo.far_copies);\n\n\t\tif (max(before_length, after_length) > min_offset_diff) {\n\t\t\t/* This cannot work */\n\t\t\tpr_warn(\"md/raid10: offset difference not enough to continue reshape\\n\");\n\t\t\tgoto out_free_conf;\n\t\t}\n\t\tconf->offset_diff = min_offset_diff;\n\n\t\tclear_bit(MD_RECOVERY_SYNC, &mddev->recovery);\n\t\tclear_bit(MD_RECOVERY_CHECK, &mddev->recovery);\n\t\tset_bit(MD_RECOVERY_RESHAPE, &mddev->recovery);\n\t\tset_bit(MD_RECOVERY_RUNNING, &mddev->recovery);\n\t\tmddev->sync_thread = md_register_thread(md_do_sync, mddev,\n\t\t\t\t\t\t\t\"reshape\");\n\t\tif (!mddev->sync_thread)\n\t\t\tgoto out_free_conf;\n\t}\n\n\treturn 0;\n\nout_free_conf:\n\tmd_unregister_thread(&mddev->thread);\n\tmempool_exit(&conf->r10bio_pool);\n\tsafe_put_page(conf->tmppage);\n\tkfree(conf->mirrors);\n\tkfree(conf);\n\tmddev->private = NULL;\nout:\n\treturn -EIO;\n}\n\nstatic void raid10_free(struct mddev *mddev, void *priv)\n{\n\tstruct r10conf *conf = priv;\n\n\tmempool_exit(&conf->r10bio_pool);\n\tsafe_put_page(conf->tmppage);\n\tkfree(conf->mirrors);\n\tkfree(conf->mirrors_old);\n\tkfree(conf->mirrors_new);\n\tbioset_exit(&conf->bio_split);\n\tkfree(conf);\n}\n\nstatic void raid10_quiesce(struct mddev *mddev, int quiesce)\n{\n\tstruct r10conf *conf = mddev->private;\n\n\tif (quiesce)\n\t\traise_barrier(conf, 0);\n\telse\n\t\tlower_barrier(conf);\n}\n\nstatic int raid10_resize(struct mddev *mddev, sector_t sectors)\n{\n\t/* Resize of 'far' arrays is not supported.\n\t * For 'near' and 'offset' arrays we can set the\n\t * number of sectors used to be an appropriate multiple\n\t * of the chunk size.\n\t * For 'offset', this is far_copies*chunksize.\n\t * For 'near' the multiplier is the LCM of\n\t * near_copies and raid_disks.\n\t * So if far_copies > 1 && !far_offset, fail.\n\t * Else find LCM(raid_disks, near_copy)*far_copies and\n\t * multiply by chunk_size.  Then round to this number.\n\t * This is mostly done by raid10_size()\n\t */\n\tstruct r10conf *conf = mddev->private;\n\tsector_t oldsize, size;\n\n\tif (mddev->reshape_position != MaxSector)\n\t\treturn -EBUSY;\n\n\tif (conf->geo.far_copies > 1 && !conf->geo.far_offset)\n\t\treturn -EINVAL;\n\n\toldsize = raid10_size(mddev, 0, 0);\n\tsize = raid10_size(mddev, sectors, 0);\n\tif (mddev->external_size &&\n\t    mddev->array_sectors > size)\n\t\treturn -EINVAL;\n\tif (mddev->bitmap) {\n\t\tint ret = md_bitmap_resize(mddev->bitmap, size, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tmd_set_array_sectors(mddev, size);\n\tif (sectors > mddev->dev_sectors &&\n\t    mddev->recovery_cp > oldsize) {\n\t\tmddev->recovery_cp = oldsize;\n\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t}\n\tcalc_sectors(conf, sectors);\n\tmddev->dev_sectors = conf->dev_sectors;\n\tmddev->resync_max_sectors = size;\n\treturn 0;\n}\n\nstatic void *raid10_takeover_raid0(struct mddev *mddev, sector_t size, int devs)\n{\n\tstruct md_rdev *rdev;\n\tstruct r10conf *conf;\n\n\tif (mddev->degraded > 0) {\n\t\tpr_warn(\"md/raid10:%s: Error: degraded raid0!\\n\",\n\t\t\tmdname(mddev));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsector_div(size, devs);\n\n\t/* Set new parameters */\n\tmddev->new_level = 10;\n\t/* new layout: far_copies = 1, near_copies = 2 */\n\tmddev->new_layout = (1<<8) + 2;\n\tmddev->new_chunk_sectors = mddev->chunk_sectors;\n\tmddev->delta_disks = mddev->raid_disks;\n\tmddev->raid_disks *= 2;\n\t/* make sure it will be not marked as dirty */\n\tmddev->recovery_cp = MaxSector;\n\tmddev->dev_sectors = size;\n\n\tconf = setup_conf(mddev);\n\tif (!IS_ERR(conf)) {\n\t\trdev_for_each(rdev, mddev)\n\t\t\tif (rdev->raid_disk >= 0) {\n\t\t\t\trdev->new_raid_disk = rdev->raid_disk * 2;\n\t\t\t\trdev->sectors = size;\n\t\t\t}\n\t\tconf->barrier = 1;\n\t}\n\n\treturn conf;\n}\n\nstatic void *raid10_takeover(struct mddev *mddev)\n{\n\tstruct r0conf *raid0_conf;\n\n\t/* raid10 can take over:\n\t *  raid0 - providing it has only two drives\n\t */\n\tif (mddev->level == 0) {\n\t\t/* for raid0 takeover only one zone is supported */\n\t\traid0_conf = mddev->private;\n\t\tif (raid0_conf->nr_strip_zones > 1) {\n\t\t\tpr_warn(\"md/raid10:%s: cannot takeover raid 0 with more than one zone.\\n\",\n\t\t\t\tmdname(mddev));\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn raid10_takeover_raid0(mddev,\n\t\t\traid0_conf->strip_zone->zone_end,\n\t\t\traid0_conf->strip_zone->nb_dev);\n\t}\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int raid10_check_reshape(struct mddev *mddev)\n{\n\t/* Called when there is a request to change\n\t * - layout (to ->new_layout)\n\t * - chunk size (to ->new_chunk_sectors)\n\t * - raid_disks (by delta_disks)\n\t * or when trying to restart a reshape that was ongoing.\n\t *\n\t * We need to validate the request and possibly allocate\n\t * space if that might be an issue later.\n\t *\n\t * Currently we reject any reshape of a 'far' mode array,\n\t * allow chunk size to change if new is generally acceptable,\n\t * allow raid_disks to increase, and allow\n\t * a switch between 'near' mode and 'offset' mode.\n\t */\n\tstruct r10conf *conf = mddev->private;\n\tstruct geom geo;\n\n\tif (conf->geo.far_copies != 1 && !conf->geo.far_offset)\n\t\treturn -EINVAL;\n\n\tif (setup_geo(&geo, mddev, geo_start) != conf->copies)\n\t\t/* mustn't change number of copies */\n\t\treturn -EINVAL;\n\tif (geo.far_copies > 1 && !geo.far_offset)\n\t\t/* Cannot switch to 'far' mode */\n\t\treturn -EINVAL;\n\n\tif (mddev->array_sectors & geo.chunk_mask)\n\t\t\t/* not factor of array size */\n\t\t\treturn -EINVAL;\n\n\tif (!enough(conf, -1))\n\t\treturn -EINVAL;\n\n\tkfree(conf->mirrors_new);\n\tconf->mirrors_new = NULL;\n\tif (mddev->delta_disks > 0) {\n\t\t/* allocate new 'mirrors' list */\n\t\tconf->mirrors_new =\n\t\t\tkcalloc(mddev->raid_disks + mddev->delta_disks,\n\t\t\t\tsizeof(struct raid10_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!conf->mirrors_new)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n/*\n * Need to check if array has failed when deciding whether to:\n *  - start an array\n *  - remove non-faulty devices\n *  - add a spare\n *  - allow a reshape\n * This determination is simple when no reshape is happening.\n * However if there is a reshape, we need to carefully check\n * both the before and after sections.\n * This is because some failed devices may only affect one\n * of the two sections, and some non-in_sync devices may\n * be insync in the section most affected by failed devices.\n */\nstatic int calc_degraded(struct r10conf *conf)\n{\n\tint degraded, degraded2;\n\tint i;\n\n\trcu_read_lock();\n\tdegraded = 0;\n\t/* 'prev' section first */\n\tfor (i = 0; i < conf->prev.raid_disks; i++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev);\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags))\n\t\t\tdegraded++;\n\t\telse if (!test_bit(In_sync, &rdev->flags))\n\t\t\t/* When we can reduce the number of devices in\n\t\t\t * an array, this might not contribute to\n\t\t\t * 'degraded'.  It does now.\n\t\t\t */\n\t\t\tdegraded++;\n\t}\n\trcu_read_unlock();\n\tif (conf->geo.raid_disks == conf->prev.raid_disks)\n\t\treturn degraded;\n\trcu_read_lock();\n\tdegraded2 = 0;\n\tfor (i = 0; i < conf->geo.raid_disks; i++) {\n\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev);\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags))\n\t\t\tdegraded2++;\n\t\telse if (!test_bit(In_sync, &rdev->flags)) {\n\t\t\t/* If reshape is increasing the number of devices,\n\t\t\t * this section has already been recovered, so\n\t\t\t * it doesn't contribute to degraded.\n\t\t\t * else it does.\n\t\t\t */\n\t\t\tif (conf->geo.raid_disks <= conf->prev.raid_disks)\n\t\t\t\tdegraded2++;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (degraded2 > degraded)\n\t\treturn degraded2;\n\treturn degraded;\n}\n\nstatic int raid10_start_reshape(struct mddev *mddev)\n{\n\t/* A 'reshape' has been requested. This commits\n\t * the various 'new' fields and sets MD_RECOVER_RESHAPE\n\t * This also checks if there are enough spares and adds them\n\t * to the array.\n\t * We currently require enough spares to make the final\n\t * array non-degraded.  We also require that the difference\n\t * between old and new data_offset - on each device - is\n\t * enough that we never risk over-writing.\n\t */\n\n\tunsigned long before_length, after_length;\n\tsector_t min_offset_diff = 0;\n\tint first = 1;\n\tstruct geom new;\n\tstruct r10conf *conf = mddev->private;\n\tstruct md_rdev *rdev;\n\tint spares = 0;\n\tint ret;\n\n\tif (test_bit(MD_RECOVERY_RUNNING, &mddev->recovery))\n\t\treturn -EBUSY;\n\n\tif (setup_geo(&new, mddev, geo_start) != conf->copies)\n\t\treturn -EINVAL;\n\n\tbefore_length = ((1 << conf->prev.chunk_shift) *\n\t\t\t conf->prev.far_copies);\n\tafter_length = ((1 << conf->geo.chunk_shift) *\n\t\t\tconf->geo.far_copies);\n\n\trdev_for_each(rdev, mddev) {\n\t\tif (!test_bit(In_sync, &rdev->flags)\n\t\t    && !test_bit(Faulty, &rdev->flags))\n\t\t\tspares++;\n\t\tif (rdev->raid_disk >= 0) {\n\t\t\tlong long diff = (rdev->new_data_offset\n\t\t\t\t\t  - rdev->data_offset);\n\t\t\tif (!mddev->reshape_backwards)\n\t\t\t\tdiff = -diff;\n\t\t\tif (diff < 0)\n\t\t\t\tdiff = 0;\n\t\t\tif (first || diff < min_offset_diff)\n\t\t\t\tmin_offset_diff = diff;\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\n\tif (max(before_length, after_length) > min_offset_diff)\n\t\treturn -EINVAL;\n\n\tif (spares < mddev->delta_disks)\n\t\treturn -EINVAL;\n\n\tconf->offset_diff = min_offset_diff;\n\tspin_lock_irq(&conf->device_lock);\n\tif (conf->mirrors_new) {\n\t\tmemcpy(conf->mirrors_new, conf->mirrors,\n\t\t       sizeof(struct raid10_info)*conf->prev.raid_disks);\n\t\tsmp_mb();\n\t\tkfree(conf->mirrors_old);\n\t\tconf->mirrors_old = conf->mirrors;\n\t\tconf->mirrors = conf->mirrors_new;\n\t\tconf->mirrors_new = NULL;\n\t}\n\tsetup_geo(&conf->geo, mddev, geo_start);\n\tsmp_mb();\n\tif (mddev->reshape_backwards) {\n\t\tsector_t size = raid10_size(mddev, 0, 0);\n\t\tif (size < mddev->array_sectors) {\n\t\t\tspin_unlock_irq(&conf->device_lock);\n\t\t\tpr_warn(\"md/raid10:%s: array size must be reduce before number of disks\\n\",\n\t\t\t\tmdname(mddev));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmddev->resync_max_sectors = size;\n\t\tconf->reshape_progress = size;\n\t} else\n\t\tconf->reshape_progress = 0;\n\tconf->reshape_safe = conf->reshape_progress;\n\tspin_unlock_irq(&conf->device_lock);\n\n\tif (mddev->delta_disks && mddev->bitmap) {\n\t\tstruct mdp_superblock_1 *sb = NULL;\n\t\tsector_t oldsize, newsize;\n\n\t\toldsize = raid10_size(mddev, 0, 0);\n\t\tnewsize = raid10_size(mddev, 0, conf->geo.raid_disks);\n\n\t\tif (!mddev_is_clustered(mddev)) {\n\t\t\tret = md_bitmap_resize(mddev->bitmap, newsize, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto abort;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\n\t\trdev_for_each(rdev, mddev) {\n\t\t\tif (rdev->raid_disk > -1 &&\n\t\t\t    !test_bit(Faulty, &rdev->flags))\n\t\t\t\tsb = page_address(rdev->sb_page);\n\t\t}\n\n\t\t/*\n\t\t * some node is already performing reshape, and no need to\n\t\t * call md_bitmap_resize again since it should be called when\n\t\t * receiving BITMAP_RESIZE msg\n\t\t */\n\t\tif ((sb && (le32_to_cpu(sb->feature_map) &\n\t\t\t    MD_FEATURE_RESHAPE_ACTIVE)) || (oldsize == newsize))\n\t\t\tgoto out;\n\n\t\tret = md_bitmap_resize(mddev->bitmap, newsize, 0, 0);\n\t\tif (ret)\n\t\t\tgoto abort;\n\n\t\tret = md_cluster_ops->resize_bitmaps(mddev, newsize, oldsize);\n\t\tif (ret) {\n\t\t\tmd_bitmap_resize(mddev->bitmap, oldsize, 0, 0);\n\t\t\tgoto abort;\n\t\t}\n\t}\nout:\n\tif (mddev->delta_disks > 0) {\n\t\trdev_for_each(rdev, mddev)\n\t\t\tif (rdev->raid_disk < 0 &&\n\t\t\t    !test_bit(Faulty, &rdev->flags)) {\n\t\t\t\tif (raid10_add_disk(mddev, rdev) == 0) {\n\t\t\t\t\tif (rdev->raid_disk >=\n\t\t\t\t\t    conf->prev.raid_disks)\n\t\t\t\t\t\tset_bit(In_sync, &rdev->flags);\n\t\t\t\t\telse\n\t\t\t\t\t\trdev->recovery_offset = 0;\n\n\t\t\t\t\t/* Failure here is OK */\n\t\t\t\t\tsysfs_link_rdev(mddev, rdev);\n\t\t\t\t}\n\t\t\t} else if (rdev->raid_disk >= conf->prev.raid_disks\n\t\t\t\t   && !test_bit(Faulty, &rdev->flags)) {\n\t\t\t\t/* This is a spare that was manually added */\n\t\t\t\tset_bit(In_sync, &rdev->flags);\n\t\t\t}\n\t}\n\t/* When a reshape changes the number of devices,\n\t * ->degraded is measured against the larger of the\n\t * pre and  post numbers.\n\t */\n\tspin_lock_irq(&conf->device_lock);\n\tmddev->degraded = calc_degraded(conf);\n\tspin_unlock_irq(&conf->device_lock);\n\tmddev->raid_disks = conf->geo.raid_disks;\n\tmddev->reshape_position = conf->reshape_progress;\n\tset_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);\n\n\tclear_bit(MD_RECOVERY_SYNC, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_CHECK, &mddev->recovery);\n\tclear_bit(MD_RECOVERY_DONE, &mddev->recovery);\n\tset_bit(MD_RECOVERY_RESHAPE, &mddev->recovery);\n\tset_bit(MD_RECOVERY_RUNNING, &mddev->recovery);\n\n\tmddev->sync_thread = md_register_thread(md_do_sync, mddev,\n\t\t\t\t\t\t\"reshape\");\n\tif (!mddev->sync_thread) {\n\t\tret = -EAGAIN;\n\t\tgoto abort;\n\t}\n\tconf->reshape_checkpoint = jiffies;\n\tmd_wakeup_thread(mddev->sync_thread);\n\tmd_new_event(mddev);\n\treturn 0;\n\nabort:\n\tmddev->recovery = 0;\n\tspin_lock_irq(&conf->device_lock);\n\tconf->geo = conf->prev;\n\tmddev->raid_disks = conf->geo.raid_disks;\n\trdev_for_each(rdev, mddev)\n\t\trdev->new_data_offset = rdev->data_offset;\n\tsmp_wmb();\n\tconf->reshape_progress = MaxSector;\n\tconf->reshape_safe = MaxSector;\n\tmddev->reshape_position = MaxSector;\n\tspin_unlock_irq(&conf->device_lock);\n\treturn ret;\n}\n\n/* Calculate the last device-address that could contain\n * any block from the chunk that includes the array-address 's'\n * and report the next address.\n * i.e. the address returned will be chunk-aligned and after\n * any data that is in the chunk containing 's'.\n */\nstatic sector_t last_dev_address(sector_t s, struct geom *geo)\n{\n\ts = (s | geo->chunk_mask) + 1;\n\ts >>= geo->chunk_shift;\n\ts *= geo->near_copies;\n\ts = DIV_ROUND_UP_SECTOR_T(s, geo->raid_disks);\n\ts *= geo->far_copies;\n\ts <<= geo->chunk_shift;\n\treturn s;\n}\n\n/* Calculate the first device-address that could contain\n * any block from the chunk that includes the array-address 's'.\n * This too will be the start of a chunk\n */\nstatic sector_t first_dev_address(sector_t s, struct geom *geo)\n{\n\ts >>= geo->chunk_shift;\n\ts *= geo->near_copies;\n\tsector_div(s, geo->raid_disks);\n\ts *= geo->far_copies;\n\ts <<= geo->chunk_shift;\n\treturn s;\n}\n\nstatic sector_t reshape_request(struct mddev *mddev, sector_t sector_nr,\n\t\t\t\tint *skipped)\n{\n\t/* We simply copy at most one chunk (smallest of old and new)\n\t * at a time, possibly less if that exceeds RESYNC_PAGES,\n\t * or we hit a bad block or something.\n\t * This might mean we pause for normal IO in the middle of\n\t * a chunk, but that is not a problem as mddev->reshape_position\n\t * can record any location.\n\t *\n\t * If we will want to write to a location that isn't\n\t * yet recorded as 'safe' (i.e. in metadata on disk) then\n\t * we need to flush all reshape requests and update the metadata.\n\t *\n\t * When reshaping forwards (e.g. to more devices), we interpret\n\t * 'safe' as the earliest block which might not have been copied\n\t * down yet.  We divide this by previous stripe size and multiply\n\t * by previous stripe length to get lowest device offset that we\n\t * cannot write to yet.\n\t * We interpret 'sector_nr' as an address that we want to write to.\n\t * From this we use last_device_address() to find where we might\n\t * write to, and first_device_address on the  'safe' position.\n\t * If this 'next' write position is after the 'safe' position,\n\t * we must update the metadata to increase the 'safe' position.\n\t *\n\t * When reshaping backwards, we round in the opposite direction\n\t * and perform the reverse test:  next write position must not be\n\t * less than current safe position.\n\t *\n\t * In all this the minimum difference in data offsets\n\t * (conf->offset_diff - always positive) allows a bit of slack,\n\t * so next can be after 'safe', but not by more than offset_diff\n\t *\n\t * We need to prepare all the bios here before we start any IO\n\t * to ensure the size we choose is acceptable to all devices.\n\t * The means one for each copy for write-out and an extra one for\n\t * read-in.\n\t * We store the read-in bio in ->master_bio and the others in\n\t * ->devs[x].bio and ->devs[x].repl_bio.\n\t */\n\tstruct r10conf *conf = mddev->private;\n\tstruct r10bio *r10_bio;\n\tsector_t next, safe, last;\n\tint max_sectors;\n\tint nr_sectors;\n\tint s;\n\tstruct md_rdev *rdev;\n\tint need_flush = 0;\n\tstruct bio *blist;\n\tstruct bio *bio, *read_bio;\n\tint sectors_done = 0;\n\tstruct page **pages;\n\n\tif (sector_nr == 0) {\n\t\t/* If restarting in the middle, skip the initial sectors */\n\t\tif (mddev->reshape_backwards &&\n\t\t    conf->reshape_progress < raid10_size(mddev, 0, 0)) {\n\t\t\tsector_nr = (raid10_size(mddev, 0, 0)\n\t\t\t\t     - conf->reshape_progress);\n\t\t} else if (!mddev->reshape_backwards &&\n\t\t\t   conf->reshape_progress > 0)\n\t\t\tsector_nr = conf->reshape_progress;\n\t\tif (sector_nr) {\n\t\t\tmddev->curr_resync_completed = sector_nr;\n\t\t\tsysfs_notify_dirent_safe(mddev->sysfs_completed);\n\t\t\t*skipped = 1;\n\t\t\treturn sector_nr;\n\t\t}\n\t}\n\n\t/* We don't use sector_nr to track where we are up to\n\t * as that doesn't work well for ->reshape_backwards.\n\t * So just use ->reshape_progress.\n\t */\n\tif (mddev->reshape_backwards) {\n\t\t/* 'next' is the earliest device address that we might\n\t\t * write to for this chunk in the new layout\n\t\t */\n\t\tnext = first_dev_address(conf->reshape_progress - 1,\n\t\t\t\t\t &conf->geo);\n\n\t\t/* 'safe' is the last device address that we might read from\n\t\t * in the old layout after a restart\n\t\t */\n\t\tsafe = last_dev_address(conf->reshape_safe - 1,\n\t\t\t\t\t&conf->prev);\n\n\t\tif (next + conf->offset_diff < safe)\n\t\t\tneed_flush = 1;\n\n\t\tlast = conf->reshape_progress - 1;\n\t\tsector_nr = last & ~(sector_t)(conf->geo.chunk_mask\n\t\t\t\t\t       & conf->prev.chunk_mask);\n\t\tif (sector_nr + RESYNC_SECTORS < last)\n\t\t\tsector_nr = last + 1 - RESYNC_SECTORS;\n\t} else {\n\t\t/* 'next' is after the last device address that we\n\t\t * might write to for this chunk in the new layout\n\t\t */\n\t\tnext = last_dev_address(conf->reshape_progress, &conf->geo);\n\n\t\t/* 'safe' is the earliest device address that we might\n\t\t * read from in the old layout after a restart\n\t\t */\n\t\tsafe = first_dev_address(conf->reshape_safe, &conf->prev);\n\n\t\t/* Need to update metadata if 'next' might be beyond 'safe'\n\t\t * as that would possibly corrupt data\n\t\t */\n\t\tif (next > safe + conf->offset_diff)\n\t\t\tneed_flush = 1;\n\n\t\tsector_nr = conf->reshape_progress;\n\t\tlast  = sector_nr | (conf->geo.chunk_mask\n\t\t\t\t     & conf->prev.chunk_mask);\n\n\t\tif (sector_nr + RESYNC_SECTORS <= last)\n\t\t\tlast = sector_nr + RESYNC_SECTORS - 1;\n\t}\n\n\tif (need_flush ||\n\t    time_after(jiffies, conf->reshape_checkpoint + 10*HZ)) {\n\t\t/* Need to update reshape_position in metadata */\n\t\twait_barrier(conf);\n\t\tmddev->reshape_position = conf->reshape_progress;\n\t\tif (mddev->reshape_backwards)\n\t\t\tmddev->curr_resync_completed = raid10_size(mddev, 0, 0)\n\t\t\t\t- conf->reshape_progress;\n\t\telse\n\t\t\tmddev->curr_resync_completed = conf->reshape_progress;\n\t\tconf->reshape_checkpoint = jiffies;\n\t\tset_bit(MD_SB_CHANGE_DEVS, &mddev->sb_flags);\n\t\tmd_wakeup_thread(mddev->thread);\n\t\twait_event(mddev->sb_wait, mddev->sb_flags == 0 ||\n\t\t\t   test_bit(MD_RECOVERY_INTR, &mddev->recovery));\n\t\tif (test_bit(MD_RECOVERY_INTR, &mddev->recovery)) {\n\t\t\tallow_barrier(conf);\n\t\t\treturn sectors_done;\n\t\t}\n\t\tconf->reshape_safe = mddev->reshape_position;\n\t\tallow_barrier(conf);\n\t}\n\n\traise_barrier(conf, 0);\nread_more:\n\t/* Now schedule reads for blocks from sector_nr to last */\n\tr10_bio = raid10_alloc_init_r10buf(conf);\n\tr10_bio->state = 0;\n\traise_barrier(conf, 1);\n\tatomic_set(&r10_bio->remaining, 0);\n\tr10_bio->mddev = mddev;\n\tr10_bio->sector = sector_nr;\n\tset_bit(R10BIO_IsReshape, &r10_bio->state);\n\tr10_bio->sectors = last - sector_nr + 1;\n\trdev = read_balance(conf, r10_bio, &max_sectors);\n\tBUG_ON(!test_bit(R10BIO_Previous, &r10_bio->state));\n\n\tif (!rdev) {\n\t\t/* Cannot read from here, so need to record bad blocks\n\t\t * on all the target devices.\n\t\t */\n\t\t// FIXME\n\t\tmempool_free(r10_bio, &conf->r10buf_pool);\n\t\tset_bit(MD_RECOVERY_INTR, &mddev->recovery);\n\t\treturn sectors_done;\n\t}\n\n\tread_bio = bio_alloc_mddev(GFP_KERNEL, RESYNC_PAGES, mddev);\n\n\tbio_set_dev(read_bio, rdev->bdev);\n\tread_bio->bi_iter.bi_sector = (r10_bio->devs[r10_bio->read_slot].addr\n\t\t\t       + rdev->data_offset);\n\tread_bio->bi_private = r10_bio;\n\tread_bio->bi_end_io = end_reshape_read;\n\tbio_set_op_attrs(read_bio, REQ_OP_READ, 0);\n\tread_bio->bi_flags &= (~0UL << BIO_RESET_BITS);\n\tread_bio->bi_status = 0;\n\tread_bio->bi_vcnt = 0;\n\tread_bio->bi_iter.bi_size = 0;\n\tr10_bio->master_bio = read_bio;\n\tr10_bio->read_slot = r10_bio->devs[r10_bio->read_slot].devnum;\n\n\t/*\n\t * Broadcast RESYNC message to other nodes, so all nodes would not\n\t * write to the region to avoid conflict.\n\t*/\n\tif (mddev_is_clustered(mddev) && conf->cluster_sync_high <= sector_nr) {\n\t\tstruct mdp_superblock_1 *sb = NULL;\n\t\tint sb_reshape_pos = 0;\n\n\t\tconf->cluster_sync_low = sector_nr;\n\t\tconf->cluster_sync_high = sector_nr + CLUSTER_RESYNC_WINDOW_SECTORS;\n\t\tsb = page_address(rdev->sb_page);\n\t\tif (sb) {\n\t\t\tsb_reshape_pos = le64_to_cpu(sb->reshape_position);\n\t\t\t/*\n\t\t\t * Set cluster_sync_low again if next address for array\n\t\t\t * reshape is less than cluster_sync_low. Since we can't\n\t\t\t * update cluster_sync_low until it has finished reshape.\n\t\t\t */\n\t\t\tif (sb_reshape_pos < conf->cluster_sync_low)\n\t\t\t\tconf->cluster_sync_low = sb_reshape_pos;\n\t\t}\n\n\t\tmd_cluster_ops->resync_info_update(mddev, conf->cluster_sync_low,\n\t\t\t\t\t\t\t  conf->cluster_sync_high);\n\t}\n\n\t/* Now find the locations in the new layout */\n\t__raid10_find_phys(&conf->geo, r10_bio);\n\n\tblist = read_bio;\n\tread_bio->bi_next = NULL;\n\n\trcu_read_lock();\n\tfor (s = 0; s < conf->copies*2; s++) {\n\t\tstruct bio *b;\n\t\tint d = r10_bio->devs[s/2].devnum;\n\t\tstruct md_rdev *rdev2;\n\t\tif (s&1) {\n\t\t\trdev2 = rcu_dereference(conf->mirrors[d].replacement);\n\t\t\tb = r10_bio->devs[s/2].repl_bio;\n\t\t} else {\n\t\t\trdev2 = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tb = r10_bio->devs[s/2].bio;\n\t\t}\n\t\tif (!rdev2 || test_bit(Faulty, &rdev2->flags))\n\t\t\tcontinue;\n\n\t\tbio_set_dev(b, rdev2->bdev);\n\t\tb->bi_iter.bi_sector = r10_bio->devs[s/2].addr +\n\t\t\trdev2->new_data_offset;\n\t\tb->bi_end_io = end_reshape_write;\n\t\tbio_set_op_attrs(b, REQ_OP_WRITE, 0);\n\t\tb->bi_next = blist;\n\t\tblist = b;\n\t}\n\n\t/* Now add as many pages as possible to all of these bios. */\n\n\tnr_sectors = 0;\n\tpages = get_resync_pages(r10_bio->devs[0].bio)->pages;\n\tfor (s = 0 ; s < max_sectors; s += PAGE_SIZE >> 9) {\n\t\tstruct page *page = pages[s / (PAGE_SIZE >> 9)];\n\t\tint len = (max_sectors - s) << 9;\n\t\tif (len > PAGE_SIZE)\n\t\t\tlen = PAGE_SIZE;\n\t\tfor (bio = blist; bio ; bio = bio->bi_next) {\n\t\t\t/*\n\t\t\t * won't fail because the vec table is big enough\n\t\t\t * to hold all these pages\n\t\t\t */\n\t\t\tbio_add_page(bio, page, len, 0);\n\t\t}\n\t\tsector_nr += len >> 9;\n\t\tnr_sectors += len >> 9;\n\t}\n\trcu_read_unlock();\n\tr10_bio->sectors = nr_sectors;\n\n\t/* Now submit the read */\n\tmd_sync_acct_bio(read_bio, r10_bio->sectors);\n\tatomic_inc(&r10_bio->remaining);\n\tread_bio->bi_next = NULL;\n\tsubmit_bio_noacct(read_bio);\n\tsectors_done += nr_sectors;\n\tif (sector_nr <= last)\n\t\tgoto read_more;\n\n\tlower_barrier(conf);\n\n\t/* Now that we have done the whole section we can\n\t * update reshape_progress\n\t */\n\tif (mddev->reshape_backwards)\n\t\tconf->reshape_progress -= sectors_done;\n\telse\n\t\tconf->reshape_progress += sectors_done;\n\n\treturn sectors_done;\n}\n\nstatic void end_reshape_request(struct r10bio *r10_bio);\nstatic int handle_reshape_read_error(struct mddev *mddev,\n\t\t\t\t     struct r10bio *r10_bio);\nstatic void reshape_request_write(struct mddev *mddev, struct r10bio *r10_bio)\n{\n\t/* Reshape read completed.  Hopefully we have a block\n\t * to write out.\n\t * If we got a read error then we do sync 1-page reads from\n\t * elsewhere until we find the data - or give up.\n\t */\n\tstruct r10conf *conf = mddev->private;\n\tint s;\n\n\tif (!test_bit(R10BIO_Uptodate, &r10_bio->state))\n\t\tif (handle_reshape_read_error(mddev, r10_bio) < 0) {\n\t\t\t/* Reshape has been aborted */\n\t\t\tmd_done_sync(mddev, r10_bio->sectors, 0);\n\t\t\treturn;\n\t\t}\n\n\t/* We definitely have the data in the pages, schedule the\n\t * writes.\n\t */\n\tatomic_set(&r10_bio->remaining, 1);\n\tfor (s = 0; s < conf->copies*2; s++) {\n\t\tstruct bio *b;\n\t\tint d = r10_bio->devs[s/2].devnum;\n\t\tstruct md_rdev *rdev;\n\t\trcu_read_lock();\n\t\tif (s&1) {\n\t\t\trdev = rcu_dereference(conf->mirrors[d].replacement);\n\t\t\tb = r10_bio->devs[s/2].repl_bio;\n\t\t} else {\n\t\t\trdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tb = r10_bio->devs[s/2].bio;\n\t\t}\n\t\tif (!rdev || test_bit(Faulty, &rdev->flags)) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\t\tatomic_inc(&rdev->nr_pending);\n\t\trcu_read_unlock();\n\t\tmd_sync_acct_bio(b, r10_bio->sectors);\n\t\tatomic_inc(&r10_bio->remaining);\n\t\tb->bi_next = NULL;\n\t\tsubmit_bio_noacct(b);\n\t}\n\tend_reshape_request(r10_bio);\n}\n\nstatic void end_reshape(struct r10conf *conf)\n{\n\tif (test_bit(MD_RECOVERY_INTR, &conf->mddev->recovery))\n\t\treturn;\n\n\tspin_lock_irq(&conf->device_lock);\n\tconf->prev = conf->geo;\n\tmd_finish_reshape(conf->mddev);\n\tsmp_wmb();\n\tconf->reshape_progress = MaxSector;\n\tconf->reshape_safe = MaxSector;\n\tspin_unlock_irq(&conf->device_lock);\n\n\tif (conf->mddev->queue)\n\t\traid10_set_io_opt(conf);\n\tconf->fullsync = 0;\n}\n\nstatic void raid10_update_reshape_pos(struct mddev *mddev)\n{\n\tstruct r10conf *conf = mddev->private;\n\tsector_t lo, hi;\n\n\tmd_cluster_ops->resync_info_get(mddev, &lo, &hi);\n\tif (((mddev->reshape_position <= hi) && (mddev->reshape_position >= lo))\n\t    || mddev->reshape_position == MaxSector)\n\t\tconf->reshape_progress = mddev->reshape_position;\n\telse\n\t\tWARN_ON_ONCE(1);\n}\n\nstatic int handle_reshape_read_error(struct mddev *mddev,\n\t\t\t\t     struct r10bio *r10_bio)\n{\n\t/* Use sync reads to get the blocks from somewhere else */\n\tint sectors = r10_bio->sectors;\n\tstruct r10conf *conf = mddev->private;\n\tstruct r10bio *r10b;\n\tint slot = 0;\n\tint idx = 0;\n\tstruct page **pages;\n\n\tr10b = kmalloc(struct_size(r10b, devs, conf->copies), GFP_NOIO);\n\tif (!r10b) {\n\t\tset_bit(MD_RECOVERY_INTR, &mddev->recovery);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* reshape IOs share pages from .devs[0].bio */\n\tpages = get_resync_pages(r10_bio->devs[0].bio)->pages;\n\n\tr10b->sector = r10_bio->sector;\n\t__raid10_find_phys(&conf->prev, r10b);\n\n\twhile (sectors) {\n\t\tint s = sectors;\n\t\tint success = 0;\n\t\tint first_slot = slot;\n\n\t\tif (s > (PAGE_SIZE >> 9))\n\t\t\ts = PAGE_SIZE >> 9;\n\n\t\trcu_read_lock();\n\t\twhile (!success) {\n\t\t\tint d = r10b->devs[slot].devnum;\n\t\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tsector_t addr;\n\t\t\tif (rdev == NULL ||\n\t\t\t    test_bit(Faulty, &rdev->flags) ||\n\t\t\t    !test_bit(In_sync, &rdev->flags))\n\t\t\t\tgoto failed;\n\n\t\t\taddr = r10b->devs[slot].addr + idx * PAGE_SIZE;\n\t\t\tatomic_inc(&rdev->nr_pending);\n\t\t\trcu_read_unlock();\n\t\t\tsuccess = sync_page_io(rdev,\n\t\t\t\t\t       addr,\n\t\t\t\t\t       s << 9,\n\t\t\t\t\t       pages[idx],\n\t\t\t\t\t       REQ_OP_READ, 0, false);\n\t\t\trdev_dec_pending(rdev, mddev);\n\t\t\trcu_read_lock();\n\t\t\tif (success)\n\t\t\t\tbreak;\n\t\tfailed:\n\t\t\tslot++;\n\t\t\tif (slot >= conf->copies)\n\t\t\t\tslot = 0;\n\t\t\tif (slot == first_slot)\n\t\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!success) {\n\t\t\t/* couldn't read this block, must give up */\n\t\t\tset_bit(MD_RECOVERY_INTR,\n\t\t\t\t&mddev->recovery);\n\t\t\tkfree(r10b);\n\t\t\treturn -EIO;\n\t\t}\n\t\tsectors -= s;\n\t\tidx++;\n\t}\n\tkfree(r10b);\n\treturn 0;\n}\n\nstatic void end_reshape_write(struct bio *bio)\n{\n\tstruct r10bio *r10_bio = get_resync_r10bio(bio);\n\tstruct mddev *mddev = r10_bio->mddev;\n\tstruct r10conf *conf = mddev->private;\n\tint d;\n\tint slot;\n\tint repl;\n\tstruct md_rdev *rdev = NULL;\n\n\td = find_bio_disk(conf, r10_bio, bio, &slot, &repl);\n\tif (repl)\n\t\trdev = conf->mirrors[d].replacement;\n\tif (!rdev) {\n\t\tsmp_mb();\n\t\trdev = conf->mirrors[d].rdev;\n\t}\n\n\tif (bio->bi_status) {\n\t\t/* FIXME should record badblock */\n\t\tmd_error(mddev, rdev);\n\t}\n\n\trdev_dec_pending(rdev, mddev);\n\tend_reshape_request(r10_bio);\n}\n\nstatic void end_reshape_request(struct r10bio *r10_bio)\n{\n\tif (!atomic_dec_and_test(&r10_bio->remaining))\n\t\treturn;\n\tmd_done_sync(r10_bio->mddev, r10_bio->sectors, 1);\n\tbio_put(r10_bio->master_bio);\n\tput_buf(r10_bio);\n}\n\nstatic void raid10_finish_reshape(struct mddev *mddev)\n{\n\tstruct r10conf *conf = mddev->private;\n\n\tif (test_bit(MD_RECOVERY_INTR, &mddev->recovery))\n\t\treturn;\n\n\tif (mddev->delta_disks > 0) {\n\t\tif (mddev->recovery_cp > mddev->resync_max_sectors) {\n\t\t\tmddev->recovery_cp = mddev->resync_max_sectors;\n\t\t\tset_bit(MD_RECOVERY_NEEDED, &mddev->recovery);\n\t\t}\n\t\tmddev->resync_max_sectors = mddev->array_sectors;\n\t} else {\n\t\tint d;\n\t\trcu_read_lock();\n\t\tfor (d = conf->geo.raid_disks ;\n\t\t     d < conf->geo.raid_disks - mddev->delta_disks;\n\t\t     d++) {\n\t\t\tstruct md_rdev *rdev = rcu_dereference(conf->mirrors[d].rdev);\n\t\t\tif (rdev)\n\t\t\t\tclear_bit(In_sync, &rdev->flags);\n\t\t\trdev = rcu_dereference(conf->mirrors[d].replacement);\n\t\t\tif (rdev)\n\t\t\t\tclear_bit(In_sync, &rdev->flags);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tmddev->layout = mddev->new_layout;\n\tmddev->chunk_sectors = 1 << conf->geo.chunk_shift;\n\tmddev->reshape_position = MaxSector;\n\tmddev->delta_disks = 0;\n\tmddev->reshape_backwards = 0;\n}\n\nstatic struct md_personality raid10_personality =\n{\n\t.name\t\t= \"raid10\",\n\t.level\t\t= 10,\n\t.owner\t\t= THIS_MODULE,\n\t.make_request\t= raid10_make_request,\n\t.run\t\t= raid10_run,\n\t.free\t\t= raid10_free,\n\t.status\t\t= raid10_status,\n\t.error_handler\t= raid10_error,\n\t.hot_add_disk\t= raid10_add_disk,\n\t.hot_remove_disk= raid10_remove_disk,\n\t.spare_active\t= raid10_spare_active,\n\t.sync_request\t= raid10_sync_request,\n\t.quiesce\t= raid10_quiesce,\n\t.size\t\t= raid10_size,\n\t.resize\t\t= raid10_resize,\n\t.takeover\t= raid10_takeover,\n\t.check_reshape\t= raid10_check_reshape,\n\t.start_reshape\t= raid10_start_reshape,\n\t.finish_reshape\t= raid10_finish_reshape,\n\t.update_reshape_pos = raid10_update_reshape_pos,\n};\n\nstatic int __init raid_init(void)\n{\n\treturn register_md_personality(&raid10_personality);\n}\n\nstatic void raid_exit(void)\n{\n\tunregister_md_personality(&raid10_personality);\n}\n\nmodule_init(raid_init);\nmodule_exit(raid_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"RAID10 (striped mirror) personality for MD\");\nMODULE_ALIAS(\"md-personality-9\"); /* RAID10 */\nMODULE_ALIAS(\"md-raid10\");\nMODULE_ALIAS(\"md-level-10\");\n\nmodule_param(max_queued_requests, int, S_IRUGO|S_IWUSR);\n"}}, "reports": [{"events": [{"location": {"col": 0, "file": 0, "line": 831}, "message": "error: uninitialized symbol 'best_pending_slot'."}], "macros": [], "notes": [], "path": "/src/drivers/md/raid10.c", "reportHash": "9b8ce1af256a9fe8ea1a0a314a8cf479", "checkerName": "smatch.check_uninitialized", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3505}, "message": "error: we previously assumed 'bio' could be null (see line 3497)"}], "macros": [], "notes": [], "path": "/src/drivers/md/raid10.c", "reportHash": "37b19f8ba5269c582dd3beaafeb1469a", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3510}, "message": "error: we previously assumed 'mreplace' could be null (see line 3396)"}], "macros": [], "notes": [], "path": "/src/drivers/md/raid10.c", "reportHash": "8e69a8010b31bd53f8a67559d03c3d49", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3529}, "message": "error: we previously assumed 'mrdev' could be null (see line 3351)"}], "macros": [], "notes": [], "path": "/src/drivers/md/raid10.c", "reportHash": "b76a191d467750cf134d52ecc7d8fca7", "checkerName": "smatch.check_check_deref", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 0, "file": 0, "line": 3860}, "message": "warn: should '1 << conf->geo.chunk_shift' be a 64 bit type?"}], "macros": [], "notes": [], "path": "/src/drivers/md/raid10.c", "reportHash": "445342dc9d110f4a9fb23015a44bfd72", "checkerName": "smatch.check_64bit_shift", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
