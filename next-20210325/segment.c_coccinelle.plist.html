<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/fs/f2fs/segment.c", "content": "// SPDX-License-Identifier: GPL-2.0\n/*\n * fs/f2fs/segment.c\n *\n * Copyright (c) 2012 Samsung Electronics Co., Ltd.\n *             http://www.samsung.com/\n */\n#include <linux/fs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/kthread.h>\n#include <linux/swap.h>\n#include <linux/timer.h>\n#include <linux/freezer.h>\n#include <linux/sched/signal.h>\n\n#include \"f2fs.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"gc.h\"\n#include <trace/events/f2fs.h>\n\n#define __reverse_ffz(x) __reverse_ffs(~(x))\n\nstatic struct kmem_cache *discard_entry_slab;\nstatic struct kmem_cache *discard_cmd_slab;\nstatic struct kmem_cache *sit_entry_set_slab;\nstatic struct kmem_cache *inmem_entry_slab;\n\nstatic unsigned long __reverse_ulong(unsigned char *str)\n{\n\tunsigned long tmp = 0;\n\tint shift = 24, idx = 0;\n\n#if BITS_PER_LONG == 64\n\tshift = 56;\n#endif\n\twhile (shift >= 0) {\n\t\ttmp |= (unsigned long)str[idx++] << shift;\n\t\tshift -= BITS_PER_BYTE;\n\t}\n\treturn tmp;\n}\n\n/*\n * __reverse_ffs is copied from include/asm-generic/bitops/__ffs.h since\n * MSB and LSB are reversed in a byte by f2fs_set_bit.\n */\nstatic inline unsigned long __reverse_ffs(unsigned long word)\n{\n\tint num = 0;\n\n#if BITS_PER_LONG == 64\n\tif ((word & 0xffffffff00000000UL) == 0)\n\t\tnum += 32;\n\telse\n\t\tword >>= 32;\n#endif\n\tif ((word & 0xffff0000) == 0)\n\t\tnum += 16;\n\telse\n\t\tword >>= 16;\n\n\tif ((word & 0xff00) == 0)\n\t\tnum += 8;\n\telse\n\t\tword >>= 8;\n\n\tif ((word & 0xf0) == 0)\n\t\tnum += 4;\n\telse\n\t\tword >>= 4;\n\n\tif ((word & 0xc) == 0)\n\t\tnum += 2;\n\telse\n\t\tword >>= 2;\n\n\tif ((word & 0x2) == 0)\n\t\tnum += 1;\n\treturn num;\n}\n\n/*\n * __find_rev_next(_zero)_bit is copied from lib/find_next_bit.c because\n * f2fs_set_bit makes MSB and LSB reversed in a byte.\n * @size must be integral times of unsigned long.\n * Example:\n *                             MSB <--> LSB\n *   f2fs_set_bit(0, bitmap) => 1000 0000\n *   f2fs_set_bit(7, bitmap) => 0000 0001\n */\nstatic unsigned long __find_rev_next_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = size;\n\tunsigned long tmp;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= (offset & ~(BITS_PER_LONG - 1));\n\toffset %= BITS_PER_LONG;\n\n\twhile (1) {\n\t\tif (*p == 0)\n\t\t\tgoto pass;\n\n\t\ttmp = __reverse_ulong((unsigned char *)p);\n\n\t\ttmp &= ~0UL >> offset;\n\t\tif (size < BITS_PER_LONG)\n\t\t\ttmp &= (~0UL << (BITS_PER_LONG - size));\n\t\tif (tmp)\n\t\t\tgoto found;\npass:\n\t\tif (size <= BITS_PER_LONG)\n\t\t\tbreak;\n\t\tsize -= BITS_PER_LONG;\n\t\toffset = 0;\n\t\tp++;\n\t}\n\treturn result;\nfound:\n\treturn result - size + __reverse_ffs(tmp);\n}\n\nstatic unsigned long __find_rev_next_zero_bit(const unsigned long *addr,\n\t\t\tunsigned long size, unsigned long offset)\n{\n\tconst unsigned long *p = addr + BIT_WORD(offset);\n\tunsigned long result = size;\n\tunsigned long tmp;\n\n\tif (offset >= size)\n\t\treturn size;\n\n\tsize -= (offset & ~(BITS_PER_LONG - 1));\n\toffset %= BITS_PER_LONG;\n\n\twhile (1) {\n\t\tif (*p == ~0UL)\n\t\t\tgoto pass;\n\n\t\ttmp = __reverse_ulong((unsigned char *)p);\n\n\t\tif (offset)\n\t\t\ttmp |= ~0UL << (BITS_PER_LONG - offset);\n\t\tif (size < BITS_PER_LONG)\n\t\t\ttmp |= ~0UL >> size;\n\t\tif (tmp != ~0UL)\n\t\t\tgoto found;\npass:\n\t\tif (size <= BITS_PER_LONG)\n\t\t\tbreak;\n\t\tsize -= BITS_PER_LONG;\n\t\toffset = 0;\n\t\tp++;\n\t}\n\treturn result;\nfound:\n\treturn result - size + __reverse_ffz(tmp);\n}\n\nbool f2fs_need_SSR(struct f2fs_sb_info *sbi)\n{\n\tint node_secs = get_blocktype_secs(sbi, F2FS_DIRTY_NODES);\n\tint dent_secs = get_blocktype_secs(sbi, F2FS_DIRTY_DENTS);\n\tint imeta_secs = get_blocktype_secs(sbi, F2FS_DIRTY_IMETA);\n\n\tif (f2fs_lfs_mode(sbi))\n\t\treturn false;\n\tif (sbi->gc_mode == GC_URGENT_HIGH)\n\t\treturn true;\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED)))\n\t\treturn true;\n\n\treturn free_sections(sbi) <= (node_secs + 2 * dent_secs + imeta_secs +\n\t\t\tSM_I(sbi)->min_ssr_sections + reserved_sections(sbi));\n}\n\nvoid f2fs_register_inmem_page(struct inode *inode, struct page *page)\n{\n\tstruct inmem_pages *new;\n\n\tf2fs_set_page_private(page, ATOMIC_WRITTEN_PAGE);\n\n\tnew = f2fs_kmem_cache_alloc(inmem_entry_slab, GFP_NOFS);\n\n\t/* add atomic page indices to the list */\n\tnew->page = page;\n\tINIT_LIST_HEAD(&new->list);\n\n\t/* increase reference count with clean state */\n\tget_page(page);\n\tmutex_lock(&F2FS_I(inode)->inmem_lock);\n\tlist_add_tail(&new->list, &F2FS_I(inode)->inmem_pages);\n\tinc_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\tmutex_unlock(&F2FS_I(inode)->inmem_lock);\n\n\ttrace_f2fs_register_inmem_page(page, INMEM);\n}\n\nstatic int __revoke_inmem_pages(struct inode *inode,\n\t\t\t\tstruct list_head *head, bool drop, bool recover,\n\t\t\t\tbool trylock)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tint err = 0;\n\n\tlist_for_each_entry_safe(cur, tmp, head, list) {\n\t\tstruct page *page = cur->page;\n\n\t\tif (drop)\n\t\t\ttrace_f2fs_commit_inmem_page(page, INMEM_DROP);\n\n\t\tif (trylock) {\n\t\t\t/*\n\t\t\t * to avoid deadlock in between page lock and\n\t\t\t * inmem_lock.\n\t\t\t */\n\t\t\tif (!trylock_page(page))\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\n\t\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\t\tif (recover) {\n\t\t\tstruct dnode_of_data dn;\n\t\t\tstruct node_info ni;\n\n\t\t\ttrace_f2fs_commit_inmem_page(page, INMEM_REVOKE);\nretry:\n\t\t\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\t\t\terr = f2fs_get_dnode_of_data(&dn, page->index,\n\t\t\t\t\t\t\t\tLOOKUP_NODE);\n\t\t\tif (err) {\n\t\t\t\tif (err == -ENOMEM) {\n\t\t\t\t\tcongestion_wait(BLK_RW_ASYNC,\n\t\t\t\t\t\t\tDEFAULT_IO_TIMEOUT);\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\terr = f2fs_get_node_info(sbi, dn.nid, &ni);\n\t\t\tif (err) {\n\t\t\t\tf2fs_put_dnode(&dn);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tif (cur->old_addr == NEW_ADDR) {\n\t\t\t\tf2fs_invalidate_blocks(sbi, dn.data_blkaddr);\n\t\t\t\tf2fs_update_data_blkaddr(&dn, NEW_ADDR);\n\t\t\t} else\n\t\t\t\tf2fs_replace_block(sbi, &dn, dn.data_blkaddr,\n\t\t\t\t\tcur->old_addr, ni.version, true, true);\n\t\t\tf2fs_put_dnode(&dn);\n\t\t}\nnext:\n\t\t/* we don't need to invalidate this in the sccessful status */\n\t\tif (drop || recover) {\n\t\t\tClearPageUptodate(page);\n\t\t\tclear_cold_data(page);\n\t\t}\n\t\tf2fs_clear_page_private(page);\n\t\tf2fs_put_page(page, 1);\n\n\t\tlist_del(&cur->list);\n\t\tkmem_cache_free(inmem_entry_slab, cur);\n\t\tdec_page_count(F2FS_I_SB(inode), F2FS_INMEM_PAGES);\n\t}\n\treturn err;\n}\n\nvoid f2fs_drop_inmem_pages_all(struct f2fs_sb_info *sbi, bool gc_failure)\n{\n\tstruct list_head *head = &sbi->inode_list[ATOMIC_FILE];\n\tstruct inode *inode;\n\tstruct f2fs_inode_info *fi;\n\tunsigned int count = sbi->atomic_files;\n\tunsigned int looped = 0;\nnext:\n\tspin_lock(&sbi->inode_lock[ATOMIC_FILE]);\n\tif (list_empty(head)) {\n\t\tspin_unlock(&sbi->inode_lock[ATOMIC_FILE]);\n\t\treturn;\n\t}\n\tfi = list_first_entry(head, struct f2fs_inode_info, inmem_ilist);\n\tinode = igrab(&fi->vfs_inode);\n\tif (inode)\n\t\tlist_move_tail(&fi->inmem_ilist, head);\n\tspin_unlock(&sbi->inode_lock[ATOMIC_FILE]);\n\n\tif (inode) {\n\t\tif (gc_failure) {\n\t\t\tif (!fi->i_gc_failures[GC_FAILURE_ATOMIC])\n\t\t\t\tgoto skip;\n\t\t}\n\t\tset_inode_flag(inode, FI_ATOMIC_REVOKE_REQUEST);\n\t\tf2fs_drop_inmem_pages(inode);\nskip:\n\t\tiput(inode);\n\t}\n\tcongestion_wait(BLK_RW_ASYNC, DEFAULT_IO_TIMEOUT);\n\tcond_resched();\n\tif (gc_failure) {\n\t\tif (++looped >= count)\n\t\t\treturn;\n\t}\n\tgoto next;\n}\n\nvoid f2fs_drop_inmem_pages(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\n\twhile (!list_empty(&fi->inmem_pages)) {\n\t\tmutex_lock(&fi->inmem_lock);\n\t\t__revoke_inmem_pages(inode, &fi->inmem_pages,\n\t\t\t\t\t\ttrue, false, true);\n\t\tmutex_unlock(&fi->inmem_lock);\n\t}\n\n\tfi->i_gc_failures[GC_FAILURE_ATOMIC] = 0;\n\n\tspin_lock(&sbi->inode_lock[ATOMIC_FILE]);\n\tif (!list_empty(&fi->inmem_ilist))\n\t\tlist_del_init(&fi->inmem_ilist);\n\tif (f2fs_is_atomic_file(inode)) {\n\t\tclear_inode_flag(inode, FI_ATOMIC_FILE);\n\t\tsbi->atomic_files--;\n\t}\n\tspin_unlock(&sbi->inode_lock[ATOMIC_FILE]);\n}\n\nvoid f2fs_drop_inmem_page(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct list_head *head = &fi->inmem_pages;\n\tstruct inmem_pages *cur = NULL;\n\n\tf2fs_bug_on(sbi, !IS_ATOMIC_WRITTEN_PAGE(page));\n\n\tmutex_lock(&fi->inmem_lock);\n\tlist_for_each_entry(cur, head, list) {\n\t\tif (cur->page == page)\n\t\t\tbreak;\n\t}\n\n\tf2fs_bug_on(sbi, list_empty(head) || cur->page != page);\n\tlist_del(&cur->list);\n\tmutex_unlock(&fi->inmem_lock);\n\n\tdec_page_count(sbi, F2FS_INMEM_PAGES);\n\tkmem_cache_free(inmem_entry_slab, cur);\n\n\tClearPageUptodate(page);\n\tf2fs_clear_page_private(page);\n\tf2fs_put_page(page, 0);\n\n\ttrace_f2fs_commit_inmem_page(page, INMEM_INVALIDATE);\n}\n\nstatic int __f2fs_commit_inmem_pages(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct inmem_pages *cur, *tmp;\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.ino = inode->i_ino,\n\t\t.type = DATA,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = REQ_SYNC | REQ_PRIO,\n\t\t.io_type = FS_DATA_IO,\n\t};\n\tstruct list_head revoke_list;\n\tbool submit_bio = false;\n\tint err = 0;\n\n\tINIT_LIST_HEAD(&revoke_list);\n\n\tlist_for_each_entry_safe(cur, tmp, &fi->inmem_pages, list) {\n\t\tstruct page *page = cur->page;\n\n\t\tlock_page(page);\n\t\tif (page->mapping == inode->i_mapping) {\n\t\t\ttrace_f2fs_commit_inmem_page(page, INMEM);\n\n\t\t\tf2fs_wait_on_page_writeback(page, DATA, true, true);\n\n\t\t\tset_page_dirty(page);\n\t\t\tif (clear_page_dirty_for_io(page)) {\n\t\t\t\tinode_dec_dirty_pages(inode);\n\t\t\t\tf2fs_remove_dirty_inode(inode);\n\t\t\t}\nretry:\n\t\t\tfio.page = page;\n\t\t\tfio.old_blkaddr = NULL_ADDR;\n\t\t\tfio.encrypted_page = NULL;\n\t\t\tfio.need_lock = LOCK_DONE;\n\t\t\terr = f2fs_do_write_data_page(&fio);\n\t\t\tif (err) {\n\t\t\t\tif (err == -ENOMEM) {\n\t\t\t\t\tcongestion_wait(BLK_RW_ASYNC,\n\t\t\t\t\t\t\tDEFAULT_IO_TIMEOUT);\n\t\t\t\t\tcond_resched();\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\tunlock_page(page);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* record old blkaddr for revoking */\n\t\t\tcur->old_addr = fio.old_blkaddr;\n\t\t\tsubmit_bio = true;\n\t\t}\n\t\tunlock_page(page);\n\t\tlist_move_tail(&cur->list, &revoke_list);\n\t}\n\n\tif (submit_bio)\n\t\tf2fs_submit_merged_write_cond(sbi, inode, NULL, 0, DATA);\n\n\tif (err) {\n\t\t/*\n\t\t * try to revoke all committed pages, but still we could fail\n\t\t * due to no memory or other reason, if that happened, EAGAIN\n\t\t * will be returned, which means in such case, transaction is\n\t\t * already not integrity, caller should use journal to do the\n\t\t * recovery or rewrite & commit last transaction. For other\n\t\t * error number, revoking was done by filesystem itself.\n\t\t */\n\t\terr = __revoke_inmem_pages(inode, &revoke_list,\n\t\t\t\t\t\tfalse, true, false);\n\n\t\t/* drop all uncommitted pages */\n\t\t__revoke_inmem_pages(inode, &fi->inmem_pages,\n\t\t\t\t\t\ttrue, false, false);\n\t} else {\n\t\t__revoke_inmem_pages(inode, &revoke_list,\n\t\t\t\t\t\tfalse, false, false);\n\t}\n\n\treturn err;\n}\n\nint f2fs_commit_inmem_pages(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint err;\n\n\tf2fs_balance_fs(sbi, true);\n\n\tdown_write(&fi->i_gc_rwsem[WRITE]);\n\n\tf2fs_lock_op(sbi);\n\tset_inode_flag(inode, FI_ATOMIC_COMMIT);\n\n\tmutex_lock(&fi->inmem_lock);\n\terr = __f2fs_commit_inmem_pages(inode);\n\tmutex_unlock(&fi->inmem_lock);\n\n\tclear_inode_flag(inode, FI_ATOMIC_COMMIT);\n\n\tf2fs_unlock_op(sbi);\n\tup_write(&fi->i_gc_rwsem[WRITE]);\n\n\treturn err;\n}\n\n/*\n * This function balances dirty node and dentry pages.\n * In addition, it controls garbage collection.\n */\nvoid f2fs_balance_fs(struct f2fs_sb_info *sbi, bool need)\n{\n\tif (time_to_inject(sbi, FAULT_CHECKPOINT)) {\n\t\tf2fs_show_injection_info(sbi, FAULT_CHECKPOINT);\n\t\tf2fs_stop_checkpoint(sbi, false);\n\t}\n\n\t/* balance_fs_bg is able to be pending */\n\tif (need && excess_cached_nats(sbi))\n\t\tf2fs_balance_fs_bg(sbi, false);\n\n\tif (!f2fs_is_checkpoint_ready(sbi))\n\t\treturn;\n\n\t/*\n\t * We should do GC or end up with checkpoint, if there are so many dirty\n\t * dir/node pages without enough free segments.\n\t */\n\tif (has_not_enough_free_secs(sbi, 0, 0)) {\n\t\tdown_write(&sbi->gc_lock);\n\t\tf2fs_gc(sbi, false, false, false, NULL_SEGNO);\n\t}\n}\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi, bool from_bg)\n{\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_POR_DOING)))\n\t\treturn;\n\n\t/* try to shrink extent cache when there is no enough memory */\n\tif (!f2fs_available_free_memory(sbi, EXTENT_CACHE))\n\t\tf2fs_shrink_extent_tree(sbi, EXTENT_CACHE_SHRINK_NUMBER);\n\n\t/* check the # of cached NAT entries */\n\tif (!f2fs_available_free_memory(sbi, NAT_ENTRIES))\n\t\tf2fs_try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK);\n\n\tif (!f2fs_available_free_memory(sbi, FREE_NIDS))\n\t\tf2fs_try_to_free_nids(sbi, MAX_FREE_NIDS);\n\telse\n\t\tf2fs_build_free_nids(sbi, false, false);\n\n\tif (excess_dirty_nats(sbi) || excess_dirty_nodes(sbi) ||\n\t\texcess_prefree_segs(sbi))\n\t\tgoto do_sync;\n\n\t/* there is background inflight IO or foreground operation recently */\n\tif (is_inflight_io(sbi, REQ_TIME) ||\n\t\t(!f2fs_time_over(sbi, REQ_TIME) && rwsem_is_locked(&sbi->cp_rwsem)))\n\t\treturn;\n\n\t/* exceed periodical checkpoint timeout threshold */\n\tif (f2fs_time_over(sbi, CP_TIME))\n\t\tgoto do_sync;\n\n\t/* checkpoint is the only way to shrink partial cached entries */\n\tif (f2fs_available_free_memory(sbi, NAT_ENTRIES) ||\n\t\tf2fs_available_free_memory(sbi, INO_ENTRIES))\n\t\treturn;\n\ndo_sync:\n\tif (test_opt(sbi, DATA_FLUSH) && from_bg) {\n\t\tstruct blk_plug plug;\n\n\t\tmutex_lock(&sbi->flush_lock);\n\n\t\tblk_start_plug(&plug);\n\t\tf2fs_sync_dirty_inodes(sbi, FILE_INODE);\n\t\tblk_finish_plug(&plug);\n\n\t\tmutex_unlock(&sbi->flush_lock);\n\t}\n\tf2fs_sync_fs(sbi->sb, true);\n\tstat_inc_bg_cp_count(sbi->stat_info);\n}\n\nstatic int __submit_flush_wait(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct block_device *bdev)\n{\n\tint ret = blkdev_issue_flush(bdev);\n\n\ttrace_f2fs_issue_flush(bdev, test_opt(sbi, NOBARRIER),\n\t\t\t\ttest_opt(sbi, FLUSH_MERGE), ret);\n\treturn ret;\n}\n\nstatic int submit_flush_wait(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tint ret = 0;\n\tint i;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn __submit_flush_wait(sbi, sbi->sb->s_bdev);\n\n\tfor (i = 0; i < sbi->s_ndevs; i++) {\n\t\tif (!f2fs_is_dirty_device(sbi, ino, i, FLUSH_INO))\n\t\t\tcontinue;\n\t\tret = __submit_flush_wait(sbi, FDEV(i).bdev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int issue_flush_thread(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;\n\twait_queue_head_t *q = &fcc->flush_wait_queue;\nrepeat:\n\tif (kthread_should_stop())\n\t\treturn 0;\n\n\tif (!llist_empty(&fcc->issue_list)) {\n\t\tstruct flush_cmd *cmd, *next;\n\t\tint ret;\n\n\t\tfcc->dispatch_list = llist_del_all(&fcc->issue_list);\n\t\tfcc->dispatch_list = llist_reverse_order(fcc->dispatch_list);\n\n\t\tcmd = llist_entry(fcc->dispatch_list, struct flush_cmd, llnode);\n\n\t\tret = submit_flush_wait(sbi, cmd->ino);\n\t\tatomic_inc(&fcc->issued_flush);\n\n\t\tllist_for_each_entry_safe(cmd, next,\n\t\t\t\t\t  fcc->dispatch_list, llnode) {\n\t\t\tcmd->ret = ret;\n\t\t\tcomplete(&cmd->wait);\n\t\t}\n\t\tfcc->dispatch_list = NULL;\n\t}\n\n\twait_event_interruptible(*q,\n\t\tkthread_should_stop() || !llist_empty(&fcc->issue_list));\n\tgoto repeat;\n}\n\nint f2fs_issue_flush(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;\n\tstruct flush_cmd cmd;\n\tint ret;\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tif (!test_opt(sbi, FLUSH_MERGE)) {\n\t\tatomic_inc(&fcc->queued_flush);\n\t\tret = submit_flush_wait(sbi, ino);\n\t\tatomic_dec(&fcc->queued_flush);\n\t\tatomic_inc(&fcc->issued_flush);\n\t\treturn ret;\n\t}\n\n\tif (atomic_inc_return(&fcc->queued_flush) == 1 ||\n\t    f2fs_is_multi_device(sbi)) {\n\t\tret = submit_flush_wait(sbi, ino);\n\t\tatomic_dec(&fcc->queued_flush);\n\n\t\tatomic_inc(&fcc->issued_flush);\n\t\treturn ret;\n\t}\n\n\tcmd.ino = ino;\n\tinit_completion(&cmd.wait);\n\n\tllist_add(&cmd.llnode, &fcc->issue_list);\n\n\t/*\n\t * update issue_list before we wake up issue_flush thread, this\n\t * smp_mb() pairs with another barrier in ___wait_event(), see\n\t * more details in comments of waitqueue_active().\n\t */\n\tsmp_mb();\n\n\tif (waitqueue_active(&fcc->flush_wait_queue))\n\t\twake_up(&fcc->flush_wait_queue);\n\n\tif (fcc->f2fs_issue_flush) {\n\t\twait_for_completion(&cmd.wait);\n\t\tatomic_dec(&fcc->queued_flush);\n\t} else {\n\t\tstruct llist_node *list;\n\n\t\tlist = llist_del_all(&fcc->issue_list);\n\t\tif (!list) {\n\t\t\twait_for_completion(&cmd.wait);\n\t\t\tatomic_dec(&fcc->queued_flush);\n\t\t} else {\n\t\t\tstruct flush_cmd *tmp, *next;\n\n\t\t\tret = submit_flush_wait(sbi, ino);\n\n\t\t\tllist_for_each_entry_safe(tmp, next, list, llnode) {\n\t\t\t\tif (tmp == &cmd) {\n\t\t\t\t\tcmd.ret = ret;\n\t\t\t\t\tatomic_dec(&fcc->queued_flush);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttmp->ret = ret;\n\t\t\t\tcomplete(&tmp->wait);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cmd.ret;\n}\n\nint f2fs_create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tif (fcc->f2fs_issue_flush)\n\t\t\treturn err;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = f2fs_kzalloc(sbi, sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->queued_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\n\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nvoid f2fs_destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free)\n{\n\tstruct flush_cmd_control *fcc = SM_I(sbi)->fcc_info;\n\n\tif (fcc && fcc->f2fs_issue_flush) {\n\t\tstruct task_struct *flush_thread = fcc->f2fs_issue_flush;\n\n\t\tfcc->f2fs_issue_flush = NULL;\n\t\tkthread_stop(flush_thread);\n\t}\n\tif (free) {\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t}\n}\n\nint f2fs_flush_device_cache(struct f2fs_sb_info *sbi)\n{\n\tint ret = 0, i;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn 0;\n\n\tif (test_opt(sbi, NOBARRIER))\n\t\treturn 0;\n\n\tfor (i = 1; i < sbi->s_ndevs; i++) {\n\t\tif (!f2fs_test_bit(i, (char *)&sbi->dirty_device))\n\t\t\tcontinue;\n\t\tret = __submit_flush_wait(sbi, FDEV(i).bdev);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tspin_lock(&sbi->dev_lock);\n\t\tf2fs_clear_bit(i, (char *)&sbi->dirty_device);\n\t\tspin_unlock(&sbi->dev_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic void __locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\t/* need not be added */\n\tif (IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]++;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (unlikely(t >= DIRTY)) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (!test_and_set_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]++;\n\n\t\tif (__is_large_section(sbi)) {\n\t\t\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\t\t\tblock_t valid_blocks =\n\t\t\t\tget_valid_blocks(sbi, segno, true);\n\n\t\t\tf2fs_bug_on(sbi, unlikely(!valid_blocks ||\n\t\t\t\t\tvalid_blocks == BLKS_PER_SEC(sbi)));\n\n\t\t\tif (!IS_CURSEC(sbi, secno))\n\t\t\t\tset_bit(secno, dirty_i->dirty_secmap);\n\t\t}\n\t}\n}\n\nstatic void __remove_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tblock_t valid_blocks;\n\n\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[dirty_type]))\n\t\tdirty_i->nr_dirty[dirty_type]--;\n\n\tif (dirty_type == DIRTY) {\n\t\tstruct seg_entry *sentry = get_seg_entry(sbi, segno);\n\t\tenum dirty_type t = sentry->type;\n\n\t\tif (test_and_clear_bit(segno, dirty_i->dirty_segmap[t]))\n\t\t\tdirty_i->nr_dirty[t]--;\n\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, true);\n\t\tif (valid_blocks == 0) {\n\t\t\tclear_bit(GET_SEC_FROM_SEG(sbi, segno),\n\t\t\t\t\t\tdirty_i->victim_secmap);\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\t\tclear_bit(segno, SIT_I(sbi)->invalid_segmap);\n#endif\n\t\t}\n\t\tif (__is_large_section(sbi)) {\n\t\t\tunsigned int secno = GET_SEC_FROM_SEG(sbi, segno);\n\n\t\t\tif (!valid_blocks ||\n\t\t\t\t\tvalid_blocks == BLKS_PER_SEC(sbi)) {\n\t\t\t\tclear_bit(secno, dirty_i->dirty_secmap);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IS_CURSEC(sbi, secno))\n\t\t\t\tset_bit(secno, dirty_i->dirty_secmap);\n\t\t}\n\t}\n}\n\n/*\n * Should not occur error such as -ENOMEM.\n * Adding dirty entry into seglist is not critical operation.\n * If a given segment is one of current working segments, it won't be added.\n */\nstatic void locate_dirty_segment(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned short valid_blocks, ckpt_valid_blocks;\n\tunsigned int usable_blocks;\n\n\tif (segno == NULL_SEGNO || IS_CURSEG(sbi, segno))\n\t\treturn;\n\n\tusable_blocks = f2fs_usable_blks_in_seg(sbi, segno);\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\tvalid_blocks = get_valid_blocks(sbi, segno, false);\n\tckpt_valid_blocks = get_ckpt_valid_blocks(sbi, segno, false);\n\n\tif (valid_blocks == 0 && (!is_sbi_flag_set(sbi, SBI_CP_DISABLED) ||\n\t\tckpt_valid_blocks == usable_blocks)) {\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t} else if (valid_blocks < usable_blocks) {\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t} else {\n\t\t/* Recovery routine with SSR needs this */\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\n\tmutex_unlock(&dirty_i->seglist_lock);\n}\n\n/* This moves currently empty dirty blocks to prefree. Must hold seglist_lock */\nvoid f2fs_dirty_to_prefree(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[DIRTY], MAIN_SEGS(sbi)) {\n\t\tif (get_valid_blocks(sbi, segno, false))\n\t\t\tcontinue;\n\t\tif (IS_CURSEG(sbi, segno))\n\t\t\tcontinue;\n\t\t__locate_dirty_segment(sbi, segno, PRE);\n\t\t__remove_dirty_segment(sbi, segno, DIRTY);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n}\n\nblock_t f2fs_get_unusable_blocks(struct f2fs_sb_info *sbi)\n{\n\tint ovp_hole_segs =\n\t\t(overprovision_segments(sbi) - reserved_segments(sbi));\n\tblock_t ovp_holes = ovp_hole_segs << sbi->log_blocks_per_seg;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tblock_t holes[2] = {0, 0};\t/* DATA and NODE */\n\tblock_t unusable;\n\tstruct seg_entry *se;\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[DIRTY], MAIN_SEGS(sbi)) {\n\t\tse = get_seg_entry(sbi, segno);\n\t\tif (IS_NODESEG(se->type))\n\t\t\tholes[NODE] += f2fs_usable_blks_in_seg(sbi, segno) -\n\t\t\t\t\t\t\tse->valid_blocks;\n\t\telse\n\t\t\tholes[DATA] += f2fs_usable_blks_in_seg(sbi, segno) -\n\t\t\t\t\t\t\tse->valid_blocks;\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\tunusable = holes[DATA] > holes[NODE] ? holes[DATA] : holes[NODE];\n\tif (unusable > ovp_holes)\n\t\treturn unusable - ovp_holes;\n\treturn 0;\n}\n\nint f2fs_disable_cp_again(struct f2fs_sb_info *sbi, block_t unusable)\n{\n\tint ovp_hole_segs =\n\t\t(overprovision_segments(sbi) - reserved_segments(sbi));\n\tif (unusable > F2FS_OPTION(sbi).unusable_cap)\n\t\treturn -EAGAIN;\n\tif (is_sbi_flag_set(sbi, SBI_CP_DISABLED_QUICK) &&\n\t\tdirty_segments(sbi) > ovp_hole_segs)\n\t\treturn -EAGAIN;\n\treturn 0;\n}\n\n/* This is only used by SBI_CP_DISABLED */\nstatic unsigned int get_free_segment(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno = 0;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[DIRTY], MAIN_SEGS(sbi)) {\n\t\tif (get_valid_blocks(sbi, segno, false))\n\t\t\tcontinue;\n\t\tif (get_ckpt_valid_blocks(sbi, segno, false))\n\t\t\tcontinue;\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t\treturn segno;\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\treturn NULL_SEGNO;\n}\n\nstatic struct discard_cmd *__create_discard_cmd(struct f2fs_sb_info *sbi,\n\t\tstruct block_device *bdev, block_t lstart,\n\t\tblock_t start, block_t len)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *pend_list;\n\tstruct discard_cmd *dc;\n\n\tf2fs_bug_on(sbi, !len);\n\n\tpend_list = &dcc->pend_list[plist_idx(len)];\n\n\tdc = f2fs_kmem_cache_alloc(discard_cmd_slab, GFP_NOFS);\n\tINIT_LIST_HEAD(&dc->list);\n\tdc->bdev = bdev;\n\tdc->lstart = lstart;\n\tdc->start = start;\n\tdc->len = len;\n\tdc->ref = 0;\n\tdc->state = D_PREP;\n\tdc->queued = 0;\n\tdc->error = 0;\n\tinit_completion(&dc->wait);\n\tlist_add_tail(&dc->list, pend_list);\n\tspin_lock_init(&dc->lock);\n\tdc->bio_ref = 0;\n\tatomic_inc(&dcc->discard_cmd_cnt);\n\tdcc->undiscard_blks += len;\n\n\treturn dc;\n}\n\nstatic struct discard_cmd *__attach_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct block_device *bdev, block_t lstart,\n\t\t\t\tblock_t start, block_t len,\n\t\t\t\tstruct rb_node *parent, struct rb_node **p,\n\t\t\t\tbool leftmost)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_cmd *dc;\n\n\tdc = __create_discard_cmd(sbi, bdev, lstart, start, len);\n\n\trb_link_node(&dc->rb_node, parent, p);\n\trb_insert_color_cached(&dc->rb_node, &dcc->root, leftmost);\n\n\treturn dc;\n}\n\nstatic void __detach_discard_cmd(struct discard_cmd_control *dcc,\n\t\t\t\t\t\t\tstruct discard_cmd *dc)\n{\n\tif (dc->state == D_DONE)\n\t\tatomic_sub(dc->queued, &dcc->queued_discard);\n\n\tlist_del(&dc->list);\n\trb_erase_cached(&dc->rb_node, &dcc->root);\n\tdcc->undiscard_blks -= dc->len;\n\n\tkmem_cache_free(discard_cmd_slab, dc);\n\n\tatomic_dec(&dcc->discard_cmd_cnt);\n}\n\nstatic void __remove_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\tstruct discard_cmd *dc)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tunsigned long flags;\n\n\ttrace_f2fs_remove_discard(dc->bdev, dc->start, dc->len);\n\n\tspin_lock_irqsave(&dc->lock, flags);\n\tif (dc->bio_ref) {\n\t\tspin_unlock_irqrestore(&dc->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&dc->lock, flags);\n\n\tf2fs_bug_on(sbi, dc->ref);\n\n\tif (dc->error == -EOPNOTSUPP)\n\t\tdc->error = 0;\n\n\tif (dc->error)\n\t\tprintk_ratelimited(\n\t\t\t\"%sF2FS-fs (%s): Issue discard(%u, %u, %u) failed, ret: %d\",\n\t\t\tKERN_INFO, sbi->sb->s_id,\n\t\t\tdc->lstart, dc->start, dc->len, dc->error);\n\t__detach_discard_cmd(dcc, dc);\n}\n\nstatic void f2fs_submit_discard_endio(struct bio *bio)\n{\n\tstruct discard_cmd *dc = (struct discard_cmd *)bio->bi_private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dc->lock, flags);\n\tif (!dc->error)\n\t\tdc->error = blk_status_to_errno(bio->bi_status);\n\tdc->bio_ref--;\n\tif (!dc->bio_ref && dc->state == D_SUBMIT) {\n\t\tdc->state = D_DONE;\n\t\tcomplete_all(&dc->wait);\n\t}\n\tspin_unlock_irqrestore(&dc->lock, flags);\n\tbio_put(bio);\n}\n\nstatic void __check_sit_bitmap(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t start, block_t end)\n{\n#ifdef CONFIG_F2FS_CHECK_FS\n\tstruct seg_entry *sentry;\n\tunsigned int segno;\n\tblock_t blk = start;\n\tunsigned long offset, size, max_blocks = sbi->blocks_per_seg;\n\tunsigned long *map;\n\n\twhile (blk < end) {\n\t\tsegno = GET_SEGNO(sbi, blk);\n\t\tsentry = get_seg_entry(sbi, segno);\n\t\toffset = GET_BLKOFF_FROM_SEG0(sbi, blk);\n\n\t\tif (end < START_BLOCK(sbi, segno + 1))\n\t\t\tsize = GET_BLKOFF_FROM_SEG0(sbi, end);\n\t\telse\n\t\t\tsize = max_blocks;\n\t\tmap = (unsigned long *)(sentry->cur_valid_map);\n\t\toffset = __find_rev_next_bit(map, size, offset);\n\t\tf2fs_bug_on(sbi, offset != size);\n\t\tblk = START_BLOCK(sbi, segno + 1);\n\t}\n#endif\n}\n\nstatic void __init_discard_policy(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct discard_policy *dpolicy,\n\t\t\t\tint discard_type, unsigned int granularity)\n{\n\t/* common policy */\n\tdpolicy->type = discard_type;\n\tdpolicy->sync = true;\n\tdpolicy->ordered = false;\n\tdpolicy->granularity = granularity;\n\n\tdpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;\n\tdpolicy->io_aware_gran = MAX_PLIST_NUM;\n\tdpolicy->timeout = false;\n\n\tif (discard_type == DPOLICY_BG) {\n\t\tdpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;\n\t\tdpolicy->mid_interval = DEF_MID_DISCARD_ISSUE_TIME;\n\t\tdpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;\n\t\tdpolicy->io_aware = true;\n\t\tdpolicy->sync = false;\n\t\tdpolicy->ordered = true;\n\t\tif (utilization(sbi) > DEF_DISCARD_URGENT_UTIL) {\n\t\t\tdpolicy->granularity = 1;\n\t\t\tdpolicy->max_interval = DEF_MIN_DISCARD_ISSUE_TIME;\n\t\t}\n\t} else if (discard_type == DPOLICY_FORCE) {\n\t\tdpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;\n\t\tdpolicy->mid_interval = DEF_MID_DISCARD_ISSUE_TIME;\n\t\tdpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;\n\t\tdpolicy->io_aware = false;\n\t} else if (discard_type == DPOLICY_FSTRIM) {\n\t\tdpolicy->io_aware = false;\n\t} else if (discard_type == DPOLICY_UMOUNT) {\n\t\tdpolicy->io_aware = false;\n\t\t/* we need to issue all to keep CP_TRIMMED_FLAG */\n\t\tdpolicy->granularity = 1;\n\t\tdpolicy->timeout = true;\n\t}\n}\n\nstatic void __update_discard_tree_range(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct block_device *bdev, block_t lstart,\n\t\t\t\tblock_t start, block_t len);\n/* this function is copied from blkdev_issue_discard from block/blk-lib.c */\nstatic int __submit_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct discard_policy *dpolicy,\n\t\t\t\t\t\tstruct discard_cmd *dc,\n\t\t\t\t\t\tunsigned int *issued)\n{\n\tstruct block_device *bdev = dc->bdev;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int max_discard_blocks =\n\t\t\tSECTOR_TO_BLOCK(q->limits.max_discard_sectors);\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *wait_list = (dpolicy->type == DPOLICY_FSTRIM) ?\n\t\t\t\t\t&(dcc->fstrim_list) : &(dcc->wait_list);\n\tint flag = dpolicy->sync ? REQ_SYNC : 0;\n\tblock_t lstart, start, len, total_len;\n\tint err = 0;\n\n\tif (dc->state != D_PREP)\n\t\treturn 0;\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK))\n\t\treturn 0;\n\n\ttrace_f2fs_issue_discard(bdev, dc->start, dc->len);\n\n\tlstart = dc->lstart;\n\tstart = dc->start;\n\tlen = dc->len;\n\ttotal_len = len;\n\n\tdc->len = 0;\n\n\twhile (total_len && *issued < dpolicy->max_requests && !err) {\n\t\tstruct bio *bio = NULL;\n\t\tunsigned long flags;\n\t\tbool last = true;\n\n\t\tif (len > max_discard_blocks) {\n\t\t\tlen = max_discard_blocks;\n\t\t\tlast = false;\n\t\t}\n\n\t\t(*issued)++;\n\t\tif (*issued == dpolicy->max_requests)\n\t\t\tlast = true;\n\n\t\tdc->len += len;\n\n\t\tif (time_to_inject(sbi, FAULT_DISCARD)) {\n\t\t\tf2fs_show_injection_info(sbi, FAULT_DISCARD);\n\t\t\terr = -EIO;\n\t\t\tgoto submit;\n\t\t}\n\t\terr = __blkdev_issue_discard(bdev,\n\t\t\t\t\tSECTOR_FROM_BLOCK(start),\n\t\t\t\t\tSECTOR_FROM_BLOCK(len),\n\t\t\t\t\tGFP_NOFS, 0, &bio);\nsubmit:\n\t\tif (err) {\n\t\t\tspin_lock_irqsave(&dc->lock, flags);\n\t\t\tif (dc->state == D_PARTIAL)\n\t\t\t\tdc->state = D_SUBMIT;\n\t\t\tspin_unlock_irqrestore(&dc->lock, flags);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tf2fs_bug_on(sbi, !bio);\n\n\t\t/*\n\t\t * should keep before submission to avoid D_DONE\n\t\t * right away\n\t\t */\n\t\tspin_lock_irqsave(&dc->lock, flags);\n\t\tif (last)\n\t\t\tdc->state = D_SUBMIT;\n\t\telse\n\t\t\tdc->state = D_PARTIAL;\n\t\tdc->bio_ref++;\n\t\tspin_unlock_irqrestore(&dc->lock, flags);\n\n\t\tatomic_inc(&dcc->queued_discard);\n\t\tdc->queued++;\n\t\tlist_move_tail(&dc->list, wait_list);\n\n\t\t/* sanity check on discard range */\n\t\t__check_sit_bitmap(sbi, lstart, lstart + len);\n\n\t\tbio->bi_private = dc;\n\t\tbio->bi_end_io = f2fs_submit_discard_endio;\n\t\tbio->bi_opf |= flag;\n\t\tsubmit_bio(bio);\n\n\t\tatomic_inc(&dcc->issued_discard);\n\n\t\tf2fs_update_iostat(sbi, FS_DISCARD, 1);\n\n\t\tlstart += len;\n\t\tstart += len;\n\t\ttotal_len -= len;\n\t\tlen = total_len;\n\t}\n\n\tif (!err && len) {\n\t\tdcc->undiscard_blks -= len;\n\t\t__update_discard_tree_range(sbi, bdev, lstart, start, len);\n\t}\n\treturn err;\n}\n\nstatic void __insert_discard_tree(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct block_device *bdev, block_t lstart,\n\t\t\t\tblock_t start, block_t len,\n\t\t\t\tstruct rb_node **insert_p,\n\t\t\t\tstruct rb_node *insert_parent)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tbool leftmost = true;\n\n\tif (insert_p && insert_parent) {\n\t\tparent = insert_parent;\n\t\tp = insert_p;\n\t\tgoto do_insert;\n\t}\n\n\tp = f2fs_lookup_rb_tree_for_insert(sbi, &dcc->root, &parent,\n\t\t\t\t\t\t\tlstart, &leftmost);\ndo_insert:\n\t__attach_discard_cmd(sbi, bdev, lstart, start, len, parent,\n\t\t\t\t\t\t\t\tp, leftmost);\n}\n\nstatic void __relocate_discard_cmd(struct discard_cmd_control *dcc,\n\t\t\t\t\t\tstruct discard_cmd *dc)\n{\n\tlist_move_tail(&dc->list, &dcc->pend_list[plist_idx(dc->len)]);\n}\n\nstatic void __punch_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct discard_cmd *dc, block_t blkaddr)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_info di = dc->di;\n\tbool modified = false;\n\n\tif (dc->state == D_DONE || dc->len == 1) {\n\t\t__remove_discard_cmd(sbi, dc);\n\t\treturn;\n\t}\n\n\tdcc->undiscard_blks -= di.len;\n\n\tif (blkaddr > di.lstart) {\n\t\tdc->len = blkaddr - dc->lstart;\n\t\tdcc->undiscard_blks += dc->len;\n\t\t__relocate_discard_cmd(dcc, dc);\n\t\tmodified = true;\n\t}\n\n\tif (blkaddr < di.lstart + di.len - 1) {\n\t\tif (modified) {\n\t\t\t__insert_discard_tree(sbi, dc->bdev, blkaddr + 1,\n\t\t\t\t\tdi.start + blkaddr + 1 - di.lstart,\n\t\t\t\t\tdi.lstart + di.len - 1 - blkaddr,\n\t\t\t\t\tNULL, NULL);\n\t\t} else {\n\t\t\tdc->lstart++;\n\t\t\tdc->len--;\n\t\t\tdc->start++;\n\t\t\tdcc->undiscard_blks += dc->len;\n\t\t\t__relocate_discard_cmd(dcc, dc);\n\t\t}\n\t}\n}\n\nstatic void __update_discard_tree_range(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct block_device *bdev, block_t lstart,\n\t\t\t\tblock_t start, block_t len)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_cmd *prev_dc = NULL, *next_dc = NULL;\n\tstruct discard_cmd *dc;\n\tstruct discard_info di = {0};\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tstruct request_queue *q = bdev_get_queue(bdev);\n\tunsigned int max_discard_blocks =\n\t\t\tSECTOR_TO_BLOCK(q->limits.max_discard_sectors);\n\tblock_t end = lstart + len;\n\n\tdc = (struct discard_cmd *)f2fs_lookup_rb_tree_ret(&dcc->root,\n\t\t\t\t\tNULL, lstart,\n\t\t\t\t\t(struct rb_entry **)&prev_dc,\n\t\t\t\t\t(struct rb_entry **)&next_dc,\n\t\t\t\t\t&insert_p, &insert_parent, true, NULL);\n\tif (dc)\n\t\tprev_dc = dc;\n\n\tif (!prev_dc) {\n\t\tdi.lstart = lstart;\n\t\tdi.len = next_dc ? next_dc->lstart - lstart : len;\n\t\tdi.len = min(di.len, len);\n\t\tdi.start = start;\n\t}\n\n\twhile (1) {\n\t\tstruct rb_node *node;\n\t\tbool merged = false;\n\t\tstruct discard_cmd *tdc = NULL;\n\n\t\tif (prev_dc) {\n\t\t\tdi.lstart = prev_dc->lstart + prev_dc->len;\n\t\t\tif (di.lstart < lstart)\n\t\t\t\tdi.lstart = lstart;\n\t\t\tif (di.lstart >= end)\n\t\t\t\tbreak;\n\n\t\t\tif (!next_dc || next_dc->lstart > end)\n\t\t\t\tdi.len = end - di.lstart;\n\t\t\telse\n\t\t\t\tdi.len = next_dc->lstart - di.lstart;\n\t\t\tdi.start = start + di.lstart - lstart;\n\t\t}\n\n\t\tif (!di.len)\n\t\t\tgoto next;\n\n\t\tif (prev_dc && prev_dc->state == D_PREP &&\n\t\t\tprev_dc->bdev == bdev &&\n\t\t\t__is_discard_back_mergeable(&di, &prev_dc->di,\n\t\t\t\t\t\t\tmax_discard_blocks)) {\n\t\t\tprev_dc->di.len += di.len;\n\t\t\tdcc->undiscard_blks += di.len;\n\t\t\t__relocate_discard_cmd(dcc, prev_dc);\n\t\t\tdi = prev_dc->di;\n\t\t\ttdc = prev_dc;\n\t\t\tmerged = true;\n\t\t}\n\n\t\tif (next_dc && next_dc->state == D_PREP &&\n\t\t\tnext_dc->bdev == bdev &&\n\t\t\t__is_discard_front_mergeable(&di, &next_dc->di,\n\t\t\t\t\t\t\tmax_discard_blocks)) {\n\t\t\tnext_dc->di.lstart = di.lstart;\n\t\t\tnext_dc->di.len += di.len;\n\t\t\tnext_dc->di.start = di.start;\n\t\t\tdcc->undiscard_blks += di.len;\n\t\t\t__relocate_discard_cmd(dcc, next_dc);\n\t\t\tif (tdc)\n\t\t\t\t__remove_discard_cmd(sbi, tdc);\n\t\t\tmerged = true;\n\t\t}\n\n\t\tif (!merged) {\n\t\t\t__insert_discard_tree(sbi, bdev, di.lstart, di.start,\n\t\t\t\t\t\t\tdi.len, NULL, NULL);\n\t\t}\n next:\n\t\tprev_dc = next_dc;\n\t\tif (!prev_dc)\n\t\t\tbreak;\n\n\t\tnode = rb_next(&prev_dc->rb_node);\n\t\tnext_dc = rb_entry_safe(node, struct discard_cmd, rb_node);\n\t}\n}\n\nstatic int __queue_discard_cmd(struct f2fs_sb_info *sbi,\n\t\tstruct block_device *bdev, block_t blkstart, block_t blklen)\n{\n\tblock_t lblkstart = blkstart;\n\n\tif (!f2fs_bdev_support_discard(bdev))\n\t\treturn 0;\n\n\ttrace_f2fs_queue_discard(bdev, blkstart, blklen);\n\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tint devi = f2fs_target_device_index(sbi, blkstart);\n\n\t\tblkstart -= FDEV(devi).start_blk;\n\t}\n\tmutex_lock(&SM_I(sbi)->dcc_info->cmd_lock);\n\t__update_discard_tree_range(sbi, bdev, lblkstart, blkstart, blklen);\n\tmutex_unlock(&SM_I(sbi)->dcc_info->cmd_lock);\n\treturn 0;\n}\n\nstatic unsigned int __issue_discard_cmd_orderly(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct discard_policy *dpolicy)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_cmd *prev_dc = NULL, *next_dc = NULL;\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tstruct discard_cmd *dc;\n\tstruct blk_plug plug;\n\tunsigned int pos = dcc->next_pos;\n\tunsigned int issued = 0;\n\tbool io_interrupted = false;\n\n\tmutex_lock(&dcc->cmd_lock);\n\tdc = (struct discard_cmd *)f2fs_lookup_rb_tree_ret(&dcc->root,\n\t\t\t\t\tNULL, pos,\n\t\t\t\t\t(struct rb_entry **)&prev_dc,\n\t\t\t\t\t(struct rb_entry **)&next_dc,\n\t\t\t\t\t&insert_p, &insert_parent, true, NULL);\n\tif (!dc)\n\t\tdc = next_dc;\n\n\tblk_start_plug(&plug);\n\n\twhile (dc) {\n\t\tstruct rb_node *node;\n\t\tint err = 0;\n\n\t\tif (dc->state != D_PREP)\n\t\t\tgoto next;\n\n\t\tif (dpolicy->io_aware && !is_idle(sbi, DISCARD_TIME)) {\n\t\t\tio_interrupted = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tdcc->next_pos = dc->lstart + dc->len;\n\t\terr = __submit_discard_cmd(sbi, dpolicy, dc, &issued);\n\n\t\tif (issued >= dpolicy->max_requests)\n\t\t\tbreak;\nnext:\n\t\tnode = rb_next(&dc->rb_node);\n\t\tif (err)\n\t\t\t__remove_discard_cmd(sbi, dc);\n\t\tdc = rb_entry_safe(node, struct discard_cmd, rb_node);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\tif (!dc)\n\t\tdcc->next_pos = 0;\n\n\tmutex_unlock(&dcc->cmd_lock);\n\n\tif (!issued && io_interrupted)\n\t\tissued = -1;\n\n\treturn issued;\n}\nstatic unsigned int __wait_all_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct discard_policy *dpolicy);\n\nstatic int __issue_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct discard_policy *dpolicy)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *pend_list;\n\tstruct discard_cmd *dc, *tmp;\n\tstruct blk_plug plug;\n\tint i, issued;\n\tbool io_interrupted = false;\n\n\tif (dpolicy->timeout)\n\t\tf2fs_update_time(sbi, UMOUNT_DISCARD_TIMEOUT);\n\nretry:\n\tissued = 0;\n\tfor (i = MAX_PLIST_NUM - 1; i >= 0; i--) {\n\t\tif (dpolicy->timeout &&\n\t\t\t\tf2fs_time_over(sbi, UMOUNT_DISCARD_TIMEOUT))\n\t\t\tbreak;\n\n\t\tif (i + 1 < dpolicy->granularity)\n\t\t\tbreak;\n\n\t\tif (i < DEFAULT_DISCARD_GRANULARITY && dpolicy->ordered)\n\t\t\treturn __issue_discard_cmd_orderly(sbi, dpolicy);\n\n\t\tpend_list = &dcc->pend_list[i];\n\n\t\tmutex_lock(&dcc->cmd_lock);\n\t\tif (list_empty(pend_list))\n\t\t\tgoto next;\n\t\tif (unlikely(dcc->rbtree_check))\n\t\t\tf2fs_bug_on(sbi, !f2fs_check_rb_tree_consistence(sbi,\n\t\t\t\t\t\t\t&dcc->root, false));\n\t\tblk_start_plug(&plug);\n\t\tlist_for_each_entry_safe(dc, tmp, pend_list, list) {\n\t\t\tf2fs_bug_on(sbi, dc->state != D_PREP);\n\n\t\t\tif (dpolicy->timeout &&\n\t\t\t\tf2fs_time_over(sbi, UMOUNT_DISCARD_TIMEOUT))\n\t\t\t\tbreak;\n\n\t\t\tif (dpolicy->io_aware && i < dpolicy->io_aware_gran &&\n\t\t\t\t\t\t!is_idle(sbi, DISCARD_TIME)) {\n\t\t\t\tio_interrupted = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t__submit_discard_cmd(sbi, dpolicy, dc, &issued);\n\n\t\t\tif (issued >= dpolicy->max_requests)\n\t\t\t\tbreak;\n\t\t}\n\t\tblk_finish_plug(&plug);\nnext:\n\t\tmutex_unlock(&dcc->cmd_lock);\n\n\t\tif (issued >= dpolicy->max_requests || io_interrupted)\n\t\t\tbreak;\n\t}\n\n\tif (dpolicy->type == DPOLICY_UMOUNT && issued) {\n\t\t__wait_all_discard_cmd(sbi, dpolicy);\n\t\tgoto retry;\n\t}\n\n\tif (!issued && io_interrupted)\n\t\tissued = -1;\n\n\treturn issued;\n}\n\nstatic bool __drop_discard_cmd(struct f2fs_sb_info *sbi)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *pend_list;\n\tstruct discard_cmd *dc, *tmp;\n\tint i;\n\tbool dropped = false;\n\n\tmutex_lock(&dcc->cmd_lock);\n\tfor (i = MAX_PLIST_NUM - 1; i >= 0; i--) {\n\t\tpend_list = &dcc->pend_list[i];\n\t\tlist_for_each_entry_safe(dc, tmp, pend_list, list) {\n\t\t\tf2fs_bug_on(sbi, dc->state != D_PREP);\n\t\t\t__remove_discard_cmd(sbi, dc);\n\t\t\tdropped = true;\n\t\t}\n\t}\n\tmutex_unlock(&dcc->cmd_lock);\n\n\treturn dropped;\n}\n\nvoid f2fs_drop_discard_cmd(struct f2fs_sb_info *sbi)\n{\n\t__drop_discard_cmd(sbi);\n}\n\nstatic unsigned int __wait_one_discard_bio(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\tstruct discard_cmd *dc)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tunsigned int len = 0;\n\n\twait_for_completion_io(&dc->wait);\n\tmutex_lock(&dcc->cmd_lock);\n\tf2fs_bug_on(sbi, dc->state != D_DONE);\n\tdc->ref--;\n\tif (!dc->ref) {\n\t\tif (!dc->error)\n\t\t\tlen = dc->len;\n\t\t__remove_discard_cmd(sbi, dc);\n\t}\n\tmutex_unlock(&dcc->cmd_lock);\n\n\treturn len;\n}\n\nstatic unsigned int __wait_discard_cmd_range(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct discard_policy *dpolicy,\n\t\t\t\t\t\tblock_t start, block_t end)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *wait_list = (dpolicy->type == DPOLICY_FSTRIM) ?\n\t\t\t\t\t&(dcc->fstrim_list) : &(dcc->wait_list);\n\tstruct discard_cmd *dc, *tmp;\n\tbool need_wait;\n\tunsigned int trimmed = 0;\n\nnext:\n\tneed_wait = false;\n\n\tmutex_lock(&dcc->cmd_lock);\n\tlist_for_each_entry_safe(dc, tmp, wait_list, list) {\n\t\tif (dc->lstart + dc->len <= start || end <= dc->lstart)\n\t\t\tcontinue;\n\t\tif (dc->len < dpolicy->granularity)\n\t\t\tcontinue;\n\t\tif (dc->state == D_DONE && !dc->ref) {\n\t\t\twait_for_completion_io(&dc->wait);\n\t\t\tif (!dc->error)\n\t\t\t\ttrimmed += dc->len;\n\t\t\t__remove_discard_cmd(sbi, dc);\n\t\t} else {\n\t\t\tdc->ref++;\n\t\t\tneed_wait = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dcc->cmd_lock);\n\n\tif (need_wait) {\n\t\ttrimmed += __wait_one_discard_bio(sbi, dc);\n\t\tgoto next;\n\t}\n\n\treturn trimmed;\n}\n\nstatic unsigned int __wait_all_discard_cmd(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct discard_policy *dpolicy)\n{\n\tstruct discard_policy dp;\n\tunsigned int discard_blks;\n\n\tif (dpolicy)\n\t\treturn __wait_discard_cmd_range(sbi, dpolicy, 0, UINT_MAX);\n\n\t/* wait all */\n\t__init_discard_policy(sbi, &dp, DPOLICY_FSTRIM, 1);\n\tdiscard_blks = __wait_discard_cmd_range(sbi, &dp, 0, UINT_MAX);\n\t__init_discard_policy(sbi, &dp, DPOLICY_UMOUNT, 1);\n\tdiscard_blks += __wait_discard_cmd_range(sbi, &dp, 0, UINT_MAX);\n\n\treturn discard_blks;\n}\n\n/* This should be covered by global mutex, &sit_i->sentry_lock */\nstatic void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_cmd *dc;\n\tbool need_wait = false;\n\n\tmutex_lock(&dcc->cmd_lock);\n\tdc = (struct discard_cmd *)f2fs_lookup_rb_tree(&dcc->root,\n\t\t\t\t\t\t\tNULL, blkaddr);\n\tif (dc) {\n\t\tif (dc->state == D_PREP) {\n\t\t\t__punch_discard_cmd(sbi, dc, blkaddr);\n\t\t} else {\n\t\t\tdc->ref++;\n\t\t\tneed_wait = true;\n\t\t}\n\t}\n\tmutex_unlock(&dcc->cmd_lock);\n\n\tif (need_wait)\n\t\t__wait_one_discard_bio(sbi, dc);\n}\n\nvoid f2fs_stop_discard_thread(struct f2fs_sb_info *sbi)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\n\tif (dcc && dcc->f2fs_issue_discard) {\n\t\tstruct task_struct *discard_thread = dcc->f2fs_issue_discard;\n\n\t\tdcc->f2fs_issue_discard = NULL;\n\t\tkthread_stop(discard_thread);\n\t}\n}\n\n/* This comes from f2fs_put_super */\nbool f2fs_issue_discard_timeout(struct f2fs_sb_info *sbi)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_policy dpolicy;\n\tbool dropped;\n\n\t__init_discard_policy(sbi, &dpolicy, DPOLICY_UMOUNT,\n\t\t\t\t\tdcc->discard_granularity);\n\t__issue_discard_cmd(sbi, &dpolicy);\n\tdropped = __drop_discard_cmd(sbi);\n\n\t/* just to make sure there is no pending discard commands */\n\t__wait_all_discard_cmd(sbi, NULL);\n\n\tf2fs_bug_on(sbi, atomic_read(&dcc->discard_cmd_cnt));\n\treturn dropped;\n}\n\nstatic int issue_discard_thread(void *data)\n{\n\tstruct f2fs_sb_info *sbi = data;\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\twait_queue_head_t *q = &dcc->discard_wait_queue;\n\tstruct discard_policy dpolicy;\n\tunsigned int wait_ms = DEF_MIN_DISCARD_ISSUE_TIME;\n\tint issued;\n\n\tset_freezable();\n\n\tdo {\n\t\t__init_discard_policy(sbi, &dpolicy, DPOLICY_BG,\n\t\t\t\t\tdcc->discard_granularity);\n\n\t\twait_event_interruptible_timeout(*q,\n\t\t\t\tkthread_should_stop() || freezing(current) ||\n\t\t\t\tdcc->discard_wake,\n\t\t\t\tmsecs_to_jiffies(wait_ms));\n\n\t\tif (dcc->discard_wake)\n\t\t\tdcc->discard_wake = 0;\n\n\t\t/* clean up pending candidates before going to sleep */\n\t\tif (atomic_read(&dcc->queued_discard))\n\t\t\t__wait_all_discard_cmd(sbi, NULL);\n\n\t\tif (try_to_freeze())\n\t\t\tcontinue;\n\t\tif (f2fs_readonly(sbi->sb))\n\t\t\tcontinue;\n\t\tif (kthread_should_stop())\n\t\t\treturn 0;\n\t\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\t\twait_ms = dpolicy.max_interval;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!atomic_read(&dcc->discard_cmd_cnt))\n\t\t\tcontinue;\n\n\t\tif (sbi->gc_mode == GC_URGENT_HIGH ||\n\t\t\t!f2fs_available_free_memory(sbi, DISCARD_CACHE))\n\t\t\t__init_discard_policy(sbi, &dpolicy, DPOLICY_FORCE, 1);\n\n\t\tsb_start_intwrite(sbi->sb);\n\n\t\tissued = __issue_discard_cmd(sbi, &dpolicy);\n\t\tif (issued > 0) {\n\t\t\t__wait_all_discard_cmd(sbi, &dpolicy);\n\t\t\twait_ms = dpolicy.min_interval;\n\t\t} else if (issued == -1){\n\t\t\twait_ms = f2fs_time_to_wait(sbi, DISCARD_TIME);\n\t\t\tif (!wait_ms)\n\t\t\t\twait_ms = dpolicy.mid_interval;\n\t\t} else {\n\t\t\twait_ms = dpolicy.max_interval;\n\t\t}\n\n\t\tsb_end_intwrite(sbi->sb);\n\n\t} while (!kthread_should_stop());\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_DEV_ZONED\nstatic int __f2fs_issue_discard_zone(struct f2fs_sb_info *sbi,\n\t\tstruct block_device *bdev, block_t blkstart, block_t blklen)\n{\n\tsector_t sector, nr_sects;\n\tblock_t lblkstart = blkstart;\n\tint devi = 0;\n\n\tif (f2fs_is_multi_device(sbi)) {\n\t\tdevi = f2fs_target_device_index(sbi, blkstart);\n\t\tif (blkstart < FDEV(devi).start_blk ||\n\t\t    blkstart > FDEV(devi).end_blk) {\n\t\t\tf2fs_err(sbi, \"Invalid block %x\", blkstart);\n\t\t\treturn -EIO;\n\t\t}\n\t\tblkstart -= FDEV(devi).start_blk;\n\t}\n\n\t/* For sequential zones, reset the zone write pointer */\n\tif (f2fs_blkz_is_seq(sbi, devi, blkstart)) {\n\t\tsector = SECTOR_FROM_BLOCK(blkstart);\n\t\tnr_sects = SECTOR_FROM_BLOCK(blklen);\n\n\t\tif (sector & (bdev_zone_sectors(bdev) - 1) ||\n\t\t\t\tnr_sects != bdev_zone_sectors(bdev)) {\n\t\t\tf2fs_err(sbi, \"(%d) %s: Unaligned zone reset attempted (block %x + %x)\",\n\t\t\t\t devi, sbi->s_ndevs ? FDEV(devi).path : \"\",\n\t\t\t\t blkstart, blklen);\n\t\t\treturn -EIO;\n\t\t}\n\t\ttrace_f2fs_issue_reset_zone(bdev, blkstart);\n\t\treturn blkdev_zone_mgmt(bdev, REQ_OP_ZONE_RESET,\n\t\t\t\t\tsector, nr_sects, GFP_NOFS);\n\t}\n\n\t/* For conventional zones, use regular discard if supported */\n\treturn __queue_discard_cmd(sbi, bdev, lblkstart, blklen);\n}\n#endif\n\nstatic int __issue_discard_async(struct f2fs_sb_info *sbi,\n\t\tstruct block_device *bdev, block_t blkstart, block_t blklen)\n{\n#ifdef CONFIG_BLK_DEV_ZONED\n\tif (f2fs_sb_has_blkzoned(sbi) && bdev_is_zoned(bdev))\n\t\treturn __f2fs_issue_discard_zone(sbi, bdev, blkstart, blklen);\n#endif\n\treturn __queue_discard_cmd(sbi, bdev, blkstart, blklen);\n}\n\nstatic int f2fs_issue_discard(struct f2fs_sb_info *sbi,\n\t\t\t\tblock_t blkstart, block_t blklen)\n{\n\tsector_t start = blkstart, len = 0;\n\tstruct block_device *bdev;\n\tstruct seg_entry *se;\n\tunsigned int offset;\n\tblock_t i;\n\tint err = 0;\n\n\tbdev = f2fs_target_device(sbi, blkstart, NULL);\n\n\tfor (i = blkstart; i < blkstart + blklen; i++, len++) {\n\t\tif (i != start) {\n\t\t\tstruct block_device *bdev2 =\n\t\t\t\tf2fs_target_device(sbi, i, NULL);\n\n\t\t\tif (bdev2 != bdev) {\n\t\t\t\terr = __issue_discard_async(sbi, bdev,\n\t\t\t\t\t\tstart, len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbdev = bdev2;\n\t\t\t\tstart = i;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\n\t\tse = get_seg_entry(sbi, GET_SEGNO(sbi, i));\n\t\toffset = GET_BLKOFF_FROM_SEG0(sbi, i);\n\n\t\tif (!f2fs_test_and_set_bit(offset, se->discard_map))\n\t\t\tsbi->discard_blks--;\n\t}\n\n\tif (len)\n\t\terr = __issue_discard_async(sbi, bdev, start, len);\n\treturn err;\n}\n\nstatic bool add_discard_addrs(struct f2fs_sb_info *sbi, struct cp_control *cpc,\n\t\t\t\t\t\t\tbool check_only)\n{\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tint max_blocks = sbi->blocks_per_seg;\n\tstruct seg_entry *se = get_seg_entry(sbi, cpc->trim_start);\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *discard_map = (unsigned long *)se->discard_map;\n\tunsigned long *dmap = SIT_I(sbi)->tmp_map;\n\tunsigned int start = 0, end = -1;\n\tbool force = (cpc->reason & CP_DISCARD);\n\tstruct discard_entry *de = NULL;\n\tstruct list_head *head = &SM_I(sbi)->dcc_info->entry_list;\n\tint i;\n\n\tif (se->valid_blocks == max_blocks || !f2fs_hw_support_discard(sbi))\n\t\treturn false;\n\n\tif (!force) {\n\t\tif (!f2fs_realtime_discard_enable(sbi) || !se->valid_blocks ||\n\t\t\tSM_I(sbi)->dcc_info->nr_discards >=\n\t\t\t\tSM_I(sbi)->dcc_info->max_discards)\n\t\t\treturn false;\n\t}\n\n\t/* SIT_VBLOCK_MAP_SIZE should be multiple of sizeof(unsigned long) */\n\tfor (i = 0; i < entries; i++)\n\t\tdmap[i] = force ? ~ckpt_map[i] & ~discard_map[i] :\n\t\t\t\t(cur_map[i] ^ ckpt_map[i]) & ckpt_map[i];\n\n\twhile (force || SM_I(sbi)->dcc_info->nr_discards <=\n\t\t\t\tSM_I(sbi)->dcc_info->max_discards) {\n\t\tstart = __find_rev_next_bit(dmap, max_blocks, end + 1);\n\t\tif (start >= max_blocks)\n\t\t\tbreak;\n\n\t\tend = __find_rev_next_zero_bit(dmap, max_blocks, start + 1);\n\t\tif (force && start && end != max_blocks\n\t\t\t\t\t&& (end - start) < cpc->trim_minlen)\n\t\t\tcontinue;\n\n\t\tif (check_only)\n\t\t\treturn true;\n\n\t\tif (!de) {\n\t\t\tde = f2fs_kmem_cache_alloc(discard_entry_slab,\n\t\t\t\t\t\t\t\tGFP_F2FS_ZERO);\n\t\t\tde->start_blkaddr = START_BLOCK(sbi, cpc->trim_start);\n\t\t\tlist_add_tail(&de->list, head);\n\t\t}\n\n\t\tfor (i = start; i < end; i++)\n\t\t\t__set_bit_le(i, (void *)de->discard_map);\n\n\t\tSM_I(sbi)->dcc_info->nr_discards += end - start;\n\t}\n\treturn false;\n}\n\nstatic void release_discard_addr(struct discard_entry *entry)\n{\n\tlist_del(&entry->list);\n\tkmem_cache_free(discard_entry_slab, entry);\n}\n\nvoid f2fs_release_discard_addrs(struct f2fs_sb_info *sbi)\n{\n\tstruct list_head *head = &(SM_I(sbi)->dcc_info->entry_list);\n\tstruct discard_entry *entry, *this;\n\n\t/* drop caches */\n\tlist_for_each_entry_safe(entry, this, head, list)\n\t\trelease_discard_addr(entry);\n}\n\n/*\n * Should call f2fs_clear_prefree_segments after checkpoint is done.\n */\nstatic void set_prefree_as_free_segments(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int segno;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor_each_set_bit(segno, dirty_i->dirty_segmap[PRE], MAIN_SEGS(sbi))\n\t\t__set_test_and_free(sbi, segno, false);\n\tmutex_unlock(&dirty_i->seglist_lock);\n}\n\nvoid f2fs_clear_prefree_segments(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct cp_control *cpc)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct list_head *head = &dcc->entry_list;\n\tstruct discard_entry *entry, *this;\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned long *prefree_map = dirty_i->dirty_segmap[PRE];\n\tunsigned int start = 0, end = -1;\n\tunsigned int secno, start_segno;\n\tbool force = (cpc->reason & CP_DISCARD);\n\tbool need_align = f2fs_lfs_mode(sbi) && __is_large_section(sbi);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\n\twhile (1) {\n\t\tint i;\n\n\t\tif (need_align && end != -1)\n\t\t\tend--;\n\t\tstart = find_next_bit(prefree_map, MAIN_SEGS(sbi), end + 1);\n\t\tif (start >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\tend = find_next_zero_bit(prefree_map, MAIN_SEGS(sbi),\n\t\t\t\t\t\t\t\tstart + 1);\n\n\t\tif (need_align) {\n\t\t\tstart = rounddown(start, sbi->segs_per_sec);\n\t\t\tend = roundup(end, sbi->segs_per_sec);\n\t\t}\n\n\t\tfor (i = start; i < end; i++) {\n\t\t\tif (test_and_clear_bit(i, prefree_map))\n\t\t\t\tdirty_i->nr_dirty[PRE]--;\n\t\t}\n\n\t\tif (!f2fs_realtime_discard_enable(sbi))\n\t\t\tcontinue;\n\n\t\tif (force && start >= cpc->trim_start &&\n\t\t\t\t\t(end - 1) <= cpc->trim_end)\n\t\t\t\tcontinue;\n\n\t\tif (!f2fs_lfs_mode(sbi) || !__is_large_section(sbi)) {\n\t\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start),\n\t\t\t\t(end - start) << sbi->log_blocks_per_seg);\n\t\t\tcontinue;\n\t\t}\nnext:\n\t\tsecno = GET_SEC_FROM_SEG(sbi, start);\n\t\tstart_segno = GET_SEG_FROM_SEC(sbi, secno);\n\t\tif (!IS_CURSEC(sbi, secno) &&\n\t\t\t!get_valid_blocks(sbi, start, true))\n\t\t\tf2fs_issue_discard(sbi, START_BLOCK(sbi, start_segno),\n\t\t\t\tsbi->segs_per_sec << sbi->log_blocks_per_seg);\n\n\t\tstart = start_segno + sbi->segs_per_sec;\n\t\tif (start < end)\n\t\t\tgoto next;\n\t\telse\n\t\t\tend = start - 1;\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\t/* send small discards */\n\tlist_for_each_entry_safe(entry, this, head, list) {\n\t\tunsigned int cur_pos = 0, next_pos, len, total_len = 0;\n\t\tbool is_valid = test_bit_le(0, entry->discard_map);\n\nfind_next:\n\t\tif (is_valid) {\n\t\t\tnext_pos = find_next_zero_bit_le(entry->discard_map,\n\t\t\t\t\tsbi->blocks_per_seg, cur_pos);\n\t\t\tlen = next_pos - cur_pos;\n\n\t\t\tif (f2fs_sb_has_blkzoned(sbi) ||\n\t\t\t    (force && len < cpc->trim_minlen))\n\t\t\t\tgoto skip;\n\n\t\t\tf2fs_issue_discard(sbi, entry->start_blkaddr + cur_pos,\n\t\t\t\t\t\t\t\t\tlen);\n\t\t\ttotal_len += len;\n\t\t} else {\n\t\t\tnext_pos = find_next_bit_le(entry->discard_map,\n\t\t\t\t\tsbi->blocks_per_seg, cur_pos);\n\t\t}\nskip:\n\t\tcur_pos = next_pos;\n\t\tis_valid = !is_valid;\n\n\t\tif (cur_pos < sbi->blocks_per_seg)\n\t\t\tgoto find_next;\n\n\t\trelease_discard_addr(entry);\n\t\tdcc->nr_discards -= total_len;\n\t}\n\n\twake_up_discard_thread(sbi, false);\n}\n\nstatic int create_discard_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct discard_cmd_control *dcc;\n\tint err = 0, i;\n\n\tif (SM_I(sbi)->dcc_info) {\n\t\tdcc = SM_I(sbi)->dcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tdcc = f2fs_kzalloc(sbi, sizeof(struct discard_cmd_control), GFP_KERNEL);\n\tif (!dcc)\n\t\treturn -ENOMEM;\n\n\tdcc->discard_granularity = DEFAULT_DISCARD_GRANULARITY;\n\tINIT_LIST_HEAD(&dcc->entry_list);\n\tfor (i = 0; i < MAX_PLIST_NUM; i++)\n\t\tINIT_LIST_HEAD(&dcc->pend_list[i]);\n\tINIT_LIST_HEAD(&dcc->wait_list);\n\tINIT_LIST_HEAD(&dcc->fstrim_list);\n\tmutex_init(&dcc->cmd_lock);\n\tatomic_set(&dcc->issued_discard, 0);\n\tatomic_set(&dcc->queued_discard, 0);\n\tatomic_set(&dcc->discard_cmd_cnt, 0);\n\tdcc->nr_discards = 0;\n\tdcc->max_discards = MAIN_SEGS(sbi) << sbi->log_blocks_per_seg;\n\tdcc->undiscard_blks = 0;\n\tdcc->next_pos = 0;\n\tdcc->root = RB_ROOT_CACHED;\n\tdcc->rbtree_check = false;\n\n\tinit_waitqueue_head(&dcc->discard_wait_queue);\n\tSM_I(sbi)->dcc_info = dcc;\ninit_thread:\n\tdcc->f2fs_issue_discard = kthread_run(issue_discard_thread, sbi,\n\t\t\t\t\"f2fs_discard-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(dcc->f2fs_issue_discard)) {\n\t\terr = PTR_ERR(dcc->f2fs_issue_discard);\n\t\tkfree(dcc);\n\t\tSM_I(sbi)->dcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n\nstatic void destroy_discard_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\n\tif (!dcc)\n\t\treturn;\n\n\tf2fs_stop_discard_thread(sbi);\n\n\t/*\n\t * Recovery can cache discard commands, so in error path of\n\t * fill_super(), it needs to give a chance to handle them.\n\t */\n\tif (unlikely(atomic_read(&dcc->discard_cmd_cnt)))\n\t\tf2fs_issue_discard_timeout(sbi);\n\n\tkfree(dcc);\n\tSM_I(sbi)->dcc_info = NULL;\n}\n\nstatic bool __mark_sit_entry_dirty(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!__test_and_set_bit(segno, sit_i->dirty_sentries_bitmap)) {\n\t\tsit_i->dirty_sentries++;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\tse->type = type;\n\tif (modified)\n\t\t__mark_sit_entry_dirty(sbi, segno);\n}\n\nstatic inline unsigned long long get_segment_mtime(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\t\tblock_t blkaddr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\n\tif (segno == NULL_SEGNO)\n\t\treturn 0;\n\treturn get_seg_entry(sbi, segno)->mtime;\n}\n\nstatic void update_segment_mtime(struct f2fs_sb_info *sbi, block_t blkaddr,\n\t\t\t\t\t\tunsigned long long old_mtime)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno = GET_SEGNO(sbi, blkaddr);\n\tunsigned long long ctime = get_mtime(sbi, false);\n\tunsigned long long mtime = old_mtime ? old_mtime : ctime;\n\n\tif (segno == NULL_SEGNO)\n\t\treturn;\n\n\tse = get_seg_entry(sbi, segno);\n\n\tif (!se->mtime)\n\t\tse->mtime = mtime;\n\telse\n\t\tse->mtime = div_u64(se->mtime * se->valid_blocks + mtime,\n\t\t\t\t\t\tse->valid_blocks + 1);\n\n\tif (ctime > SIT_I(sbi)->max_mtime)\n\t\tSIT_I(sbi)->max_mtime = ctime;\n}\n\nstatic void update_sit_entry(struct f2fs_sb_info *sbi, block_t blkaddr, int del)\n{\n\tstruct seg_entry *se;\n\tunsigned int segno, offset;\n\tlong int new_vblocks;\n\tbool exist;\n#ifdef CONFIG_F2FS_CHECK_FS\n\tbool mir_exist;\n#endif\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\n\tse = get_seg_entry(sbi, segno);\n\tnew_vblocks = se->valid_blocks + del;\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tf2fs_bug_on(sbi, (new_vblocks < 0 ||\n\t\t\t(new_vblocks > f2fs_usable_blks_in_seg(sbi, segno))));\n\n\tse->valid_blocks = new_vblocks;\n\n\t/* Update valid block bitmap */\n\tif (del > 0) {\n\t\texist = f2fs_test_and_set_bit(offset, se->cur_valid_map);\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\tmir_exist = f2fs_test_and_set_bit(offset,\n\t\t\t\t\t\tse->cur_valid_map_mir);\n\t\tif (unlikely(exist != mir_exist)) {\n\t\t\tf2fs_err(sbi, \"Inconsistent error when setting bitmap, blk:%u, old bit:%d\",\n\t\t\t\t blkaddr, exist);\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t}\n#endif\n\t\tif (unlikely(exist)) {\n\t\t\tf2fs_err(sbi, \"Bitmap was wrongly set, blk:%u\",\n\t\t\t\t blkaddr);\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tse->valid_blocks--;\n\t\t\tdel = 0;\n\t\t}\n\n\t\tif (!f2fs_test_and_set_bit(offset, se->discard_map))\n\t\t\tsbi->discard_blks--;\n\n\t\t/*\n\t\t * SSR should never reuse block which is checkpointed\n\t\t * or newly invalidated.\n\t\t */\n\t\tif (!is_sbi_flag_set(sbi, SBI_CP_DISABLED)) {\n\t\t\tif (!f2fs_test_and_set_bit(offset, se->ckpt_valid_map))\n\t\t\t\tse->ckpt_valid_blocks++;\n\t\t}\n\t} else {\n\t\texist = f2fs_test_and_clear_bit(offset, se->cur_valid_map);\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\tmir_exist = f2fs_test_and_clear_bit(offset,\n\t\t\t\t\t\tse->cur_valid_map_mir);\n\t\tif (unlikely(exist != mir_exist)) {\n\t\t\tf2fs_err(sbi, \"Inconsistent error when clearing bitmap, blk:%u, old bit:%d\",\n\t\t\t\t blkaddr, exist);\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t}\n#endif\n\t\tif (unlikely(!exist)) {\n\t\t\tf2fs_err(sbi, \"Bitmap was wrongly cleared, blk:%u\",\n\t\t\t\t blkaddr);\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tse->valid_blocks++;\n\t\t\tdel = 0;\n\t\t} else if (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\t\t/*\n\t\t\t * If checkpoints are off, we must not reuse data that\n\t\t\t * was used in the previous checkpoint. If it was used\n\t\t\t * before, we must track that to know how much space we\n\t\t\t * really have.\n\t\t\t */\n\t\t\tif (f2fs_test_bit(offset, se->ckpt_valid_map)) {\n\t\t\t\tspin_lock(&sbi->stat_lock);\n\t\t\t\tsbi->unusable_block_count++;\n\t\t\t\tspin_unlock(&sbi->stat_lock);\n\t\t\t}\n\t\t}\n\n\t\tif (f2fs_test_and_clear_bit(offset, se->discard_map))\n\t\t\tsbi->discard_blks++;\n\t}\n\tif (!f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tse->ckpt_valid_blocks += del;\n\n\t__mark_sit_entry_dirty(sbi, segno);\n\n\t/* update total number of valid blocks to be written in ckpt area */\n\tSIT_I(sbi)->written_valid_blocks += del;\n\n\tif (__is_large_section(sbi))\n\t\tget_sec_entry(sbi, segno)->valid_blocks += del;\n}\n\nvoid f2fs_invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr)\n{\n\tunsigned int segno = GET_SEGNO(sbi, addr);\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tf2fs_bug_on(sbi, addr == NULL_ADDR);\n\tif (addr == NEW_ADDR || addr == COMPRESS_ADDR)\n\t\treturn;\n\n\tinvalidate_mapping_pages(META_MAPPING(sbi), addr, addr);\n\n\t/* add it into sit main buffer */\n\tdown_write(&sit_i->sentry_lock);\n\n\tupdate_segment_mtime(sbi, addr, 0);\n\tupdate_sit_entry(sbi, addr, -1);\n\n\t/* add it into dirty seglist */\n\tlocate_dirty_segment(sbi, segno);\n\n\tup_write(&sit_i->sentry_lock);\n}\n\nbool f2fs_is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int segno, offset;\n\tstruct seg_entry *se;\n\tbool is_cp = false;\n\n\tif (!__is_valid_data_blkaddr(blkaddr))\n\t\treturn true;\n\n\tdown_read(&sit_i->sentry_lock);\n\n\tsegno = GET_SEGNO(sbi, blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\toffset = GET_BLKOFF_FROM_SEG0(sbi, blkaddr);\n\n\tif (f2fs_test_bit(offset, se->ckpt_valid_map))\n\t\tis_cp = true;\n\n\tup_read(&sit_i->sentry_lock);\n\n\treturn is_cp;\n}\n\n/*\n * This function should be resided under the curseg_mutex lock\n */\nstatic void __add_sum_entry(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tstruct f2fs_summary *sum)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tvoid *addr = curseg->sum_blk;\n\taddr += curseg->next_blkoff * sizeof(struct f2fs_summary);\n\tmemcpy(addr, sum, sizeof(struct f2fs_summary));\n}\n\n/*\n * Calculate the number of current summary pages for writing\n */\nint f2fs_npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra)\n{\n\tint valid_sum_count = 0;\n\tint i, sum_in_page;\n\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tvalid_sum_count += sbi->blocks_per_seg;\n\t\telse {\n\t\t\tif (for_ra)\n\t\t\t\tvalid_sum_count += le16_to_cpu(\n\t\t\t\t\tF2FS_CKPT(sbi)->cur_data_blkoff[i]);\n\t\t\telse\n\t\t\t\tvalid_sum_count += curseg_blkoff(sbi, i);\n\t\t}\n\t}\n\n\tsum_in_page = (PAGE_SIZE - 2 * SUM_JOURNAL_SIZE -\n\t\t\tSUM_FOOTER_SIZE) / SUMMARY_SIZE;\n\tif (valid_sum_count <= sum_in_page)\n\t\treturn 1;\n\telse if ((valid_sum_count - sum_in_page) <=\n\t\t(PAGE_SIZE - SUM_FOOTER_SIZE) / SUMMARY_SIZE)\n\t\treturn 2;\n\treturn 3;\n}\n\n/*\n * Caller should put this summary page\n */\nstruct page *f2fs_get_sum_page(struct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tif (unlikely(f2fs_cp_error(sbi)))\n\t\treturn ERR_PTR(-EIO);\n\treturn f2fs_get_meta_page_retry(sbi, GET_SUM_BLOCK(sbi, segno));\n}\n\nvoid f2fs_update_meta_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tvoid *src, block_t blk_addr)\n{\n\tstruct page *page = f2fs_grab_meta_page(sbi, blk_addr);\n\n\tmemcpy(page_address(page), src, PAGE_SIZE);\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}\n\nstatic void write_sum_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_summary_block *sum_blk, block_t blk_addr)\n{\n\tf2fs_update_meta_page(sbi, (void *)sum_blk, blk_addr);\n}\n\nstatic void write_current_sum_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tint type, block_t blk_addr)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct page *page = f2fs_grab_meta_page(sbi, blk_addr);\n\tstruct f2fs_summary_block *src = curseg->sum_blk;\n\tstruct f2fs_summary_block *dst;\n\n\tdst = (struct f2fs_summary_block *)page_address(page);\n\tmemset(dst, 0, PAGE_SIZE);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\n\tdown_read(&curseg->journal_rwsem);\n\tmemcpy(&dst->journal, curseg->journal, SUM_JOURNAL_SIZE);\n\tup_read(&curseg->journal_rwsem);\n\n\tmemcpy(dst->entries, src->entries, SUM_ENTRY_SIZE);\n\tmemcpy(&dst->footer, &src->footer, SUM_FOOTER_SIZE);\n\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tset_page_dirty(page);\n\tf2fs_put_page(page, 1);\n}\n\nstatic int is_next_segment_free(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *curseg, int type)\n{\n\tunsigned int segno = curseg->segno + 1;\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\n\tif (segno < MAIN_SEGS(sbi) && segno % sbi->segs_per_sec)\n\t\treturn !test_bit(segno, free_i->free_segmap);\n\treturn 0;\n}\n\n/*\n * Find a new segment from the free segments bitmap to right order\n * This function should be returned with success, otherwise BUG\n */\nstatic void get_new_segment(struct f2fs_sb_info *sbi,\n\t\t\tunsigned int *newseg, bool new_sec, int dir)\n{\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno, secno, zoneno;\n\tunsigned int total_zones = MAIN_SECS(sbi) / sbi->secs_per_zone;\n\tunsigned int hint = GET_SEC_FROM_SEG(sbi, *newseg);\n\tunsigned int old_zoneno = GET_ZONE_FROM_SEG(sbi, *newseg);\n\tunsigned int left_start = hint;\n\tbool init = true;\n\tint go_left = 0;\n\tint i;\n\n\tspin_lock(&free_i->segmap_lock);\n\n\tif (!new_sec && ((*newseg + 1) % sbi->segs_per_sec)) {\n\t\tsegno = find_next_zero_bit(free_i->free_segmap,\n\t\t\tGET_SEG_FROM_SEC(sbi, hint + 1), *newseg + 1);\n\t\tif (segno < GET_SEG_FROM_SEC(sbi, hint + 1))\n\t\t\tgoto got_it;\n\t}\nfind_other_zone:\n\tsecno = find_next_zero_bit(free_i->free_secmap, MAIN_SECS(sbi), hint);\n\tif (secno >= MAIN_SECS(sbi)) {\n\t\tif (dir == ALLOC_RIGHT) {\n\t\t\tsecno = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\t\tf2fs_bug_on(sbi, secno >= MAIN_SECS(sbi));\n\t\t} else {\n\t\t\tgo_left = 1;\n\t\t\tleft_start = hint - 1;\n\t\t}\n\t}\n\tif (go_left == 0)\n\t\tgoto skip_left;\n\n\twhile (test_bit(left_start, free_i->free_secmap)) {\n\t\tif (left_start > 0) {\n\t\t\tleft_start--;\n\t\t\tcontinue;\n\t\t}\n\t\tleft_start = find_next_zero_bit(free_i->free_secmap,\n\t\t\t\t\t\t\tMAIN_SECS(sbi), 0);\n\t\tf2fs_bug_on(sbi, left_start >= MAIN_SECS(sbi));\n\t\tbreak;\n\t}\n\tsecno = left_start;\nskip_left:\n\tsegno = GET_SEG_FROM_SEC(sbi, secno);\n\tzoneno = GET_ZONE_FROM_SEC(sbi, secno);\n\n\t/* give up on finding another zone */\n\tif (!init)\n\t\tgoto got_it;\n\tif (sbi->secs_per_zone == 1)\n\t\tgoto got_it;\n\tif (zoneno == old_zoneno)\n\t\tgoto got_it;\n\tif (dir == ALLOC_LEFT) {\n\t\tif (!go_left && zoneno + 1 >= total_zones)\n\t\t\tgoto got_it;\n\t\tif (go_left && zoneno == 0)\n\t\t\tgoto got_it;\n\t}\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++)\n\t\tif (CURSEG_I(sbi, i)->zone == zoneno)\n\t\t\tbreak;\n\n\tif (i < NR_CURSEG_TYPE) {\n\t\t/* zone is in user, try another */\n\t\tif (go_left)\n\t\t\thint = zoneno * sbi->secs_per_zone - 1;\n\t\telse if (zoneno + 1 >= total_zones)\n\t\t\thint = 0;\n\t\telse\n\t\t\thint = (zoneno + 1) * sbi->secs_per_zone;\n\t\tinit = false;\n\t\tgoto find_other_zone;\n\t}\ngot_it:\n\t/* set it as dirty segment in free segmap */\n\tf2fs_bug_on(sbi, test_bit(segno, free_i->free_segmap));\n\t__set_inuse(sbi, segno);\n\t*newseg = segno;\n\tspin_unlock(&free_i->segmap_lock);\n}\n\nstatic void reset_curseg(struct f2fs_sb_info *sbi, int type, int modified)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tstruct summary_footer *sum_footer;\n\tunsigned short seg_type = curseg->seg_type;\n\n\tcurseg->inited = true;\n\tcurseg->segno = curseg->next_segno;\n\tcurseg->zone = GET_ZONE_FROM_SEG(sbi, curseg->segno);\n\tcurseg->next_blkoff = 0;\n\tcurseg->next_segno = NULL_SEGNO;\n\n\tsum_footer = &(curseg->sum_blk->footer);\n\tmemset(sum_footer, 0, sizeof(struct summary_footer));\n\n\tsanity_check_seg_type(sbi, seg_type);\n\n\tif (IS_DATASEG(seg_type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_DATA);\n\tif (IS_NODESEG(seg_type))\n\t\tSET_SUM_TYPE(sum_footer, SUM_TYPE_NODE);\n\t__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);\n}\n\nstatic unsigned int __get_next_segno(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned short seg_type = curseg->seg_type;\n\n\tsanity_check_seg_type(sbi, seg_type);\n\n\t/* if segs_per_sec is large than 1, we need to keep original policy. */\n\tif (__is_large_section(sbi))\n\t\treturn curseg->segno;\n\n\t/* inmem log may not locate on any segment after mount */\n\tif (!curseg->inited)\n\t\treturn 0;\n\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED)))\n\t\treturn 0;\n\n\tif (test_opt(sbi, NOHEAP) &&\n\t\t(seg_type == CURSEG_HOT_DATA || IS_NODESEG(seg_type)))\n\t\treturn 0;\n\n\tif (SIT_I(sbi)->last_victim[ALLOC_NEXT])\n\t\treturn SIT_I(sbi)->last_victim[ALLOC_NEXT];\n\n\t/* find segments from 0 to reuse freed segments */\n\tif (F2FS_OPTION(sbi).alloc_mode == ALLOC_MODE_REUSE)\n\t\treturn 0;\n\n\treturn curseg->segno;\n}\n\n/*\n * Allocate a current working segment.\n * This function always allocates a free segment in LFS manner.\n */\nstatic void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned short seg_type = curseg->seg_type;\n\tunsigned int segno = curseg->segno;\n\tint dir = ALLOC_LEFT;\n\n\tif (curseg->inited)\n\t\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\tif (seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;\n\n\tif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;\n\n\tsegno = __get_next_segno(sbi, type);\n\tget_new_segment(sbi, &segno, new_sec, dir);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = LFS;\n}\n\nstatic void __next_free_blkoff(struct f2fs_sb_info *sbi,\n\t\t\tstruct curseg_info *seg, block_t start)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, seg->segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, start);\n\n\tseg->next_blkoff = pos;\n}\n\n/*\n * If a segment is written by LFS manner, next block offset is just obtained\n * by increasing the current block offset. However, if a segment is written by\n * SSR manner, next block offset obtained by calling __next_free_blkoff\n */\nstatic void __refresh_next_blkoff(struct f2fs_sb_info *sbi,\n\t\t\t\tstruct curseg_info *seg)\n{\n\tif (seg->alloc_type == SSR)\n\t\t__next_free_blkoff(sbi, seg, seg->next_blkoff + 1);\n\telse\n\t\tseg->next_blkoff++;\n}\n\nbool segment_has_free_slot(struct f2fs_sb_info *sbi, int segno)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\tint entries = SIT_VBLOCK_MAP_SIZE / sizeof(unsigned long);\n\tunsigned long *target_map = SIT_I(sbi)->tmp_map;\n\tunsigned long *ckpt_map = (unsigned long *)se->ckpt_valid_map;\n\tunsigned long *cur_map = (unsigned long *)se->cur_valid_map;\n\tint i, pos;\n\n\tfor (i = 0; i < entries; i++)\n\t\ttarget_map[i] = ckpt_map[i] | cur_map[i];\n\n\tpos = __find_rev_next_zero_bit(target_map, sbi->blocks_per_seg, 0);\n\n\treturn pos < sbi->blocks_per_seg;\n}\n\n/*\n * This function always allocates a used segment(from dirty seglist) by SSR\n * manner, so it should recover the existing segment information of valid blocks\n */\nstatic void change_curseg(struct f2fs_sb_info *sbi, int type, bool flush)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int new_segno = curseg->next_segno;\n\tstruct f2fs_summary_block *sum_node;\n\tstruct page *sum_page;\n\n\tif (flush)\n\t\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\n\t__set_test_and_inuse(sbi, new_segno);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\t__remove_dirty_segment(sbi, new_segno, PRE);\n\t__remove_dirty_segment(sbi, new_segno, DIRTY);\n\tmutex_unlock(&dirty_i->seglist_lock);\n\n\treset_curseg(sbi, type, 1);\n\tcurseg->alloc_type = SSR;\n\t__next_free_blkoff(sbi, curseg, 0);\n\n\tsum_page = f2fs_get_sum_page(sbi, new_segno);\n\tif (IS_ERR(sum_page)) {\n\t\t/* GC won't be able to use stale summary pages by cp_error */\n\t\tmemset(curseg->sum_blk, 0, SUM_ENTRY_SIZE);\n\t\treturn;\n\t}\n\tsum_node = (struct f2fs_summary_block *)page_address(sum_page);\n\tmemcpy(curseg->sum_blk, sum_node, SUM_ENTRY_SIZE);\n\tf2fs_put_page(sum_page, 1);\n}\n\nstatic int get_ssr_segment(struct f2fs_sb_info *sbi, int type,\n\t\t\t\tint alloc_mode, unsigned long long age);\n\nstatic void get_atssr_segment(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tint target_type, int alloc_mode,\n\t\t\t\t\tunsigned long long age)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\tcurseg->seg_type = target_type;\n\n\tif (get_ssr_segment(sbi, type, alloc_mode, age)) {\n\t\tstruct seg_entry *se = get_seg_entry(sbi, curseg->next_segno);\n\n\t\tcurseg->seg_type = se->type;\n\t\tchange_curseg(sbi, type, true);\n\t} else {\n\t\t/* allocate cold segment by default */\n\t\tcurseg->seg_type = CURSEG_COLD_DATA;\n\t\tnew_curseg(sbi, type, true);\n\t}\n\tstat_inc_seg_type(sbi, curseg);\n}\n\nstatic void __f2fs_init_atgc_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_ALL_DATA_ATGC);\n\n\tif (!sbi->am.atgc_enabled)\n\t\treturn;\n\n\tdown_read(&SM_I(sbi)->curseg_lock);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tdown_write(&SIT_I(sbi)->sentry_lock);\n\n\tget_atssr_segment(sbi, CURSEG_ALL_DATA_ATGC, CURSEG_COLD_DATA, SSR, 0);\n\n\tup_write(&SIT_I(sbi)->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tup_read(&SM_I(sbi)->curseg_lock);\n\n}\nvoid f2fs_init_inmem_curseg(struct f2fs_sb_info *sbi)\n{\n\t__f2fs_init_atgc_curseg(sbi);\n}\n\nstatic void __f2fs_save_inmem_curseg(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tif (!curseg->inited)\n\t\tgoto out;\n\n\tif (get_valid_blocks(sbi, curseg->segno, false)) {\n\t\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, curseg->segno));\n\t} else {\n\t\tmutex_lock(&DIRTY_I(sbi)->seglist_lock);\n\t\t__set_test_and_free(sbi, curseg->segno, true);\n\t\tmutex_unlock(&DIRTY_I(sbi)->seglist_lock);\n\t}\nout:\n\tmutex_unlock(&curseg->curseg_mutex);\n}\n\nvoid f2fs_save_inmem_curseg(struct f2fs_sb_info *sbi)\n{\n\t__f2fs_save_inmem_curseg(sbi, CURSEG_COLD_DATA_PINNED);\n\n\tif (sbi->am.atgc_enabled)\n\t\t__f2fs_save_inmem_curseg(sbi, CURSEG_ALL_DATA_ATGC);\n}\n\nstatic void __f2fs_restore_inmem_curseg(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tif (!curseg->inited)\n\t\tgoto out;\n\tif (get_valid_blocks(sbi, curseg->segno, false))\n\t\tgoto out;\n\n\tmutex_lock(&DIRTY_I(sbi)->seglist_lock);\n\t__set_test_and_inuse(sbi, curseg->segno);\n\tmutex_unlock(&DIRTY_I(sbi)->seglist_lock);\nout:\n\tmutex_unlock(&curseg->curseg_mutex);\n}\n\nvoid f2fs_restore_inmem_curseg(struct f2fs_sb_info *sbi)\n{\n\t__f2fs_restore_inmem_curseg(sbi, CURSEG_COLD_DATA_PINNED);\n\n\tif (sbi->am.atgc_enabled)\n\t\t__f2fs_restore_inmem_curseg(sbi, CURSEG_ALL_DATA_ATGC);\n}\n\nstatic int get_ssr_segment(struct f2fs_sb_info *sbi, int type,\n\t\t\t\tint alloc_mode, unsigned long long age)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tconst struct victim_selection *v_ops = DIRTY_I(sbi)->v_ops;\n\tunsigned segno = NULL_SEGNO;\n\tunsigned short seg_type = curseg->seg_type;\n\tint i, cnt;\n\tbool reversed = false;\n\n\tsanity_check_seg_type(sbi, seg_type);\n\n\t/* f2fs_need_SSR() already forces to do this */\n\tif (!v_ops->get_victim(sbi, &segno, BG_GC, seg_type, alloc_mode, age)) {\n\t\tcurseg->next_segno = segno;\n\t\treturn 1;\n\t}\n\n\t/* For node segments, let's do SSR more intensively */\n\tif (IS_NODESEG(seg_type)) {\n\t\tif (seg_type >= CURSEG_WARM_NODE) {\n\t\t\treversed = true;\n\t\t\ti = CURSEG_COLD_NODE;\n\t\t} else {\n\t\t\ti = CURSEG_HOT_NODE;\n\t\t}\n\t\tcnt = NR_CURSEG_NODE_TYPE;\n\t} else {\n\t\tif (seg_type >= CURSEG_WARM_DATA) {\n\t\t\treversed = true;\n\t\t\ti = CURSEG_COLD_DATA;\n\t\t} else {\n\t\t\ti = CURSEG_HOT_DATA;\n\t\t}\n\t\tcnt = NR_CURSEG_DATA_TYPE;\n\t}\n\n\tfor (; cnt-- > 0; reversed ? i-- : i++) {\n\t\tif (i == seg_type)\n\t\t\tcontinue;\n\t\tif (!v_ops->get_victim(sbi, &segno, BG_GC, i, alloc_mode, age)) {\n\t\t\tcurseg->next_segno = segno;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* find valid_blocks=0 in dirty list */\n\tif (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {\n\t\tsegno = get_free_segment(sbi);\n\t\tif (segno != NULL_SEGNO) {\n\t\t\tcurseg->next_segno = segno;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * flush out current segment and replace it with new segment\n * This function should be returned with success, otherwise BUG\n */\nstatic void allocate_segment_by_default(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tint type, bool force)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\tif (force)\n\t\tnew_curseg(sbi, type, true);\n\telse if (!is_set_ckpt_flags(sbi, CP_CRC_RECOVERY_FLAG) &&\n\t\t\t\t\tcurseg->seg_type == CURSEG_WARM_NODE)\n\t\tnew_curseg(sbi, type, false);\n\telse if (curseg->alloc_type == LFS &&\n\t\t\tis_next_segment_free(sbi, curseg, type) &&\n\t\t\tlikely(!is_sbi_flag_set(sbi, SBI_CP_DISABLED)))\n\t\tnew_curseg(sbi, type, false);\n\telse if (f2fs_need_SSR(sbi) &&\n\t\t\tget_ssr_segment(sbi, type, SSR, 0))\n\t\tchange_curseg(sbi, type, true);\n\telse\n\t\tnew_curseg(sbi, type, false);\n\n\tstat_inc_seg_type(sbi, curseg);\n}\n\nvoid f2fs_allocate_segment_for_resize(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int start, unsigned int end)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int segno;\n\n\tdown_read(&SM_I(sbi)->curseg_lock);\n\tmutex_lock(&curseg->curseg_mutex);\n\tdown_write(&SIT_I(sbi)->sentry_lock);\n\n\tsegno = CURSEG_I(sbi, type)->segno;\n\tif (segno < start || segno > end)\n\t\tgoto unlock;\n\n\tif (f2fs_need_SSR(sbi) && get_ssr_segment(sbi, type, SSR, 0))\n\t\tchange_curseg(sbi, type, true);\n\telse\n\t\tnew_curseg(sbi, type, true);\n\n\tstat_inc_seg_type(sbi, curseg);\n\n\tlocate_dirty_segment(sbi, segno);\nunlock:\n\tup_write(&SIT_I(sbi)->sentry_lock);\n\n\tif (segno != curseg->segno)\n\t\tf2fs_notice(sbi, \"For resize: curseg of type %d: %u ==> %u\",\n\t\t\t    type, segno, curseg->segno);\n\n\tmutex_unlock(&curseg->curseg_mutex);\n\tup_read(&SM_I(sbi)->curseg_lock);\n}\n\nstatic void __allocate_new_segment(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\t\t\t\tbool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\tif (!curseg->inited)\n\t\tgoto alloc;\n\n\tif (curseg->next_blkoff ||\n\t\tget_valid_blocks(sbi, curseg->segno, new_sec))\n\t\tgoto alloc;\n\n\tif (!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec))\n\t\treturn;\nalloc:\n\told_segno = curseg->segno;\n\tSIT_I(sbi)->s_ops->allocate_segment(sbi, type, true);\n\tlocate_dirty_segment(sbi, old_segno);\n}\n\nstatic void __allocate_new_section(struct f2fs_sb_info *sbi, int type)\n{\n\t__allocate_new_segment(sbi, type, true);\n}\n\nvoid f2fs_allocate_new_section(struct f2fs_sb_info *sbi, int type)\n{\n\tdown_write(&SIT_I(sbi)->sentry_lock);\n\t__allocate_new_section(sbi, type);\n\tup_write(&SIT_I(sbi)->sentry_lock);\n}\n\nvoid f2fs_allocate_new_segments(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\tdown_write(&SIT_I(sbi)->sentry_lock);\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++)\n\t\t__allocate_new_segment(sbi, i, false);\n\tup_write(&SIT_I(sbi)->sentry_lock);\n}\n\nstatic const struct segment_allocation default_salloc_ops = {\n\t.allocate_segment = allocate_segment_by_default,\n};\n\nbool f2fs_exist_trim_candidates(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tstruct cp_control *cpc)\n{\n\t__u64 trim_start = cpc->trim_start;\n\tbool has_candidate = false;\n\n\tdown_write(&SIT_I(sbi)->sentry_lock);\n\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++) {\n\t\tif (add_discard_addrs(sbi, cpc, true)) {\n\t\t\thas_candidate = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tup_write(&SIT_I(sbi)->sentry_lock);\n\n\tcpc->trim_start = trim_start;\n\treturn has_candidate;\n}\n\nstatic unsigned int __issue_discard_cmd_range(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct discard_policy *dpolicy,\n\t\t\t\t\tunsigned int start, unsigned int end)\n{\n\tstruct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;\n\tstruct discard_cmd *prev_dc = NULL, *next_dc = NULL;\n\tstruct rb_node **insert_p = NULL, *insert_parent = NULL;\n\tstruct discard_cmd *dc;\n\tstruct blk_plug plug;\n\tint issued;\n\tunsigned int trimmed = 0;\n\nnext:\n\tissued = 0;\n\n\tmutex_lock(&dcc->cmd_lock);\n\tif (unlikely(dcc->rbtree_check))\n\t\tf2fs_bug_on(sbi, !f2fs_check_rb_tree_consistence(sbi,\n\t\t\t\t\t\t\t&dcc->root, false));\n\n\tdc = (struct discard_cmd *)f2fs_lookup_rb_tree_ret(&dcc->root,\n\t\t\t\t\tNULL, start,\n\t\t\t\t\t(struct rb_entry **)&prev_dc,\n\t\t\t\t\t(struct rb_entry **)&next_dc,\n\t\t\t\t\t&insert_p, &insert_parent, true, NULL);\n\tif (!dc)\n\t\tdc = next_dc;\n\n\tblk_start_plug(&plug);\n\n\twhile (dc && dc->lstart <= end) {\n\t\tstruct rb_node *node;\n\t\tint err = 0;\n\n\t\tif (dc->len < dpolicy->granularity)\n\t\t\tgoto skip;\n\n\t\tif (dc->state != D_PREP) {\n\t\t\tlist_move_tail(&dc->list, &dcc->fstrim_list);\n\t\t\tgoto skip;\n\t\t}\n\n\t\terr = __submit_discard_cmd(sbi, dpolicy, dc, &issued);\n\n\t\tif (issued >= dpolicy->max_requests) {\n\t\t\tstart = dc->lstart + dc->len;\n\n\t\t\tif (err)\n\t\t\t\t__remove_discard_cmd(sbi, dc);\n\n\t\t\tblk_finish_plug(&plug);\n\t\t\tmutex_unlock(&dcc->cmd_lock);\n\t\t\ttrimmed += __wait_all_discard_cmd(sbi, NULL);\n\t\t\tcongestion_wait(BLK_RW_ASYNC, DEFAULT_IO_TIMEOUT);\n\t\t\tgoto next;\n\t\t}\nskip:\n\t\tnode = rb_next(&dc->rb_node);\n\t\tif (err)\n\t\t\t__remove_discard_cmd(sbi, dc);\n\t\tdc = rb_entry_safe(node, struct discard_cmd, rb_node);\n\n\t\tif (fatal_signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\tblk_finish_plug(&plug);\n\tmutex_unlock(&dcc->cmd_lock);\n\n\treturn trimmed;\n}\n\nint f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tblock_t start_block, end_block;\n\tstruct cp_control cpc;\n\tstruct discard_policy dpolicy;\n\tunsigned long long trimmed = 0;\n\tint err = 0;\n\tbool need_align = f2fs_lfs_mode(sbi) && __is_large_section(sbi);\n\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\n\tif (end < MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_warn(sbi, \"Found FS corruption, run fsck to fix.\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tif (need_align) {\n\t\tstart_segno = rounddown(start_segno, sbi->segs_per_sec);\n\t\tend_segno = roundup(end_segno + 1, sbi->segs_per_sec) - 1;\n\t}\n\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\tcpc.trim_start = start_segno;\n\tcpc.trim_end = end_segno;\n\n\tif (sbi->discard_blks == 0)\n\t\tgoto out;\n\n\tdown_write(&sbi->gc_lock);\n\terr = f2fs_write_checkpoint(sbi, &cpc);\n\tup_write(&sbi->gc_lock);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * We filed discard candidates, but actually we don't need to wait for\n\t * all of them, since they'll be issued in idle time along with runtime\n\t * discard option. User configuration looks like using runtime discard\n\t * or periodic fstrim instead of it.\n\t */\n\tif (f2fs_realtime_discard_enable(sbi))\n\t\tgoto out;\n\n\tstart_block = START_BLOCK(sbi, start_segno);\n\tend_block = START_BLOCK(sbi, end_segno + 1);\n\n\t__init_discard_policy(sbi, &dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);\n\ttrimmed = __issue_discard_cmd_range(sbi, &dpolicy,\n\t\t\t\t\tstart_block, end_block);\n\n\ttrimmed += __wait_discard_cmd_range(sbi, &dpolicy,\n\t\t\t\t\tstart_block, end_block);\nout:\n\tif (!err)\n\t\trange->len = F2FS_BLK_TO_BYTES(trimmed);\n\treturn err;\n}\n\nstatic bool __has_curseg_space(struct f2fs_sb_info *sbi,\n\t\t\t\t\tstruct curseg_info *curseg)\n{\n\treturn curseg->next_blkoff < f2fs_usable_blks_in_seg(sbi,\n\t\t\t\t\t\t\tcurseg->segno);\n}\n\nint f2fs_rw_hint_to_seg_type(enum rw_hint hint)\n{\n\tswitch (hint) {\n\tcase WRITE_LIFE_SHORT:\n\t\treturn CURSEG_HOT_DATA;\n\tcase WRITE_LIFE_EXTREME:\n\t\treturn CURSEG_COLD_DATA;\n\tdefault:\n\t\treturn CURSEG_WARM_DATA;\n\t}\n}\n\n/* This returns write hints for each segment type. This hints will be\n * passed down to block layer. There are mapping tables which depend on\n * the mount option 'whint_mode'.\n *\n * 1) whint_mode=off. F2FS only passes down WRITE_LIFE_NOT_SET.\n *\n * 2) whint_mode=user-based. F2FS tries to pass down hints given by users.\n *\n * User                  F2FS                     Block\n * ----                  ----                     -----\n *                       META                     WRITE_LIFE_NOT_SET\n *                       HOT_NODE                 \"\n *                       WARM_NODE                \"\n *                       COLD_NODE                \"\n * ioctl(COLD)           COLD_DATA                WRITE_LIFE_EXTREME\n * extension list        \"                        \"\n *\n * -- buffered io\n * WRITE_LIFE_EXTREME    COLD_DATA                WRITE_LIFE_EXTREME\n * WRITE_LIFE_SHORT      HOT_DATA                 WRITE_LIFE_SHORT\n * WRITE_LIFE_NOT_SET    WARM_DATA                WRITE_LIFE_NOT_SET\n * WRITE_LIFE_NONE       \"                        \"\n * WRITE_LIFE_MEDIUM     \"                        \"\n * WRITE_LIFE_LONG       \"                        \"\n *\n * -- direct io\n * WRITE_LIFE_EXTREME    COLD_DATA                WRITE_LIFE_EXTREME\n * WRITE_LIFE_SHORT      HOT_DATA                 WRITE_LIFE_SHORT\n * WRITE_LIFE_NOT_SET    WARM_DATA                WRITE_LIFE_NOT_SET\n * WRITE_LIFE_NONE       \"                        WRITE_LIFE_NONE\n * WRITE_LIFE_MEDIUM     \"                        WRITE_LIFE_MEDIUM\n * WRITE_LIFE_LONG       \"                        WRITE_LIFE_LONG\n *\n * 3) whint_mode=fs-based. F2FS passes down hints with its policy.\n *\n * User                  F2FS                     Block\n * ----                  ----                     -----\n *                       META                     WRITE_LIFE_MEDIUM;\n *                       HOT_NODE                 WRITE_LIFE_NOT_SET\n *                       WARM_NODE                \"\n *                       COLD_NODE                WRITE_LIFE_NONE\n * ioctl(COLD)           COLD_DATA                WRITE_LIFE_EXTREME\n * extension list        \"                        \"\n *\n * -- buffered io\n * WRITE_LIFE_EXTREME    COLD_DATA                WRITE_LIFE_EXTREME\n * WRITE_LIFE_SHORT      HOT_DATA                 WRITE_LIFE_SHORT\n * WRITE_LIFE_NOT_SET    WARM_DATA                WRITE_LIFE_LONG\n * WRITE_LIFE_NONE       \"                        \"\n * WRITE_LIFE_MEDIUM     \"                        \"\n * WRITE_LIFE_LONG       \"                        \"\n *\n * -- direct io\n * WRITE_LIFE_EXTREME    COLD_DATA                WRITE_LIFE_EXTREME\n * WRITE_LIFE_SHORT      HOT_DATA                 WRITE_LIFE_SHORT\n * WRITE_LIFE_NOT_SET    WARM_DATA                WRITE_LIFE_NOT_SET\n * WRITE_LIFE_NONE       \"                        WRITE_LIFE_NONE\n * WRITE_LIFE_MEDIUM     \"                        WRITE_LIFE_MEDIUM\n * WRITE_LIFE_LONG       \"                        WRITE_LIFE_LONG\n */\n\nenum rw_hint f2fs_io_type_to_rw_hint(struct f2fs_sb_info *sbi,\n\t\t\t\tenum page_type type, enum temp_type temp)\n{\n\tif (F2FS_OPTION(sbi).whint_mode == WHINT_MODE_USER) {\n\t\tif (type == DATA) {\n\t\t\tif (temp == WARM)\n\t\t\t\treturn WRITE_LIFE_NOT_SET;\n\t\t\telse if (temp == HOT)\n\t\t\t\treturn WRITE_LIFE_SHORT;\n\t\t\telse if (temp == COLD)\n\t\t\t\treturn WRITE_LIFE_EXTREME;\n\t\t} else {\n\t\t\treturn WRITE_LIFE_NOT_SET;\n\t\t}\n\t} else if (F2FS_OPTION(sbi).whint_mode == WHINT_MODE_FS) {\n\t\tif (type == DATA) {\n\t\t\tif (temp == WARM)\n\t\t\t\treturn WRITE_LIFE_LONG;\n\t\t\telse if (temp == HOT)\n\t\t\t\treturn WRITE_LIFE_SHORT;\n\t\t\telse if (temp == COLD)\n\t\t\t\treturn WRITE_LIFE_EXTREME;\n\t\t} else if (type == NODE) {\n\t\t\tif (temp == WARM || temp == HOT)\n\t\t\t\treturn WRITE_LIFE_NOT_SET;\n\t\t\telse if (temp == COLD)\n\t\t\t\treturn WRITE_LIFE_NONE;\n\t\t} else if (type == META) {\n\t\t\treturn WRITE_LIFE_MEDIUM;\n\t\t}\n\t}\n\treturn WRITE_LIFE_NOT_SET;\n}\n\nstatic int __get_segment_type_2(struct f2fs_io_info *fio)\n{\n\tif (fio->type == DATA)\n\t\treturn CURSEG_HOT_DATA;\n\telse\n\t\treturn CURSEG_HOT_NODE;\n}\n\nstatic int __get_segment_type_4(struct f2fs_io_info *fio)\n{\n\tif (fio->type == DATA) {\n\t\tstruct inode *inode = fio->page->mapping->host;\n\n\t\tif (S_ISDIR(inode->i_mode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\telse\n\t\t\treturn CURSEG_COLD_DATA;\n\t} else {\n\t\tif (IS_DNODE(fio->page) && is_cold_node(fio->page))\n\t\t\treturn CURSEG_WARM_NODE;\n\t\telse\n\t\t\treturn CURSEG_COLD_NODE;\n\t}\n}\n\nstatic int __get_segment_type_6(struct f2fs_io_info *fio)\n{\n\tif (fio->type == DATA) {\n\t\tstruct inode *inode = fio->page->mapping->host;\n\n\t\tif (is_cold_data(fio->page)) {\n\t\t\tif (fio->sbi->am.atgc_enabled &&\n\t\t\t\t(fio->io_type == FS_DATA_IO) &&\n\t\t\t\t(fio->sbi->gc_mode != GC_URGENT_HIGH))\n\t\t\t\treturn CURSEG_ALL_DATA_ATGC;\n\t\t\telse\n\t\t\t\treturn CURSEG_COLD_DATA;\n\t\t}\n\t\tif (file_is_cold(inode) || f2fs_need_compress_data(inode))\n\t\t\treturn CURSEG_COLD_DATA;\n\t\tif (file_is_hot(inode) ||\n\t\t\t\tis_inode_flag_set(inode, FI_HOT_DATA) ||\n\t\t\t\tf2fs_is_atomic_file(inode) ||\n\t\t\t\tf2fs_is_volatile_file(inode))\n\t\t\treturn CURSEG_HOT_DATA;\n\t\treturn f2fs_rw_hint_to_seg_type(inode->i_write_hint);\n\t} else {\n\t\tif (IS_DNODE(fio->page))\n\t\t\treturn is_cold_node(fio->page) ? CURSEG_WARM_NODE :\n\t\t\t\t\t\tCURSEG_HOT_NODE;\n\t\treturn CURSEG_COLD_NODE;\n\t}\n}\n\nstatic int __get_segment_type(struct f2fs_io_info *fio)\n{\n\tint type = 0;\n\n\tswitch (F2FS_OPTION(fio->sbi).active_logs) {\n\tcase 2:\n\t\ttype = __get_segment_type_2(fio);\n\t\tbreak;\n\tcase 4:\n\t\ttype = __get_segment_type_4(fio);\n\t\tbreak;\n\tcase 6:\n\t\ttype = __get_segment_type_6(fio);\n\t\tbreak;\n\tdefault:\n\t\tf2fs_bug_on(fio->sbi, true);\n\t}\n\n\tif (IS_HOT(type))\n\t\tfio->temp = HOT;\n\telse if (IS_WARM(type))\n\t\tfio->temp = WARM;\n\telse\n\t\tfio->temp = COLD;\n\treturn type;\n}\n\nvoid f2fs_allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type,\n\t\tstruct f2fs_io_info *fio)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned long long old_mtime;\n\tbool from_gc = (type == CURSEG_ALL_DATA_ATGC);\n\tstruct seg_entry *se = NULL;\n\n\tdown_read(&SM_I(sbi)->curseg_lock);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tdown_write(&sit_i->sentry_lock);\n\n\tif (from_gc) {\n\t\tf2fs_bug_on(sbi, GET_SEGNO(sbi, old_blkaddr) == NULL_SEGNO);\n\t\tse = get_seg_entry(sbi, GET_SEGNO(sbi, old_blkaddr));\n\t\tsanity_check_seg_type(sbi, se->type);\n\t\tf2fs_bug_on(sbi, IS_NODESEG(se->type));\n\t}\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\tf2fs_bug_on(sbi, curseg->next_blkoff >= sbi->blocks_per_seg);\n\n\tf2fs_wait_discard_bio(sbi, *new_blkaddr);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (from_gc) {\n\t\told_mtime = get_segment_mtime(sbi, old_blkaddr);\n\t} else {\n\t\tupdate_segment_mtime(sbi, old_blkaddr, 0);\n\t\told_mtime = 0;\n\t}\n\tupdate_segment_mtime(sbi, *new_blkaddr, old_mtime);\n\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\tupdate_sit_entry(sbi, *new_blkaddr, 1);\n\tif (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old_blkaddr, -1);\n\n\tif (!__has_curseg_space(sbi, curseg)) {\n\t\tif (from_gc)\n\t\t\tget_atssr_segment(sbi, type, se->type,\n\t\t\t\t\t\tAT_SSR, se->mtime);\n\t\telse\n\t\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\t}\n\t/*\n\t * segment dirty status should be updated after segment allocation,\n\t * so we just need to update status only one time after previous\n\t * segment being closed.\n\t */\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr));\n\n\tup_write(&sit_i->sentry_lock);\n\n\tif (page && IS_NODESEG(type)) {\n\t\tfill_node_footer_blkaddr(page, NEXT_FREE_BLKADDR(sbi, curseg));\n\n\t\tf2fs_inode_chksum_set(sbi, page);\n\t}\n\n\tif (F2FS_IO_ALIGNED(sbi))\n\t\tfio->retry = false;\n\n\tif (fio) {\n\t\tstruct f2fs_bio_info *io;\n\n\t\tINIT_LIST_HEAD(&fio->list);\n\t\tfio->in_list = true;\n\t\tio = sbi->write_io[fio->type] + fio->temp;\n\t\tspin_lock(&io->io_lock);\n\t\tlist_add_tail(&fio->list, &io->io_list);\n\t\tspin_unlock(&io->io_lock);\n\t}\n\n\tmutex_unlock(&curseg->curseg_mutex);\n\n\tup_read(&SM_I(sbi)->curseg_lock);\n}\n\nstatic void update_device_state(struct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tunsigned int devidx;\n\n\tif (!f2fs_is_multi_device(sbi))\n\t\treturn;\n\n\tdevidx = f2fs_target_device_index(sbi, fio->new_blkaddr);\n\n\t/* update device state for fsync */\n\tf2fs_set_dirty_device(sbi, fio->ino, devidx, FLUSH_INO);\n\n\t/* update device state for checkpoint */\n\tif (!f2fs_test_bit(devidx, (char *)&sbi->dirty_device)) {\n\t\tspin_lock(&sbi->dev_lock);\n\t\tf2fs_set_bit(devidx, (char *)&sbi->dirty_device);\n\t\tspin_unlock(&sbi->dev_lock);\n\t}\n}\n\nstatic void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(fio);\n\tbool keep_order = (f2fs_lfs_mode(fio->sbi) && type == CURSEG_COLD_DATA);\n\n\tif (keep_order)\n\t\tdown_read(&fio->sbi->io_order_lock);\nreallocate:\n\tf2fs_allocate_data_block(fio->sbi, fio->page, fio->old_blkaddr,\n\t\t\t&fio->new_blkaddr, sum, type, fio);\n\tif (GET_SEGNO(fio->sbi, fio->old_blkaddr) != NULL_SEGNO)\n\t\tinvalidate_mapping_pages(META_MAPPING(fio->sbi),\n\t\t\t\t\tfio->old_blkaddr, fio->old_blkaddr);\n\n\t/* writeout dirty page into bdev */\n\tf2fs_submit_page_write(fio);\n\tif (fio->retry) {\n\t\tfio->old_blkaddr = fio->new_blkaddr;\n\t\tgoto reallocate;\n\t}\n\n\tupdate_device_state(fio);\n\n\tif (keep_order)\n\t\tup_read(&fio->sbi->io_order_lock);\n}\n\nvoid f2fs_do_write_meta_page(struct f2fs_sb_info *sbi, struct page *page,\n\t\t\t\t\tenum iostat_type io_type)\n{\n\tstruct f2fs_io_info fio = {\n\t\t.sbi = sbi,\n\t\t.type = META,\n\t\t.temp = HOT,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = REQ_SYNC | REQ_META | REQ_PRIO,\n\t\t.old_blkaddr = page->index,\n\t\t.new_blkaddr = page->index,\n\t\t.page = page,\n\t\t.encrypted_page = NULL,\n\t\t.in_list = false,\n\t};\n\n\tif (unlikely(page->index >= MAIN_BLKADDR(sbi)))\n\t\tfio.op_flags &= ~REQ_META;\n\n\tset_page_writeback(page);\n\tClearPageError(page);\n\tf2fs_submit_page_write(&fio);\n\n\tstat_inc_meta_count(sbi, page->index);\n\tf2fs_update_iostat(sbi, io_type, F2FS_BLKSIZE);\n}\n\nvoid f2fs_do_write_node_page(unsigned int nid, struct f2fs_io_info *fio)\n{\n\tstruct f2fs_summary sum;\n\n\tset_summary(&sum, nid, 0, 0);\n\tdo_write_page(&sum, fio);\n\n\tf2fs_update_iostat(fio->sbi, fio->io_type, F2FS_BLKSIZE);\n}\n\nvoid f2fs_outplace_write_data(struct dnode_of_data *dn,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tstruct f2fs_summary sum;\n\n\tf2fs_bug_on(sbi, dn->data_blkaddr == NULL_ADDR);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, fio->version);\n\tdo_write_page(&sum, fio);\n\tf2fs_update_data_blkaddr(dn, fio->new_blkaddr);\n\n\tf2fs_update_iostat(sbi, fio->io_type, F2FS_BLKSIZE);\n}\n\nint f2fs_inplace_write_data(struct f2fs_io_info *fio)\n{\n\tint err;\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tunsigned int segno;\n\n\tfio->new_blkaddr = fio->old_blkaddr;\n\t/* i/o temperature is needed for passing down write hints */\n\t__get_segment_type(fio);\n\n\tsegno = GET_SEGNO(sbi, fio->new_blkaddr);\n\n\tif (!IS_DATASEG(get_seg_entry(sbi, segno)->type)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, \"%s: incorrect segment(%u) type, run fsck to fix.\",\n\t\t\t  __func__, segno);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tstat_inc_inplace_blocks(fio->sbi);\n\n\tif (fio->bio && !(SM_I(sbi)->ipu_policy & (1 << F2FS_IPU_NOCACHE)))\n\t\terr = f2fs_merge_page_bio(fio);\n\telse\n\t\terr = f2fs_submit_page_bio(fio);\n\tif (!err) {\n\t\tupdate_device_state(fio);\n\t\tf2fs_update_iostat(fio->sbi, fio->io_type, F2FS_BLKSIZE);\n\t}\n\n\treturn err;\n}\n\nstatic inline int __f2fs_get_curseg(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\tunsigned int segno)\n{\n\tint i;\n\n\tfor (i = CURSEG_HOT_DATA; i < NO_CHECK_TYPE; i++) {\n\t\tif (CURSEG_I(sbi, i)->segno == segno)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nvoid f2fs_do_replace_block(struct f2fs_sb_info *sbi, struct f2fs_summary *sum,\n\t\t\t\tblock_t old_blkaddr, block_t new_blkaddr,\n\t\t\t\tbool recover_curseg, bool recover_newaddr,\n\t\t\t\tbool from_gc)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg;\n\tunsigned int segno, old_cursegno;\n\tstruct seg_entry *se;\n\tint type;\n\tunsigned short old_blkoff;\n\n\tsegno = GET_SEGNO(sbi, new_blkaddr);\n\tse = get_seg_entry(sbi, segno);\n\ttype = se->type;\n\n\tdown_write(&SM_I(sbi)->curseg_lock);\n\n\tif (!recover_curseg) {\n\t\t/* for recovery flow */\n\t\tif (se->valid_blocks == 0 && !IS_CURSEG(sbi, segno)) {\n\t\t\tif (old_blkaddr == NULL_ADDR)\n\t\t\t\ttype = CURSEG_COLD_DATA;\n\t\t\telse\n\t\t\t\ttype = CURSEG_WARM_DATA;\n\t\t}\n\t} else {\n\t\tif (IS_CURSEG(sbi, segno)) {\n\t\t\t/* se->type is volatile as SSR allocation */\n\t\t\ttype = __f2fs_get_curseg(sbi, segno);\n\t\t\tf2fs_bug_on(sbi, type == NO_CHECK_TYPE);\n\t\t} else {\n\t\t\ttype = CURSEG_WARM_DATA;\n\t\t}\n\t}\n\n\tf2fs_bug_on(sbi, !IS_DATASEG(type));\n\tcurseg = CURSEG_I(sbi, type);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tdown_write(&sit_i->sentry_lock);\n\n\told_cursegno = curseg->segno;\n\told_blkoff = curseg->next_blkoff;\n\n\t/* change the current segment */\n\tif (segno != curseg->segno) {\n\t\tcurseg->next_segno = segno;\n\t\tchange_curseg(sbi, type, true);\n\t}\n\n\tcurseg->next_blkoff = GET_BLKOFF_FROM_SEG0(sbi, new_blkaddr);\n\t__add_sum_entry(sbi, type, sum);\n\n\tif (!recover_curseg || recover_newaddr) {\n\t\tif (!from_gc)\n\t\t\tupdate_segment_mtime(sbi, new_blkaddr, 0);\n\t\tupdate_sit_entry(sbi, new_blkaddr, 1);\n\t}\n\tif (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO) {\n\t\tinvalidate_mapping_pages(META_MAPPING(sbi),\n\t\t\t\t\told_blkaddr, old_blkaddr);\n\t\tif (!from_gc)\n\t\t\tupdate_segment_mtime(sbi, old_blkaddr, 0);\n\t\tupdate_sit_entry(sbi, old_blkaddr, -1);\n\t}\n\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, new_blkaddr));\n\n\tlocate_dirty_segment(sbi, old_cursegno);\n\n\tif (recover_curseg) {\n\t\tif (old_cursegno != curseg->segno) {\n\t\t\tcurseg->next_segno = old_cursegno;\n\t\t\tchange_curseg(sbi, type, true);\n\t\t}\n\t\tcurseg->next_blkoff = old_blkoff;\n\t}\n\n\tup_write(&sit_i->sentry_lock);\n\tmutex_unlock(&curseg->curseg_mutex);\n\tup_write(&SM_I(sbi)->curseg_lock);\n}\n\nvoid f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,\n\t\t\t\tblock_t old_addr, block_t new_addr,\n\t\t\t\tunsigned char version, bool recover_curseg,\n\t\t\t\tbool recover_newaddr)\n{\n\tstruct f2fs_summary sum;\n\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, version);\n\n\tf2fs_do_replace_block(sbi, &sum, old_addr, new_addr,\n\t\t\t\t\trecover_curseg, recover_newaddr, false);\n\n\tf2fs_update_data_blkaddr(dn, new_addr);\n}\n\nvoid f2fs_wait_on_page_writeback(struct page *page,\n\t\t\t\tenum page_type type, bool ordered, bool locked)\n{\n\tif (PageWriteback(page)) {\n\t\tstruct f2fs_sb_info *sbi = F2FS_P_SB(page);\n\n\t\t/* submit cached LFS IO */\n\t\tf2fs_submit_merged_write_cond(sbi, NULL, page, 0, type);\n\t\t/* sbumit cached IPU IO */\n\t\tf2fs_submit_merged_ipu_write(sbi, NULL, page);\n\t\tif (ordered) {\n\t\t\twait_on_page_writeback(page);\n\t\t\tf2fs_bug_on(sbi, locked && PageWriteback(page));\n\t\t} else {\n\t\t\twait_for_stable_page(page);\n\t\t}\n\t}\n}\n\nvoid f2fs_wait_on_block_writeback(struct inode *inode, block_t blkaddr)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *cpage;\n\n\tif (!f2fs_post_read_required(inode))\n\t\treturn;\n\n\tif (!__is_valid_data_blkaddr(blkaddr))\n\t\treturn;\n\n\tcpage = find_lock_page(META_MAPPING(sbi), blkaddr);\n\tif (cpage) {\n\t\tf2fs_wait_on_page_writeback(cpage, DATA, true, true);\n\t\tf2fs_put_page(cpage, 1);\n\t}\n}\n\nvoid f2fs_wait_on_block_writeback_range(struct inode *inode, block_t blkaddr,\n\t\t\t\t\t\t\t\tblock_t len)\n{\n\tblock_t i;\n\n\tfor (i = 0; i < len; i++)\n\t\tf2fs_wait_on_block_writeback(inode, blkaddr + i);\n}\n\nstatic int read_compacted_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct curseg_info *seg_i;\n\tunsigned char *kaddr;\n\tstruct page *page;\n\tblock_t start;\n\tint i, j, offset;\n\n\tstart = start_sum_block(sbi);\n\n\tpage = f2fs_get_meta_page(sbi, start++);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\tkaddr = (unsigned char *)page_address(page);\n\n\t/* Step 1: restore nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(seg_i->journal, kaddr, SUM_JOURNAL_SIZE);\n\n\t/* Step 2: restore sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(seg_i->journal, kaddr + SUM_JOURNAL_SIZE, SUM_JOURNAL_SIZE);\n\toffset = 2 * SUM_JOURNAL_SIZE;\n\n\t/* Step 3: restore summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blk_off;\n\t\tunsigned int segno;\n\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[i]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[i]);\n\t\tseg_i->next_segno = segno;\n\t\treset_curseg(sbi, i, 0);\n\t\tseg_i->alloc_type = ckpt->alloc_type[i];\n\t\tseg_i->next_blkoff = blk_off;\n\n\t\tif (seg_i->alloc_type == SSR)\n\t\t\tblk_off = sbi->blocks_per_seg;\n\n\t\tfor (j = 0; j < blk_off; j++) {\n\t\t\tstruct f2fs_summary *s;\n\t\t\ts = (struct f2fs_summary *)(kaddr + offset);\n\t\t\tseg_i->sum_blk->entries[j] = *s;\n\t\t\toffset += SUMMARY_SIZE;\n\t\t\tif (offset + SUMMARY_SIZE <= PAGE_SIZE -\n\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\n\t\t\tpage = f2fs_get_meta_page(sbi, start++);\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn PTR_ERR(page);\n\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\toffset = 0;\n\t\t}\n\t}\n\tf2fs_put_page(page, 1);\n\treturn 0;\n}\n\nstatic int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\tint err = 0;\n\n\t/* get segment number and block addr */\n\tif (IS_DATASEG(type)) {\n\t\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_DATA]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_PERSIST_TYPE, type);\n\t\telse\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type);\n\t} else {\n\t\tsegno = le32_to_cpu(ckpt->cur_node_segno[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tblk_off = le16_to_cpu(ckpt->cur_node_blkoff[type -\n\t\t\t\t\t\t\tCURSEG_HOT_NODE]);\n\t\tif (__exist_node_summaries(sbi))\n\t\t\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_NODE_TYPE,\n\t\t\t\t\t\t\ttype - CURSEG_HOT_NODE);\n\t\telse\n\t\t\tblk_addr = GET_SUM_BLOCK(sbi, segno);\n\t}\n\n\tnew = f2fs_get_meta_page(sbi, blk_addr);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tif (IS_NODESEG(type)) {\n\t\tif (__exist_node_summaries(sbi)) {\n\t\t\tstruct f2fs_summary *ns = &sum->entries[0];\n\t\t\tint i;\n\t\t\tfor (i = 0; i < sbi->blocks_per_seg; i++, ns++) {\n\t\t\t\tns->version = 0;\n\t\t\t\tns->ofs_in_node = 0;\n\t\t\t}\n\t\t} else {\n\t\t\terr = f2fs_restore_node_summary(sbi, segno, sum);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* set uncompleted segment to curseg */\n\tcurseg = CURSEG_I(sbi, type);\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* update journal info */\n\tdown_write(&curseg->journal_rwsem);\n\tmemcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);\n\tup_write(&curseg->journal_rwsem);\n\n\tmemcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);\n\tmemcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off;\n\tmutex_unlock(&curseg->curseg_mutex);\nout:\n\tf2fs_put_page(new, 1);\n\treturn err;\n}\n\nstatic int restore_curseg_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_journal *sit_j = CURSEG_I(sbi, CURSEG_COLD_DATA)->journal;\n\tstruct f2fs_journal *nat_j = CURSEG_I(sbi, CURSEG_HOT_DATA)->journal;\n\tint type = CURSEG_HOT_DATA;\n\tint err;\n\n\tif (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG)) {\n\t\tint npages = f2fs_npages_for_summary_flush(sbi, true);\n\n\t\tif (npages >= 2)\n\t\t\tf2fs_ra_meta_pages(sbi, start_sum_block(sbi), npages,\n\t\t\t\t\t\t\tMETA_CP, true);\n\n\t\t/* restore for compacted data summary */\n\t\terr = read_compacted_summaries(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t\ttype = CURSEG_HOT_NODE;\n\t}\n\n\tif (__exist_node_summaries(sbi))\n\t\tf2fs_ra_meta_pages(sbi,\n\t\t\t\tsum_blk_addr(sbi, NR_CURSEG_PERSIST_TYPE, type),\n\t\t\t\tNR_CURSEG_PERSIST_TYPE - type, META_CP, true);\n\n\tfor (; type <= CURSEG_COLD_NODE; type++) {\n\t\terr = read_normal_summaries(sbi, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* sanity check for summary blocks */\n\tif (nats_in_cursum(nat_j) > NAT_JOURNAL_ENTRIES ||\n\t\t\tsits_in_cursum(sit_j) > SIT_JOURNAL_ENTRIES) {\n\t\tf2fs_err(sbi, \"invalid journal entries nats %u sits %u\\n\",\n\t\t\t nats_in_cursum(nat_j), sits_in_cursum(sit_j));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void write_compacted_summaries(struct f2fs_sb_info *sbi, block_t blkaddr)\n{\n\tstruct page *page;\n\tunsigned char *kaddr;\n\tstruct f2fs_summary *summary;\n\tstruct curseg_info *seg_i;\n\tint written_size = 0;\n\tint i, j;\n\n\tpage = f2fs_grab_meta_page(sbi, blkaddr++);\n\tkaddr = (unsigned char *)page_address(page);\n\tmemset(kaddr, 0, PAGE_SIZE);\n\n\t/* Step 1: write nat cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tmemcpy(kaddr, seg_i->journal, SUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 2: write sit cache */\n\tseg_i = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tmemcpy(kaddr + written_size, seg_i->journal, SUM_JOURNAL_SIZE);\n\twritten_size += SUM_JOURNAL_SIZE;\n\n\t/* Step 3: write summary entries */\n\tfor (i = CURSEG_HOT_DATA; i <= CURSEG_COLD_DATA; i++) {\n\t\tunsigned short blkoff;\n\t\tseg_i = CURSEG_I(sbi, i);\n\t\tif (sbi->ckpt->alloc_type[i] == SSR)\n\t\t\tblkoff = sbi->blocks_per_seg;\n\t\telse\n\t\t\tblkoff = curseg_blkoff(sbi, i);\n\n\t\tfor (j = 0; j < blkoff; j++) {\n\t\t\tif (!page) {\n\t\t\t\tpage = f2fs_grab_meta_page(sbi, blkaddr++);\n\t\t\t\tkaddr = (unsigned char *)page_address(page);\n\t\t\t\tmemset(kaddr, 0, PAGE_SIZE);\n\t\t\t\twritten_size = 0;\n\t\t\t}\n\t\t\tsummary = (struct f2fs_summary *)(kaddr + written_size);\n\t\t\t*summary = seg_i->sum_blk->entries[j];\n\t\t\twritten_size += SUMMARY_SIZE;\n\n\t\t\tif (written_size + SUMMARY_SIZE <= PAGE_SIZE -\n\t\t\t\t\t\t\tSUM_FOOTER_SIZE)\n\t\t\t\tcontinue;\n\n\t\t\tset_page_dirty(page);\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\tif (page) {\n\t\tset_page_dirty(page);\n\t\tf2fs_put_page(page, 1);\n\t}\n}\n\nstatic void write_normal_summaries(struct f2fs_sb_info *sbi,\n\t\t\t\t\tblock_t blkaddr, int type)\n{\n\tint i, end;\n\tif (IS_DATASEG(type))\n\t\tend = type + NR_CURSEG_DATA_TYPE;\n\telse\n\t\tend = type + NR_CURSEG_NODE_TYPE;\n\n\tfor (i = type; i < end; i++)\n\t\twrite_current_sum_page(sbi, i, blkaddr + (i - type));\n}\n\nvoid f2fs_write_data_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\tif (is_set_ckpt_flags(sbi, CP_COMPACT_SUM_FLAG))\n\t\twrite_compacted_summaries(sbi, start_blk);\n\telse\n\t\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_DATA);\n}\n\nvoid f2fs_write_node_summaries(struct f2fs_sb_info *sbi, block_t start_blk)\n{\n\twrite_normal_summaries(sbi, start_blk, CURSEG_HOT_NODE);\n}\n\nint f2fs_lookup_journal_in_cursum(struct f2fs_journal *journal, int type,\n\t\t\t\t\tunsigned int val, int alloc)\n{\n\tint i;\n\n\tif (type == NAT_JOURNAL) {\n\t\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\t\tif (le32_to_cpu(nid_in_journal(journal, i)) == val)\n\t\t\t\treturn i;\n\t\t}\n\t\tif (alloc && __has_cursum_space(journal, 1, NAT_JOURNAL))\n\t\t\treturn update_nats_in_cursum(journal, 1);\n\t} else if (type == SIT_JOURNAL) {\n\t\tfor (i = 0; i < sits_in_cursum(journal); i++)\n\t\t\tif (le32_to_cpu(segno_in_journal(journal, i)) == val)\n\t\t\t\treturn i;\n\t\tif (alloc && __has_cursum_space(journal, 1, SIT_JOURNAL))\n\t\t\treturn update_sits_in_cursum(journal, 1);\n\t}\n\treturn -1;\n}\n\nstatic struct page *get_current_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\treturn f2fs_get_meta_page(sbi, current_sit_addr(sbi, segno));\n}\n\nstatic struct page *get_next_sit_page(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int start)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct page *page;\n\tpgoff_t src_off, dst_off;\n\n\tsrc_off = current_sit_addr(sbi, start);\n\tdst_off = next_sit_addr(sbi, src_off);\n\n\tpage = f2fs_grab_meta_page(sbi, dst_off);\n\tseg_info_to_sit_page(sbi, page, start);\n\n\tset_page_dirty(page);\n\tset_to_next_sit(sit_i, start);\n\n\treturn page;\n}\n\nstatic struct sit_entry_set *grab_sit_entry_set(void)\n{\n\tstruct sit_entry_set *ses =\n\t\t\tf2fs_kmem_cache_alloc(sit_entry_set_slab, GFP_NOFS);\n\n\tses->entry_cnt = 0;\n\tINIT_LIST_HEAD(&ses->set_list);\n\treturn ses;\n}\n\nstatic void release_sit_entry_set(struct sit_entry_set *ses)\n{\n\tlist_del(&ses->set_list);\n\tkmem_cache_free(sit_entry_set_slab, ses);\n}\n\nstatic void adjust_sit_entry_set(struct sit_entry_set *ses,\n\t\t\t\t\t\tstruct list_head *head)\n{\n\tstruct sit_entry_set *next = ses;\n\n\tif (list_is_last(&ses->set_list, head))\n\t\treturn;\n\n\tlist_for_each_entry_continue(next, head, set_list)\n\t\tif (ses->entry_cnt <= next->entry_cnt)\n\t\t\tbreak;\n\n\tlist_move_tail(&ses->set_list, &next->set_list);\n}\n\nstatic void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}\n\nstatic void add_sits_in_set(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\tstruct list_head *set_list = &sm_info->sit_entry_set;\n\tunsigned long *bitmap = SIT_I(sbi)->dirty_sentries_bitmap;\n\tunsigned int segno;\n\n\tfor_each_set_bit(segno, bitmap, MAIN_SEGS(sbi))\n\t\tadd_sit_entry(segno, set_list);\n}\n\nstatic void remove_sits_in_journal(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i;\n\n\tdown_write(&curseg->journal_rwsem);\n\tfor (i = 0; i < sits_in_cursum(journal); i++) {\n\t\tunsigned int segno;\n\t\tbool dirtied;\n\n\t\tsegno = le32_to_cpu(segno_in_journal(journal, i));\n\t\tdirtied = __mark_sit_entry_dirty(sbi, segno);\n\n\t\tif (!dirtied)\n\t\t\tadd_sit_entry(segno, &SM_I(sbi)->sit_entry_set);\n\t}\n\tupdate_sits_in_cursum(journal, -i);\n\tup_write(&curseg->journal_rwsem);\n}\n\n/*\n * CP calls this function, which flushes SIT entries including sit_journal,\n * and moves prefree segs to free segs.\n */\nvoid f2fs_flush_sit_entries(struct f2fs_sb_info *sbi, struct cp_control *cpc)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned long *bitmap = sit_i->dirty_sentries_bitmap;\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct sit_entry_set *ses, *tmp;\n\tstruct list_head *head = &SM_I(sbi)->sit_entry_set;\n\tbool to_journal = !is_sbi_flag_set(sbi, SBI_IS_RESIZEFS);\n\tstruct seg_entry *se;\n\n\tdown_write(&sit_i->sentry_lock);\n\n\tif (!sit_i->dirty_sentries)\n\t\tgoto out;\n\n\t/*\n\t * add and account sit entries of dirty bitmap in sit entry\n\t * set temporarily\n\t */\n\tadd_sits_in_set(sbi);\n\n\t/*\n\t * if there are no enough space in journal to store dirty sit\n\t * entries, remove all entries from journal and add and account\n\t * them in sit entry set.\n\t */\n\tif (!__has_cursum_space(journal, sit_i->dirty_sentries, SIT_JOURNAL) ||\n\t\t\t\t\t\t\t\t!to_journal)\n\t\tremove_sits_in_journal(sbi);\n\n\t/*\n\t * there are two steps to flush sit entries:\n\t * #1, flush sit entries to journal in current cold data summary block.\n\t * #2, flush sit entries to sit page.\n\t */\n\tlist_for_each_entry_safe(ses, tmp, head, set_list) {\n\t\tstruct page *page = NULL;\n\t\tstruct f2fs_sit_block *raw_sit = NULL;\n\t\tunsigned int start_segno = ses->start_segno;\n\t\tunsigned int end = min(start_segno + SIT_ENTRY_PER_BLOCK,\n\t\t\t\t\t\t(unsigned long)MAIN_SEGS(sbi));\n\t\tunsigned int segno = start_segno;\n\n\t\tif (to_journal &&\n\t\t\t!__has_cursum_space(journal, ses->entry_cnt, SIT_JOURNAL))\n\t\t\tto_journal = false;\n\n\t\tif (to_journal) {\n\t\t\tdown_write(&curseg->journal_rwsem);\n\t\t} else {\n\t\t\tpage = get_next_sit_page(sbi, start_segno);\n\t\t\traw_sit = page_address(page);\n\t\t}\n\n\t\t/* flush dirty sit entries in region of current sit set */\n\t\tfor_each_set_bit_from(segno, bitmap, end) {\n\t\t\tint offset, sit_offset;\n\n\t\t\tse = get_seg_entry(sbi, segno);\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\t\tif (memcmp(se->cur_valid_map, se->cur_valid_map_mir,\n\t\t\t\t\t\tSIT_VBLOCK_MAP_SIZE))\n\t\t\t\tf2fs_bug_on(sbi, 1);\n#endif\n\n\t\t\t/* add discard candidates */\n\t\t\tif (!(cpc->reason & CP_DISCARD)) {\n\t\t\t\tcpc->trim_start = segno;\n\t\t\t\tadd_discard_addrs(sbi, cpc, false);\n\t\t\t}\n\n\t\t\tif (to_journal) {\n\t\t\t\toffset = f2fs_lookup_journal_in_cursum(journal,\n\t\t\t\t\t\t\tSIT_JOURNAL, segno, 1);\n\t\t\t\tf2fs_bug_on(sbi, offset < 0);\n\t\t\t\tsegno_in_journal(journal, offset) =\n\t\t\t\t\t\t\tcpu_to_le32(segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t&sit_in_journal(journal, offset));\n\t\t\t\tcheck_block_count(sbi, segno,\n\t\t\t\t\t&sit_in_journal(journal, offset));\n\t\t\t} else {\n\t\t\t\tsit_offset = SIT_ENTRY_OFFSET(sit_i, segno);\n\t\t\t\tseg_info_to_raw_sit(se,\n\t\t\t\t\t\t&raw_sit->entries[sit_offset]);\n\t\t\t\tcheck_block_count(sbi, segno,\n\t\t\t\t\t\t&raw_sit->entries[sit_offset]);\n\t\t\t}\n\n\t\t\t__clear_bit(segno, bitmap);\n\t\t\tsit_i->dirty_sentries--;\n\t\t\tses->entry_cnt--;\n\t\t}\n\n\t\tif (to_journal)\n\t\t\tup_write(&curseg->journal_rwsem);\n\t\telse\n\t\t\tf2fs_put_page(page, 1);\n\n\t\tf2fs_bug_on(sbi, ses->entry_cnt);\n\t\trelease_sit_entry_set(ses);\n\t}\n\n\tf2fs_bug_on(sbi, !list_empty(head));\n\tf2fs_bug_on(sbi, sit_i->dirty_sentries);\nout:\n\tif (cpc->reason & CP_DISCARD) {\n\t\t__u64 trim_start = cpc->trim_start;\n\n\t\tfor (; cpc->trim_start <= cpc->trim_end; cpc->trim_start++)\n\t\t\tadd_discard_addrs(sbi, cpc, false);\n\n\t\tcpc->trim_start = trim_start;\n\t}\n\tup_write(&sit_i->sentry_lock);\n\n\tset_prefree_as_free_segments(sbi);\n}\n\nstatic int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *bitmap;\n\tunsigned int bitmap_size, main_bitmap_size, sit_bitmap_size;\n\n\t/* allocate memory for SIT information */\n\tsit_i = f2fs_kzalloc(sbi, sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries =\n\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct seg_entry),\n\t\t\t\t\t      MAIN_SEGS(sbi)),\n\t\t\t      GFP_KERNEL);\n\tif (!sit_i->sentries)\n\t\treturn -ENOMEM;\n\n\tmain_bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsit_i->dirty_sentries_bitmap = f2fs_kvzalloc(sbi, main_bitmap_size,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!sit_i->dirty_sentries_bitmap)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 4;\n#else\n\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * 3;\n#endif\n\tsit_i->bitmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);\n\tif (!sit_i->bitmap)\n\t\treturn -ENOMEM;\n\n\tbitmap = sit_i->bitmap;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tsit_i->sentries[start].cur_valid_map = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n\n\t\tsit_i->sentries[start].ckpt_valid_map = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\tsit_i->sentries[start].cur_valid_map_mir = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n#endif\n\n\t\tsit_i->sentries[start].discard_map = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n\t}\n\n\tsit_i->tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\tif (!sit_i->tmp_map)\n\t\treturn -ENOMEM;\n\n\tif (__is_large_section(sbi)) {\n\t\tsit_i->sec_entries =\n\t\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct sec_entry),\n\t\t\t\t\t\t      MAIN_SECS(sbi)),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!sit_i->sec_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* get information related with SIT */\n\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;\n\n\t/* setup SIT bitmap from ckeckpoint pack */\n\tsit_bitmap_size = __bitmap_size(sbi, SIT_BITMAP);\n\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);\n\n\tsit_i->sit_bitmap = kmemdup(src_bitmap, sit_bitmap_size, GFP_KERNEL);\n\tif (!sit_i->sit_bitmap)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tsit_i->sit_bitmap_mir = kmemdup(src_bitmap,\n\t\t\t\t\tsit_bitmap_size, GFP_KERNEL);\n\tif (!sit_i->sit_bitmap_mir)\n\t\treturn -ENOMEM;\n\n\tsit_i->invalid_segmap = f2fs_kvzalloc(sbi,\n\t\t\t\t\tmain_bitmap_size, GFP_KERNEL);\n\tif (!sit_i->invalid_segmap)\n\t\treturn -ENOMEM;\n#endif\n\n\t/* init SIT information */\n\tsit_i->s_ops = &default_salloc_ops;\n\n\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);\n\tsit_i->sit_blocks = sit_segs << sbi->log_blocks_per_seg;\n\tsit_i->written_valid_blocks = 0;\n\tsit_i->bitmap_size = sit_bitmap_size;\n\tsit_i->dirty_sentries = 0;\n\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;\n\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);\n\tsit_i->mounted_time = ktime_get_boottime_seconds();\n\tinit_rwsem(&sit_i->sentry_lock);\n\treturn 0;\n}\n\nstatic int build_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i;\n\tunsigned int bitmap_size, sec_bitmap_size;\n\n\t/* allocate memory for free segmap information */\n\tfree_i = f2fs_kzalloc(sbi, sizeof(struct free_segmap_info), GFP_KERNEL);\n\tif (!free_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->free_info = free_i;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tfree_i->free_segmap = f2fs_kvmalloc(sbi, bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_segmap)\n\t\treturn -ENOMEM;\n\n\tsec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\tfree_i->free_secmap = f2fs_kvmalloc(sbi, sec_bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_secmap)\n\t\treturn -ENOMEM;\n\n\t/* set all segments as dirty temporarily */\n\tmemset(free_i->free_segmap, 0xff, bitmap_size);\n\tmemset(free_i->free_secmap, 0xff, sec_bitmap_size);\n\n\t/* init free segmap information */\n\tfree_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));\n\tfree_i->free_segments = 0;\n\tfree_i->free_sections = 0;\n\tspin_lock_init(&free_i->segmap_lock);\n\treturn 0;\n}\n\nstatic int build_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array;\n\tint i;\n\n\tarray = f2fs_kzalloc(sbi, array_size(NR_CURSEG_TYPE,\n\t\t\t\t\tsizeof(*array)), GFP_KERNEL);\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->curseg_array = array;\n\n\tfor (i = 0; i < NO_CHECK_TYPE; i++) {\n\t\tmutex_init(&array[i].curseg_mutex);\n\t\tarray[i].sum_blk = f2fs_kzalloc(sbi, PAGE_SIZE, GFP_KERNEL);\n\t\tif (!array[i].sum_blk)\n\t\t\treturn -ENOMEM;\n\t\tinit_rwsem(&array[i].journal_rwsem);\n\t\tarray[i].journal = f2fs_kzalloc(sbi,\n\t\t\t\tsizeof(struct f2fs_journal), GFP_KERNEL);\n\t\tif (!array[i].journal)\n\t\t\treturn -ENOMEM;\n\t\tif (i < NR_PERSISTENT_LOG)\n\t\t\tarray[i].seg_type = CURSEG_HOT_DATA + i;\n\t\telse if (i == CURSEG_COLD_DATA_PINNED)\n\t\t\tarray[i].seg_type = CURSEG_COLD_DATA;\n\t\telse if (i == CURSEG_ALL_DATA_ATGC)\n\t\t\tarray[i].seg_type = CURSEG_COLD_DATA;\n\t\tarray[i].segno = NULL_SEGNO;\n\t\tarray[i].next_blkoff = 0;\n\t\tarray[i].inited = false;\n\t}\n\treturn restore_curseg_summaries(sbi);\n}\n\nstatic int build_sit_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct seg_entry *se;\n\tstruct f2fs_sit_entry sit;\n\tint sit_blk_cnt = SIT_BLK_CNT(sbi);\n\tunsigned int i, start, end;\n\tunsigned int readed, start_blk = 0;\n\tint err = 0;\n\tblock_t total_node_blocks = 0;\n\n\tdo {\n\t\treaded = f2fs_ra_meta_pages(sbi, start_blk, BIO_MAX_VECS,\n\t\t\t\t\t\t\tMETA_SIT, true);\n\n\t\tstart = start_blk * sit_i->sents_per_block;\n\t\tend = (start_blk + readed) * sit_i->sents_per_block;\n\n\t\tfor (; start < end && start < MAIN_SEGS(sbi); start++) {\n\t\t\tstruct f2fs_sit_block *sit_blk;\n\t\t\tstruct page *page;\n\n\t\t\tse = &sit_i->sentries[start];\n\t\t\tpage = get_current_sit_page(sbi, start);\n\t\t\tif (IS_ERR(page))\n\t\t\t\treturn PTR_ERR(page);\n\t\t\tsit_blk = (struct f2fs_sit_block *)page_address(page);\n\t\t\tsit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];\n\t\t\tf2fs_put_page(page, 1);\n\n\t\t\terr = check_block_count(sbi, start, &sit);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tseg_info_from_raw_sit(se, &sit);\n\t\t\tif (IS_NODESEG(se->type))\n\t\t\t\ttotal_node_blocks += se->valid_blocks;\n\n\t\t\t/* build discard map only one time */\n\t\t\tif (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {\n\t\t\t\tmemset(se->discard_map, 0xff,\n\t\t\t\t\tSIT_VBLOCK_MAP_SIZE);\n\t\t\t} else {\n\t\t\t\tmemcpy(se->discard_map,\n\t\t\t\t\tse->cur_valid_map,\n\t\t\t\t\tSIT_VBLOCK_MAP_SIZE);\n\t\t\t\tsbi->discard_blks +=\n\t\t\t\t\tsbi->blocks_per_seg -\n\t\t\t\t\tse->valid_blocks;\n\t\t\t}\n\n\t\t\tif (__is_large_section(sbi))\n\t\t\t\tget_sec_entry(sbi, start)->valid_blocks +=\n\t\t\t\t\t\t\tse->valid_blocks;\n\t\t}\n\t\tstart_blk += readed;\n\t} while (start_blk < sit_blk_cnt);\n\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < sits_in_cursum(journal); i++) {\n\t\tunsigned int old_valid_blocks;\n\n\t\tstart = le32_to_cpu(segno_in_journal(journal, i));\n\t\tif (start >= MAIN_SEGS(sbi)) {\n\t\t\tf2fs_err(sbi, \"Wrong journal entry on segno %u\",\n\t\t\t\t start);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tse = &sit_i->sentries[start];\n\t\tsit = sit_in_journal(journal, i);\n\n\t\told_valid_blocks = se->valid_blocks;\n\t\tif (IS_NODESEG(se->type))\n\t\t\ttotal_node_blocks -= old_valid_blocks;\n\n\t\terr = check_block_count(sbi, start, &sit);\n\t\tif (err)\n\t\t\tbreak;\n\t\tseg_info_from_raw_sit(se, &sit);\n\t\tif (IS_NODESEG(se->type))\n\t\t\ttotal_node_blocks += se->valid_blocks;\n\n\t\tif (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {\n\t\t\tmemset(se->discard_map, 0xff, SIT_VBLOCK_MAP_SIZE);\n\t\t} else {\n\t\t\tmemcpy(se->discard_map, se->cur_valid_map,\n\t\t\t\t\t\tSIT_VBLOCK_MAP_SIZE);\n\t\t\tsbi->discard_blks += old_valid_blocks;\n\t\t\tsbi->discard_blks -= se->valid_blocks;\n\t\t}\n\n\t\tif (__is_large_section(sbi)) {\n\t\t\tget_sec_entry(sbi, start)->valid_blocks +=\n\t\t\t\t\t\t\tse->valid_blocks;\n\t\t\tget_sec_entry(sbi, start)->valid_blocks -=\n\t\t\t\t\t\t\told_valid_blocks;\n\t\t}\n\t}\n\tup_read(&curseg->journal_rwsem);\n\n\tif (!err && total_node_blocks != valid_node_count(sbi)) {\n\t\tf2fs_err(sbi, \"SIT is corrupted node# %u vs %u\",\n\t\t\t total_node_blocks, valid_node_count(sbi));\n\t\terr = -EFSCORRUPTED;\n\t}\n\n\treturn err;\n}\n\nstatic void init_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tunsigned int start;\n\tint type;\n\tstruct seg_entry *sentry;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tif (f2fs_usable_blks_in_seg(sbi, start) == 0)\n\t\t\tcontinue;\n\t\tsentry = get_seg_entry(sbi, start);\n\t\tif (!sentry->valid_blocks)\n\t\t\t__set_free(sbi, start);\n\t\telse\n\t\t\tSIT_I(sbi)->written_valid_blocks +=\n\t\t\t\t\t\tsentry->valid_blocks;\n\t}\n\n\t/* set use the current segments */\n\tfor (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {\n\t\tstruct curseg_info *curseg_t = CURSEG_I(sbi, type);\n\t\t__set_test_and_inuse(sbi, curseg_t->segno);\n\t}\n}\n\nstatic void init_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno = 0, offset = 0, secno;\n\tblock_t valid_blocks, usable_blks_in_seg;\n\tblock_t blks_per_sec = BLKS_PER_SEC(sbi);\n\n\twhile (1) {\n\t\t/* find dirty segment based on free segmap */\n\t\tsegno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);\n\t\tif (segno >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\toffset = segno + 1;\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, false);\n\t\tusable_blks_in_seg = f2fs_usable_blks_in_seg(sbi, segno);\n\t\tif (valid_blocks == usable_blks_in_seg || !valid_blocks)\n\t\t\tcontinue;\n\t\tif (valid_blocks > usable_blks_in_seg) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n\n\tif (!__is_large_section(sbi))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, true);\n\t\tsecno = GET_SEC_FROM_SEG(sbi, segno);\n\n\t\tif (!valid_blocks || valid_blocks == blks_per_sec)\n\t\t\tcontinue;\n\t\tif (IS_CURSEC(sbi, secno))\n\t\t\tcontinue;\n\t\tset_bit(secno, dirty_i->dirty_secmap);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n}\n\nstatic int init_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tunsigned int bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\n\tdirty_i->victim_secmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);\n\tif (!dirty_i->victim_secmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int build_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i;\n\tunsigned int bitmap_size, i;\n\n\t/* allocate memory for dirty segments list information */\n\tdirty_i = f2fs_kzalloc(sbi, sizeof(struct dirty_seglist_info),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!dirty_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->dirty_info = dirty_i;\n\tmutex_init(&dirty_i->seglist_lock);\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++) {\n\t\tdirty_i->dirty_segmap[i] = f2fs_kvzalloc(sbi, bitmap_size,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!dirty_i->dirty_segmap[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (__is_large_section(sbi)) {\n\t\tbitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\t\tdirty_i->dirty_secmap = f2fs_kvzalloc(sbi,\n\t\t\t\t\t\tbitmap_size, GFP_KERNEL);\n\t\tif (!dirty_i->dirty_secmap)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tinit_dirty_segmap(sbi);\n\treturn init_victim_secmap(sbi);\n}\n\nstatic int sanity_check_curseg(struct f2fs_sb_info *sbi)\n{\n\tint i;\n\n\t/*\n\t * In LFS/SSR curseg, .next_blkoff should point to an unused blkaddr;\n\t * In LFS curseg, all blkaddr after .next_blkoff should be unused.\n\t */\n\tfor (i = 0; i < NR_PERSISTENT_LOG; i++) {\n\t\tstruct curseg_info *curseg = CURSEG_I(sbi, i);\n\t\tstruct seg_entry *se = get_seg_entry(sbi, curseg->segno);\n\t\tunsigned int blkofs = curseg->next_blkoff;\n\n\t\tsanity_check_seg_type(sbi, curseg->seg_type);\n\n\t\tif (f2fs_test_bit(blkofs, se->cur_valid_map))\n\t\t\tgoto out;\n\n\t\tif (curseg->alloc_type == SSR)\n\t\t\tcontinue;\n\n\t\tfor (blkofs += 1; blkofs < sbi->blocks_per_seg; blkofs++) {\n\t\t\tif (!f2fs_test_bit(blkofs, se->cur_valid_map))\n\t\t\t\tcontinue;\nout:\n\t\t\tf2fs_err(sbi,\n\t\t\t\t \"Current segment's next free block offset is inconsistent with bitmap, logtype:%u, segno:%u, type:%u, next_blkoff:%u, blkofs:%u\",\n\t\t\t\t i, curseg->segno, curseg->alloc_type,\n\t\t\t\t curseg->next_blkoff, blkofs);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_BLK_DEV_ZONED\n\nstatic int check_zone_write_pointer(struct f2fs_sb_info *sbi,\n\t\t\t\t    struct f2fs_dev_info *fdev,\n\t\t\t\t    struct blk_zone *zone)\n{\n\tunsigned int wp_segno, wp_blkoff, zone_secno, zone_segno, segno;\n\tblock_t zone_block, wp_block, last_valid_block;\n\tunsigned int log_sectors_per_block = sbi->log_blocksize - SECTOR_SHIFT;\n\tint i, s, b, ret;\n\tstruct seg_entry *se;\n\n\tif (zone->type != BLK_ZONE_TYPE_SEQWRITE_REQ)\n\t\treturn 0;\n\n\twp_block = fdev->start_blk + (zone->wp >> log_sectors_per_block);\n\twp_segno = GET_SEGNO(sbi, wp_block);\n\twp_blkoff = wp_block - START_BLOCK(sbi, wp_segno);\n\tzone_block = fdev->start_blk + (zone->start >> log_sectors_per_block);\n\tzone_segno = GET_SEGNO(sbi, zone_block);\n\tzone_secno = GET_SEC_FROM_SEG(sbi, zone_segno);\n\n\tif (zone_segno >= MAIN_SEGS(sbi))\n\t\treturn 0;\n\n\t/*\n\t * Skip check of zones cursegs point to, since\n\t * fix_curseg_write_pointer() checks them.\n\t */\n\tfor (i = 0; i < NO_CHECK_TYPE; i++)\n\t\tif (zone_secno == GET_SEC_FROM_SEG(sbi,\n\t\t\t\t\t\t   CURSEG_I(sbi, i)->segno))\n\t\t\treturn 0;\n\n\t/*\n\t * Get last valid block of the zone.\n\t */\n\tlast_valid_block = zone_block - 1;\n\tfor (s = sbi->segs_per_sec - 1; s >= 0; s--) {\n\t\tsegno = zone_segno + s;\n\t\tse = get_seg_entry(sbi, segno);\n\t\tfor (b = sbi->blocks_per_seg - 1; b >= 0; b--)\n\t\t\tif (f2fs_test_bit(b, se->cur_valid_map)) {\n\t\t\t\tlast_valid_block = START_BLOCK(sbi, segno) + b;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (last_valid_block >= zone_block)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If last valid block is beyond the write pointer, report the\n\t * inconsistency. This inconsistency does not cause write error\n\t * because the zone will not be selected for write operation until\n\t * it get discarded. Just report it.\n\t */\n\tif (last_valid_block >= wp_block) {\n\t\tf2fs_notice(sbi, \"Valid block beyond write pointer: \"\n\t\t\t    \"valid block[0x%x,0x%x] wp[0x%x,0x%x]\",\n\t\t\t    GET_SEGNO(sbi, last_valid_block),\n\t\t\t    GET_BLKOFF_FROM_SEG0(sbi, last_valid_block),\n\t\t\t    wp_segno, wp_blkoff);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If there is no valid block in the zone and if write pointer is\n\t * not at zone start, reset the write pointer.\n\t */\n\tif (last_valid_block + 1 == zone_block && zone->wp != zone->start) {\n\t\tf2fs_notice(sbi,\n\t\t\t    \"Zone without valid block has non-zero write \"\n\t\t\t    \"pointer. Reset the write pointer: wp[0x%x,0x%x]\",\n\t\t\t    wp_segno, wp_blkoff);\n\t\tret = __f2fs_issue_discard_zone(sbi, fdev->bdev, zone_block,\n\t\t\t\t\tzone->len >> log_sectors_per_block);\n\t\tif (ret) {\n\t\t\tf2fs_err(sbi, \"Discard zone failed: %s (errno=%d)\",\n\t\t\t\t fdev->path, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct f2fs_dev_info *get_target_zoned_dev(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t  block_t zone_blkaddr)\n{\n\tint i;\n\n\tfor (i = 0; i < sbi->s_ndevs; i++) {\n\t\tif (!bdev_is_zoned(FDEV(i).bdev))\n\t\t\tcontinue;\n\t\tif (sbi->s_ndevs == 1 || (FDEV(i).start_blk <= zone_blkaddr &&\n\t\t\t\tzone_blkaddr <= FDEV(i).end_blk))\n\t\t\treturn &FDEV(i);\n\t}\n\n\treturn NULL;\n}\n\nstatic int report_one_zone_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t      void *data) {\n\tmemcpy(data, zone, sizeof(struct blk_zone));\n\treturn 0;\n}\n\nstatic int fix_curseg_write_pointer(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct curseg_info *cs = CURSEG_I(sbi, type);\n\tstruct f2fs_dev_info *zbd;\n\tstruct blk_zone zone;\n\tunsigned int cs_section, wp_segno, wp_blkoff, wp_sector_off;\n\tblock_t cs_zone_block, wp_block;\n\tunsigned int log_sectors_per_block = sbi->log_blocksize - SECTOR_SHIFT;\n\tsector_t zone_sector;\n\tint err;\n\n\tcs_section = GET_SEC_FROM_SEG(sbi, cs->segno);\n\tcs_zone_block = START_BLOCK(sbi, GET_SEG_FROM_SEC(sbi, cs_section));\n\n\tzbd = get_target_zoned_dev(sbi, cs_zone_block);\n\tif (!zbd)\n\t\treturn 0;\n\n\t/* report zone for the sector the curseg points to */\n\tzone_sector = (sector_t)(cs_zone_block - zbd->start_blk)\n\t\t<< log_sectors_per_block;\n\terr = blkdev_report_zones(zbd->bdev, zone_sector, 1,\n\t\t\t\t  report_one_zone_cb, &zone);\n\tif (err != 1) {\n\t\tf2fs_err(sbi, \"Report zone failed: %s errno=(%d)\",\n\t\t\t zbd->path, err);\n\t\treturn err;\n\t}\n\n\tif (zone.type != BLK_ZONE_TYPE_SEQWRITE_REQ)\n\t\treturn 0;\n\n\twp_block = zbd->start_blk + (zone.wp >> log_sectors_per_block);\n\twp_segno = GET_SEGNO(sbi, wp_block);\n\twp_blkoff = wp_block - START_BLOCK(sbi, wp_segno);\n\twp_sector_off = zone.wp & GENMASK(log_sectors_per_block - 1, 0);\n\n\tif (cs->segno == wp_segno && cs->next_blkoff == wp_blkoff &&\n\t\twp_sector_off == 0)\n\t\treturn 0;\n\n\tf2fs_notice(sbi, \"Unaligned curseg[%d] with write pointer: \"\n\t\t    \"curseg[0x%x,0x%x] wp[0x%x,0x%x]\",\n\t\t    type, cs->segno, cs->next_blkoff, wp_segno, wp_blkoff);\n\n\tf2fs_notice(sbi, \"Assign new section to curseg[%d]: \"\n\t\t    \"curseg[0x%x,0x%x]\", type, cs->segno, cs->next_blkoff);\n\tallocate_segment_by_default(sbi, type, true);\n\n\t/* check consistency of the zone curseg pointed to */\n\tif (check_zone_write_pointer(sbi, zbd, &zone))\n\t\treturn -EIO;\n\n\t/* check newly assigned zone */\n\tcs_section = GET_SEC_FROM_SEG(sbi, cs->segno);\n\tcs_zone_block = START_BLOCK(sbi, GET_SEG_FROM_SEC(sbi, cs_section));\n\n\tzbd = get_target_zoned_dev(sbi, cs_zone_block);\n\tif (!zbd)\n\t\treturn 0;\n\n\tzone_sector = (sector_t)(cs_zone_block - zbd->start_blk)\n\t\t<< log_sectors_per_block;\n\terr = blkdev_report_zones(zbd->bdev, zone_sector, 1,\n\t\t\t\t  report_one_zone_cb, &zone);\n\tif (err != 1) {\n\t\tf2fs_err(sbi, \"Report zone failed: %s errno=(%d)\",\n\t\t\t zbd->path, err);\n\t\treturn err;\n\t}\n\n\tif (zone.type != BLK_ZONE_TYPE_SEQWRITE_REQ)\n\t\treturn 0;\n\n\tif (zone.wp != zone.start) {\n\t\tf2fs_notice(sbi,\n\t\t\t    \"New zone for curseg[%d] is not yet discarded. \"\n\t\t\t    \"Reset the zone: curseg[0x%x,0x%x]\",\n\t\t\t    type, cs->segno, cs->next_blkoff);\n\t\terr = __f2fs_issue_discard_zone(sbi, zbd->bdev,\n\t\t\t\tzone_sector >> log_sectors_per_block,\n\t\t\t\tzone.len >> log_sectors_per_block);\n\t\tif (err) {\n\t\t\tf2fs_err(sbi, \"Discard zone failed: %s (errno=%d)\",\n\t\t\t\t zbd->path, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint f2fs_fix_curseg_write_pointer(struct f2fs_sb_info *sbi)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < NR_PERSISTENT_LOG; i++) {\n\t\tret = fix_curseg_write_pointer(sbi, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct check_zone_write_pointer_args {\n\tstruct f2fs_sb_info *sbi;\n\tstruct f2fs_dev_info *fdev;\n};\n\nstatic int check_zone_write_pointer_cb(struct blk_zone *zone, unsigned int idx,\n\t\t\t\t      void *data) {\n\tstruct check_zone_write_pointer_args *args;\n\targs = (struct check_zone_write_pointer_args *)data;\n\n\treturn check_zone_write_pointer(args->sbi, args->fdev, zone);\n}\n\nint f2fs_check_write_pointer(struct f2fs_sb_info *sbi)\n{\n\tint i, ret;\n\tstruct check_zone_write_pointer_args args;\n\n\tfor (i = 0; i < sbi->s_ndevs; i++) {\n\t\tif (!bdev_is_zoned(FDEV(i).bdev))\n\t\t\tcontinue;\n\n\t\targs.sbi = sbi;\n\t\targs.fdev = &FDEV(i);\n\t\tret = blkdev_report_zones(FDEV(i).bdev, 0, BLK_ALL_ZONES,\n\t\t\t\t\t  check_zone_write_pointer_cb, &args);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_conv_zone(struct f2fs_sb_info *sbi, unsigned int zone_idx,\n\t\t\t\t\t\tunsigned int dev_idx)\n{\n\tif (!bdev_is_zoned(FDEV(dev_idx).bdev))\n\t\treturn true;\n\treturn !test_bit(zone_idx, FDEV(dev_idx).blkz_seq);\n}\n\n/* Return the zone index in the given device */\nstatic unsigned int get_zone_idx(struct f2fs_sb_info *sbi, unsigned int secno,\n\t\t\t\t\tint dev_idx)\n{\n\tblock_t sec_start_blkaddr = START_BLOCK(sbi, GET_SEG_FROM_SEC(sbi, secno));\n\n\treturn (sec_start_blkaddr - FDEV(dev_idx).start_blk) >>\n\t\t\t\t\t\tsbi->log_blocks_per_blkz;\n}\n\n/*\n * Return the usable segments in a section based on the zone's\n * corresponding zone capacity. Zone is equal to a section.\n */\nstatic inline unsigned int f2fs_usable_zone_segs_in_sec(\n\t\tstruct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tunsigned int dev_idx, zone_idx, unusable_segs_in_sec;\n\n\tdev_idx = f2fs_target_device_index(sbi, START_BLOCK(sbi, segno));\n\tzone_idx = get_zone_idx(sbi, GET_SEC_FROM_SEG(sbi, segno), dev_idx);\n\n\t/* Conventional zone's capacity is always equal to zone size */\n\tif (is_conv_zone(sbi, zone_idx, dev_idx))\n\t\treturn sbi->segs_per_sec;\n\n\t/*\n\t * If the zone_capacity_blocks array is NULL, then zone capacity\n\t * is equal to the zone size for all zones\n\t */\n\tif (!FDEV(dev_idx).zone_capacity_blocks)\n\t\treturn sbi->segs_per_sec;\n\n\t/* Get the segment count beyond zone capacity block */\n\tunusable_segs_in_sec = (sbi->blocks_per_blkz -\n\t\t\t\tFDEV(dev_idx).zone_capacity_blocks[zone_idx]) >>\n\t\t\t\tsbi->log_blocks_per_seg;\n\treturn sbi->segs_per_sec - unusable_segs_in_sec;\n}\n\n/*\n * Return the number of usable blocks in a segment. The number of blocks\n * returned is always equal to the number of blocks in a segment for\n * segments fully contained within a sequential zone capacity or a\n * conventional zone. For segments partially contained in a sequential\n * zone capacity, the number of usable blocks up to the zone capacity\n * is returned. 0 is returned in all other cases.\n */\nstatic inline unsigned int f2fs_usable_zone_blks_in_seg(\n\t\t\tstruct f2fs_sb_info *sbi, unsigned int segno)\n{\n\tblock_t seg_start, sec_start_blkaddr, sec_cap_blkaddr;\n\tunsigned int zone_idx, dev_idx, secno;\n\n\tsecno = GET_SEC_FROM_SEG(sbi, segno);\n\tseg_start = START_BLOCK(sbi, segno);\n\tdev_idx = f2fs_target_device_index(sbi, seg_start);\n\tzone_idx = get_zone_idx(sbi, secno, dev_idx);\n\n\t/*\n\t * Conventional zone's capacity is always equal to zone size,\n\t * so, blocks per segment is unchanged.\n\t */\n\tif (is_conv_zone(sbi, zone_idx, dev_idx))\n\t\treturn sbi->blocks_per_seg;\n\n\tif (!FDEV(dev_idx).zone_capacity_blocks)\n\t\treturn sbi->blocks_per_seg;\n\n\tsec_start_blkaddr = START_BLOCK(sbi, GET_SEG_FROM_SEC(sbi, secno));\n\tsec_cap_blkaddr = sec_start_blkaddr +\n\t\t\t\tFDEV(dev_idx).zone_capacity_blocks[zone_idx];\n\n\t/*\n\t * If segment starts before zone capacity and spans beyond\n\t * zone capacity, then usable blocks are from seg start to\n\t * zone capacity. If the segment starts after the zone capacity,\n\t * then there are no usable blocks.\n\t */\n\tif (seg_start >= sec_cap_blkaddr)\n\t\treturn 0;\n\tif (seg_start + sbi->blocks_per_seg > sec_cap_blkaddr)\n\t\treturn sec_cap_blkaddr - seg_start;\n\n\treturn sbi->blocks_per_seg;\n}\n#else\nint f2fs_fix_curseg_write_pointer(struct f2fs_sb_info *sbi)\n{\n\treturn 0;\n}\n\nint f2fs_check_write_pointer(struct f2fs_sb_info *sbi)\n{\n\treturn 0;\n}\n\nstatic inline unsigned int f2fs_usable_zone_blks_in_seg(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\tunsigned int segno)\n{\n\treturn 0;\n}\n\nstatic inline unsigned int f2fs_usable_zone_segs_in_sec(struct f2fs_sb_info *sbi,\n\t\t\t\t\t\t\tunsigned int segno)\n{\n\treturn 0;\n}\n#endif\nunsigned int f2fs_usable_blks_in_seg(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn f2fs_usable_zone_blks_in_seg(sbi, segno);\n\n\treturn sbi->blocks_per_seg;\n}\n\nunsigned int f2fs_usable_segs_in_sec(struct f2fs_sb_info *sbi,\n\t\t\t\t\tunsigned int segno)\n{\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn f2fs_usable_zone_segs_in_sec(sbi, segno);\n\n\treturn sbi->segs_per_sec;\n}\n\n/*\n * Update min, max modified time for cost-benefit GC algorithm\n */\nstatic void init_min_max_mtime(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tunsigned int segno;\n\n\tdown_write(&sit_i->sentry_lock);\n\n\tsit_i->min_mtime = ULLONG_MAX;\n\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += sbi->segs_per_sec) {\n\t\tunsigned int i;\n\t\tunsigned long long mtime = 0;\n\n\t\tfor (i = 0; i < sbi->segs_per_sec; i++)\n\t\t\tmtime += get_seg_entry(sbi, segno + i)->mtime;\n\n\t\tmtime = div_u64(mtime, sbi->segs_per_sec);\n\n\t\tif (sit_i->min_mtime > mtime)\n\t\t\tsit_i->min_mtime = mtime;\n\t}\n\tsit_i->max_mtime = get_mtime(sbi, false);\n\tsit_i->dirty_max_mtime = 0;\n\tup_write(&sit_i->sentry_lock);\n}\n\nint f2fs_build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)\n\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;\n\n\tif (!f2fs_lfs_mode(sbi))\n\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\tsm_info->min_seq_blocks = sbi->blocks_per_seg * sbi->segs_per_sec;\n\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;\n\tsm_info->min_ssr_sections = reserved_sections(sbi);\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tinit_rwsem(&sm_info->curseg_lock);\n\n\tif (!f2fs_readonly(sbi->sb)) {\n\t\terr = f2fs_create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = create_discard_cmd_control(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = build_sit_info(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_free_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\terr = build_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\t/* reinit free segmap based on SIT */\n\terr = build_sit_entries(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_free_segmap(sbi);\n\terr = build_dirty_segmap(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = sanity_check_curseg(sbi);\n\tif (err)\n\t\treturn err;\n\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}\n\nstatic void discard_dirty_segmap(struct f2fs_sb_info *sbi,\n\t\tenum dirty_type dirty_type)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tkvfree(dirty_i->dirty_segmap[dirty_type]);\n\tdirty_i->nr_dirty[dirty_type] = 0;\n\tmutex_unlock(&dirty_i->seglist_lock);\n}\n\nstatic void destroy_victim_secmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tkvfree(dirty_i->victim_secmap);\n}\n\nstatic void destroy_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tint i;\n\n\tif (!dirty_i)\n\t\treturn;\n\n\t/* discard pre-free/dirty segments list */\n\tfor (i = 0; i < NR_DIRTY_TYPE; i++)\n\t\tdiscard_dirty_segmap(sbi, i);\n\n\tif (__is_large_section(sbi)) {\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\tkvfree(dirty_i->dirty_secmap);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n\n\tdestroy_victim_secmap(sbi);\n\tSM_I(sbi)->dirty_info = NULL;\n\tkfree(dirty_i);\n}\n\nstatic void destroy_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array = SM_I(sbi)->curseg_array;\n\tint i;\n\n\tif (!array)\n\t\treturn;\n\tSM_I(sbi)->curseg_array = NULL;\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++) {\n\t\tkfree(array[i].sum_blk);\n\t\tkfree(array[i].journal);\n\t}\n\tkfree(array);\n}\n\nstatic void destroy_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i = SM_I(sbi)->free_info;\n\tif (!free_i)\n\t\treturn;\n\tSM_I(sbi)->free_info = NULL;\n\tkvfree(free_i->free_segmap);\n\tkvfree(free_i->free_secmap);\n\tkfree(free_i);\n}\n\nstatic void destroy_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\n\tif (!sit_i)\n\t\treturn;\n\n\tif (sit_i->sentries)\n\t\tkvfree(sit_i->bitmap);\n\tkfree(sit_i->tmp_map);\n\n\tkvfree(sit_i->sentries);\n\tkvfree(sit_i->sec_entries);\n\tkvfree(sit_i->dirty_sentries_bitmap);\n\n\tSM_I(sbi)->sit_info = NULL;\n\tkvfree(sit_i->sit_bitmap);\n#ifdef CONFIG_F2FS_CHECK_FS\n\tkvfree(sit_i->sit_bitmap_mir);\n\tkvfree(sit_i->invalid_segmap);\n#endif\n\tkfree(sit_i);\n}\n\nvoid f2fs_destroy_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_sm_info *sm_info = SM_I(sbi);\n\n\tif (!sm_info)\n\t\treturn;\n\tf2fs_destroy_flush_cmd_control(sbi, true);\n\tdestroy_discard_cmd_control(sbi);\n\tdestroy_dirty_segmap(sbi);\n\tdestroy_curseg(sbi);\n\tdestroy_free_segmap(sbi);\n\tdestroy_sit_info(sbi);\n\tsbi->sm_info = NULL;\n\tkfree(sm_info);\n}\n\nint __init f2fs_create_segment_manager_caches(void)\n{\n\tdiscard_entry_slab = f2fs_kmem_cache_create(\"f2fs_discard_entry\",\n\t\t\tsizeof(struct discard_entry));\n\tif (!discard_entry_slab)\n\t\tgoto fail;\n\n\tdiscard_cmd_slab = f2fs_kmem_cache_create(\"f2fs_discard_cmd\",\n\t\t\tsizeof(struct discard_cmd));\n\tif (!discard_cmd_slab)\n\t\tgoto destroy_discard_entry;\n\n\tsit_entry_set_slab = f2fs_kmem_cache_create(\"f2fs_sit_entry_set\",\n\t\t\tsizeof(struct sit_entry_set));\n\tif (!sit_entry_set_slab)\n\t\tgoto destroy_discard_cmd;\n\n\tinmem_entry_slab = f2fs_kmem_cache_create(\"f2fs_inmem_page_entry\",\n\t\t\tsizeof(struct inmem_pages));\n\tif (!inmem_entry_slab)\n\t\tgoto destroy_sit_entry_set;\n\treturn 0;\n\ndestroy_sit_entry_set:\n\tkmem_cache_destroy(sit_entry_set_slab);\ndestroy_discard_cmd:\n\tkmem_cache_destroy(discard_cmd_slab);\ndestroy_discard_entry:\n\tkmem_cache_destroy(discard_entry_slab);\nfail:\n\treturn -ENOMEM;\n}\n\nvoid f2fs_destroy_segment_manager_caches(void)\n{\n\tkmem_cache_destroy(sit_entry_set_slab);\n\tkmem_cache_destroy(discard_cmd_slab);\n\tkmem_cache_destroy(discard_entry_slab);\n\tkmem_cache_destroy(inmem_entry_slab);\n}\n"}}, "reports": [{"events": [{"location": {"col": 41, "file": 0, "line": 1645}, "message": "ERROR: invalid reference to the index variable of the iterator on line 1626"}], "macros": [], "notes": [], "path": "/src/fs/f2fs/segment.c", "reportHash": "2d96b6d043162ef30eadf7da7e706001", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 38, "file": 0, "line": 361}, "message": "ERROR: invalid reference to the index variable of the iterator on line 356"}], "macros": [], "notes": [], "path": "/src/fs/f2fs/segment.c", "reportHash": "8b252220201f871fd2b8d536deeee504", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
