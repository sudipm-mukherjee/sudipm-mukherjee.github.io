<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/src/drivers/scsi/mpt3sas/mpt3sas_base.c", "content": "/*\n * This is the Fusion MPT base driver providing common API layer interface\n * for access to MPT (Message Passing Technology) firmware.\n *\n * This code is based on drivers/scsi/mpt3sas/mpt3sas_base.c\n * Copyright (C) 2012-2014  LSI Corporation\n * Copyright (C) 2013-2014 Avago Technologies\n *  (mailto: MPT-FusionLinux.pdl@avagotech.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * NO WARRANTY\n * THE PROGRAM IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT\n * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,\n * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is\n * solely responsible for determining the appropriateness of using and\n * distributing the Program and assumes all risks associated with its\n * exercise of rights under this Agreement, including but not limited to\n * the risks and costs of program errors, damage to or loss of data,\n * programs or equipment, and unavailability or interruption of operations.\n\n * DISCLAIMER OF LIABILITY\n * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED\n * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES\n\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/kdev_t.h>\n#include <linux/blkdev.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <linux/kthread.h>\n#include <asm/page.h>        /* To get host page size per arch */\n#include <linux/aer.h>\n\n\n#include \"mpt3sas_base.h\"\n\nstatic MPT_CALLBACK\tmpt_callbacks[MPT_MAX_CALLBACKS];\n\n\n#define FAULT_POLLING_INTERVAL 1000 /* in milliseconds */\n\n /* maximum controller queue depth */\n#define MAX_HBA_QUEUE_DEPTH\t30000\n#define MAX_CHAIN_DEPTH\t\t100000\nstatic int max_queue_depth = -1;\nmodule_param(max_queue_depth, int, 0444);\nMODULE_PARM_DESC(max_queue_depth, \" max controller queue depth \");\n\nstatic int max_sgl_entries = -1;\nmodule_param(max_sgl_entries, int, 0444);\nMODULE_PARM_DESC(max_sgl_entries, \" max sg entries \");\n\nstatic int msix_disable = -1;\nmodule_param(msix_disable, int, 0444);\nMODULE_PARM_DESC(msix_disable, \" disable msix routed interrupts (default=0)\");\n\nstatic int smp_affinity_enable = 1;\nmodule_param(smp_affinity_enable, int, 0444);\nMODULE_PARM_DESC(smp_affinity_enable, \"SMP affinity feature enable/disable Default: enable(1)\");\n\nstatic int max_msix_vectors = -1;\nmodule_param(max_msix_vectors, int, 0444);\nMODULE_PARM_DESC(max_msix_vectors,\n\t\" max msix vectors\");\n\nstatic int irqpoll_weight = -1;\nmodule_param(irqpoll_weight, int, 0444);\nMODULE_PARM_DESC(irqpoll_weight,\n\t\"irq poll weight (default= one fourth of HBA queue depth)\");\n\nstatic int mpt3sas_fwfault_debug;\nMODULE_PARM_DESC(mpt3sas_fwfault_debug,\n\t\" enable detection of firmware fault and halt firmware - (default=0)\");\n\nstatic int perf_mode = -1;\nmodule_param(perf_mode, int, 0444);\nMODULE_PARM_DESC(perf_mode,\n\t\"Performance mode (only for Aero/Sea Generation), options:\\n\\t\\t\"\n\t\"0 - balanced: high iops mode is enabled &\\n\\t\\t\"\n\t\"interrupt coalescing is enabled only on high iops queues,\\n\\t\\t\"\n\t\"1 - iops: high iops mode is disabled &\\n\\t\\t\"\n\t\"interrupt coalescing is enabled on all queues,\\n\\t\\t\"\n\t\"2 - latency: high iops mode is disabled &\\n\\t\\t\"\n\t\"interrupt coalescing is enabled on all queues with timeout value 0xA,\\n\"\n\t\"\\t\\tdefault - default perf_mode is 'balanced'\"\n\t);\n\nenum mpt3sas_perf_mode {\n\tMPT_PERF_MODE_DEFAULT\t= -1,\n\tMPT_PERF_MODE_BALANCED\t= 0,\n\tMPT_PERF_MODE_IOPS\t= 1,\n\tMPT_PERF_MODE_LATENCY\t= 2,\n};\n\nstatic int\n_base_wait_on_iocstate(struct MPT3SAS_ADAPTER *ioc,\n\t\tu32 ioc_state, int timeout);\nstatic int\n_base_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc);\nstatic void\n_base_clear_outstanding_commands(struct MPT3SAS_ADAPTER *ioc);\n\n/**\n * mpt3sas_base_check_cmd_timeout - Function\n *\t\tto check timeout and command termination due\n *\t\tto Host reset.\n *\n * @ioc:\tper adapter object.\n * @status:\tStatus of issued command.\n * @mpi_request:mf request pointer.\n * @sz:\t\tsize of buffer.\n *\n * @Returns - 1/0 Reset to be done or Not\n */\nu8\nmpt3sas_base_check_cmd_timeout(struct MPT3SAS_ADAPTER *ioc,\n\t\tu8 status, void *mpi_request, int sz)\n{\n\tu8 issue_reset = 0;\n\n\tif (!(status & MPT3_CMD_RESET))\n\t\tissue_reset = 1;\n\n\tioc_err(ioc, \"Command %s\\n\",\n\t\tissue_reset == 0 ? \"terminated due to Host Reset\" : \"Timeout\");\n\t_debug_dump_mf(mpi_request, sz);\n\n\treturn issue_reset;\n}\n\n/**\n * _scsih_set_fwfault_debug - global setting of ioc->fwfault_debug.\n * @val: ?\n * @kp: ?\n *\n * Return: ?\n */\nstatic int\n_scsih_set_fwfault_debug(const char *val, const struct kernel_param *kp)\n{\n\tint ret = param_set_int(val, kp);\n\tstruct MPT3SAS_ADAPTER *ioc;\n\n\tif (ret)\n\t\treturn ret;\n\n\t/* global ioc spinlock to protect controller list on list operations */\n\tpr_info(\"setting fwfault_debug(%d)\\n\", mpt3sas_fwfault_debug);\n\tspin_lock(&gioc_lock);\n\tlist_for_each_entry(ioc, &mpt3sas_ioc_list, list)\n\t\tioc->fwfault_debug = mpt3sas_fwfault_debug;\n\tspin_unlock(&gioc_lock);\n\treturn 0;\n}\nmodule_param_call(mpt3sas_fwfault_debug, _scsih_set_fwfault_debug,\n\tparam_get_int, &mpt3sas_fwfault_debug, 0644);\n\n/**\n * _base_readl_aero - retry readl for max three times.\n * @addr: MPT Fusion system interface register address\n *\n * Retry the readl() for max three times if it gets zero value\n * while reading the system interface register.\n */\nstatic inline u32\n_base_readl_aero(const volatile void __iomem *addr)\n{\n\tu32 i = 0, ret_val;\n\n\tdo {\n\t\tret_val = readl(addr);\n\t\ti++;\n\t} while (ret_val == 0 && i < 3);\n\n\treturn ret_val;\n}\n\nstatic inline u32\n_base_readl(const volatile void __iomem *addr)\n{\n\treturn readl(addr);\n}\n\n/**\n * _base_clone_reply_to_sys_mem - copies reply to reply free iomem\n *\t\t\t\t  in BAR0 space.\n *\n * @ioc: per adapter object\n * @reply: reply message frame(lower 32bit addr)\n * @index: System request message index.\n */\nstatic void\n_base_clone_reply_to_sys_mem(struct MPT3SAS_ADAPTER *ioc, u32 reply,\n\t\tu32 index)\n{\n\t/*\n\t * 256 is offset within sys register.\n\t * 256 offset MPI frame starts. Max MPI frame supported is 32.\n\t * 32 * 128 = 4K. From here, Clone of reply free for mcpu starts\n\t */\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\tvoid __iomem *reply_free_iomem = (void __iomem *)ioc->chip +\n\t\t\tMPI_FRAME_START_OFFSET +\n\t\t\t(cmd_credit * ioc->request_sz) + (index * sizeof(u32));\n\n\twritel(reply, reply_free_iomem);\n}\n\n/**\n * _base_clone_mpi_to_sys_mem - Writes/copies MPI frames\n *\t\t\t\tto system/BAR0 region.\n *\n * @dst_iomem: Pointer to the destination location in BAR0 space.\n * @src: Pointer to the Source data.\n * @size: Size of data to be copied.\n */\nstatic void\n_base_clone_mpi_to_sys_mem(void *dst_iomem, void *src, u32 size)\n{\n\tint i;\n\tu32 *src_virt_mem = (u32 *)src;\n\n\tfor (i = 0; i < size/4; i++)\n\t\twritel((u32)src_virt_mem[i],\n\t\t\t\t(void __iomem *)dst_iomem + (i * 4));\n}\n\n/**\n * _base_clone_to_sys_mem - Writes/copies data to system/BAR0 region\n *\n * @dst_iomem: Pointer to the destination location in BAR0 space.\n * @src: Pointer to the Source data.\n * @size: Size of data to be copied.\n */\nstatic void\n_base_clone_to_sys_mem(void __iomem *dst_iomem, void *src, u32 size)\n{\n\tint i;\n\tu32 *src_virt_mem = (u32 *)(src);\n\n\tfor (i = 0; i < size/4; i++)\n\t\twritel((u32)src_virt_mem[i],\n\t\t\t(void __iomem *)dst_iomem + (i * 4));\n}\n\n/**\n * _base_get_chain - Calculates and Returns virtual chain address\n *\t\t\t for the provided smid in BAR0 space.\n *\n * @ioc: per adapter object\n * @smid: system request message index\n * @sge_chain_count: Scatter gather chain count.\n *\n * Return: the chain address.\n */\nstatic inline void __iomem*\n_base_get_chain(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\t\tu8 sge_chain_count)\n{\n\tvoid __iomem *base_chain, *chain_virt;\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\n\tbase_chain  = (void __iomem *)ioc->chip + MPI_FRAME_START_OFFSET +\n\t\t(cmd_credit * ioc->request_sz) +\n\t\tREPLY_FREE_POOL_SIZE;\n\tchain_virt = base_chain + (smid * ioc->facts.MaxChainDepth *\n\t\t\tioc->request_sz) + (sge_chain_count * ioc->request_sz);\n\treturn chain_virt;\n}\n\n/**\n * _base_get_chain_phys - Calculates and Returns physical address\n *\t\t\tin BAR0 for scatter gather chains, for\n *\t\t\tthe provided smid.\n *\n * @ioc: per adapter object\n * @smid: system request message index\n * @sge_chain_count: Scatter gather chain count.\n *\n * Return: Physical chain address.\n */\nstatic inline phys_addr_t\n_base_get_chain_phys(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\t\tu8 sge_chain_count)\n{\n\tphys_addr_t base_chain_phys, chain_phys;\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\n\tbase_chain_phys  = ioc->chip_phys + MPI_FRAME_START_OFFSET +\n\t\t(cmd_credit * ioc->request_sz) +\n\t\tREPLY_FREE_POOL_SIZE;\n\tchain_phys = base_chain_phys + (smid * ioc->facts.MaxChainDepth *\n\t\t\tioc->request_sz) + (sge_chain_count * ioc->request_sz);\n\treturn chain_phys;\n}\n\n/**\n * _base_get_buffer_bar0 - Calculates and Returns BAR0 mapped Host\n *\t\t\tbuffer address for the provided smid.\n *\t\t\t(Each smid can have 64K starts from 17024)\n *\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: Pointer to buffer location in BAR0.\n */\n\nstatic void __iomem *\n_base_get_buffer_bar0(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\t// Added extra 1 to reach end of chain.\n\tvoid __iomem *chain_end = _base_get_chain(ioc,\n\t\t\tcmd_credit + 1,\n\t\t\tioc->facts.MaxChainDepth);\n\treturn chain_end + (smid * 64 * 1024);\n}\n\n/**\n * _base_get_buffer_phys_bar0 - Calculates and Returns BAR0 mapped\n *\t\tHost buffer Physical address for the provided smid.\n *\t\t(Each smid can have 64K starts from 17024)\n *\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: Pointer to buffer location in BAR0.\n */\nstatic phys_addr_t\n_base_get_buffer_phys_bar0(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tu16 cmd_credit = ioc->facts.RequestCredit + 1;\n\tphys_addr_t chain_end_phys = _base_get_chain_phys(ioc,\n\t\t\tcmd_credit + 1,\n\t\t\tioc->facts.MaxChainDepth);\n\treturn chain_end_phys + (smid * 64 * 1024);\n}\n\n/**\n * _base_get_chain_buffer_dma_to_chain_buffer - Iterates chain\n *\t\t\tlookup list and Provides chain_buffer\n *\t\t\taddress for the matching dma address.\n *\t\t\t(Each smid can have 64K starts from 17024)\n *\n * @ioc: per adapter object\n * @chain_buffer_dma: Chain buffer dma address.\n *\n * Return: Pointer to chain buffer. Or Null on Failure.\n */\nstatic void *\n_base_get_chain_buffer_dma_to_chain_buffer(struct MPT3SAS_ADAPTER *ioc,\n\t\tdma_addr_t chain_buffer_dma)\n{\n\tu16 index, j;\n\tstruct chain_tracker *ct;\n\n\tfor (index = 0; index < ioc->scsiio_depth; index++) {\n\t\tfor (j = 0; j < ioc->chains_needed_per_io; j++) {\n\t\t\tct = &ioc->chain_lookup[index].chains_per_smid[j];\n\t\t\tif (ct && ct->chain_buffer_dma == chain_buffer_dma)\n\t\t\t\treturn ct->chain_buffer;\n\t\t}\n\t}\n\tioc_info(ioc, \"Provided chain_buffer_dma address is not in the lookup list\\n\");\n\treturn NULL;\n}\n\n/**\n * _clone_sg_entries -\tMPI EP's scsiio and config requests\n *\t\t\tare handled here. Base function for\n *\t\t\tdouble buffering, before submitting\n *\t\t\tthe requests.\n *\n * @ioc: per adapter object.\n * @mpi_request: mf request pointer.\n * @smid: system request message index.\n */\nstatic void _clone_sg_entries(struct MPT3SAS_ADAPTER *ioc,\n\t\tvoid *mpi_request, u16 smid)\n{\n\tMpi2SGESimple32_t *sgel, *sgel_next;\n\tu32  sgl_flags, sge_chain_count = 0;\n\tbool is_write = false;\n\tu16 i = 0;\n\tvoid __iomem *buffer_iomem;\n\tphys_addr_t buffer_iomem_phys;\n\tvoid __iomem *buff_ptr;\n\tphys_addr_t buff_ptr_phys;\n\tvoid __iomem *dst_chain_addr[MCPU_MAX_CHAINS_PER_IO];\n\tvoid *src_chain_addr[MCPU_MAX_CHAINS_PER_IO];\n\tphys_addr_t dst_addr_phys;\n\tMPI2RequestHeader_t *request_hdr;\n\tstruct scsi_cmnd *scmd;\n\tstruct scatterlist *sg_scmd = NULL;\n\tint is_scsiio_req = 0;\n\n\trequest_hdr = (MPI2RequestHeader_t *) mpi_request;\n\n\tif (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST) {\n\t\tMpi25SCSIIORequest_t *scsiio_request =\n\t\t\t(Mpi25SCSIIORequest_t *)mpi_request;\n\t\tsgel = (Mpi2SGESimple32_t *) &scsiio_request->SGL;\n\t\tis_scsiio_req = 1;\n\t} else if (request_hdr->Function == MPI2_FUNCTION_CONFIG) {\n\t\tMpi2ConfigRequest_t  *config_req =\n\t\t\t(Mpi2ConfigRequest_t *)mpi_request;\n\t\tsgel = (Mpi2SGESimple32_t *) &config_req->PageBufferSGE;\n\t} else\n\t\treturn;\n\n\t/* From smid we can get scsi_cmd, once we have sg_scmd,\n\t * we just need to get sg_virt and sg_next to get virual\n\t * address associated with sgel->Address.\n\t */\n\n\tif (is_scsiio_req) {\n\t\t/* Get scsi_cmd using smid */\n\t\tscmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\t\tif (scmd == NULL) {\n\t\t\tioc_err(ioc, \"scmd is NULL\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* Get sg_scmd from scmd provided */\n\t\tsg_scmd = scsi_sglist(scmd);\n\t}\n\n\t/*\n\t * 0 - 255\tSystem register\n\t * 256 - 4352\tMPI Frame. (This is based on maxCredit 32)\n\t * 4352 - 4864\tReply_free pool (512 byte is reserved\n\t *\t\tconsidering maxCredit 32. Reply need extra\n\t *\t\troom, for mCPU case kept four times of\n\t *\t\tmaxCredit).\n\t * 4864 - 17152\tSGE chain element. (32cmd * 3 chain of\n\t *\t\t128 byte size = 12288)\n\t * 17152 - x\tHost buffer mapped with smid.\n\t *\t\t(Each smid can have 64K Max IO.)\n\t * BAR0+Last 1K MSIX Addr and Data\n\t * Total size in use 2113664 bytes of 4MB BAR0\n\t */\n\n\tbuffer_iomem = _base_get_buffer_bar0(ioc, smid);\n\tbuffer_iomem_phys = _base_get_buffer_phys_bar0(ioc, smid);\n\n\tbuff_ptr = buffer_iomem;\n\tbuff_ptr_phys = buffer_iomem_phys;\n\tWARN_ON(buff_ptr_phys > U32_MAX);\n\n\tif (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t(MPI2_SGE_FLAGS_HOST_TO_IOC << MPI2_SGE_FLAGS_SHIFT))\n\t\tis_write = true;\n\n\tfor (i = 0; i < MPT_MIN_PHYS_SEGMENTS + ioc->facts.MaxChainDepth; i++) {\n\n\t\tsgl_flags =\n\t\t    (le32_to_cpu(sgel->FlagsLength) >> MPI2_SGE_FLAGS_SHIFT);\n\n\t\tswitch (sgl_flags & MPI2_SGE_FLAGS_ELEMENT_MASK) {\n\t\tcase MPI2_SGE_FLAGS_CHAIN_ELEMENT:\n\t\t\t/*\n\t\t\t * Helper function which on passing\n\t\t\t * chain_buffer_dma returns chain_buffer. Get\n\t\t\t * the virtual address for sgel->Address\n\t\t\t */\n\t\t\tsgel_next =\n\t\t\t\t_base_get_chain_buffer_dma_to_chain_buffer(ioc,\n\t\t\t\t\t\tle32_to_cpu(sgel->Address));\n\t\t\tif (sgel_next == NULL)\n\t\t\t\treturn;\n\t\t\t/*\n\t\t\t * This is coping 128 byte chain\n\t\t\t * frame (not a host buffer)\n\t\t\t */\n\t\t\tdst_chain_addr[sge_chain_count] =\n\t\t\t\t_base_get_chain(ioc,\n\t\t\t\t\tsmid, sge_chain_count);\n\t\t\tsrc_chain_addr[sge_chain_count] =\n\t\t\t\t\t\t(void *) sgel_next;\n\t\t\tdst_addr_phys = _base_get_chain_phys(ioc,\n\t\t\t\t\t\tsmid, sge_chain_count);\n\t\t\tWARN_ON(dst_addr_phys > U32_MAX);\n\t\t\tsgel->Address =\n\t\t\t\tcpu_to_le32(lower_32_bits(dst_addr_phys));\n\t\t\tsgel = sgel_next;\n\t\t\tsge_chain_count++;\n\t\t\tbreak;\n\t\tcase MPI2_SGE_FLAGS_SIMPLE_ELEMENT:\n\t\t\tif (is_write) {\n\t\t\t\tif (is_scsiio_req) {\n\t\t\t\t\t_base_clone_to_sys_mem(buff_ptr,\n\t\t\t\t\t    sg_virt(sg_scmd),\n\t\t\t\t\t    (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t\t\t    0x00ffffff));\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: this relies on a a zero\n\t\t\t\t\t * PCI mem_offset.\n\t\t\t\t\t */\n\t\t\t\t\tsgel->Address =\n\t\t\t\t\t    cpu_to_le32((u32)buff_ptr_phys);\n\t\t\t\t} else {\n\t\t\t\t\t_base_clone_to_sys_mem(buff_ptr,\n\t\t\t\t\t    ioc->config_vaddr,\n\t\t\t\t\t    (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t\t\t    0x00ffffff));\n\t\t\t\t\tsgel->Address =\n\t\t\t\t\t    cpu_to_le32((u32)buff_ptr_phys);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuff_ptr += (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t    0x00ffffff);\n\t\t\tbuff_ptr_phys += (le32_to_cpu(sgel->FlagsLength) &\n\t\t\t    0x00ffffff);\n\t\t\tif ((le32_to_cpu(sgel->FlagsLength) &\n\t\t\t    (MPI2_SGE_FLAGS_END_OF_BUFFER\n\t\t\t\t\t<< MPI2_SGE_FLAGS_SHIFT)))\n\t\t\t\tgoto eob_clone_chain;\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * Every single element in MPT will have\n\t\t\t\t * associated sg_next. Better to sanity that\n\t\t\t\t * sg_next is not NULL, but it will be a bug\n\t\t\t\t * if it is null.\n\t\t\t\t */\n\t\t\t\tif (is_scsiio_req) {\n\t\t\t\t\tsg_scmd = sg_next(sg_scmd);\n\t\t\t\t\tif (sg_scmd)\n\t\t\t\t\t\tsgel++;\n\t\t\t\t\telse\n\t\t\t\t\t\tgoto eob_clone_chain;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\neob_clone_chain:\n\tfor (i = 0; i < sge_chain_count; i++) {\n\t\tif (is_scsiio_req)\n\t\t\t_base_clone_to_sys_mem(dst_chain_addr[i],\n\t\t\t\tsrc_chain_addr[i], ioc->request_sz);\n\t}\n}\n\n/**\n *  mpt3sas_remove_dead_ioc_func - kthread context to remove dead ioc\n * @arg: input argument, used to derive ioc\n *\n * Return:\n * 0 if controller is removed from pci subsystem.\n * -1 for other case.\n */\nstatic int mpt3sas_remove_dead_ioc_func(void *arg)\n{\n\tstruct MPT3SAS_ADAPTER *ioc = (struct MPT3SAS_ADAPTER *)arg;\n\tstruct pci_dev *pdev;\n\n\tif (!ioc)\n\t\treturn -1;\n\n\tpdev = ioc->pdev;\n\tif (!pdev)\n\t\treturn -1;\n\tpci_stop_and_remove_bus_device_locked(pdev);\n\treturn 0;\n}\n\n/**\n * _base_sync_drv_fw_timestamp - Sync Drive-Fw TimeStamp.\n * @ioc: Per Adapter Object\n *\n * Return nothing.\n */\nstatic void _base_sync_drv_fw_timestamp(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26IoUnitControlRequest_t *mpi_request;\n\tMpi26IoUnitControlReply_t *mpi_reply;\n\tu16 smid;\n\tktime_t current_time;\n\tu64 TimeStamp = 0;\n\tu8 issue_reset = 0;\n\n\tmutex_lock(&ioc->scsih_cmds.mutex);\n\tif (ioc->scsih_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"scsih_cmd in use %s\\n\", __func__);\n\t\tgoto out;\n\t}\n\tioc->scsih_cmds.status = MPT3_CMD_PENDING;\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->scsih_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"Failed obtaining a smid %s\\n\", __func__);\n\t\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\t\tgoto out;\n\t}\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->scsih_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi26IoUnitControlRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_IO_UNIT_CONTROL;\n\tmpi_request->Operation = MPI26_CTRL_OP_SET_IOC_PARAMETER;\n\tmpi_request->IOCParameter = MPI26_SET_IOC_PARAMETER_SYNC_TIMESTAMP;\n\tcurrent_time = ktime_get_real();\n\tTimeStamp = ktime_to_ms(current_time);\n\tmpi_request->Reserved7 = cpu_to_le32(TimeStamp & 0xFFFFFFFF);\n\tmpi_request->IOCParameterValue = cpu_to_le32(TimeStamp >> 32);\n\tinit_completion(&ioc->scsih_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"Io Unit Control Sync TimeStamp (sending), @time %lld ms\\n\",\n\t    TimeStamp));\n\twait_for_completion_timeout(&ioc->scsih_cmds.done,\n\t\tMPT3SAS_TIMESYNC_TIMEOUT_SECONDS*HZ);\n\tif (!(ioc->scsih_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->scsih_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2SasIoUnitControlRequest_t)/4, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\tif (ioc->scsih_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\tmpi_reply = ioc->scsih_cmds.reply;\n\t\tdinitprintk(ioc, ioc_info(ioc,\n\t\t    \"Io Unit Control sync timestamp (complete): ioc_status(0x%04x), loginfo(0x%08x)\\n\",\n\t\t    le16_to_cpu(mpi_reply->IOCStatus),\n\t\t    le32_to_cpu(mpi_reply->IOCLogInfo)));\n\t}\nissue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\nout:\n\tmutex_unlock(&ioc->scsih_cmds.mutex);\n}\n\n/**\n * _base_fault_reset_work - workq handling ioc fault conditions\n * @work: input argument, used to derive ioc\n *\n * Context: sleep.\n */\nstatic void\n_base_fault_reset_work(struct work_struct *work)\n{\n\tstruct MPT3SAS_ADAPTER *ioc =\n\t    container_of(work, struct MPT3SAS_ADAPTER, fault_reset_work.work);\n\tunsigned long\t flags;\n\tu32 doorbell;\n\tint rc;\n\tstruct task_struct *p;\n\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tif ((ioc->shost_recovery && (ioc->ioc_coredump_loop == 0)) ||\n\t\t\tioc->pci_error_recovery)\n\t\tgoto rearm_timer;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\n\tdoorbell = mpt3sas_base_get_iocstate(ioc, 0);\n\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_MASK) {\n\t\tioc_err(ioc, \"SAS host is non-operational !!!!\\n\");\n\n\t\t/* It may be possible that EEH recovery can resolve some of\n\t\t * pci bus failure issues rather removing the dead ioc function\n\t\t * by considering controller is in a non-operational state. So\n\t\t * here priority is given to the EEH recovery. If it doesn't\n\t\t * not resolve this issue, mpt3sas driver will consider this\n\t\t * controller to non-operational state and remove the dead ioc\n\t\t * function.\n\t\t */\n\t\tif (ioc->non_operational_loop++ < 5) {\n\t\t\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock,\n\t\t\t\t\t\t\t flags);\n\t\t\tgoto rearm_timer;\n\t\t}\n\n\t\t/*\n\t\t * Call _scsih_flush_pending_cmds callback so that we flush all\n\t\t * pending commands back to OS. This call is required to aovid\n\t\t * deadlock at block layer. Dead IOC will fail to do diag reset,\n\t\t * and this call is safe since dead ioc will never return any\n\t\t * command back from HW.\n\t\t */\n\t\tioc->schedule_dead_ioc_flush_running_cmds(ioc);\n\t\t/*\n\t\t * Set remove_host flag early since kernel thread will\n\t\t * take some time to execute.\n\t\t */\n\t\tioc->remove_host = 1;\n\t\t/*Remove the Dead Host */\n\t\tp = kthread_run(mpt3sas_remove_dead_ioc_func, ioc,\n\t\t    \"%s_dead_ioc_%d\", ioc->driver_name, ioc->id);\n\t\tif (IS_ERR(p))\n\t\t\tioc_err(ioc, \"%s: Running mpt3sas_dead_ioc thread failed !!!!\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tioc_err(ioc, \"%s: Running mpt3sas_dead_ioc thread success !!!!\\n\",\n\t\t\t\t__func__);\n\t\treturn; /* don't rearm timer */\n\t}\n\n\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_COREDUMP) {\n\t\tu8 timeout = (ioc->manu_pg11.CoreDumpTOSec) ?\n\t\t    ioc->manu_pg11.CoreDumpTOSec :\n\t\t    MPT3SAS_DEFAULT_COREDUMP_TIMEOUT_SECONDS;\n\n\t\ttimeout /= (FAULT_POLLING_INTERVAL/1000);\n\n\t\tif (ioc->ioc_coredump_loop == 0) {\n\t\t\tmpt3sas_print_coredump_info(ioc,\n\t\t\t    doorbell & MPI2_DOORBELL_DATA_MASK);\n\t\t\t/* do not accept any IOs and disable the interrupts */\n\t\t\tspin_lock_irqsave(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tioc->shost_recovery = 1;\n\t\t\tspin_unlock_irqrestore(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tmpt3sas_base_mask_interrupts(ioc);\n\t\t\t_base_clear_outstanding_commands(ioc);\n\t\t}\n\n\t\tioc_info(ioc, \"%s: CoreDump loop %d.\",\n\t\t    __func__, ioc->ioc_coredump_loop);\n\n\t\t/* Wait until CoreDump completes or times out */\n\t\tif (ioc->ioc_coredump_loop++ < timeout) {\n\t\t\tspin_lock_irqsave(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tgoto rearm_timer;\n\t\t}\n\t}\n\n\tif (ioc->ioc_coredump_loop) {\n\t\tif ((doorbell & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_COREDUMP)\n\t\t\tioc_err(ioc, \"%s: CoreDump completed. LoopCount: %d\",\n\t\t\t    __func__, ioc->ioc_coredump_loop);\n\t\telse\n\t\t\tioc_err(ioc, \"%s: CoreDump Timed out. LoopCount: %d\",\n\t\t\t    __func__, ioc->ioc_coredump_loop);\n\t\tioc->ioc_coredump_loop = MPT3SAS_COREDUMP_LOOP_DONE;\n\t}\n\tioc->non_operational_loop = 0;\n\tif ((doorbell & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL) {\n\t\trc = mpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\t\tioc_warn(ioc, \"%s: hard reset: %s\\n\",\n\t\t\t __func__, rc == 0 ? \"success\" : \"failed\");\n\t\tdoorbell = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\t\tmpt3sas_print_fault_code(ioc, doorbell &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\t} else if ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t    MPI2_IOC_STATE_COREDUMP)\n\t\t\tmpt3sas_print_coredump_info(ioc, doorbell &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tif (rc && (doorbell & MPI2_IOC_STATE_MASK) !=\n\t\t    MPI2_IOC_STATE_OPERATIONAL)\n\t\t\treturn; /* don't rearm timer */\n\t}\n\tioc->ioc_coredump_loop = 0;\n\tif (ioc->time_sync_interval &&\n\t    ++ioc->timestamp_update_count >= ioc->time_sync_interval) {\n\t\tioc->timestamp_update_count = 0;\n\t\t_base_sync_drv_fw_timestamp(ioc);\n\t}\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n rearm_timer:\n\tif (ioc->fault_reset_work_q)\n\t\tqueue_delayed_work(ioc->fault_reset_work_q,\n\t\t    &ioc->fault_reset_work,\n\t\t    msecs_to_jiffies(FAULT_POLLING_INTERVAL));\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n}\n\n/**\n * mpt3sas_base_start_watchdog - start the fault_reset_work_q\n * @ioc: per adapter object\n *\n * Context: sleep.\n */\nvoid\nmpt3sas_base_start_watchdog(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned long\t flags;\n\n\tif (ioc->fault_reset_work_q)\n\t\treturn;\n\n\tioc->timestamp_update_count = 0;\n\t/* initialize fault polling */\n\n\tINIT_DELAYED_WORK(&ioc->fault_reset_work, _base_fault_reset_work);\n\tsnprintf(ioc->fault_reset_work_q_name,\n\t    sizeof(ioc->fault_reset_work_q_name), \"poll_%s%d_status\",\n\t    ioc->driver_name, ioc->id);\n\tioc->fault_reset_work_q =\n\t\tcreate_singlethread_workqueue(ioc->fault_reset_work_q_name);\n\tif (!ioc->fault_reset_work_q) {\n\t\tioc_err(ioc, \"%s: failed (line=%d)\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tif (ioc->fault_reset_work_q)\n\t\tqueue_delayed_work(ioc->fault_reset_work_q,\n\t\t    &ioc->fault_reset_work,\n\t\t    msecs_to_jiffies(FAULT_POLLING_INTERVAL));\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n}\n\n/**\n * mpt3sas_base_stop_watchdog - stop the fault_reset_work_q\n * @ioc: per adapter object\n *\n * Context: sleep.\n */\nvoid\nmpt3sas_base_stop_watchdog(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned long flags;\n\tstruct workqueue_struct *wq;\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\twq = ioc->fault_reset_work_q;\n\tioc->fault_reset_work_q = NULL;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\tif (wq) {\n\t\tif (!cancel_delayed_work_sync(&ioc->fault_reset_work))\n\t\t\tflush_workqueue(wq);\n\t\tdestroy_workqueue(wq);\n\t}\n}\n\n/**\n * mpt3sas_base_fault_info - verbose translation of firmware FAULT code\n * @ioc: per adapter object\n * @fault_code: fault code\n */\nvoid\nmpt3sas_base_fault_info(struct MPT3SAS_ADAPTER *ioc , u16 fault_code)\n{\n\tioc_err(ioc, \"fault_state(0x%04x)!\\n\", fault_code);\n}\n\n/**\n * mpt3sas_base_coredump_info - verbose translation of firmware CoreDump state\n * @ioc: per adapter object\n * @fault_code: fault code\n *\n * Return nothing.\n */\nvoid\nmpt3sas_base_coredump_info(struct MPT3SAS_ADAPTER *ioc, u16 fault_code)\n{\n\tioc_err(ioc, \"coredump_state(0x%04x)!\\n\", fault_code);\n}\n\n/**\n * mpt3sas_base_wait_for_coredump_completion - Wait until coredump\n * completes or times out\n * @ioc: per adapter object\n * @caller: caller function name\n *\n * Returns 0 for success, non-zero for failure.\n */\nint\nmpt3sas_base_wait_for_coredump_completion(struct MPT3SAS_ADAPTER *ioc,\n\t\tconst char *caller)\n{\n\tu8 timeout = (ioc->manu_pg11.CoreDumpTOSec) ?\n\t\t\tioc->manu_pg11.CoreDumpTOSec :\n\t\t\tMPT3SAS_DEFAULT_COREDUMP_TIMEOUT_SECONDS;\n\n\tint ioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_FAULT,\n\t\t\t\t\ttimeout);\n\n\tif (ioc_state)\n\t\tioc_err(ioc,\n\t\t    \"%s: CoreDump timed out. (ioc_state=0x%x)\\n\",\n\t\t    caller, ioc_state);\n\telse\n\t\tioc_info(ioc,\n\t\t    \"%s: CoreDump completed. (ioc_state=0x%x)\\n\",\n\t\t    caller, ioc_state);\n\n\treturn ioc_state;\n}\n\n/**\n * mpt3sas_halt_firmware - halt's mpt controller firmware\n * @ioc: per adapter object\n *\n * For debugging timeout related issues.  Writing 0xCOFFEE00\n * to the doorbell register will halt controller firmware. With\n * the purpose to stop both driver and firmware, the enduser can\n * obtain a ring buffer from controller UART.\n */\nvoid\nmpt3sas_halt_firmware(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 doorbell;\n\n\tif (!ioc->fwfault_debug)\n\t\treturn;\n\n\tdump_stack();\n\n\tdoorbell = ioc->base_readl(&ioc->chip->Doorbell);\n\tif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, doorbell &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t} else if ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tmpt3sas_print_coredump_info(ioc, doorbell &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t} else {\n\t\twritel(0xC0FFEE00, &ioc->chip->Doorbell);\n\t\tioc_err(ioc, \"Firmware is halted due to command timeout\\n\");\n\t}\n\n\tif (ioc->fwfault_debug == 2)\n\t\tfor (;;)\n\t\t\t;\n\telse\n\t\tpanic(\"panic in %s\\n\", __func__);\n}\n\n/**\n * _base_sas_ioc_info - verbose translation of the ioc status\n * @ioc: per adapter object\n * @mpi_reply: reply mf payload returned from firmware\n * @request_hdr: request mf\n */\nstatic void\n_base_sas_ioc_info(struct MPT3SAS_ADAPTER *ioc, MPI2DefaultReply_t *mpi_reply,\n\tMPI2RequestHeader_t *request_hdr)\n{\n\tu16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tchar *desc = NULL;\n\tu16 frame_sz;\n\tchar *func_str = NULL;\n\n\t/* SCSI_IO, RAID_PASS are handled from _scsih_scsi_ioc_info */\n\tif (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\n\t    request_hdr->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||\n\t    request_hdr->Function == MPI2_FUNCTION_EVENT_NOTIFICATION)\n\t\treturn;\n\n\tif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\n\t\treturn;\n\t/*\n\t * Older Firmware version doesn't support driver trigger pages.\n\t * So, skip displaying 'config invalid type' type\n\t * of error message.\n\t */\n\tif (request_hdr->Function == MPI2_FUNCTION_CONFIG) {\n\t\tMpi2ConfigRequest_t *rqst = (Mpi2ConfigRequest_t *)request_hdr;\n\n\t\tif ((rqst->ExtPageType ==\n\t\t    MPI2_CONFIG_EXTPAGETYPE_DRIVER_PERSISTENT_TRIGGER) &&\n\t\t    !(ioc->logging_level & MPT_DEBUG_CONFIG)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (ioc_status) {\n\n/****************************************************************************\n*  Common IOCStatus values for all replies\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_INVALID_FUNCTION:\n\t\tdesc = \"invalid function\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_BUSY:\n\t\tdesc = \"busy\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_SGL:\n\t\tdesc = \"invalid sgl\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INTERNAL_ERROR:\n\t\tdesc = \"internal error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_VPID:\n\t\tdesc = \"invalid vpid\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:\n\t\tdesc = \"insufficient resources\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INSUFFICIENT_POWER:\n\t\tdesc = \"insufficient power\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_FIELD:\n\t\tdesc = \"invalid field\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_INVALID_STATE:\n\t\tdesc = \"invalid state\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_OP_STATE_NOT_SUPPORTED:\n\t\tdesc = \"op state not supported\";\n\t\tbreak;\n\n/****************************************************************************\n*  Config IOCStatus values\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_ACTION:\n\t\tdesc = \"config invalid action\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_TYPE:\n\t\tdesc = \"config invalid type\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_PAGE:\n\t\tdesc = \"config invalid page\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_INVALID_DATA:\n\t\tdesc = \"config invalid data\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_NO_DEFAULTS:\n\t\tdesc = \"config no defaults\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_CONFIG_CANT_COMMIT:\n\t\tdesc = \"config cant commit\";\n\t\tbreak;\n\n/****************************************************************************\n*  SCSI IO Reply\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:\n\tcase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\n\tcase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\n\tcase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\n\tcase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\n\tcase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\n\tcase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\n\tcase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\n\tcase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\n\tcase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\n\t\tbreak;\n\n/****************************************************************************\n*  For use by SCSI Initiator and SCSI Target end-to-end data protection\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\n\t\tdesc = \"eedp guard error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\n\t\tdesc = \"eedp ref tag error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\n\t\tdesc = \"eedp app tag error\";\n\t\tbreak;\n\n/****************************************************************************\n*  SCSI Target values\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_TARGET_INVALID_IO_INDEX:\n\t\tdesc = \"target invalid io index\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_ABORTED:\n\t\tdesc = \"target aborted\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_NO_CONN_RETRYABLE:\n\t\tdesc = \"target no conn retryable\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_NO_CONNECTION:\n\t\tdesc = \"target no connection\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:\n\t\tdesc = \"target xfer count mismatch\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:\n\t\tdesc = \"target data offset error\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:\n\t\tdesc = \"target too much write data\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_IU_TOO_SHORT:\n\t\tdesc = \"target iu too short\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT:\n\t\tdesc = \"target ack nak timeout\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_TARGET_NAK_RECEIVED:\n\t\tdesc = \"target nak received\";\n\t\tbreak;\n\n/****************************************************************************\n*  Serial Attached SCSI values\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_SAS_SMP_REQUEST_FAILED:\n\t\tdesc = \"smp request failed\";\n\t\tbreak;\n\tcase MPI2_IOCSTATUS_SAS_SMP_DATA_OVERRUN:\n\t\tdesc = \"smp data overrun\";\n\t\tbreak;\n\n/****************************************************************************\n*  Diagnostic Buffer Post / Diagnostic Release values\n****************************************************************************/\n\n\tcase MPI2_IOCSTATUS_DIAGNOSTIC_RELEASED:\n\t\tdesc = \"diagnostic released\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tswitch (request_hdr->Function) {\n\tcase MPI2_FUNCTION_CONFIG:\n\t\tframe_sz = sizeof(Mpi2ConfigRequest_t) + ioc->sge_size;\n\t\tfunc_str = \"config_page\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SCSI_TASK_MGMT:\n\t\tframe_sz = sizeof(Mpi2SCSITaskManagementRequest_t);\n\t\tfunc_str = \"task_mgmt\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\n\t\tframe_sz = sizeof(Mpi2SasIoUnitControlRequest_t);\n\t\tfunc_str = \"sas_iounit_ctl\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\n\t\tframe_sz = sizeof(Mpi2SepRequest_t);\n\t\tfunc_str = \"enclosure\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_IOC_INIT:\n\t\tframe_sz = sizeof(Mpi2IOCInitRequest_t);\n\t\tfunc_str = \"ioc_init\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_PORT_ENABLE:\n\t\tframe_sz = sizeof(Mpi2PortEnableRequest_t);\n\t\tfunc_str = \"port_enable\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_SMP_PASSTHROUGH:\n\t\tframe_sz = sizeof(Mpi2SmpPassthroughRequest_t) + ioc->sge_size;\n\t\tfunc_str = \"smp_passthru\";\n\t\tbreak;\n\tcase MPI2_FUNCTION_NVME_ENCAPSULATED:\n\t\tframe_sz = sizeof(Mpi26NVMeEncapsulatedRequest_t) +\n\t\t    ioc->sge_size;\n\t\tfunc_str = \"nvme_encapsulated\";\n\t\tbreak;\n\tdefault:\n\t\tframe_sz = 32;\n\t\tfunc_str = \"unknown\";\n\t\tbreak;\n\t}\n\n\tioc_warn(ioc, \"ioc_status: %s(0x%04x), request(0x%p),(%s)\\n\",\n\t\t desc, ioc_status, request_hdr, func_str);\n\n\t_debug_dump_mf(request_hdr, frame_sz/4);\n}\n\n/**\n * _base_display_event_data - verbose translation of firmware asyn events\n * @ioc: per adapter object\n * @mpi_reply: reply mf payload returned from firmware\n */\nstatic void\n_base_display_event_data(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2EventNotificationReply_t *mpi_reply)\n{\n\tchar *desc = NULL;\n\tu16 event;\n\n\tif (!(ioc->logging_level & MPT_DEBUG_EVENTS))\n\t\treturn;\n\n\tevent = le16_to_cpu(mpi_reply->Event);\n\n\tswitch (event) {\n\tcase MPI2_EVENT_LOG_DATA:\n\t\tdesc = \"Log Data\";\n\t\tbreak;\n\tcase MPI2_EVENT_STATE_CHANGE:\n\t\tdesc = \"Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_HARD_RESET_RECEIVED:\n\t\tdesc = \"Hard Reset Received\";\n\t\tbreak;\n\tcase MPI2_EVENT_EVENT_CHANGE:\n\t\tdesc = \"Event Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_OPERATION_STATUS:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Operation Status\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DISCOVERY:\n\t{\n\t\tMpi2EventDataSasDiscovery_t *event_data =\n\t\t    (Mpi2EventDataSasDiscovery_t *)mpi_reply->EventData;\n\t\tioc_info(ioc, \"Discovery: (%s)\",\n\t\t\t event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED ?\n\t\t\t \"start\" : \"stop\");\n\t\tif (event_data->DiscoveryStatus)\n\t\t\tpr_cont(\" discovery_status(0x%08x)\",\n\t\t\t    le32_to_cpu(event_data->DiscoveryStatus));\n\t\tpr_cont(\"\\n\");\n\t\treturn;\n\t}\n\tcase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\n\t\tdesc = \"SAS Broadcast Primitive\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"SAS Init Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_INIT_TABLE_OVERFLOW:\n\t\tdesc = \"SAS Init Table Overflow\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\n\t\tdesc = \"SAS Topology Change List\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"SAS Enclosure Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_VOLUME:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Volume\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_PHYSICAL_DISK:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Physical Disk\";\n\t\tbreak;\n\tcase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"IR Configuration Change List\";\n\t\tbreak;\n\tcase MPI2_EVENT_LOG_ENTRY_ADDED:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\tdesc = \"Log Entry Added\";\n\t\tbreak;\n\tcase MPI2_EVENT_TEMP_THRESHOLD:\n\t\tdesc = \"Temperature Threshold\";\n\t\tbreak;\n\tcase MPI2_EVENT_ACTIVE_CABLE_EXCEPTION:\n\t\tdesc = \"Cable Event\";\n\t\tbreak;\n\tcase MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR:\n\t\tdesc = \"SAS Device Discovery Error\";\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE:\n\t\tdesc = \"PCIE Device Status Change\";\n\t\tbreak;\n\tcase MPI2_EVENT_PCIE_ENUMERATION:\n\t{\n\t\tMpi26EventDataPCIeEnumeration_t *event_data =\n\t\t\t(Mpi26EventDataPCIeEnumeration_t *)mpi_reply->EventData;\n\t\tioc_info(ioc, \"PCIE Enumeration: (%s)\",\n\t\t\t event_data->ReasonCode == MPI26_EVENT_PCIE_ENUM_RC_STARTED ?\n\t\t\t \"start\" : \"stop\");\n\t\tif (event_data->EnumerationStatus)\n\t\t\tpr_cont(\"enumeration_status(0x%08x)\",\n\t\t\t\tle32_to_cpu(event_data->EnumerationStatus));\n\t\tpr_cont(\"\\n\");\n\t\treturn;\n\t}\n\tcase MPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST:\n\t\tdesc = \"PCIE Topology Change List\";\n\t\tbreak;\n\t}\n\n\tif (!desc)\n\t\treturn;\n\n\tioc_info(ioc, \"%s\\n\", desc);\n}\n\n/**\n * _base_sas_log_info - verbose translation of firmware log info\n * @ioc: per adapter object\n * @log_info: log info\n */\nstatic void\n_base_sas_log_info(struct MPT3SAS_ADAPTER *ioc , u32 log_info)\n{\n\tunion loginfo_type {\n\t\tu32\tloginfo;\n\t\tstruct {\n\t\t\tu32\tsubcode:16;\n\t\t\tu32\tcode:8;\n\t\t\tu32\toriginator:4;\n\t\t\tu32\tbus_type:4;\n\t\t} dw;\n\t};\n\tunion loginfo_type sas_loginfo;\n\tchar *originator_str = NULL;\n\n\tsas_loginfo.loginfo = log_info;\n\tif (sas_loginfo.dw.bus_type != 3 /*SAS*/)\n\t\treturn;\n\n\t/* each nexus loss loginfo */\n\tif (log_info == 0x31170000)\n\t\treturn;\n\n\t/* eat the loginfos associated with task aborts */\n\tif (ioc->ignore_loginfos && (log_info == 0x30050000 || log_info ==\n\t    0x31140000 || log_info == 0x31130000))\n\t\treturn;\n\n\tswitch (sas_loginfo.dw.originator) {\n\tcase 0:\n\t\toriginator_str = \"IOP\";\n\t\tbreak;\n\tcase 1:\n\t\toriginator_str = \"PL\";\n\t\tbreak;\n\tcase 2:\n\t\tif (!ioc->hide_ir_msg)\n\t\t\toriginator_str = \"IR\";\n\t\telse\n\t\t\toriginator_str = \"WarpDrive\";\n\t\tbreak;\n\t}\n\n\tioc_warn(ioc, \"log_info(0x%08x): originator(%s), code(0x%02x), sub_code(0x%04x)\\n\",\n\t\t log_info,\n\t\t originator_str, sas_loginfo.dw.code, sas_loginfo.dw.subcode);\n}\n\n/**\n * _base_display_reply_info -\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n */\nstatic void\n_base_display_reply_info(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\tu16 ioc_status;\n\tu32 loginfo = 0;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (unlikely(!mpi_reply)) {\n\t\tioc_err(ioc, \"mpi_reply not valid at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus);\n\n\tif ((ioc_status & MPI2_IOCSTATUS_MASK) &&\n\t    (ioc->logging_level & MPT_DEBUG_REPLY)) {\n\t\t_base_sas_ioc_info(ioc , mpi_reply,\n\t\t   mpt3sas_base_get_msg_frame(ioc, smid));\n\t}\n\n\tif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {\n\t\tloginfo = le32_to_cpu(mpi_reply->IOCLogInfo);\n\t\t_base_sas_log_info(ioc, loginfo);\n\t}\n\n\tif (ioc_status || loginfo) {\n\t\tioc_status &= MPI2_IOCSTATUS_MASK;\n\t\tmpt3sas_trigger_mpi(ioc, ioc_status, loginfo);\n\t}\n}\n\n/**\n * mpt3sas_base_done - base internal command completion routine\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n *\n * Return:\n * 1 meaning mf should be freed from _base_interrupt\n * 0 means the mf is freed from this function.\n */\nu8\nmpt3sas_base_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (mpi_reply && mpi_reply->Function == MPI2_FUNCTION_EVENT_ACK)\n\t\treturn mpt3sas_check_for_pending_internal_cmds(ioc, smid);\n\n\tif (ioc->base_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\n\tioc->base_cmds.status |= MPT3_CMD_COMPLETE;\n\tif (mpi_reply) {\n\t\tioc->base_cmds.status |= MPT3_CMD_REPLY_VALID;\n\t\tmemcpy(ioc->base_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\t}\n\tioc->base_cmds.status &= ~MPT3_CMD_PENDING;\n\n\tcomplete(&ioc->base_cmds.done);\n\treturn 1;\n}\n\n/**\n * _base_async_event - main callback handler for firmware asyn events\n * @ioc: per adapter object\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n *\n * Return:\n * 1 meaning mf should be freed from _base_interrupt\n * 0 means the mf is freed from this function.\n */\nstatic u8\n_base_async_event(struct MPT3SAS_ADAPTER *ioc, u8 msix_index, u32 reply)\n{\n\tMpi2EventNotificationReply_t *mpi_reply;\n\tMpi2EventAckRequest_t *ack_request;\n\tu16 smid;\n\tstruct _event_ack_list *delayed_event_ack;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (!mpi_reply)\n\t\treturn 1;\n\tif (mpi_reply->Function != MPI2_FUNCTION_EVENT_NOTIFICATION)\n\t\treturn 1;\n\n\t_base_display_event_data(ioc, mpi_reply);\n\n\tif (!(mpi_reply->AckRequired & MPI2_EVENT_NOTIFICATION_ACK_REQUIRED))\n\t\tgoto out;\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tdelayed_event_ack = kzalloc(sizeof(*delayed_event_ack),\n\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!delayed_event_ack)\n\t\t\tgoto out;\n\t\tINIT_LIST_HEAD(&delayed_event_ack->list);\n\t\tdelayed_event_ack->Event = mpi_reply->Event;\n\t\tdelayed_event_ack->EventContext = mpi_reply->EventContext;\n\t\tlist_add_tail(&delayed_event_ack->list,\n\t\t\t\t&ioc->delayed_event_ack_list);\n\t\tdewtprintk(ioc,\n\t\t\t   ioc_info(ioc, \"DELAYED: EVENT ACK: event (0x%04x)\\n\",\n\t\t\t\t    le16_to_cpu(mpi_reply->Event)));\n\t\tgoto out;\n\t}\n\n\tack_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tmemset(ack_request, 0, sizeof(Mpi2EventAckRequest_t));\n\tack_request->Function = MPI2_FUNCTION_EVENT_ACK;\n\tack_request->Event = mpi_reply->Event;\n\tack_request->EventContext = mpi_reply->EventContext;\n\tack_request->VF_ID = 0;  /* TODO */\n\tack_request->VP_ID = 0;\n\tioc->put_smid_default(ioc, smid);\n\n out:\n\n\t/* scsih callback handler */\n\tmpt3sas_scsih_event_callback(ioc, msix_index, reply);\n\n\t/* ctl callback handler */\n\tmpt3sas_ctl_event_callback(ioc, msix_index, reply);\n\n\treturn 1;\n}\n\nstatic struct scsiio_tracker *\n_get_st_from_smid(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct scsi_cmnd *cmd;\n\n\tif (WARN_ON(!smid) ||\n\t    WARN_ON(smid >= ioc->hi_priority_smid))\n\t\treturn NULL;\n\n\tcmd = mpt3sas_scsih_scsi_lookup_get(ioc, smid);\n\tif (cmd)\n\t\treturn scsi_cmd_priv(cmd);\n\n\treturn NULL;\n}\n\n/**\n * _base_get_cb_idx - obtain the callback index\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: callback index.\n */\nstatic u8\n_base_get_cb_idx(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tint i;\n\tu16 ctl_smid = ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT + 1;\n\tu8 cb_idx = 0xFF;\n\n\tif (smid < ioc->hi_priority_smid) {\n\t\tstruct scsiio_tracker *st;\n\n\t\tif (smid < ctl_smid) {\n\t\t\tst = _get_st_from_smid(ioc, smid);\n\t\t\tif (st)\n\t\t\t\tcb_idx = st->cb_idx;\n\t\t} else if (smid == ctl_smid)\n\t\t\tcb_idx = ioc->ctl_cb_idx;\n\t} else if (smid < ioc->internal_smid) {\n\t\ti = smid - ioc->hi_priority_smid;\n\t\tcb_idx = ioc->hpr_lookup[i].cb_idx;\n\t} else if (smid <= ioc->hba_queue_depth) {\n\t\ti = smid - ioc->internal_smid;\n\t\tcb_idx = ioc->internal_lookup[i].cb_idx;\n\t}\n\treturn cb_idx;\n}\n\n/**\n * mpt3sas_base_mask_interrupts - disable interrupts\n * @ioc: per adapter object\n *\n * Disabling ResetIRQ, Reply and Doorbell Interrupts\n */\nvoid\nmpt3sas_base_mask_interrupts(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 him_register;\n\n\tioc->mask_interrupts = 1;\n\thim_register = ioc->base_readl(&ioc->chip->HostInterruptMask);\n\thim_register |= MPI2_HIM_DIM + MPI2_HIM_RIM + MPI2_HIM_RESET_IRQ_MASK;\n\twritel(him_register, &ioc->chip->HostInterruptMask);\n\tioc->base_readl(&ioc->chip->HostInterruptMask);\n}\n\n/**\n * mpt3sas_base_unmask_interrupts - enable interrupts\n * @ioc: per adapter object\n *\n * Enabling only Reply Interrupts\n */\nvoid\nmpt3sas_base_unmask_interrupts(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 him_register;\n\n\thim_register = ioc->base_readl(&ioc->chip->HostInterruptMask);\n\thim_register &= ~MPI2_HIM_RIM;\n\twritel(him_register, &ioc->chip->HostInterruptMask);\n\tioc->mask_interrupts = 0;\n}\n\nunion reply_descriptor {\n\tu64 word;\n\tstruct {\n\t\tu32 low;\n\t\tu32 high;\n\t} u;\n};\n\nstatic u32 base_mod64(u64 dividend, u32 divisor)\n{\n\tu32 remainder;\n\n\tif (!divisor)\n\t\tpr_err(\"mpt3sas: DIVISOR is zero, in div fn\\n\");\n\tremainder = do_div(dividend, divisor);\n\treturn remainder;\n}\n\n/**\n * _base_process_reply_queue - Process reply descriptors from reply\n *\t\tdescriptor post queue.\n * @reply_q: per IRQ's reply queue object.\n *\n * Return: number of reply descriptors processed from reply\n *\t\tdescriptor queue.\n */\nstatic int\n_base_process_reply_queue(struct adapter_reply_queue *reply_q)\n{\n\tunion reply_descriptor rd;\n\tu64 completed_cmds;\n\tu8 request_descript_type;\n\tu16 smid;\n\tu8 cb_idx;\n\tu32 reply;\n\tu8 msix_index = reply_q->msix_index;\n\tstruct MPT3SAS_ADAPTER *ioc = reply_q->ioc;\n\tMpi2ReplyDescriptorsUnion_t *rpf;\n\tu8 rc;\n\n\tcompleted_cmds = 0;\n\tif (!atomic_add_unless(&reply_q->busy, 1, 1))\n\t\treturn completed_cmds;\n\n\trpf = &reply_q->reply_post_free[reply_q->reply_post_host_index];\n\trequest_descript_type = rpf->Default.ReplyFlags\n\t     & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\n\tif (request_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED) {\n\t\tatomic_dec(&reply_q->busy);\n\t\treturn completed_cmds;\n\t}\n\n\tcb_idx = 0xFF;\n\tdo {\n\t\trd.word = le64_to_cpu(rpf->Words);\n\t\tif (rd.u.low == UINT_MAX || rd.u.high == UINT_MAX)\n\t\t\tgoto out;\n\t\treply = 0;\n\t\tsmid = le16_to_cpu(rpf->Default.DescriptorTypeDependent1);\n\t\tif (request_descript_type ==\n\t\t    MPI25_RPY_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO_SUCCESS ||\n\t\t    request_descript_type ==\n\t\t    MPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS ||\n\t\t    request_descript_type ==\n\t\t    MPI26_RPY_DESCRIPT_FLAGS_PCIE_ENCAPSULATED_SUCCESS) {\n\t\t\tcb_idx = _base_get_cb_idx(ioc, smid);\n\t\t\tif ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&\n\t\t\t    (likely(mpt_callbacks[cb_idx] != NULL))) {\n\t\t\t\trc = mpt_callbacks[cb_idx](ioc, smid,\n\t\t\t\t    msix_index, 0);\n\t\t\t\tif (rc)\n\t\t\t\t\tmpt3sas_base_free_smid(ioc, smid);\n\t\t\t}\n\t\t} else if (request_descript_type ==\n\t\t    MPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY) {\n\t\t\treply = le32_to_cpu(\n\t\t\t    rpf->AddressReply.ReplyFrameAddress);\n\t\t\tif (reply > ioc->reply_dma_max_address ||\n\t\t\t    reply < ioc->reply_dma_min_address)\n\t\t\t\treply = 0;\n\t\t\tif (smid) {\n\t\t\t\tcb_idx = _base_get_cb_idx(ioc, smid);\n\t\t\t\tif ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&\n\t\t\t\t    (likely(mpt_callbacks[cb_idx] != NULL))) {\n\t\t\t\t\trc = mpt_callbacks[cb_idx](ioc, smid,\n\t\t\t\t\t    msix_index, reply);\n\t\t\t\t\tif (reply)\n\t\t\t\t\t\t_base_display_reply_info(ioc,\n\t\t\t\t\t\t    smid, msix_index, reply);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tmpt3sas_base_free_smid(ioc,\n\t\t\t\t\t\t    smid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_base_async_event(ioc, msix_index, reply);\n\t\t\t}\n\n\t\t\t/* reply free queue handling */\n\t\t\tif (reply) {\n\t\t\t\tioc->reply_free_host_index =\n\t\t\t\t    (ioc->reply_free_host_index ==\n\t\t\t\t    (ioc->reply_free_queue_depth - 1)) ?\n\t\t\t\t    0 : ioc->reply_free_host_index + 1;\n\t\t\t\tioc->reply_free[ioc->reply_free_host_index] =\n\t\t\t\t    cpu_to_le32(reply);\n\t\t\t\tif (ioc->is_mcpu_endpoint)\n\t\t\t\t\t_base_clone_reply_to_sys_mem(ioc,\n\t\t\t\t\t\treply,\n\t\t\t\t\t\tioc->reply_free_host_index);\n\t\t\t\twritel(ioc->reply_free_host_index,\n\t\t\t\t    &ioc->chip->ReplyFreeHostIndex);\n\t\t\t}\n\t\t}\n\n\t\trpf->Words = cpu_to_le64(ULLONG_MAX);\n\t\treply_q->reply_post_host_index =\n\t\t    (reply_q->reply_post_host_index ==\n\t\t    (ioc->reply_post_queue_depth - 1)) ? 0 :\n\t\t    reply_q->reply_post_host_index + 1;\n\t\trequest_descript_type =\n\t\t    reply_q->reply_post_free[reply_q->reply_post_host_index].\n\t\t    Default.ReplyFlags & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\n\t\tcompleted_cmds++;\n\t\t/* Update the reply post host index after continuously\n\t\t * processing the threshold number of Reply Descriptors.\n\t\t * So that FW can find enough entries to post the Reply\n\t\t * Descriptors in the reply descriptor post queue.\n\t\t */\n\t\tif (completed_cmds >= ioc->thresh_hold) {\n\t\t\tif (ioc->combined_reply_queue) {\n\t\t\t\twritel(reply_q->reply_post_host_index |\n\t\t\t\t\t\t((msix_index  & 7) <<\n\t\t\t\t\t\t MPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\t\t    ioc->replyPostRegisterIndex[msix_index/8]);\n\t\t\t} else {\n\t\t\t\twritel(reply_q->reply_post_host_index |\n\t\t\t\t\t\t(msix_index <<\n\t\t\t\t\t\t MPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\t\t\t\t&ioc->chip->ReplyPostHostIndex);\n\t\t\t}\n\t\t\tif (!reply_q->irq_poll_scheduled) {\n\t\t\t\treply_q->irq_poll_scheduled = true;\n\t\t\t\tirq_poll_sched(&reply_q->irqpoll);\n\t\t\t}\n\t\t\tatomic_dec(&reply_q->busy);\n\t\t\treturn completed_cmds;\n\t\t}\n\t\tif (request_descript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\n\t\t\tgoto out;\n\t\tif (!reply_q->reply_post_host_index)\n\t\t\trpf = reply_q->reply_post_free;\n\t\telse\n\t\t\trpf++;\n\t} while (1);\n\n out:\n\n\tif (!completed_cmds) {\n\t\tatomic_dec(&reply_q->busy);\n\t\treturn completed_cmds;\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\twritel(reply_q->reply_post_host_index,\n\t\tioc->reply_post_host_index[msix_index]);\n\t\tatomic_dec(&reply_q->busy);\n\t\treturn completed_cmds;\n\t}\n\n\t/* Update Reply Post Host Index.\n\t * For those HBA's which support combined reply queue feature\n\t * 1. Get the correct Supplemental Reply Post Host Index Register.\n\t *    i.e. (msix_index / 8)th entry from Supplemental Reply Post Host\n\t *    Index Register address bank i.e replyPostRegisterIndex[],\n\t * 2. Then update this register with new reply host index value\n\t *    in ReplyPostIndex field and the MSIxIndex field with\n\t *    msix_index value reduced to a value between 0 and 7,\n\t *    using a modulo 8 operation. Since each Supplemental Reply Post\n\t *    Host Index Register supports 8 MSI-X vectors.\n\t *\n\t * For other HBA's just update the Reply Post Host Index register with\n\t * new reply host index value in ReplyPostIndex Field and msix_index\n\t * value in MSIxIndex field.\n\t */\n\tif (ioc->combined_reply_queue)\n\t\twritel(reply_q->reply_post_host_index | ((msix_index  & 7) <<\n\t\t\tMPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\tioc->replyPostRegisterIndex[msix_index/8]);\n\telse\n\t\twritel(reply_q->reply_post_host_index | (msix_index <<\n\t\t\tMPI2_RPHI_MSIX_INDEX_SHIFT),\n\t\t\t&ioc->chip->ReplyPostHostIndex);\n\tatomic_dec(&reply_q->busy);\n\treturn completed_cmds;\n}\n\n/**\n * _base_interrupt - MPT adapter (IOC) specific interrupt handler.\n * @irq: irq number (not used)\n * @bus_id: bus identifier cookie == pointer to MPT_ADAPTER structure\n *\n * Return: IRQ_HANDLED if processed, else IRQ_NONE.\n */\nstatic irqreturn_t\n_base_interrupt(int irq, void *bus_id)\n{\n\tstruct adapter_reply_queue *reply_q = bus_id;\n\tstruct MPT3SAS_ADAPTER *ioc = reply_q->ioc;\n\n\tif (ioc->mask_interrupts)\n\t\treturn IRQ_NONE;\n\tif (reply_q->irq_poll_scheduled)\n\t\treturn IRQ_HANDLED;\n\treturn ((_base_process_reply_queue(reply_q) > 0) ?\n\t\t\tIRQ_HANDLED : IRQ_NONE);\n}\n\n/**\n * _base_irqpoll - IRQ poll callback handler\n * @irqpoll: irq_poll object\n * @budget: irq poll weight\n *\n * returns number of reply descriptors processed\n */\nstatic int\n_base_irqpoll(struct irq_poll *irqpoll, int budget)\n{\n\tstruct adapter_reply_queue *reply_q;\n\tint num_entries = 0;\n\n\treply_q = container_of(irqpoll, struct adapter_reply_queue,\n\t\t\tirqpoll);\n\tif (reply_q->irq_line_enable) {\n\t\tdisable_irq_nosync(reply_q->os_irq);\n\t\treply_q->irq_line_enable = false;\n\t}\n\tnum_entries = _base_process_reply_queue(reply_q);\n\tif (num_entries < budget) {\n\t\tirq_poll_complete(irqpoll);\n\t\treply_q->irq_poll_scheduled = false;\n\t\treply_q->irq_line_enable = true;\n\t\tenable_irq(reply_q->os_irq);\n\t\t/*\n\t\t * Go for one more round of processing the\n\t\t * reply descriptor post queue incase if HBA\n\t\t * Firmware has posted some reply descriptors\n\t\t * while reenabling the IRQ.\n\t\t */\n\t\t_base_process_reply_queue(reply_q);\n\t}\n\n\treturn num_entries;\n}\n\n/**\n * _base_init_irqpolls - initliaze IRQ polls\n * @ioc: per adapter object\n *\n * returns nothing\n */\nstatic void\n_base_init_irqpolls(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct adapter_reply_queue *reply_q, *next;\n\n\tif (list_empty(&ioc->reply_queue_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(reply_q, next, &ioc->reply_queue_list, list) {\n\t\tirq_poll_init(&reply_q->irqpoll,\n\t\t\tioc->hba_queue_depth/4, _base_irqpoll);\n\t\treply_q->irq_poll_scheduled = false;\n\t\treply_q->irq_line_enable = true;\n\t\treply_q->os_irq = pci_irq_vector(ioc->pdev,\n\t\t    reply_q->msix_index);\n\t}\n}\n\n/**\n * _base_is_controller_msix_enabled - is controller support muli-reply queues\n * @ioc: per adapter object\n *\n * Return: Whether or not MSI/X is enabled.\n */\nstatic inline int\n_base_is_controller_msix_enabled(struct MPT3SAS_ADAPTER *ioc)\n{\n\treturn (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable;\n}\n\n/**\n * mpt3sas_base_sync_reply_irqs - flush pending MSIX interrupts\n * @ioc: per adapter object\n * @poll: poll over reply descriptor pools incase interrupt for\n *\t\ttimed-out SCSI command got delayed\n * Context: non ISR conext\n *\n * Called when a Task Management request has completed.\n */\nvoid\nmpt3sas_base_sync_reply_irqs(struct MPT3SAS_ADAPTER *ioc, u8 poll)\n{\n\tstruct adapter_reply_queue *reply_q;\n\n\t/* If MSIX capability is turned off\n\t * then multi-queues are not enabled\n\t */\n\tif (!_base_is_controller_msix_enabled(ioc))\n\t\treturn;\n\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tif (ioc->shost_recovery || ioc->remove_host ||\n\t\t\t\tioc->pci_error_recovery)\n\t\t\treturn;\n\t\t/* TMs are on msix_index == 0 */\n\t\tif (reply_q->msix_index == 0)\n\t\t\tcontinue;\n\t\tsynchronize_irq(pci_irq_vector(ioc->pdev, reply_q->msix_index));\n\t\tif (reply_q->irq_poll_scheduled) {\n\t\t\t/* Calling irq_poll_disable will wait for any pending\n\t\t\t * callbacks to have completed.\n\t\t\t */\n\t\t\tirq_poll_disable(&reply_q->irqpoll);\n\t\t\tirq_poll_enable(&reply_q->irqpoll);\n\t\t\t/* check how the scheduled poll has ended,\n\t\t\t * clean up only if necessary\n\t\t\t */\n\t\t\tif (reply_q->irq_poll_scheduled) {\n\t\t\t\treply_q->irq_poll_scheduled = false;\n\t\t\t\treply_q->irq_line_enable = true;\n\t\t\t\tenable_irq(reply_q->os_irq);\n\t\t\t}\n\t\t}\n\t}\n\tif (poll)\n\t\t_base_process_reply_queue(reply_q);\n}\n\n/**\n * mpt3sas_base_release_callback_handler - clear interrupt callback handler\n * @cb_idx: callback index\n */\nvoid\nmpt3sas_base_release_callback_handler(u8 cb_idx)\n{\n\tmpt_callbacks[cb_idx] = NULL;\n}\n\n/**\n * mpt3sas_base_register_callback_handler - obtain index for the interrupt callback handler\n * @cb_func: callback function\n *\n * Return: Index of @cb_func.\n */\nu8\nmpt3sas_base_register_callback_handler(MPT_CALLBACK cb_func)\n{\n\tu8 cb_idx;\n\n\tfor (cb_idx = MPT_MAX_CALLBACKS-1; cb_idx; cb_idx--)\n\t\tif (mpt_callbacks[cb_idx] == NULL)\n\t\t\tbreak;\n\n\tmpt_callbacks[cb_idx] = cb_func;\n\treturn cb_idx;\n}\n\n/**\n * mpt3sas_base_initialize_callback_handler - initialize the interrupt callback handler\n */\nvoid\nmpt3sas_base_initialize_callback_handler(void)\n{\n\tu8 cb_idx;\n\n\tfor (cb_idx = 0; cb_idx < MPT_MAX_CALLBACKS; cb_idx++)\n\t\tmpt3sas_base_release_callback_handler(cb_idx);\n}\n\n\n/**\n * _base_build_zero_len_sge - build zero length sg entry\n * @ioc: per adapter object\n * @paddr: virtual address for SGE\n *\n * Create a zero length scatter gather entry to insure the IOCs hardware has\n * something to use if the target device goes brain dead and tries\n * to send data even when none is asked for.\n */\nstatic void\n_base_build_zero_len_sge(struct MPT3SAS_ADAPTER *ioc, void *paddr)\n{\n\tu32 flags_length = (u32)((MPI2_SGE_FLAGS_LAST_ELEMENT |\n\t    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST |\n\t    MPI2_SGE_FLAGS_SIMPLE_ELEMENT) <<\n\t    MPI2_SGE_FLAGS_SHIFT);\n\tioc->base_add_sg_single(paddr, flags_length, -1);\n}\n\n/**\n * _base_add_sg_single_32 - Place a simple 32 bit SGE at address pAddr.\n * @paddr: virtual address for SGE\n * @flags_length: SGE flags and data transfer length\n * @dma_addr: Physical address\n */\nstatic void\n_base_add_sg_single_32(void *paddr, u32 flags_length, dma_addr_t dma_addr)\n{\n\tMpi2SGESimple32_t *sgel = paddr;\n\n\tflags_length |= (MPI2_SGE_FLAGS_32_BIT_ADDRESSING |\n\t    MPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;\n\tsgel->FlagsLength = cpu_to_le32(flags_length);\n\tsgel->Address = cpu_to_le32(dma_addr);\n}\n\n\n/**\n * _base_add_sg_single_64 - Place a simple 64 bit SGE at address pAddr.\n * @paddr: virtual address for SGE\n * @flags_length: SGE flags and data transfer length\n * @dma_addr: Physical address\n */\nstatic void\n_base_add_sg_single_64(void *paddr, u32 flags_length, dma_addr_t dma_addr)\n{\n\tMpi2SGESimple64_t *sgel = paddr;\n\n\tflags_length |= (MPI2_SGE_FLAGS_64_BIT_ADDRESSING |\n\t    MPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;\n\tsgel->FlagsLength = cpu_to_le32(flags_length);\n\tsgel->Address = cpu_to_le64(dma_addr);\n}\n\n/**\n * _base_get_chain_buffer_tracker - obtain chain tracker\n * @ioc: per adapter object\n * @scmd: SCSI commands of the IO request\n *\n * Return: chain tracker from chain_lookup table using key as\n * smid and smid's chain_offset.\n */\nstatic struct chain_tracker *\n_base_get_chain_buffer_tracker(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t       struct scsi_cmnd *scmd)\n{\n\tstruct chain_tracker *chain_req;\n\tstruct scsiio_tracker *st = scsi_cmd_priv(scmd);\n\tu16 smid = st->smid;\n\tu8 chain_offset =\n\t   atomic_read(&ioc->chain_lookup[smid - 1].chain_offset);\n\n\tif (chain_offset == ioc->chains_needed_per_io)\n\t\treturn NULL;\n\n\tchain_req = &ioc->chain_lookup[smid - 1].chains_per_smid[chain_offset];\n\tatomic_inc(&ioc->chain_lookup[smid - 1].chain_offset);\n\treturn chain_req;\n}\n\n\n/**\n * _base_build_sg - build generic sg\n * @ioc: per adapter object\n * @psge: virtual address for SGE\n * @data_out_dma: physical address for WRITES\n * @data_out_sz: data xfer size for WRITES\n * @data_in_dma: physical address for READS\n * @data_in_sz: data xfer size for READS\n */\nstatic void\n_base_build_sg(struct MPT3SAS_ADAPTER *ioc, void *psge,\n\tdma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\n\tsize_t data_in_sz)\n{\n\tu32 sgl_flags;\n\n\tif (!data_out_sz && !data_in_sz) {\n\t\t_base_build_zero_len_sge(ioc, psge);\n\t\treturn;\n\t}\n\n\tif (data_out_sz && data_in_sz) {\n\t\t/* WRITE sgel first */\n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_out_sz, data_out_dma);\n\n\t\t/* incr sgel */\n\t\tpsge += ioc->sge_size;\n\n\t\t/* READ sgel last */\n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\n\t\t    MPI2_SGE_FLAGS_END_OF_LIST);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_in_sz, data_in_dma);\n\t} else if (data_out_sz) /* WRITE */ {\n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\n\t\t    MPI2_SGE_FLAGS_END_OF_LIST | MPI2_SGE_FLAGS_HOST_TO_IOC);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_out_sz, data_out_dma);\n\t} else if (data_in_sz) /* READ */ {\n\t\tsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\n\t\t    MPI2_SGE_FLAGS_END_OF_LIST);\n\t\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\t\tioc->base_add_sg_single(psge, sgl_flags |\n\t\t    data_in_sz, data_in_dma);\n\t}\n}\n\n/* IEEE format sgls */\n\n/**\n * _base_build_nvme_prp - This function is called for NVMe end devices to build\n * a native SGL (NVMe PRP). The native SGL is built starting in the first PRP\n * entry of the NVMe message (PRP1).  If the data buffer is small enough to be\n * described entirely using PRP1, then PRP2 is not used.  If needed, PRP2 is\n * used to describe a larger data buffer.  If the data buffer is too large to\n * describe using the two PRP entriess inside the NVMe message, then PRP1\n * describes the first data memory segment, and PRP2 contains a pointer to a PRP\n * list located elsewhere in memory to describe the remaining data memory\n * segments.  The PRP list will be contiguous.\n *\n * The native SGL for NVMe devices is a Physical Region Page (PRP).  A PRP\n * consists of a list of PRP entries to describe a number of noncontigous\n * physical memory segments as a single memory buffer, just as a SGL does.  Note\n * however, that this function is only used by the IOCTL call, so the memory\n * given will be guaranteed to be contiguous.  There is no need to translate\n * non-contiguous SGL into a PRP in this case.  All PRPs will describe\n * contiguous space that is one page size each.\n *\n * Each NVMe message contains two PRP entries.  The first (PRP1) either contains\n * a PRP list pointer or a PRP element, depending upon the command.  PRP2\n * contains the second PRP element if the memory being described fits within 2\n * PRP entries, or a PRP list pointer if the PRP spans more than two entries.\n *\n * A PRP list pointer contains the address of a PRP list, structured as a linear\n * array of PRP entries.  Each PRP entry in this list describes a segment of\n * physical memory.\n *\n * Each 64-bit PRP entry comprises an address and an offset field.  The address\n * always points at the beginning of a 4KB physical memory page, and the offset\n * describes where within that 4KB page the memory segment begins.  Only the\n * first element in a PRP list may contain a non-zero offest, implying that all\n * memory segments following the first begin at the start of a 4KB page.\n *\n * Each PRP element normally describes 4KB of physical memory, with exceptions\n * for the first and last elements in the list.  If the memory being described\n * by the list begins at a non-zero offset within the first 4KB page, then the\n * first PRP element will contain a non-zero offset indicating where the region\n * begins within the 4KB page.  The last memory segment may end before the end\n * of the 4KB segment, depending upon the overall size of the memory being\n * described by the PRP list.\n *\n * Since PRP entries lack any indication of size, the overall data buffer length\n * is used to determine where the end of the data memory buffer is located, and\n * how many PRP entries are required to describe it.\n *\n * @ioc: per adapter object\n * @smid: system request message index for getting asscociated SGL\n * @nvme_encap_request: the NVMe request msg frame pointer\n * @data_out_dma: physical address for WRITES\n * @data_out_sz: data xfer size for WRITES\n * @data_in_dma: physical address for READS\n * @data_in_sz: data xfer size for READS\n */\nstatic void\n_base_build_nvme_prp(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tMpi26NVMeEncapsulatedRequest_t *nvme_encap_request,\n\tdma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\n\tsize_t data_in_sz)\n{\n\tint\t\tprp_size = NVME_PRP_SIZE;\n\t__le64\t\t*prp_entry, *prp1_entry, *prp2_entry;\n\t__le64\t\t*prp_page;\n\tdma_addr_t\tprp_entry_dma, prp_page_dma, dma_addr;\n\tu32\t\toffset, entry_len;\n\tu32\t\tpage_mask_result, page_mask;\n\tsize_t\t\tlength;\n\tstruct mpt3sas_nvme_cmd *nvme_cmd =\n\t\t(void *)nvme_encap_request->NVMe_Command;\n\n\t/*\n\t * Not all commands require a data transfer. If no data, just return\n\t * without constructing any PRP.\n\t */\n\tif (!data_in_sz && !data_out_sz)\n\t\treturn;\n\tprp1_entry = &nvme_cmd->prp1;\n\tprp2_entry = &nvme_cmd->prp2;\n\tprp_entry = prp1_entry;\n\t/*\n\t * For the PRP entries, use the specially allocated buffer of\n\t * contiguous memory.\n\t */\n\tprp_page = (__le64 *)mpt3sas_base_get_pcie_sgl(ioc, smid);\n\tprp_page_dma = mpt3sas_base_get_pcie_sgl_dma(ioc, smid);\n\n\t/*\n\t * Check if we are within 1 entry of a page boundary we don't\n\t * want our first entry to be a PRP List entry.\n\t */\n\tpage_mask = ioc->page_size - 1;\n\tpage_mask_result = (uintptr_t)((u8 *)prp_page + prp_size) & page_mask;\n\tif (!page_mask_result) {\n\t\t/* Bump up to next page boundary. */\n\t\tprp_page = (__le64 *)((u8 *)prp_page + prp_size);\n\t\tprp_page_dma = prp_page_dma + prp_size;\n\t}\n\n\t/*\n\t * Set PRP physical pointer, which initially points to the current PRP\n\t * DMA memory page.\n\t */\n\tprp_entry_dma = prp_page_dma;\n\n\t/* Get physical address and length of the data buffer. */\n\tif (data_in_sz) {\n\t\tdma_addr = data_in_dma;\n\t\tlength = data_in_sz;\n\t} else {\n\t\tdma_addr = data_out_dma;\n\t\tlength = data_out_sz;\n\t}\n\n\t/* Loop while the length is not zero. */\n\twhile (length) {\n\t\t/*\n\t\t * Check if we need to put a list pointer here if we are at\n\t\t * page boundary - prp_size (8 bytes).\n\t\t */\n\t\tpage_mask_result = (prp_entry_dma + prp_size) & page_mask;\n\t\tif (!page_mask_result) {\n\t\t\t/*\n\t\t\t * This is the last entry in a PRP List, so we need to\n\t\t\t * put a PRP list pointer here.  What this does is:\n\t\t\t *   - bump the current memory pointer to the next\n\t\t\t *     address, which will be the next full page.\n\t\t\t *   - set the PRP Entry to point to that page.  This\n\t\t\t *     is now the PRP List pointer.\n\t\t\t *   - bump the PRP Entry pointer the start of the\n\t\t\t *     next page.  Since all of this PRP memory is\n\t\t\t *     contiguous, no need to get a new page - it's\n\t\t\t *     just the next address.\n\t\t\t */\n\t\t\tprp_entry_dma++;\n\t\t\t*prp_entry = cpu_to_le64(prp_entry_dma);\n\t\t\tprp_entry++;\n\t\t}\n\n\t\t/* Need to handle if entry will be part of a page. */\n\t\toffset = dma_addr & page_mask;\n\t\tentry_len = ioc->page_size - offset;\n\n\t\tif (prp_entry == prp1_entry) {\n\t\t\t/*\n\t\t\t * Must fill in the first PRP pointer (PRP1) before\n\t\t\t * moving on.\n\t\t\t */\n\t\t\t*prp1_entry = cpu_to_le64(dma_addr);\n\n\t\t\t/*\n\t\t\t * Now point to the second PRP entry within the\n\t\t\t * command (PRP2).\n\t\t\t */\n\t\t\tprp_entry = prp2_entry;\n\t\t} else if (prp_entry == prp2_entry) {\n\t\t\t/*\n\t\t\t * Should the PRP2 entry be a PRP List pointer or just\n\t\t\t * a regular PRP pointer?  If there is more than one\n\t\t\t * more page of data, must use a PRP List pointer.\n\t\t\t */\n\t\t\tif (length > ioc->page_size) {\n\t\t\t\t/*\n\t\t\t\t * PRP2 will contain a PRP List pointer because\n\t\t\t\t * more PRP's are needed with this command. The\n\t\t\t\t * list will start at the beginning of the\n\t\t\t\t * contiguous buffer.\n\t\t\t\t */\n\t\t\t\t*prp2_entry = cpu_to_le64(prp_entry_dma);\n\n\t\t\t\t/*\n\t\t\t\t * The next PRP Entry will be the start of the\n\t\t\t\t * first PRP List.\n\t\t\t\t */\n\t\t\t\tprp_entry = prp_page;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * After this, the PRP Entries are complete.\n\t\t\t\t * This command uses 2 PRP's and no PRP list.\n\t\t\t\t */\n\t\t\t\t*prp2_entry = cpu_to_le64(dma_addr);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Put entry in list and bump the addresses.\n\t\t\t *\n\t\t\t * After PRP1 and PRP2 are filled in, this will fill in\n\t\t\t * all remaining PRP entries in a PRP List, one per\n\t\t\t * each time through the loop.\n\t\t\t */\n\t\t\t*prp_entry = cpu_to_le64(dma_addr);\n\t\t\tprp_entry++;\n\t\t\tprp_entry_dma++;\n\t\t}\n\n\t\t/*\n\t\t * Bump the phys address of the command's data buffer by the\n\t\t * entry_len.\n\t\t */\n\t\tdma_addr += entry_len;\n\n\t\t/* Decrement length accounting for last partial page. */\n\t\tif (entry_len > length)\n\t\t\tlength = 0;\n\t\telse\n\t\t\tlength -= entry_len;\n\t}\n}\n\n/**\n * base_make_prp_nvme -\n * Prepare PRPs(Physical Region Page)- SGLs specific to NVMe drives only\n *\n * @ioc:\t\tper adapter object\n * @scmd:\t\tSCSI command from the mid-layer\n * @mpi_request:\tmpi request\n * @smid:\t\tmsg Index\n * @sge_count:\t\tscatter gather element count.\n *\n * Return:\t\ttrue: PRPs are built\n *\t\t\tfalse: IEEE SGLs needs to be built\n */\nstatic void\nbase_make_prp_nvme(struct MPT3SAS_ADAPTER *ioc,\n\t\tstruct scsi_cmnd *scmd,\n\t\tMpi25SCSIIORequest_t *mpi_request,\n\t\tu16 smid, int sge_count)\n{\n\tint sge_len, num_prp_in_chain = 0;\n\tMpi25IeeeSgeChain64_t *main_chain_element, *ptr_first_sgl;\n\t__le64 *curr_buff;\n\tdma_addr_t msg_dma, sge_addr, offset;\n\tu32 page_mask, page_mask_result;\n\tstruct scatterlist *sg_scmd;\n\tu32 first_prp_len;\n\tint data_len = scsi_bufflen(scmd);\n\tu32 nvme_pg_size;\n\n\tnvme_pg_size = max_t(u32, ioc->page_size, NVME_PRP_PAGE_SIZE);\n\t/*\n\t * Nvme has a very convoluted prp format.  One prp is required\n\t * for each page or partial page. Driver need to split up OS sg_list\n\t * entries if it is longer than one page or cross a page\n\t * boundary.  Driver also have to insert a PRP list pointer entry as\n\t * the last entry in each physical page of the PRP list.\n\t *\n\t * NOTE: The first PRP \"entry\" is actually placed in the first\n\t * SGL entry in the main message as IEEE 64 format.  The 2nd\n\t * entry in the main message is the chain element, and the rest\n\t * of the PRP entries are built in the contiguous pcie buffer.\n\t */\n\tpage_mask = nvme_pg_size - 1;\n\n\t/*\n\t * Native SGL is needed.\n\t * Put a chain element in main message frame that points to the first\n\t * chain buffer.\n\t *\n\t * NOTE:  The ChainOffset field must be 0 when using a chain pointer to\n\t *        a native SGL.\n\t */\n\n\t/* Set main message chain element pointer */\n\tmain_chain_element = (pMpi25IeeeSgeChain64_t)&mpi_request->SGL;\n\t/*\n\t * For NVMe the chain element needs to be the 2nd SG entry in the main\n\t * message.\n\t */\n\tmain_chain_element = (Mpi25IeeeSgeChain64_t *)\n\t\t((u8 *)main_chain_element + sizeof(MPI25_IEEE_SGE_CHAIN64));\n\n\t/*\n\t * For the PRP entries, use the specially allocated buffer of\n\t * contiguous memory.  Normal chain buffers can't be used\n\t * because each chain buffer would need to be the size of an OS\n\t * page (4k).\n\t */\n\tcurr_buff = mpt3sas_base_get_pcie_sgl(ioc, smid);\n\tmsg_dma = mpt3sas_base_get_pcie_sgl_dma(ioc, smid);\n\n\tmain_chain_element->Address = cpu_to_le64(msg_dma);\n\tmain_chain_element->NextChainOffset = 0;\n\tmain_chain_element->Flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t\t\tMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR |\n\t\t\tMPI26_IEEE_SGE_FLAGS_NSF_NVME_PRP;\n\n\t/* Build first prp, sge need not to be page aligned*/\n\tptr_first_sgl = (pMpi25IeeeSgeChain64_t)&mpi_request->SGL;\n\tsg_scmd = scsi_sglist(scmd);\n\tsge_addr = sg_dma_address(sg_scmd);\n\tsge_len = sg_dma_len(sg_scmd);\n\n\toffset = sge_addr & page_mask;\n\tfirst_prp_len = nvme_pg_size - offset;\n\n\tptr_first_sgl->Address = cpu_to_le64(sge_addr);\n\tptr_first_sgl->Length = cpu_to_le32(first_prp_len);\n\n\tdata_len -= first_prp_len;\n\n\tif (sge_len > first_prp_len) {\n\t\tsge_addr += first_prp_len;\n\t\tsge_len -= first_prp_len;\n\t} else if (data_len && (sge_len == first_prp_len)) {\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsge_addr = sg_dma_address(sg_scmd);\n\t\tsge_len = sg_dma_len(sg_scmd);\n\t}\n\n\tfor (;;) {\n\t\toffset = sge_addr & page_mask;\n\n\t\t/* Put PRP pointer due to page boundary*/\n\t\tpage_mask_result = (uintptr_t)(curr_buff + 1) & page_mask;\n\t\tif (unlikely(!page_mask_result)) {\n\t\t\tscmd_printk(KERN_NOTICE,\n\t\t\t\tscmd, \"page boundary curr_buff: 0x%p\\n\",\n\t\t\t\tcurr_buff);\n\t\t\tmsg_dma += 8;\n\t\t\t*curr_buff = cpu_to_le64(msg_dma);\n\t\t\tcurr_buff++;\n\t\t\tnum_prp_in_chain++;\n\t\t}\n\n\t\t*curr_buff = cpu_to_le64(sge_addr);\n\t\tcurr_buff++;\n\t\tmsg_dma += 8;\n\t\tnum_prp_in_chain++;\n\n\t\tsge_addr += nvme_pg_size;\n\t\tsge_len -= nvme_pg_size;\n\t\tdata_len -= nvme_pg_size;\n\n\t\tif (data_len <= 0)\n\t\t\tbreak;\n\n\t\tif (sge_len > 0)\n\t\t\tcontinue;\n\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsge_addr = sg_dma_address(sg_scmd);\n\t\tsge_len = sg_dma_len(sg_scmd);\n\t}\n\n\tmain_chain_element->Length =\n\t\tcpu_to_le32(num_prp_in_chain * sizeof(u64));\n\treturn;\n}\n\nstatic bool\nbase_is_prp_possible(struct MPT3SAS_ADAPTER *ioc,\n\tstruct _pcie_device *pcie_device, struct scsi_cmnd *scmd, int sge_count)\n{\n\tu32 data_length = 0;\n\tbool build_prp = true;\n\n\tdata_length = scsi_bufflen(scmd);\n\tif (pcie_device &&\n\t    (mpt3sas_scsih_is_pcie_scsi_device(pcie_device->device_info))) {\n\t\tbuild_prp = false;\n\t\treturn build_prp;\n\t}\n\n\t/* If Datalenth is <= 16K and number of SGE\u2019s entries are <= 2\n\t * we built IEEE SGL\n\t */\n\tif ((data_length <= NVME_PRP_PAGE_SIZE*4) && (sge_count <= 2))\n\t\tbuild_prp = false;\n\n\treturn build_prp;\n}\n\n/**\n * _base_check_pcie_native_sgl - This function is called for PCIe end devices to\n * determine if the driver needs to build a native SGL.  If so, that native\n * SGL is built in the special contiguous buffers allocated especially for\n * PCIe SGL creation.  If the driver will not build a native SGL, return\n * TRUE and a normal IEEE SGL will be built.  Currently this routine\n * supports NVMe.\n * @ioc: per adapter object\n * @mpi_request: mf request pointer\n * @smid: system request message index\n * @scmd: scsi command\n * @pcie_device: points to the PCIe device's info\n *\n * Return: 0 if native SGL was built, 1 if no SGL was built\n */\nstatic int\n_base_check_pcie_native_sgl(struct MPT3SAS_ADAPTER *ioc,\n\tMpi25SCSIIORequest_t *mpi_request, u16 smid, struct scsi_cmnd *scmd,\n\tstruct _pcie_device *pcie_device)\n{\n\tint sges_left;\n\n\t/* Get the SG list pointer and info. */\n\tsges_left = scsi_dma_map(scmd);\n\tif (sges_left < 0) {\n\t\tsdev_printk(KERN_ERR, scmd->device,\n\t\t\t\"scsi_dma_map failed: request for %d bytes!\\n\",\n\t\t\tscsi_bufflen(scmd));\n\t\treturn 1;\n\t}\n\n\t/* Check if we need to build a native SG list. */\n\tif (!base_is_prp_possible(ioc, pcie_device,\n\t\t\t\tscmd, sges_left)) {\n\t\t/* We built a native SG list, just return. */\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Build native NVMe PRP.\n\t */\n\tbase_make_prp_nvme(ioc, scmd, mpi_request,\n\t\t\tsmid, sges_left);\n\n\treturn 0;\nout:\n\tscsi_dma_unmap(scmd);\n\treturn 1;\n}\n\n/**\n * _base_add_sg_single_ieee - add sg element for IEEE format\n * @paddr: virtual address for SGE\n * @flags: SGE flags\n * @chain_offset: number of 128 byte elements from start of segment\n * @length: data transfer length\n * @dma_addr: Physical address\n */\nstatic void\n_base_add_sg_single_ieee(void *paddr, u8 flags, u8 chain_offset, u32 length,\n\tdma_addr_t dma_addr)\n{\n\tMpi25IeeeSgeChain64_t *sgel = paddr;\n\n\tsgel->Flags = flags;\n\tsgel->NextChainOffset = chain_offset;\n\tsgel->Length = cpu_to_le32(length);\n\tsgel->Address = cpu_to_le64(dma_addr);\n}\n\n/**\n * _base_build_zero_len_sge_ieee - build zero length sg entry for IEEE format\n * @ioc: per adapter object\n * @paddr: virtual address for SGE\n *\n * Create a zero length scatter gather entry to insure the IOCs hardware has\n * something to use if the target device goes brain dead and tries\n * to send data even when none is asked for.\n */\nstatic void\n_base_build_zero_len_sge_ieee(struct MPT3SAS_ADAPTER *ioc, void *paddr)\n{\n\tu8 sgl_flags = (MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\tMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR |\n\t\tMPI25_IEEE_SGE_FLAGS_END_OF_LIST);\n\n\t_base_add_sg_single_ieee(paddr, sgl_flags, 0, 0, -1);\n}\n\n/**\n * _base_build_sg_scmd - main sg creation routine\n *\t\tpcie_device is unused here!\n * @ioc: per adapter object\n * @scmd: scsi command\n * @smid: system request message index\n * @unused: unused pcie_device pointer\n * Context: none.\n *\n * The main routine that builds scatter gather table from a given\n * scsi request sent via the .queuecommand main handler.\n *\n * Return: 0 success, anything else error\n */\nstatic int\n_base_build_sg_scmd(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd, u16 smid, struct _pcie_device *unused)\n{\n\tMpi2SCSIIORequest_t *mpi_request;\n\tdma_addr_t chain_dma;\n\tstruct scatterlist *sg_scmd;\n\tvoid *sg_local, *chain;\n\tu32 chain_offset;\n\tu32 chain_length;\n\tu32 chain_flags;\n\tint sges_left;\n\tu32 sges_in_segment;\n\tu32 sgl_flags;\n\tu32 sgl_flags_last_element;\n\tu32 sgl_flags_end_buffer;\n\tstruct chain_tracker *chain_req;\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t/* init scatter gather flags */\n\tsgl_flags = MPI2_SGE_FLAGS_SIMPLE_ELEMENT;\n\tif (scmd->sc_data_direction == DMA_TO_DEVICE)\n\t\tsgl_flags |= MPI2_SGE_FLAGS_HOST_TO_IOC;\n\tsgl_flags_last_element = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT)\n\t    << MPI2_SGE_FLAGS_SHIFT;\n\tsgl_flags_end_buffer = (sgl_flags | MPI2_SGE_FLAGS_LAST_ELEMENT |\n\t    MPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST)\n\t    << MPI2_SGE_FLAGS_SHIFT;\n\tsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\n\n\tsg_scmd = scsi_sglist(scmd);\n\tsges_left = scsi_dma_map(scmd);\n\tif (sges_left < 0) {\n\t\tsdev_printk(KERN_ERR, scmd->device,\n\t\t \"scsi_dma_map failed: request for %d bytes!\\n\",\n\t\t scsi_bufflen(scmd));\n\t\treturn -ENOMEM;\n\t}\n\n\tsg_local = &mpi_request->SGL;\n\tsges_in_segment = ioc->max_sges_in_main_message;\n\tif (sges_left <= sges_in_segment)\n\t\tgoto fill_in_last_segment;\n\n\tmpi_request->ChainOffset = (offsetof(Mpi2SCSIIORequest_t, SGL) +\n\t    (sges_in_segment * ioc->sge_size))/4;\n\n\t/* fill in main message segment when there is a chain following */\n\twhile (sges_in_segment) {\n\t\tif (sges_in_segment == 1)\n\t\t\tioc->base_add_sg_single(sg_local,\n\t\t\t    sgl_flags_last_element | sg_dma_len(sg_scmd),\n\t\t\t    sg_dma_address(sg_scmd));\n\t\telse\n\t\t\tioc->base_add_sg_single(sg_local, sgl_flags |\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size;\n\t\tsges_left--;\n\t\tsges_in_segment--;\n\t}\n\n\t/* initializing the chain flags and pointers */\n\tchain_flags = MPI2_SGE_FLAGS_CHAIN_ELEMENT << MPI2_SGE_FLAGS_SHIFT;\n\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\tif (!chain_req)\n\t\treturn -1;\n\tchain = chain_req->chain_buffer;\n\tchain_dma = chain_req->chain_buffer_dma;\n\tdo {\n\t\tsges_in_segment = (sges_left <=\n\t\t    ioc->max_sges_in_chain_message) ? sges_left :\n\t\t    ioc->max_sges_in_chain_message;\n\t\tchain_offset = (sges_left == sges_in_segment) ?\n\t\t    0 : (sges_in_segment * ioc->sge_size)/4;\n\t\tchain_length = sges_in_segment * ioc->sge_size;\n\t\tif (chain_offset) {\n\t\t\tchain_offset = chain_offset <<\n\t\t\t    MPI2_SGE_CHAIN_OFFSET_SHIFT;\n\t\t\tchain_length += ioc->sge_size;\n\t\t}\n\t\tioc->base_add_sg_single(sg_local, chain_flags | chain_offset |\n\t\t    chain_length, chain_dma);\n\t\tsg_local = chain;\n\t\tif (!chain_offset)\n\t\t\tgoto fill_in_last_segment;\n\n\t\t/* fill in chain segments */\n\t\twhile (sges_in_segment) {\n\t\t\tif (sges_in_segment == 1)\n\t\t\t\tioc->base_add_sg_single(sg_local,\n\t\t\t\t    sgl_flags_last_element |\n\t\t\t\t    sg_dma_len(sg_scmd),\n\t\t\t\t    sg_dma_address(sg_scmd));\n\t\t\telse\n\t\t\t\tioc->base_add_sg_single(sg_local, sgl_flags |\n\t\t\t\t    sg_dma_len(sg_scmd),\n\t\t\t\t    sg_dma_address(sg_scmd));\n\t\t\tsg_scmd = sg_next(sg_scmd);\n\t\t\tsg_local += ioc->sge_size;\n\t\t\tsges_left--;\n\t\t\tsges_in_segment--;\n\t\t}\n\n\t\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\t\tif (!chain_req)\n\t\t\treturn -1;\n\t\tchain = chain_req->chain_buffer;\n\t\tchain_dma = chain_req->chain_buffer_dma;\n\t} while (1);\n\n\n fill_in_last_segment:\n\n\t/* fill the last segment */\n\twhile (sges_left) {\n\t\tif (sges_left == 1)\n\t\t\tioc->base_add_sg_single(sg_local, sgl_flags_end_buffer |\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\telse\n\t\t\tioc->base_add_sg_single(sg_local, sgl_flags |\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size;\n\t\tsges_left--;\n\t}\n\n\treturn 0;\n}\n\n/**\n * _base_build_sg_scmd_ieee - main sg creation routine for IEEE format\n * @ioc: per adapter object\n * @scmd: scsi command\n * @smid: system request message index\n * @pcie_device: Pointer to pcie_device. If set, the pcie native sgl will be\n * constructed on need.\n * Context: none.\n *\n * The main routine that builds scatter gather table from a given\n * scsi request sent via the .queuecommand main handler.\n *\n * Return: 0 success, anything else error\n */\nstatic int\n_base_build_sg_scmd_ieee(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd, u16 smid, struct _pcie_device *pcie_device)\n{\n\tMpi25SCSIIORequest_t *mpi_request;\n\tdma_addr_t chain_dma;\n\tstruct scatterlist *sg_scmd;\n\tvoid *sg_local, *chain;\n\tu32 chain_offset;\n\tu32 chain_length;\n\tint sges_left;\n\tu32 sges_in_segment;\n\tu8 simple_sgl_flags;\n\tu8 simple_sgl_flags_last;\n\tu8 chain_sgl_flags;\n\tstruct chain_tracker *chain_req;\n\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t/* init scatter gather flags */\n\tsimple_sgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\tsimple_sgl_flags_last = simple_sgl_flags |\n\t    MPI25_IEEE_SGE_FLAGS_END_OF_LIST;\n\tchain_sgl_flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |\n\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\n\t/* Check if we need to build a native SG list. */\n\tif ((pcie_device) && (_base_check_pcie_native_sgl(ioc, mpi_request,\n\t\t\tsmid, scmd, pcie_device) == 0)) {\n\t\t/* We built a native SG list, just return. */\n\t\treturn 0;\n\t}\n\n\tsg_scmd = scsi_sglist(scmd);\n\tsges_left = scsi_dma_map(scmd);\n\tif (sges_left < 0) {\n\t\tsdev_printk(KERN_ERR, scmd->device,\n\t\t\t\"scsi_dma_map failed: request for %d bytes!\\n\",\n\t\t\tscsi_bufflen(scmd));\n\t\treturn -ENOMEM;\n\t}\n\n\tsg_local = &mpi_request->SGL;\n\tsges_in_segment = (ioc->request_sz -\n\t\t   offsetof(Mpi25SCSIIORequest_t, SGL))/ioc->sge_size_ieee;\n\tif (sges_left <= sges_in_segment)\n\t\tgoto fill_in_last_segment;\n\n\tmpi_request->ChainOffset = (sges_in_segment - 1 /* chain element */) +\n\t    (offsetof(Mpi25SCSIIORequest_t, SGL)/ioc->sge_size_ieee);\n\n\t/* fill in main message segment when there is a chain following */\n\twhile (sges_in_segment > 1) {\n\t\t_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\n\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size_ieee;\n\t\tsges_left--;\n\t\tsges_in_segment--;\n\t}\n\n\t/* initializing the pointers */\n\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\tif (!chain_req)\n\t\treturn -1;\n\tchain = chain_req->chain_buffer;\n\tchain_dma = chain_req->chain_buffer_dma;\n\tdo {\n\t\tsges_in_segment = (sges_left <=\n\t\t    ioc->max_sges_in_chain_message) ? sges_left :\n\t\t    ioc->max_sges_in_chain_message;\n\t\tchain_offset = (sges_left == sges_in_segment) ?\n\t\t    0 : sges_in_segment;\n\t\tchain_length = sges_in_segment * ioc->sge_size_ieee;\n\t\tif (chain_offset)\n\t\t\tchain_length += ioc->sge_size_ieee;\n\t\t_base_add_sg_single_ieee(sg_local, chain_sgl_flags,\n\t\t    chain_offset, chain_length, chain_dma);\n\n\t\tsg_local = chain;\n\t\tif (!chain_offset)\n\t\t\tgoto fill_in_last_segment;\n\n\t\t/* fill in chain segments */\n\t\twhile (sges_in_segment) {\n\t\t\t_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\t\tsg_scmd = sg_next(sg_scmd);\n\t\t\tsg_local += ioc->sge_size_ieee;\n\t\t\tsges_left--;\n\t\t\tsges_in_segment--;\n\t\t}\n\n\t\tchain_req = _base_get_chain_buffer_tracker(ioc, scmd);\n\t\tif (!chain_req)\n\t\t\treturn -1;\n\t\tchain = chain_req->chain_buffer;\n\t\tchain_dma = chain_req->chain_buffer_dma;\n\t} while (1);\n\n\n fill_in_last_segment:\n\n\t/* fill the last segment */\n\twhile (sges_left > 0) {\n\t\tif (sges_left == 1)\n\t\t\t_base_add_sg_single_ieee(sg_local,\n\t\t\t    simple_sgl_flags_last, 0, sg_dma_len(sg_scmd),\n\t\t\t    sg_dma_address(sg_scmd));\n\t\telse\n\t\t\t_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\n\t\t\t    sg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\n\t\tsg_scmd = sg_next(sg_scmd);\n\t\tsg_local += ioc->sge_size_ieee;\n\t\tsges_left--;\n\t}\n\n\treturn 0;\n}\n\n/**\n * _base_build_sg_ieee - build generic sg for IEEE format\n * @ioc: per adapter object\n * @psge: virtual address for SGE\n * @data_out_dma: physical address for WRITES\n * @data_out_sz: data xfer size for WRITES\n * @data_in_dma: physical address for READS\n * @data_in_sz: data xfer size for READS\n */\nstatic void\n_base_build_sg_ieee(struct MPT3SAS_ADAPTER *ioc, void *psge,\n\tdma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\n\tsize_t data_in_sz)\n{\n\tu8 sgl_flags;\n\n\tif (!data_out_sz && !data_in_sz) {\n\t\t_base_build_zero_len_sge_ieee(ioc, psge);\n\t\treturn;\n\t}\n\n\tif (data_out_sz && data_in_sz) {\n\t\t/* WRITE sgel first */\n\t\tsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_out_sz,\n\t\t    data_out_dma);\n\n\t\t/* incr sgel */\n\t\tpsge += ioc->sge_size_ieee;\n\n\t\t/* READ sgel last */\n\t\tsgl_flags |= MPI25_IEEE_SGE_FLAGS_END_OF_LIST;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_in_sz,\n\t\t    data_in_dma);\n\t} else if (data_out_sz) /* WRITE */ {\n\t\tsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI25_IEEE_SGE_FLAGS_END_OF_LIST |\n\t\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_out_sz,\n\t\t    data_out_dma);\n\t} else if (data_in_sz) /* READ */ {\n\t\tsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\n\t\t    MPI25_IEEE_SGE_FLAGS_END_OF_LIST |\n\t\t    MPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\n\t\t_base_add_sg_single_ieee(psge, sgl_flags, 0, data_in_sz,\n\t\t    data_in_dma);\n\t}\n}\n\n#define convert_to_kb(x) ((x) << (PAGE_SHIFT - 10))\n\n/**\n * _base_config_dma_addressing - set dma addressing\n * @ioc: per adapter object\n * @pdev: PCI device struct\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_config_dma_addressing(struct MPT3SAS_ADAPTER *ioc, struct pci_dev *pdev)\n{\n\tstruct sysinfo s;\n\n\tif (ioc->is_mcpu_endpoint ||\n\t    sizeof(dma_addr_t) == 4 || ioc->use_32bit_dma ||\n\t    dma_get_required_mask(&pdev->dev) <= 32)\n\t\tioc->dma_mask = 32;\n\t/* Set 63 bit DMA mask for all SAS3 and SAS35 controllers */\n\telse if (ioc->hba_mpi_version_belonged > MPI2_VERSION)\n\t\tioc->dma_mask = 63;\n\telse\n\t\tioc->dma_mask = 64;\n\n\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(ioc->dma_mask)) ||\n\t    dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(ioc->dma_mask)))\n\t\treturn -ENODEV;\n\n\tif (ioc->dma_mask > 32) {\n\t\tioc->base_add_sg_single = &_base_add_sg_single_64;\n\t\tioc->sge_size = sizeof(Mpi2SGESimple64_t);\n\t} else {\n\t\tioc->base_add_sg_single = &_base_add_sg_single_32;\n\t\tioc->sge_size = sizeof(Mpi2SGESimple32_t);\n\t}\n\n\tsi_meminfo(&s);\n\tioc_info(ioc, \"%d BIT PCI BUS DMA ADDRESSING SUPPORTED, total mem (%ld kB)\\n\",\n\t\tioc->dma_mask, convert_to_kb(s.totalram));\n\n\treturn 0;\n}\n\n/**\n * _base_check_enable_msix - checks MSIX capabable.\n * @ioc: per adapter object\n *\n * Check to see if card is capable of MSIX, and set number\n * of available msix vectors\n */\nstatic int\n_base_check_enable_msix(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint base;\n\tu16 message_control;\n\n\t/* Check whether controller SAS2008 B0 controller,\n\t * if it is SAS2008 B0 controller use IO-APIC instead of MSIX\n\t */\n\tif (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 &&\n\t    ioc->pdev->revision == SAS2_PCI_DEVICE_B0_REVISION) {\n\t\treturn -EINVAL;\n\t}\n\n\tbase = pci_find_capability(ioc->pdev, PCI_CAP_ID_MSIX);\n\tif (!base) {\n\t\tdfailprintk(ioc, ioc_info(ioc, \"msix not supported\\n\"));\n\t\treturn -EINVAL;\n\t}\n\n\t/* get msix vector count */\n\t/* NUMA_IO not supported for older controllers */\n\tif (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2004 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_1 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_2 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2108_3 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_1 ||\n\t    ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2116_2)\n\t\tioc->msix_vector_count = 1;\n\telse {\n\t\tpci_read_config_word(ioc->pdev, base + 2, &message_control);\n\t\tioc->msix_vector_count = (message_control & 0x3FF) + 1;\n\t}\n\tdinitprintk(ioc, ioc_info(ioc, \"msix is supported, vector_count(%d)\\n\",\n\t\t\t\t  ioc->msix_vector_count));\n\treturn 0;\n}\n\n/**\n * _base_free_irq - free irq\n * @ioc: per adapter object\n *\n * Freeing respective reply_queue from the list.\n */\nstatic void\n_base_free_irq(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct adapter_reply_queue *reply_q, *next;\n\n\tif (list_empty(&ioc->reply_queue_list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(reply_q, next, &ioc->reply_queue_list, list) {\n\t\tlist_del(&reply_q->list);\n\t\tif (ioc->smp_affinity_enable)\n\t\t\tirq_set_affinity_hint(pci_irq_vector(ioc->pdev,\n\t\t\t    reply_q->msix_index), NULL);\n\t\tfree_irq(pci_irq_vector(ioc->pdev, reply_q->msix_index),\n\t\t\t reply_q);\n\t\tkfree(reply_q);\n\t}\n}\n\n/**\n * _base_request_irq - request irq\n * @ioc: per adapter object\n * @index: msix index into vector table\n *\n * Inserting respective reply_queue into the list.\n */\nstatic int\n_base_request_irq(struct MPT3SAS_ADAPTER *ioc, u8 index)\n{\n\tstruct pci_dev *pdev = ioc->pdev;\n\tstruct adapter_reply_queue *reply_q;\n\tint r;\n\n\treply_q =  kzalloc(sizeof(struct adapter_reply_queue), GFP_KERNEL);\n\tif (!reply_q) {\n\t\tioc_err(ioc, \"unable to allocate memory %zu!\\n\",\n\t\t\tsizeof(struct adapter_reply_queue));\n\t\treturn -ENOMEM;\n\t}\n\treply_q->ioc = ioc;\n\treply_q->msix_index = index;\n\n\tatomic_set(&reply_q->busy, 0);\n\tif (ioc->msix_enable)\n\t\tsnprintf(reply_q->name, MPT_NAME_LENGTH, \"%s%d-msix%d\",\n\t\t    ioc->driver_name, ioc->id, index);\n\telse\n\t\tsnprintf(reply_q->name, MPT_NAME_LENGTH, \"%s%d\",\n\t\t    ioc->driver_name, ioc->id);\n\tr = request_irq(pci_irq_vector(pdev, index), _base_interrupt,\n\t\t\tIRQF_SHARED, reply_q->name, reply_q);\n\tif (r) {\n\t\tpr_err(\"%s: unable to allocate interrupt %d!\\n\",\n\t\t       reply_q->name, pci_irq_vector(pdev, index));\n\t\tkfree(reply_q);\n\t\treturn -EBUSY;\n\t}\n\n\tINIT_LIST_HEAD(&reply_q->list);\n\tlist_add_tail(&reply_q->list, &ioc->reply_queue_list);\n\treturn 0;\n}\n\n/**\n * _base_assign_reply_queues - assigning msix index for each cpu\n * @ioc: per adapter object\n *\n * The enduser would need to set the affinity via /proc/irq/#/smp_affinity\n *\n * It would nice if we could call irq_set_affinity, however it is not\n * an exported symbol\n */\nstatic void\n_base_assign_reply_queues(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned int cpu, nr_cpus, nr_msix, index = 0;\n\tstruct adapter_reply_queue *reply_q;\n\tint local_numa_node;\n\n\tif (!_base_is_controller_msix_enabled(ioc))\n\t\treturn;\n\n\tif (ioc->msix_load_balance)\n\t\treturn;\n\n\tmemset(ioc->cpu_msix_table, 0, ioc->cpu_msix_table_sz);\n\n\tnr_cpus = num_online_cpus();\n\tnr_msix = ioc->reply_queue_count = min(ioc->reply_queue_count,\n\t\t\t\t\t       ioc->facts.MaxMSIxVectors);\n\tif (!nr_msix)\n\t\treturn;\n\n\tif (ioc->smp_affinity_enable) {\n\n\t\t/*\n\t\t * set irq affinity to local numa node for those irqs\n\t\t * corresponding to high iops queues.\n\t\t */\n\t\tif (ioc->high_iops_queues) {\n\t\t\tlocal_numa_node = dev_to_node(&ioc->pdev->dev);\n\t\t\tfor (index = 0; index < ioc->high_iops_queues;\n\t\t\t    index++) {\n\t\t\t\tirq_set_affinity_hint(pci_irq_vector(ioc->pdev,\n\t\t\t\t    index), cpumask_of_node(local_numa_node));\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\t\tconst cpumask_t *mask;\n\n\t\t\tif (reply_q->msix_index < ioc->high_iops_queues)\n\t\t\t\tcontinue;\n\n\t\t\tmask = pci_irq_get_affinity(ioc->pdev,\n\t\t\t    reply_q->msix_index);\n\t\t\tif (!mask) {\n\t\t\t\tioc_warn(ioc, \"no affinity for msi %x\\n\",\n\t\t\t\t\t reply_q->msix_index);\n\t\t\t\tgoto fall_back;\n\t\t\t}\n\n\t\t\tfor_each_cpu_and(cpu, mask, cpu_online_mask) {\n\t\t\t\tif (cpu >= ioc->cpu_msix_table_sz)\n\t\t\t\t\tbreak;\n\t\t\t\tioc->cpu_msix_table[cpu] = reply_q->msix_index;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\nfall_back:\n\tcpu = cpumask_first(cpu_online_mask);\n\tnr_msix -= ioc->high_iops_queues;\n\tindex = 0;\n\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tunsigned int i, group = nr_cpus / nr_msix;\n\n\t\tif (reply_q->msix_index < ioc->high_iops_queues)\n\t\t\tcontinue;\n\n\t\tif (cpu >= nr_cpus)\n\t\t\tbreak;\n\n\t\tif (index < nr_cpus % nr_msix)\n\t\t\tgroup++;\n\n\t\tfor (i = 0 ; i < group ; i++) {\n\t\t\tioc->cpu_msix_table[cpu] = reply_q->msix_index;\n\t\t\tcpu = cpumask_next(cpu, cpu_online_mask);\n\t\t}\n\t\tindex++;\n\t}\n}\n\n/**\n * _base_check_and_enable_high_iops_queues - enable high iops mode\n * @ioc: per adapter object\n * @hba_msix_vector_count: msix vectors supported by HBA\n *\n * Enable high iops queues only if\n *  - HBA is a SEA/AERO controller and\n *  - MSI-Xs vector supported by the HBA is 128 and\n *  - total CPU count in the system >=16 and\n *  - loaded driver with default max_msix_vectors module parameter and\n *  - system booted in non kdump mode\n *\n * returns nothing.\n */\nstatic void\n_base_check_and_enable_high_iops_queues(struct MPT3SAS_ADAPTER *ioc,\n\t\tint hba_msix_vector_count)\n{\n\tu16 lnksta, speed;\n\n\tif (perf_mode == MPT_PERF_MODE_IOPS ||\n\t    perf_mode == MPT_PERF_MODE_LATENCY) {\n\t\tioc->high_iops_queues = 0;\n\t\treturn;\n\t}\n\n\tif (perf_mode == MPT_PERF_MODE_DEFAULT) {\n\n\t\tpcie_capability_read_word(ioc->pdev, PCI_EXP_LNKSTA, &lnksta);\n\t\tspeed = lnksta & PCI_EXP_LNKSTA_CLS;\n\n\t\tif (speed < 0x4) {\n\t\t\tioc->high_iops_queues = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!reset_devices && ioc->is_aero_ioc &&\n\t    hba_msix_vector_count == MPT3SAS_GEN35_MAX_MSIX_QUEUES &&\n\t    num_online_cpus() >= MPT3SAS_HIGH_IOPS_REPLY_QUEUES &&\n\t    max_msix_vectors == -1)\n\t\tioc->high_iops_queues = MPT3SAS_HIGH_IOPS_REPLY_QUEUES;\n\telse\n\t\tioc->high_iops_queues = 0;\n}\n\n/**\n * _base_disable_msix - disables msix\n * @ioc: per adapter object\n *\n */\nstatic void\n_base_disable_msix(struct MPT3SAS_ADAPTER *ioc)\n{\n\tif (!ioc->msix_enable)\n\t\treturn;\n\tpci_free_irq_vectors(ioc->pdev);\n\tioc->msix_enable = 0;\n}\n\n/**\n * _base_alloc_irq_vectors - allocate msix vectors\n * @ioc: per adapter object\n *\n */\nstatic int\n_base_alloc_irq_vectors(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i, irq_flags = PCI_IRQ_MSIX;\n\tstruct irq_affinity desc = { .pre_vectors = ioc->high_iops_queues };\n\tstruct irq_affinity *descp = &desc;\n\n\tif (ioc->smp_affinity_enable)\n\t\tirq_flags |= PCI_IRQ_AFFINITY;\n\telse\n\t\tdescp = NULL;\n\n\tioc_info(ioc, \" %d %d\\n\", ioc->high_iops_queues,\n\t    ioc->reply_queue_count);\n\n\ti = pci_alloc_irq_vectors_affinity(ioc->pdev,\n\t    ioc->high_iops_queues,\n\t    ioc->reply_queue_count, irq_flags, descp);\n\n\treturn i;\n}\n\n/**\n * _base_enable_msix - enables msix, failback to io_apic\n * @ioc: per adapter object\n *\n */\nstatic int\n_base_enable_msix(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint r;\n\tint i, local_max_msix_vectors;\n\tu8 try_msix = 0;\n\n\tioc->msix_load_balance = false;\n\n\tif (msix_disable == -1 || msix_disable == 0)\n\t\ttry_msix = 1;\n\n\tif (!try_msix)\n\t\tgoto try_ioapic;\n\n\tif (_base_check_enable_msix(ioc) != 0)\n\t\tgoto try_ioapic;\n\n\tioc_info(ioc, \"MSI-X vectors supported: %d\\n\", ioc->msix_vector_count);\n\tpr_info(\"\\t no of cores: %d, max_msix_vectors: %d\\n\",\n\t\tioc->cpu_count, max_msix_vectors);\n\tif (ioc->is_aero_ioc)\n\t\t_base_check_and_enable_high_iops_queues(ioc,\n\t\t\tioc->msix_vector_count);\n\tioc->reply_queue_count =\n\t\tmin_t(int, ioc->cpu_count + ioc->high_iops_queues,\n\t\tioc->msix_vector_count);\n\n\tif (!ioc->rdpq_array_enable && max_msix_vectors == -1)\n\t\tlocal_max_msix_vectors = (reset_devices) ? 1 : 8;\n\telse\n\t\tlocal_max_msix_vectors = max_msix_vectors;\n\n\tif (local_max_msix_vectors > 0)\n\t\tioc->reply_queue_count = min_t(int, local_max_msix_vectors,\n\t\t\tioc->reply_queue_count);\n\telse if (local_max_msix_vectors == 0)\n\t\tgoto try_ioapic;\n\n\t/*\n\t * Enable msix_load_balance only if combined reply queue mode is\n\t * disabled on SAS3 & above generation HBA devices.\n\t */\n\tif (!ioc->combined_reply_queue &&\n\t    ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tioc_info(ioc,\n\t\t    \"combined ReplyQueue is off, Enabling msix load balance\\n\");\n\t\tioc->msix_load_balance = true;\n\t}\n\n\t/*\n\t * smp affinity setting is not need when msix load balance\n\t * is enabled.\n\t */\n\tif (ioc->msix_load_balance)\n\t\tioc->smp_affinity_enable = 0;\n\n\tr = _base_alloc_irq_vectors(ioc);\n\tif (r < 0) {\n\t\tioc_info(ioc, \"pci_alloc_irq_vectors failed (r=%d) !!!\\n\", r);\n\t\tgoto try_ioapic;\n\t}\n\n\tioc->msix_enable = 1;\n\tioc->reply_queue_count = r;\n\tfor (i = 0; i < ioc->reply_queue_count; i++) {\n\t\tr = _base_request_irq(ioc, i);\n\t\tif (r) {\n\t\t\t_base_free_irq(ioc);\n\t\t\t_base_disable_msix(ioc);\n\t\t\tgoto try_ioapic;\n\t\t}\n\t}\n\n\tioc_info(ioc, \"High IOPs queues : %s\\n\",\n\t\t\tioc->high_iops_queues ? \"enabled\" : \"disabled\");\n\n\treturn 0;\n\n/* failback to io_apic interrupt routing */\n try_ioapic:\n\tioc->high_iops_queues = 0;\n\tioc_info(ioc, \"High IOPs queues : disabled\\n\");\n\tioc->reply_queue_count = 1;\n\tr = pci_alloc_irq_vectors(ioc->pdev, 1, 1, PCI_IRQ_LEGACY);\n\tif (r < 0) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"pci_alloc_irq_vector(legacy) failed (r=%d) !!!\\n\",\n\t\t\t\t     r));\n\t} else\n\t\tr = _base_request_irq(ioc, 0);\n\n\treturn r;\n}\n\n/**\n * mpt3sas_base_unmap_resources - free controller resources\n * @ioc: per adapter object\n */\nstatic void\nmpt3sas_base_unmap_resources(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct pci_dev *pdev = ioc->pdev;\n\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t_base_free_irq(ioc);\n\t_base_disable_msix(ioc);\n\n\tkfree(ioc->replyPostRegisterIndex);\n\tioc->replyPostRegisterIndex = NULL;\n\n\n\tif (ioc->chip_phys) {\n\t\tiounmap(ioc->chip);\n\t\tioc->chip_phys = 0;\n\t}\n\n\tif (pci_is_enabled(pdev)) {\n\t\tpci_release_selected_regions(ioc->pdev, ioc->bars);\n\t\tpci_disable_pcie_error_reporting(pdev);\n\t\tpci_disable_device(pdev);\n\t}\n}\n\nstatic int\n_base_diag_reset(struct MPT3SAS_ADAPTER *ioc);\n\n/**\n * _base_check_for_fault_and_issue_reset - check if IOC is in fault state\n *     and if it is in fault state then issue diag reset.\n * @ioc: per adapter object\n *\n * Returns: 0 for success, non-zero for failure.\n */\nstatic int\n_base_check_for_fault_and_issue_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 ioc_state;\n\tint rc = -EFAULT;\n\n\tdinitprintk(ioc, pr_info(\"%s\\n\", __func__));\n\tif (ioc->pci_error_recovery)\n\t\treturn 0;\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tdhsprintk(ioc, pr_info(\"%s: ioc_state(0x%08x)\\n\", __func__, ioc_state));\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\trc = _base_diag_reset(ioc);\n\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tmpt3sas_print_coredump_info(ioc, ioc_state &\n\t\t     MPI2_DOORBELL_DATA_MASK);\n\t\tmpt3sas_base_wait_for_coredump_completion(ioc, __func__);\n\t\trc = _base_diag_reset(ioc);\n\t}\n\n\treturn rc;\n}\n\n/**\n * mpt3sas_base_map_resources - map in controller resources (io/irq/memap)\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nint\nmpt3sas_base_map_resources(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct pci_dev *pdev = ioc->pdev;\n\tu32 memap_sz;\n\tu32 pio_sz;\n\tint i, r = 0, rc;\n\tu64 pio_chip = 0;\n\tphys_addr_t chip_phys = 0;\n\tstruct adapter_reply_queue *reply_q;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);\n\tif (pci_enable_device_mem(pdev)) {\n\t\tioc_warn(ioc, \"pci_enable_device_mem: failed\\n\");\n\t\tioc->bars = 0;\n\t\treturn -ENODEV;\n\t}\n\n\n\tif (pci_request_selected_regions(pdev, ioc->bars,\n\t    ioc->driver_name)) {\n\t\tioc_warn(ioc, \"pci_request_selected_regions: failed\\n\");\n\t\tioc->bars = 0;\n\t\tr = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n/* AER (Advanced Error Reporting) hooks */\n\tpci_enable_pcie_error_reporting(pdev);\n\n\tpci_set_master(pdev);\n\n\n\tif (_base_config_dma_addressing(ioc, pdev) != 0) {\n\t\tioc_warn(ioc, \"no suitable DMA mask for %s\\n\", pci_name(pdev));\n\t\tr = -ENODEV;\n\t\tgoto out_fail;\n\t}\n\n\tfor (i = 0, memap_sz = 0, pio_sz = 0; (i < DEVICE_COUNT_RESOURCE) &&\n\t     (!memap_sz || !pio_sz); i++) {\n\t\tif (pci_resource_flags(pdev, i) & IORESOURCE_IO) {\n\t\t\tif (pio_sz)\n\t\t\t\tcontinue;\n\t\t\tpio_chip = (u64)pci_resource_start(pdev, i);\n\t\t\tpio_sz = pci_resource_len(pdev, i);\n\t\t} else if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\n\t\t\tif (memap_sz)\n\t\t\t\tcontinue;\n\t\t\tioc->chip_phys = pci_resource_start(pdev, i);\n\t\t\tchip_phys = ioc->chip_phys;\n\t\t\tmemap_sz = pci_resource_len(pdev, i);\n\t\t\tioc->chip = ioremap(ioc->chip_phys, memap_sz);\n\t\t}\n\t}\n\n\tif (ioc->chip == NULL) {\n\t\tioc_err(ioc,\n\t\t    \"unable to map adapter memory! or resource not found\\n\");\n\t\tr = -EINVAL;\n\t\tgoto out_fail;\n\t}\n\n\tmpt3sas_base_mask_interrupts(ioc);\n\n\tr = _base_get_ioc_facts(ioc);\n\tif (r) {\n\t\trc = _base_check_for_fault_and_issue_reset(ioc);\n\t\tif (rc || (_base_get_ioc_facts(ioc)))\n\t\t\tgoto out_fail;\n\t}\n\n\tif (!ioc->rdpq_array_enable_assigned) {\n\t\tioc->rdpq_array_enable = ioc->rdpq_array_capable;\n\t\tioc->rdpq_array_enable_assigned = 1;\n\t}\n\n\tr = _base_enable_msix(ioc);\n\tif (r)\n\t\tgoto out_fail;\n\n\tif (!ioc->is_driver_loading)\n\t\t_base_init_irqpolls(ioc);\n\t/* Use the Combined reply queue feature only for SAS3 C0 & higher\n\t * revision HBAs and also only when reply queue count is greater than 8\n\t */\n\tif (ioc->combined_reply_queue) {\n\t\t/* Determine the Supplemental Reply Post Host Index Registers\n\t\t * Addresse. Supplemental Reply Post Host Index Registers\n\t\t * starts at offset MPI25_SUP_REPLY_POST_HOST_INDEX_OFFSET and\n\t\t * each register is at offset bytes of\n\t\t * MPT3_SUP_REPLY_POST_HOST_INDEX_REG_OFFSET from previous one.\n\t\t */\n\t\tioc->replyPostRegisterIndex = kcalloc(\n\t\t     ioc->combined_reply_index_count,\n\t\t     sizeof(resource_size_t *), GFP_KERNEL);\n\t\tif (!ioc->replyPostRegisterIndex) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"allocation for replyPostRegisterIndex failed!\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfor (i = 0; i < ioc->combined_reply_index_count; i++) {\n\t\t\tioc->replyPostRegisterIndex[i] = (resource_size_t *)\n\t\t\t     ((u8 __force *)&ioc->chip->Doorbell +\n\t\t\t     MPI25_SUP_REPLY_POST_HOST_INDEX_OFFSET +\n\t\t\t     (i * MPT3_SUP_REPLY_POST_HOST_INDEX_REG_OFFSET));\n\t\t}\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\tioc->reply_post_host_index[0] = (resource_size_t __iomem *)\n\t\t    &ioc->chip->ReplyPostHostIndex;\n\n\t\tfor (i = 1; i < ioc->cpu_msix_table_sz; i++)\n\t\t\tioc->reply_post_host_index[i] =\n\t\t\t(resource_size_t __iomem *)\n\t\t\t((u8 __iomem *)&ioc->chip->Doorbell + (0x4000 + ((i - 1)\n\t\t\t* 4)));\n\t}\n\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list)\n\t\tpr_info(\"%s: %s enabled: IRQ %d\\n\",\n\t\t\treply_q->name,\n\t\t\tioc->msix_enable ? \"PCI-MSI-X\" : \"IO-APIC\",\n\t\t\tpci_irq_vector(ioc->pdev, reply_q->msix_index));\n\n\tioc_info(ioc, \"iomem(%pap), mapped(0x%p), size(%d)\\n\",\n\t\t &chip_phys, ioc->chip, memap_sz);\n\tioc_info(ioc, \"ioport(0x%016llx), size(%d)\\n\",\n\t\t (unsigned long long)pio_chip, pio_sz);\n\n\t/* Save PCI configuration state for recovery from PCI AER/EEH errors */\n\tpci_save_state(pdev);\n\treturn 0;\n\n out_fail:\n\tmpt3sas_base_unmap_resources(ioc);\n\treturn r;\n}\n\n/**\n * mpt3sas_base_get_msg_frame - obtain request mf pointer\n * @ioc: per adapter object\n * @smid: system request message index(smid zero is invalid)\n *\n * Return: virt pointer to message frame.\n */\nvoid *\nmpt3sas_base_get_msg_frame(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn (void *)(ioc->request + (smid * ioc->request_sz));\n}\n\n/**\n * mpt3sas_base_get_sense_buffer - obtain a sense buffer virt addr\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: virt pointer to sense buffer.\n */\nvoid *\nmpt3sas_base_get_sense_buffer(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn (void *)(ioc->sense + ((smid - 1) * SCSI_SENSE_BUFFERSIZE));\n}\n\n/**\n * mpt3sas_base_get_sense_buffer_dma - obtain a sense buffer dma addr\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: phys pointer to the low 32bit address of the sense buffer.\n */\n__le32\nmpt3sas_base_get_sense_buffer_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn cpu_to_le32(ioc->sense_dma + ((smid - 1) *\n\t    SCSI_SENSE_BUFFERSIZE));\n}\n\n/**\n * mpt3sas_base_get_pcie_sgl - obtain a PCIe SGL virt addr\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: virt pointer to a PCIe SGL.\n */\nvoid *\nmpt3sas_base_get_pcie_sgl(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn (void *)(ioc->pcie_sg_lookup[smid - 1].pcie_sgl);\n}\n\n/**\n * mpt3sas_base_get_pcie_sgl_dma - obtain a PCIe SGL dma addr\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return: phys pointer to the address of the PCIe buffer.\n */\ndma_addr_t\nmpt3sas_base_get_pcie_sgl_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\treturn ioc->pcie_sg_lookup[smid - 1].pcie_sgl_dma;\n}\n\n/**\n * mpt3sas_base_get_reply_virt_addr - obtain reply frames virt address\n * @ioc: per adapter object\n * @phys_addr: lower 32 physical addr of the reply\n *\n * Converts 32bit lower physical addr into a virt address.\n */\nvoid *\nmpt3sas_base_get_reply_virt_addr(struct MPT3SAS_ADAPTER *ioc, u32 phys_addr)\n{\n\tif (!phys_addr)\n\t\treturn NULL;\n\treturn ioc->reply + (phys_addr - (u32)ioc->reply_dma);\n}\n\n/**\n * _base_get_msix_index - get the msix index\n * @ioc: per adapter object\n * @scmd: scsi_cmnd object\n *\n * returns msix index of general reply queues,\n * i.e. reply queue on which IO request's reply\n * should be posted by the HBA firmware.\n */\nstatic inline u8\n_base_get_msix_index(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd)\n{\n\t/* Enables reply_queue load balancing */\n\tif (ioc->msix_load_balance)\n\t\treturn ioc->reply_queue_count ?\n\t\t    base_mod64(atomic64_add_return(1,\n\t\t    &ioc->total_io_cnt), ioc->reply_queue_count) : 0;\n\n\tif (scmd && ioc->shost->nr_hw_queues > 1) {\n\t\tu32 tag = blk_mq_unique_tag(scmd->request);\n\n\t\treturn blk_mq_unique_tag_to_hwq(tag) +\n\t\t\tioc->high_iops_queues;\n\t}\n\n\treturn ioc->cpu_msix_table[raw_smp_processor_id()];\n}\n\n/**\n * _base_get_high_iops_msix_index - get the msix index of\n *\t\t\t\thigh iops queues\n * @ioc: per adapter object\n * @scmd: scsi_cmnd object\n *\n * Returns: msix index of high iops reply queues.\n * i.e. high iops reply queue on which IO request's\n * reply should be posted by the HBA firmware.\n */\nstatic inline u8\n_base_get_high_iops_msix_index(struct MPT3SAS_ADAPTER *ioc,\n\tstruct scsi_cmnd *scmd)\n{\n\t/**\n\t * Round robin the IO interrupts among the high iops\n\t * reply queues in terms of batch count 16 when outstanding\n\t * IOs on the target device is >=8.\n\t */\n\n\tif (scsi_device_busy(scmd->device) > MPT3SAS_DEVICE_HIGH_IOPS_DEPTH)\n\t\treturn base_mod64((\n\t\t    atomic64_add_return(1, &ioc->high_iops_outstanding) /\n\t\t    MPT3SAS_HIGH_IOPS_BATCH_COUNT),\n\t\t    MPT3SAS_HIGH_IOPS_REPLY_QUEUES);\n\n\treturn _base_get_msix_index(ioc, scmd);\n}\n\n/**\n * mpt3sas_base_get_smid - obtain a free smid from internal queue\n * @ioc: per adapter object\n * @cb_idx: callback index\n *\n * Return: smid (zero is invalid)\n */\nu16\nmpt3sas_base_get_smid(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)\n{\n\tunsigned long flags;\n\tstruct request_tracker *request;\n\tu16 smid;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tif (list_empty(&ioc->internal_free_list)) {\n\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\tioc_err(ioc, \"%s: smid not available\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\trequest = list_entry(ioc->internal_free_list.next,\n\t    struct request_tracker, tracker_list);\n\trequest->cb_idx = cb_idx;\n\tsmid = request->smid;\n\tlist_del(&request->tracker_list);\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\treturn smid;\n}\n\n/**\n * mpt3sas_base_get_smid_scsiio - obtain a free smid from scsiio queue\n * @ioc: per adapter object\n * @cb_idx: callback index\n * @scmd: pointer to scsi command object\n *\n * Return: smid (zero is invalid)\n */\nu16\nmpt3sas_base_get_smid_scsiio(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx,\n\tstruct scsi_cmnd *scmd)\n{\n\tstruct scsiio_tracker *request = scsi_cmd_priv(scmd);\n\tu16 smid;\n\tu32 tag, unique_tag;\n\n\tunique_tag = blk_mq_unique_tag(scmd->request);\n\ttag = blk_mq_unique_tag_to_tag(unique_tag);\n\n\t/*\n\t * Store hw queue number corresponding to the tag.\n\t * This hw queue number is used later to determine\n\t * the unique_tag using the logic below. This unique_tag\n\t * is used to retrieve the scmd pointer corresponding\n\t * to tag using scsi_host_find_tag() API.\n\t *\n\t * tag = smid - 1;\n\t * unique_tag = ioc->io_queue_num[tag] << BLK_MQ_UNIQUE_TAG_BITS | tag;\n\t */\n\tioc->io_queue_num[tag] = blk_mq_unique_tag_to_hwq(unique_tag);\n\n\tsmid = tag + 1;\n\trequest->cb_idx = cb_idx;\n\trequest->smid = smid;\n\trequest->scmd = scmd;\n\tINIT_LIST_HEAD(&request->chain_list);\n\treturn smid;\n}\n\n/**\n * mpt3sas_base_get_smid_hpr - obtain a free smid from hi-priority queue\n * @ioc: per adapter object\n * @cb_idx: callback index\n *\n * Return: smid (zero is invalid)\n */\nu16\nmpt3sas_base_get_smid_hpr(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)\n{\n\tunsigned long flags;\n\tstruct request_tracker *request;\n\tu16 smid;\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tif (list_empty(&ioc->hpr_free_list)) {\n\t\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\t\treturn 0;\n\t}\n\n\trequest = list_entry(ioc->hpr_free_list.next,\n\t    struct request_tracker, tracker_list);\n\trequest->cb_idx = cb_idx;\n\tsmid = request->smid;\n\tlist_del(&request->tracker_list);\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\treturn smid;\n}\n\nstatic void\n_base_recovery_check(struct MPT3SAS_ADAPTER *ioc)\n{\n\t/*\n\t * See _wait_for_commands_to_complete() call with regards to this code.\n\t */\n\tif (ioc->shost_recovery && ioc->pending_io_count) {\n\t\tioc->pending_io_count = scsi_host_busy(ioc->shost);\n\t\tif (ioc->pending_io_count == 0)\n\t\t\twake_up(&ioc->reset_wq);\n\t}\n}\n\nvoid mpt3sas_base_clear_st(struct MPT3SAS_ADAPTER *ioc,\n\t\t\t   struct scsiio_tracker *st)\n{\n\tif (WARN_ON(st->smid == 0))\n\t\treturn;\n\tst->cb_idx = 0xFF;\n\tst->direct_io = 0;\n\tst->scmd = NULL;\n\tatomic_set(&ioc->chain_lookup[st->smid - 1].chain_offset, 0);\n\tst->smid = 0;\n}\n\n/**\n * mpt3sas_base_free_smid - put smid back on free_list\n * @ioc: per adapter object\n * @smid: system request message index\n */\nvoid\nmpt3sas_base_free_smid(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tunsigned long flags;\n\tint i;\n\n\tif (smid < ioc->hi_priority_smid) {\n\t\tstruct scsiio_tracker *st;\n\t\tvoid *request;\n\n\t\tst = _get_st_from_smid(ioc, smid);\n\t\tif (!st) {\n\t\t\t_base_recovery_check(ioc);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Clear MPI request frame */\n\t\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\t\tmemset(request, 0, ioc->request_sz);\n\n\t\tmpt3sas_base_clear_st(ioc, st);\n\t\t_base_recovery_check(ioc);\n\t\tioc->io_queue_num[smid - 1] = 0;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\tif (smid < ioc->internal_smid) {\n\t\t/* hi-priority */\n\t\ti = smid - ioc->hi_priority_smid;\n\t\tioc->hpr_lookup[i].cb_idx = 0xFF;\n\t\tlist_add(&ioc->hpr_lookup[i].tracker_list, &ioc->hpr_free_list);\n\t} else if (smid <= ioc->hba_queue_depth) {\n\t\t/* internal queue */\n\t\ti = smid - ioc->internal_smid;\n\t\tioc->internal_lookup[i].cb_idx = 0xFF;\n\t\tlist_add(&ioc->internal_lookup[i].tracker_list,\n\t\t    &ioc->internal_free_list);\n\t}\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n}\n\n/**\n * _base_mpi_ep_writeq - 32 bit write to MMIO\n * @b: data payload\n * @addr: address in MMIO space\n * @writeq_lock: spin lock\n *\n * This special handling for MPI EP to take care of 32 bit\n * environment where its not quarenteed to send the entire word\n * in one transfer.\n */\nstatic inline void\n_base_mpi_ep_writeq(__u64 b, volatile void __iomem *addr,\n\t\t\t\t\tspinlock_t *writeq_lock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(writeq_lock, flags);\n\t__raw_writel((u32)(b), addr);\n\t__raw_writel((u32)(b >> 32), (addr + 4));\n\tspin_unlock_irqrestore(writeq_lock, flags);\n}\n\n/**\n * _base_writeq - 64 bit write to MMIO\n * @b: data payload\n * @addr: address in MMIO space\n * @writeq_lock: spin lock\n *\n * Glue for handling an atomic 64 bit word to MMIO. This special handling takes\n * care of 32 bit environment where its not quarenteed to send the entire word\n * in one transfer.\n */\n#if defined(writeq) && defined(CONFIG_64BIT)\nstatic inline void\n_base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)\n{\n\twmb();\n\t__raw_writeq(b, addr);\n\tbarrier();\n}\n#else\nstatic inline void\n_base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)\n{\n\t_base_mpi_ep_writeq(b, addr, writeq_lock);\n}\n#endif\n\n/**\n * _base_set_and_get_msix_index - get the msix index and assign to msix_io\n *                                variable of scsi tracker\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * returns msix index.\n */\nstatic u8\n_base_set_and_get_msix_index(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tstruct scsiio_tracker *st = NULL;\n\n\tif (smid < ioc->hi_priority_smid)\n\t\tst = _get_st_from_smid(ioc, smid);\n\n\tif (st == NULL)\n\t\treturn  _base_get_msix_index(ioc, NULL);\n\n\tst->msix_io = ioc->get_msix_index_for_smlio(ioc, st->scmd);\n\treturn st->msix_io;\n}\n\n/**\n * _base_put_smid_mpi_ep_scsi_io - send SCSI_IO request to firmware\n * @ioc: per adapter object\n * @smid: system request message index\n * @handle: device handle\n */\nstatic void\n_base_put_smid_mpi_ep_scsi_io(struct MPT3SAS_ADAPTER *ioc,\n\tu16 smid, u16 handle)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\tvoid *mpi_req_iomem;\n\t__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t_clone_sg_entries(ioc, (void *) mfp, smid);\n\tmpi_req_iomem = (void __force *)ioc->chip +\n\t\t\tMPI_FRAME_START_OFFSET + (smid * ioc->request_sz);\n\t_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,\n\t\t\t\t\tioc->request_sz);\n\tdescriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\n\tdescriptor.SCSIIO.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SCSIIO.SMID = cpu_to_le16(smid);\n\tdescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\n\tdescriptor.SCSIIO.LMID = 0;\n\t_base_mpi_ep_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n/**\n * _base_put_smid_scsi_io - send SCSI_IO request to firmware\n * @ioc: per adapter object\n * @smid: system request message index\n * @handle: device handle\n */\nstatic void\n_base_put_smid_scsi_io(struct MPT3SAS_ADAPTER *ioc, u16 smid, u16 handle)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\n\n\tdescriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\n\tdescriptor.SCSIIO.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SCSIIO.SMID = cpu_to_le16(smid);\n\tdescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\n\tdescriptor.SCSIIO.LMID = 0;\n\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n/**\n * _base_put_smid_fast_path - send fast path request to firmware\n * @ioc: per adapter object\n * @smid: system request message index\n * @handle: device handle\n */\nstatic void\n_base_put_smid_fast_path(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 handle)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\n\tdescriptor.SCSIIO.RequestFlags =\n\t    MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO;\n\tdescriptor.SCSIIO.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SCSIIO.SMID = cpu_to_le16(smid);\n\tdescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\n\tdescriptor.SCSIIO.LMID = 0;\n\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n/**\n * _base_put_smid_hi_priority - send Task Management request to firmware\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_task: msix_task will be same as msix of IO incase of task abort else 0.\n */\nstatic void\n_base_put_smid_hi_priority(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 msix_task)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tvoid *mpi_req_iomem;\n\tu64 *request;\n\n\tif (ioc->is_mcpu_endpoint) {\n\t\t__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t\t/* TBD 256 is offset within sys register. */\n\t\tmpi_req_iomem = (void __force *)ioc->chip\n\t\t\t\t\t+ MPI_FRAME_START_OFFSET\n\t\t\t\t\t+ (smid * ioc->request_sz);\n\t\t_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,\n\t\t\t\t\t\t\tioc->request_sz);\n\t}\n\n\trequest = (u64 *)&descriptor;\n\n\tdescriptor.HighPriority.RequestFlags =\n\t    MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;\n\tdescriptor.HighPriority.MSIxIndex =  msix_task;\n\tdescriptor.HighPriority.SMID = cpu_to_le16(smid);\n\tdescriptor.HighPriority.LMID = 0;\n\tdescriptor.HighPriority.Reserved1 = 0;\n\tif (ioc->is_mcpu_endpoint)\n\t\t_base_mpi_ep_writeq(*request,\n\t\t\t\t&ioc->chip->RequestDescriptorPostLow,\n\t\t\t\t&ioc->scsi_lookup_lock);\n\telse\n\t\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t\t    &ioc->scsi_lookup_lock);\n}\n\n/**\n * mpt3sas_base_put_smid_nvme_encap - send NVMe encapsulated request to\n *  firmware\n * @ioc: per adapter object\n * @smid: system request message index\n */\nvoid\nmpt3sas_base_put_smid_nvme_encap(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tu64 *request = (u64 *)&descriptor;\n\n\tdescriptor.Default.RequestFlags =\n\t\tMPI26_REQ_DESCRIPT_FLAGS_PCIE_ENCAPSULATED;\n\tdescriptor.Default.MSIxIndex =  _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.Default.SMID = cpu_to_le16(smid);\n\tdescriptor.Default.LMID = 0;\n\tdescriptor.Default.DescriptorTypeDependent = 0;\n\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t    &ioc->scsi_lookup_lock);\n}\n\n/**\n * _base_put_smid_default - Default, primarily used for config pages\n * @ioc: per adapter object\n * @smid: system request message index\n */\nstatic void\n_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tMpi2RequestDescriptorUnion_t descriptor;\n\tvoid *mpi_req_iomem;\n\tu64 *request;\n\n\tif (ioc->is_mcpu_endpoint) {\n\t\t__le32 *mfp = (__le32 *)mpt3sas_base_get_msg_frame(ioc, smid);\n\n\t\t_clone_sg_entries(ioc, (void *) mfp, smid);\n\t\t/* TBD 256 is offset within sys register */\n\t\tmpi_req_iomem = (void __force *)ioc->chip +\n\t\t\tMPI_FRAME_START_OFFSET + (smid * ioc->request_sz);\n\t\t_base_clone_mpi_to_sys_mem(mpi_req_iomem, (void *)mfp,\n\t\t\t\t\t\t\tioc->request_sz);\n\t}\n\trequest = (u64 *)&descriptor;\n\tdescriptor.Default.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;\n\tdescriptor.Default.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.Default.SMID = cpu_to_le16(smid);\n\tdescriptor.Default.LMID = 0;\n\tdescriptor.Default.DescriptorTypeDependent = 0;\n\tif (ioc->is_mcpu_endpoint)\n\t\t_base_mpi_ep_writeq(*request,\n\t\t\t\t&ioc->chip->RequestDescriptorPostLow,\n\t\t\t\t&ioc->scsi_lookup_lock);\n\telse\n\t\t_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\n\t\t\t\t&ioc->scsi_lookup_lock);\n}\n\n/**\n * _base_put_smid_scsi_io_atomic - send SCSI_IO request to firmware using\n *   Atomic Request Descriptor\n * @ioc: per adapter object\n * @smid: system request message index\n * @handle: device handle, unused in this function, for function type match\n *\n * Return nothing.\n */\nstatic void\n_base_put_smid_scsi_io_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 handle)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\n\tdescriptor.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n/**\n * _base_put_smid_fast_path_atomic - send fast path request to firmware\n * using Atomic Request Descriptor\n * @ioc: per adapter object\n * @smid: system request message index\n * @handle: device handle, unused in this function, for function type match\n * Return nothing\n */\nstatic void\n_base_put_smid_fast_path_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 handle)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO;\n\tdescriptor.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n/**\n * _base_put_smid_hi_priority_atomic - send Task Management request to\n * firmware using Atomic Request Descriptor\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_task: msix_task will be same as msix of IO incase of task abort else 0\n *\n * Return nothing.\n */\nstatic void\n_base_put_smid_hi_priority_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid,\n\tu16 msix_task)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;\n\tdescriptor.MSIxIndex = msix_task;\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n/**\n * _base_put_smid_default_atomic - Default, primarily used for config pages\n * use Atomic Request Descriptor\n * @ioc: per adapter object\n * @smid: system request message index\n *\n * Return nothing.\n */\nstatic void\n_base_put_smid_default_atomic(struct MPT3SAS_ADAPTER *ioc, u16 smid)\n{\n\tMpi26AtomicRequestDescriptor_t descriptor;\n\tu32 *request = (u32 *)&descriptor;\n\n\tdescriptor.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;\n\tdescriptor.MSIxIndex = _base_set_and_get_msix_index(ioc, smid);\n\tdescriptor.SMID = cpu_to_le16(smid);\n\n\twritel(cpu_to_le32(*request), &ioc->chip->AtomicRequestDescriptorPost);\n}\n\n/**\n * _base_display_OEMs_branding - Display branding string\n * @ioc: per adapter object\n */\nstatic void\n_base_display_OEMs_branding(struct MPT3SAS_ADAPTER *ioc)\n{\n\tif (ioc->pdev->subsystem_vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn;\n\n\tswitch (ioc->pdev->subsystem_vendor) {\n\tcase PCI_VENDOR_ID_INTEL:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_INTEL_RMS2LL080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS2LL080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS2LL040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS2LL040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_SSD910_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_SSD910_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2308_2:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_INTEL_RS25GB008_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RS25GB008_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25JB080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25JB080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25JB040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25JB040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25KB080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25KB080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25KB040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25KB040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25LB040_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25LB040_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_INTEL_RMS25LB080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_INTEL_RMS25LB080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_INTEL_RMS3JC080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RMS3JC080_BRANDING);\n\t\t\t\tbreak;\n\n\t\t\tcase MPT3SAS_INTEL_RS3GC008_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RS3GC008_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_INTEL_RS3FC044_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RS3FC044_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_INTEL_RS3UC080_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_INTEL_RS3UC080_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"Intel(R) Controller: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_DELL:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_DELL_6GBPS_SAS_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_6GBPS_SAS_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_ADAPTER_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_ADAPTER_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_INTEGRATED_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_INTEGRATED_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_MODULAR_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_MODULAR_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_EMBEDDED_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_EMBEDDED_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_PERC_H200_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_PERC_H200_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_DELL_6GBPS_SAS_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_DELL_6GBPS_SAS_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Dell 6Gbps HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_DELL_12G_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_DELL_12G_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Dell 12Gbps HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"Dell HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_CISCO:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3008:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_CISCO_12G_8E_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_8E_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_CISCO_12G_8I_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_8I_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_CISCO_12G_AVILA_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_AVILA_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Cisco 12Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI25_MFGPAGE_DEVID_SAS3108_1:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT3SAS_CISCO_12G_AVILA_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_AVILA_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT3SAS_CISCO_12G_COLUSA_MEZZANINE_HBA_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT3SAS_CISCO_12G_COLUSA_MEZZANINE_HBA_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"Cisco 12Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"Cisco SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase MPT2SAS_HP_3PAR_SSVID:\n\t\tswitch (ioc->pdev->device) {\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2004:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_DAUGHTER_2_4_INTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"HP 6Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MPI2_MFGPAGE_DEVID_SAS2308_2:\n\t\t\tswitch (ioc->pdev->subsystem_device) {\n\t\t\tcase MPT2SAS_HP_2_4_INTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_2_4_INTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_HP_2_4_EXTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_2_4_EXTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_1_4_INTERNAL_1_4_EXTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tcase MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_SSDID:\n\t\t\t\tioc_info(ioc, \"%s\\n\",\n\t\t\t\t\t MPT2SAS_HP_EMBEDDED_2_4_INTERNAL_BRANDING);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tioc_info(ioc, \"HP 6Gbps SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tioc_info(ioc, \"HP SAS HBA: Subsystem ID: 0x%X\\n\",\n\t\t\t\t ioc->pdev->subsystem_device);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/**\n * _base_display_fwpkg_version - sends FWUpload request to pull FWPkg\n *\t\t\t\tversion from FW Image Header.\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\n\tstatic int\n_base_display_fwpkg_version(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2FWImageHeader_t *fw_img_hdr;\n\tMpi26ComponentImageHeader_t *cmp_img_hdr;\n\tMpi25FWUploadRequest_t *mpi_request;\n\tMpi2FWUploadReply_t mpi_reply;\n\tint r = 0;\n\tu32  package_version = 0;\n\tvoid *fwpkg_data = NULL;\n\tdma_addr_t fwpkg_data_dma;\n\tu16 smid, ioc_status;\n\tsize_t data_length;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tdata_length = sizeof(Mpi2FWImageHeader_t);\n\tfwpkg_data = dma_alloc_coherent(&ioc->pdev->dev, data_length,\n\t\t\t&fwpkg_data_dma, GFP_KERNEL);\n\tif (!fwpkg_data) {\n\t\tioc_err(ioc,\n\t\t    \"Memory allocation for fwpkg data failed at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi25FWUploadRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_FW_UPLOAD;\n\tmpi_request->ImageType = MPI2_FW_UPLOAD_ITYPE_FW_FLASH;\n\tmpi_request->ImageSize = cpu_to_le32(data_length);\n\tioc->build_sg(ioc, &mpi_request->SGL, 0, 0, fwpkg_data_dma,\n\t\t\tdata_length);\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\t/* Wait for 15 seconds */\n\twait_for_completion_timeout(&ioc->base_cmds.done,\n\t\t\tFW_IMG_HDR_READ_TIMEOUT*HZ);\n\tioc_info(ioc, \"%s: complete\\n\", __func__);\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t\t\tsizeof(Mpi25FWUploadRequest_t)/4);\n\t\tr = -ETIME;\n\t} else {\n\t\tmemset(&mpi_reply, 0, sizeof(Mpi2FWUploadReply_t));\n\t\tif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID) {\n\t\t\tmemcpy(&mpi_reply, ioc->base_cmds.reply,\n\t\t\t\t\tsizeof(Mpi2FWUploadReply_t));\n\t\t\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t\t\t\t\t\tMPI2_IOCSTATUS_MASK;\n\t\t\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\t\t\tfw_img_hdr = (Mpi2FWImageHeader_t *)fwpkg_data;\n\t\t\t\tif (le32_to_cpu(fw_img_hdr->Signature) ==\n\t\t\t\t    MPI26_IMAGE_HEADER_SIGNATURE0_MPI26) {\n\t\t\t\t\tcmp_img_hdr =\n\t\t\t\t\t    (Mpi26ComponentImageHeader_t *)\n\t\t\t\t\t    (fwpkg_data);\n\t\t\t\t\tpackage_version =\n\t\t\t\t\t    le32_to_cpu(\n\t\t\t\t\t    cmp_img_hdr->ApplicationSpecific);\n\t\t\t\t} else\n\t\t\t\t\tpackage_version =\n\t\t\t\t\t    le32_to_cpu(\n\t\t\t\t\t    fw_img_hdr->PackageVersion.Word);\n\t\t\t\tif (package_version)\n\t\t\t\t\tioc_info(ioc,\n\t\t\t\t\t\"FW Package Ver(%02d.%02d.%02d.%02d)\\n\",\n\t\t\t\t\t((package_version) & 0xFF000000) >> 24,\n\t\t\t\t\t((package_version) & 0x00FF0000) >> 16,\n\t\t\t\t\t((package_version) & 0x0000FF00) >> 8,\n\t\t\t\t\t(package_version) & 0x000000FF);\n\t\t\t} else {\n\t\t\t\t_debug_dump_mf(&mpi_reply,\n\t\t\t\t\t\tsizeof(Mpi2FWUploadReply_t)/4);\n\t\t\t}\n\t\t}\n\t}\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\nout:\n\tif (fwpkg_data)\n\t\tdma_free_coherent(&ioc->pdev->dev, data_length, fwpkg_data,\n\t\t\t\tfwpkg_data_dma);\n\treturn r;\n}\n\n/**\n * _base_display_ioc_capabilities - Disply IOC's capabilities.\n * @ioc: per adapter object\n */\nstatic void\n_base_display_ioc_capabilities(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i = 0;\n\tchar desc[16];\n\tu32 iounit_pg1_flags;\n\tu32 bios_version;\n\n\tbios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);\n\tstrncpy(desc, ioc->manu_pg0.ChipName, 16);\n\tioc_info(ioc, \"%s: FWVersion(%02d.%02d.%02d.%02d), ChipRevision(0x%02x), BiosVersion(%02d.%02d.%02d.%02d)\\n\",\n\t\t desc,\n\t\t (ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\n\t\t (ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\n\t\t (ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\n\t\t ioc->facts.FWVersion.Word & 0x000000FF,\n\t\t ioc->pdev->revision,\n\t\t (bios_version & 0xFF000000) >> 24,\n\t\t (bios_version & 0x00FF0000) >> 16,\n\t\t (bios_version & 0x0000FF00) >> 8,\n\t\t bios_version & 0x000000FF);\n\n\t_base_display_OEMs_branding(ioc);\n\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_NVME_DEVICES) {\n\t\tpr_info(\"%sNVMe\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tioc_info(ioc, \"Protocol=(\");\n\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR) {\n\t\tpr_cont(\"Initiator\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_TARGET) {\n\t\tpr_cont(\"%sTarget\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\ti = 0;\n\tpr_cont(\"), Capabilities=(\");\n\n\tif (!ioc->hide_ir_msg) {\n\t\tif (ioc->facts.IOCCapabilities &\n\t\t    MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID) {\n\t\t\tpr_cont(\"Raid\");\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR) {\n\t\tpr_cont(\"%sTLR\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_MULTICAST) {\n\t\tpr_cont(\"%sMulticast\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_BIDIRECTIONAL_TARGET) {\n\t\tpr_cont(\"%sBIDI Target\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_EEDP) {\n\t\tpr_cont(\"%sEEDP\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER) {\n\t\tpr_cont(\"%sSnapshot Buffer\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER) {\n\t\tpr_cont(\"%sDiag Trace Buffer\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER) {\n\t\tpr_cont(\"%sDiag Extended Buffer\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tif (ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING) {\n\t\tpr_cont(\"%sTask Set Full\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tiounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);\n\tif (!(iounit_pg1_flags & MPI2_IOUNITPAGE1_NATIVE_COMMAND_Q_DISABLE)) {\n\t\tpr_cont(\"%sNCQ\", i ? \",\" : \"\");\n\t\ti++;\n\t}\n\n\tpr_cont(\")\\n\");\n}\n\n/**\n * mpt3sas_base_update_missing_delay - change the missing delay timers\n * @ioc: per adapter object\n * @device_missing_delay: amount of time till device is reported missing\n * @io_missing_delay: interval IO is returned when there is a missing device\n *\n * Passed on the command line, this function will modify the device missing\n * delay, as well as the io missing delay. This should be called at driver\n * load time.\n */\nvoid\nmpt3sas_base_update_missing_delay(struct MPT3SAS_ADAPTER *ioc,\n\tu16 device_missing_delay, u8 io_missing_delay)\n{\n\tu16 dmd, dmd_new, dmd_orignal;\n\tu8 io_missing_delay_original;\n\tu16 sz;\n\tMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\n\tMpi2ConfigReply_t mpi_reply;\n\tu8 num_phys = 0;\n\tu16 ioc_status;\n\n\tmpt3sas_config_get_number_hba_phys(ioc, &num_phys);\n\tif (!num_phys)\n\t\treturn;\n\n\tsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (num_phys *\n\t    sizeof(Mpi2SasIOUnit1PhyData_t));\n\tsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\n\tif (!sas_iounit_pg1) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\n\t    sas_iounit_pg1, sz))) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"failure at %s:%d/%s()!\\n\",\n\t\t\t__FILE__, __LINE__, __func__);\n\t\tgoto out;\n\t}\n\n\t/* device missing delay */\n\tdmd = sas_iounit_pg1->ReportDeviceMissingDelay;\n\tif (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\n\t\tdmd = (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\n\telse\n\t\tdmd = dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\tdmd_orignal = dmd;\n\tif (device_missing_delay > 0x7F) {\n\t\tdmd = (device_missing_delay > 0x7F0) ? 0x7F0 :\n\t\t    device_missing_delay;\n\t\tdmd = dmd / 16;\n\t\tdmd |= MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16;\n\t} else\n\t\tdmd = device_missing_delay;\n\tsas_iounit_pg1->ReportDeviceMissingDelay = dmd;\n\n\t/* io missing delay */\n\tio_missing_delay_original = sas_iounit_pg1->IODeviceMissingDelay;\n\tsas_iounit_pg1->IODeviceMissingDelay = io_missing_delay;\n\n\tif (!mpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,\n\t    sz)) {\n\t\tif (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\n\t\t\tdmd_new = (dmd &\n\t\t\t    MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\n\t\telse\n\t\t\tdmd_new =\n\t\t    dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\n\t\tioc_info(ioc, \"device_missing_delay: old(%d), new(%d)\\n\",\n\t\t\t dmd_orignal, dmd_new);\n\t\tioc_info(ioc, \"ioc_missing_delay: old(%d), new(%d)\\n\",\n\t\t\t io_missing_delay_original,\n\t\t\t io_missing_delay);\n\t\tioc->device_missing_delay = dmd_new;\n\t\tioc->io_missing_delay = io_missing_delay;\n\t}\n\nout:\n\tkfree(sas_iounit_pg1);\n}\n\n/**\n * _base_update_ioc_page1_inlinewith_perf_mode - Update IOC Page1 fields\n *    according to performance mode.\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_update_ioc_page1_inlinewith_perf_mode(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2IOCPage1_t ioc_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\n\tmpt3sas_config_get_ioc_pg1(ioc, &mpi_reply, &ioc->ioc_pg1_copy);\n\tmemcpy(&ioc_pg1, &ioc->ioc_pg1_copy, sizeof(Mpi2IOCPage1_t));\n\n\tswitch (perf_mode) {\n\tcase MPT_PERF_MODE_DEFAULT:\n\tcase MPT_PERF_MODE_BALANCED:\n\t\tif (ioc->high_iops_queues) {\n\t\t\tioc_info(ioc,\n\t\t\t\t\"Enable interrupt coalescing only for first\\t\"\n\t\t\t\t\"%d reply queues\\n\",\n\t\t\t\tMPT3SAS_HIGH_IOPS_REPLY_QUEUES);\n\t\t\t/*\n\t\t\t * If 31st bit is zero then interrupt coalescing is\n\t\t\t * enabled for all reply descriptor post queues.\n\t\t\t * If 31st bit is set to one then user can\n\t\t\t * enable/disable interrupt coalescing on per reply\n\t\t\t * descriptor post queue group(8) basis. So to enable\n\t\t\t * interrupt coalescing only on first reply descriptor\n\t\t\t * post queue group 31st bit and zero th bit is enabled.\n\t\t\t */\n\t\t\tioc_pg1.ProductSpecific = cpu_to_le32(0x80000000 |\n\t\t\t    ((1 << MPT3SAS_HIGH_IOPS_REPLY_QUEUES/8) - 1));\n\t\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply, &ioc_pg1);\n\t\t\tioc_info(ioc, \"performance mode: balanced\\n\");\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase MPT_PERF_MODE_LATENCY:\n\t\t/*\n\t\t * Enable interrupt coalescing on all reply queues\n\t\t * with timeout value 0xA\n\t\t */\n\t\tioc_pg1.CoalescingTimeout = cpu_to_le32(0xa);\n\t\tioc_pg1.Flags |= cpu_to_le32(MPI2_IOCPAGE1_REPLY_COALESCING);\n\t\tioc_pg1.ProductSpecific = 0;\n\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply, &ioc_pg1);\n\t\tioc_info(ioc, \"performance mode: latency\\n\");\n\t\tbreak;\n\tcase MPT_PERF_MODE_IOPS:\n\t\t/*\n\t\t * Enable interrupt coalescing on all reply queues.\n\t\t */\n\t\tioc_info(ioc,\n\t\t    \"performance mode: iops with coalescing timeout: 0x%x\\n\",\n\t\t    le32_to_cpu(ioc_pg1.CoalescingTimeout));\n\t\tioc_pg1.Flags |= cpu_to_le32(MPI2_IOCPAGE1_REPLY_COALESCING);\n\t\tioc_pg1.ProductSpecific = 0;\n\t\tmpt3sas_config_set_ioc_pg1(ioc, &mpi_reply, &ioc_pg1);\n\t\tbreak;\n\t}\n}\n\n/**\n * _base_get_event_diag_triggers - get event diag trigger values from\n *\t\t\t\tpersistent pages\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_get_event_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage2_t trigger_pg2;\n\tstruct SL_WH_EVENT_TRIGGER_T *event_tg;\n\tMPI26_DRIVER_MPI_EVENT_TIGGER_ENTRY *mpi_event_tg;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r = 0, i = 0;\n\tu16 count = 0;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg2(ioc, &mpi_reply,\n\t    &trigger_pg2);\n\tif (r)\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg2, ioc_status(0x%04x)\\n\",\n\t\t   __func__, ioc_status));\n\t\treturn;\n\t}\n\n\tif (le16_to_cpu(trigger_pg2.NumMPIEventTrigger)) {\n\t\tcount = le16_to_cpu(trigger_pg2.NumMPIEventTrigger);\n\t\tcount = min_t(u16, NUM_VALID_ENTRIES, count);\n\t\tioc->diag_trigger_event.ValidEntries = count;\n\n\t\tevent_tg = &ioc->diag_trigger_event.EventTriggerEntry[0];\n\t\tmpi_event_tg = &trigger_pg2.MPIEventTriggers[0];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tevent_tg->EventValue = le16_to_cpu(\n\t\t\t    mpi_event_tg->MPIEventCode);\n\t\t\tevent_tg->LogEntryQualifier = le16_to_cpu(\n\t\t\t    mpi_event_tg->MPIEventCodeSpecific);\n\t\t\tevent_tg++;\n\t\t\tmpi_event_tg++;\n\t\t}\n\t}\n}\n\n/**\n * _base_get_scsi_diag_triggers - get scsi diag trigger values from\n *\t\t\t\tpersistent pages\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_get_scsi_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage3_t trigger_pg3;\n\tstruct SL_WH_SCSI_TRIGGER_T *scsi_tg;\n\tMPI26_DRIVER_SCSI_SENSE_TIGGER_ENTRY *mpi_scsi_tg;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r = 0, i = 0;\n\tu16 count = 0;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg3(ioc, &mpi_reply,\n\t    &trigger_pg3);\n\tif (r)\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg3, ioc_status(0x%04x)\\n\",\n\t\t    __func__, ioc_status));\n\t\treturn;\n\t}\n\n\tif (le16_to_cpu(trigger_pg3.NumSCSISenseTrigger)) {\n\t\tcount = le16_to_cpu(trigger_pg3.NumSCSISenseTrigger);\n\t\tcount = min_t(u16, NUM_VALID_ENTRIES, count);\n\t\tioc->diag_trigger_scsi.ValidEntries = count;\n\n\t\tscsi_tg = &ioc->diag_trigger_scsi.SCSITriggerEntry[0];\n\t\tmpi_scsi_tg = &trigger_pg3.SCSISenseTriggers[0];\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tscsi_tg->ASCQ = mpi_scsi_tg->ASCQ;\n\t\t\tscsi_tg->ASC = mpi_scsi_tg->ASC;\n\t\t\tscsi_tg->SenseKey = mpi_scsi_tg->SenseKey;\n\n\t\t\tscsi_tg++;\n\t\t\tmpi_scsi_tg++;\n\t\t}\n\t}\n}\n\n/**\n * _base_get_mpi_diag_triggers - get mpi diag trigger values from\n *\t\t\t\tpersistent pages\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_get_mpi_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage4_t trigger_pg4;\n\tstruct SL_WH_MPI_TRIGGER_T *status_tg;\n\tMPI26_DRIVER_IOCSTATUS_LOGINFO_TIGGER_ENTRY *mpi_status_tg;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r = 0, i = 0;\n\tu16 count = 0;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg4(ioc, &mpi_reply,\n\t    &trigger_pg4);\n\tif (r)\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg4, ioc_status(0x%04x)\\n\",\n\t\t    __func__, ioc_status));\n\t\treturn;\n\t}\n\n\tif (le16_to_cpu(trigger_pg4.NumIOCStatusLogInfoTrigger)) {\n\t\tcount = le16_to_cpu(trigger_pg4.NumIOCStatusLogInfoTrigger);\n\t\tcount = min_t(u16, NUM_VALID_ENTRIES, count);\n\t\tioc->diag_trigger_mpi.ValidEntries = count;\n\n\t\tstatus_tg = &ioc->diag_trigger_mpi.MPITriggerEntry[0];\n\t\tmpi_status_tg = &trigger_pg4.IOCStatusLoginfoTriggers[0];\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tstatus_tg->IOCStatus = le16_to_cpu(\n\t\t\t    mpi_status_tg->IOCStatus);\n\t\t\tstatus_tg->IocLogInfo = le32_to_cpu(\n\t\t\t    mpi_status_tg->LogInfo);\n\n\t\t\tstatus_tg++;\n\t\t\tmpi_status_tg++;\n\t\t}\n\t}\n}\n\n/**\n * _base_get_master_diag_triggers - get master diag trigger values from\n *\t\t\t\tpersistent pages\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_get_master_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage1_t trigger_pg1;\n\tMpi2ConfigReply_t mpi_reply;\n\tint r;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg1(ioc, &mpi_reply,\n\t    &trigger_pg1);\n\tif (r)\n\t\treturn;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tdinitprintk(ioc,\n\t\t    ioc_err(ioc,\n\t\t    \"%s: Failed to get trigger pg1, ioc_status(0x%04x)\\n\",\n\t\t   __func__, ioc_status));\n\t\treturn;\n\t}\n\n\tif (le16_to_cpu(trigger_pg1.NumMasterTrigger))\n\t\tioc->diag_trigger_master.MasterData |=\n\t\t    le32_to_cpu(\n\t\t    trigger_pg1.MasterTriggers[0].MasterTriggerFlags);\n}\n\n/**\n * _base_check_for_trigger_pages_support - checks whether HBA FW supports\n *\t\t\t\t\tdriver trigger pages or not\n * @ioc : per adapter object\n *\n * Returns trigger flags mask if HBA FW supports driver trigger pages,\n * otherwise returns EFAULT.\n */\nstatic int\n_base_check_for_trigger_pages_support(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi26DriverTriggerPage0_t trigger_pg0;\n\tint r = 0;\n\tMpi2ConfigReply_t mpi_reply;\n\tu16 ioc_status;\n\n\tr = mpt3sas_config_get_driver_trigger_pg0(ioc, &mpi_reply,\n\t    &trigger_pg0);\n\tif (r)\n\t\treturn -EFAULT;\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\n\t    MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\treturn -EFAULT;\n\n\treturn le16_to_cpu(trigger_pg0.TriggerFlags);\n}\n\n/**\n * _base_get_diag_triggers - Retrieve diag trigger values from\n *\t\t\t\tpersistent pages.\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_get_diag_triggers(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint trigger_flags;\n\n\t/*\n\t * Default setting of master trigger.\n\t */\n\tioc->diag_trigger_master.MasterData =\n\t    (MASTER_TRIGGER_FW_FAULT + MASTER_TRIGGER_ADAPTER_RESET);\n\n\ttrigger_flags = _base_check_for_trigger_pages_support(ioc);\n\tif (trigger_flags < 0)\n\t\treturn;\n\n\tioc->supports_trigger_pages = 1;\n\n\t/*\n\t * Retrieve master diag trigger values from driver trigger pg1\n\t * if master trigger bit enabled in TriggerFlags.\n\t */\n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_MASTER_TRIGGER_VALID)\n\t\t_base_get_master_diag_triggers(ioc);\n\n\t/*\n\t * Retrieve event diag trigger values from driver trigger pg2\n\t * if event trigger bit enabled in TriggerFlags.\n\t */\n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_MPI_EVENT_TRIGGER_VALID)\n\t\t_base_get_event_diag_triggers(ioc);\n\n\t/*\n\t * Retrieve scsi diag trigger values from driver trigger pg3\n\t * if scsi trigger bit enabled in TriggerFlags.\n\t */\n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_SCSI_SENSE_TRIGGER_VALID)\n\t\t_base_get_scsi_diag_triggers(ioc);\n\t/*\n\t * Retrieve mpi error diag trigger values from driver trigger pg4\n\t * if loginfo trigger bit enabled in TriggerFlags.\n\t */\n\tif ((u16)trigger_flags &\n\t    MPI26_DRIVER_TRIGGER0_FLAG_LOGINFO_TRIGGER_VALID)\n\t\t_base_get_mpi_diag_triggers(ioc);\n}\n\n/**\n * _base_update_diag_trigger_pages - Update the driver trigger pages after\n *\t\t\tonline FW update, incase updated FW supports driver\n *\t\t\ttrigger pages.\n * @ioc : per adapter object\n *\n * Return nothing.\n */\nstatic void\n_base_update_diag_trigger_pages(struct MPT3SAS_ADAPTER *ioc)\n{\n\n\tif (ioc->diag_trigger_master.MasterData)\n\t\tmpt3sas_config_update_driver_trigger_pg1(ioc,\n\t\t    &ioc->diag_trigger_master, 1);\n\n\tif (ioc->diag_trigger_event.ValidEntries)\n\t\tmpt3sas_config_update_driver_trigger_pg2(ioc,\n\t\t    &ioc->diag_trigger_event, 1);\n\n\tif (ioc->diag_trigger_scsi.ValidEntries)\n\t\tmpt3sas_config_update_driver_trigger_pg3(ioc,\n\t\t    &ioc->diag_trigger_scsi, 1);\n\n\tif (ioc->diag_trigger_mpi.ValidEntries)\n\t\tmpt3sas_config_update_driver_trigger_pg4(ioc,\n\t\t    &ioc->diag_trigger_mpi, 1);\n}\n\n/**\n * _base_static_config_pages - static start of day config pages\n * @ioc: per adapter object\n */\nstatic void\n_base_static_config_pages(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2ConfigReply_t mpi_reply;\n\tu32 iounit_pg1_flags;\n\tint tg_flags = 0;\n\tioc->nvme_abort_timeout = 30;\n\tmpt3sas_config_get_manufacturing_pg0(ioc, &mpi_reply, &ioc->manu_pg0);\n\tif (ioc->ir_firmware)\n\t\tmpt3sas_config_get_manufacturing_pg10(ioc, &mpi_reply,\n\t\t    &ioc->manu_pg10);\n\n\t/*\n\t * Ensure correct T10 PI operation if vendor left EEDPTagMode\n\t * flag unset in NVDATA.\n\t */\n\tmpt3sas_config_get_manufacturing_pg11(ioc, &mpi_reply, &ioc->manu_pg11);\n\tif (!ioc->is_gen35_ioc && ioc->manu_pg11.EEDPTagMode == 0) {\n\t\tpr_err(\"%s: overriding NVDATA EEDPTagMode setting\\n\",\n\t\t    ioc->name);\n\t\tioc->manu_pg11.EEDPTagMode &= ~0x3;\n\t\tioc->manu_pg11.EEDPTagMode |= 0x1;\n\t\tmpt3sas_config_set_manufacturing_pg11(ioc, &mpi_reply,\n\t\t    &ioc->manu_pg11);\n\t}\n\tif (ioc->manu_pg11.AddlFlags2 & NVME_TASK_MNGT_CUSTOM_MASK)\n\t\tioc->tm_custom_handling = 1;\n\telse {\n\t\tioc->tm_custom_handling = 0;\n\t\tif (ioc->manu_pg11.NVMeAbortTO < NVME_TASK_ABORT_MIN_TIMEOUT)\n\t\t\tioc->nvme_abort_timeout = NVME_TASK_ABORT_MIN_TIMEOUT;\n\t\telse if (ioc->manu_pg11.NVMeAbortTO >\n\t\t\t\t\tNVME_TASK_ABORT_MAX_TIMEOUT)\n\t\t\tioc->nvme_abort_timeout = NVME_TASK_ABORT_MAX_TIMEOUT;\n\t\telse\n\t\t\tioc->nvme_abort_timeout = ioc->manu_pg11.NVMeAbortTO;\n\t}\n\tioc->time_sync_interval =\n\t    ioc->manu_pg11.TimeSyncInterval & MPT3SAS_TIMESYNC_MASK;\n\tif (ioc->time_sync_interval) {\n\t\tif (ioc->manu_pg11.TimeSyncInterval & MPT3SAS_TIMESYNC_UNIT_MASK)\n\t\t\tioc->time_sync_interval =\n\t\t\t    ioc->time_sync_interval * SECONDS_PER_HOUR;\n\t\telse\n\t\t\tioc->time_sync_interval =\n\t\t\t    ioc->time_sync_interval * SECONDS_PER_MIN;\n\t\tdinitprintk(ioc, ioc_info(ioc,\n\t\t    \"Driver-FW TimeSync interval is %d seconds. ManuPg11 TimeSync Unit is in %s\\n\",\n\t\t    ioc->time_sync_interval, (ioc->manu_pg11.TimeSyncInterval &\n\t\t    MPT3SAS_TIMESYNC_UNIT_MASK) ? \"Hour\" : \"Minute\"));\n\t} else {\n\t\tif (ioc->is_gen35_ioc)\n\t\t\tioc_warn(ioc,\n\t\t\t    \"TimeSync Interval in Manuf page-11 is not enabled. Periodic Time-Sync will be disabled\\n\");\n\t}\n\tmpt3sas_config_get_bios_pg2(ioc, &mpi_reply, &ioc->bios_pg2);\n\tmpt3sas_config_get_bios_pg3(ioc, &mpi_reply, &ioc->bios_pg3);\n\tmpt3sas_config_get_ioc_pg8(ioc, &mpi_reply, &ioc->ioc_pg8);\n\tmpt3sas_config_get_iounit_pg0(ioc, &mpi_reply, &ioc->iounit_pg0);\n\tmpt3sas_config_get_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);\n\tmpt3sas_config_get_iounit_pg8(ioc, &mpi_reply, &ioc->iounit_pg8);\n\t_base_display_ioc_capabilities(ioc);\n\n\t/*\n\t * Enable task_set_full handling in iounit_pg1 when the\n\t * facts capabilities indicate that its supported.\n\t */\n\tiounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);\n\tif ((ioc->facts.IOCCapabilities &\n\t    MPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING))\n\t\tiounit_pg1_flags &=\n\t\t    ~MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;\n\telse\n\t\tiounit_pg1_flags |=\n\t\t    MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;\n\tioc->iounit_pg1.Flags = cpu_to_le32(iounit_pg1_flags);\n\tmpt3sas_config_set_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);\n\n\tif (ioc->iounit_pg8.NumSensors)\n\t\tioc->temp_sensors_count = ioc->iounit_pg8.NumSensors;\n\tif (ioc->is_aero_ioc)\n\t\t_base_update_ioc_page1_inlinewith_perf_mode(ioc);\n\tif (ioc->is_gen35_ioc) {\n\t\tif (ioc->is_driver_loading)\n\t\t\t_base_get_diag_triggers(ioc);\n\t\telse {\n\t\t\t/*\n\t\t\t * In case of online HBA FW update operation,\n\t\t\t * check whether updated FW supports the driver trigger\n\t\t\t * pages or not.\n\t\t\t * - If previous FW has not supported driver trigger\n\t\t\t *   pages and newer FW supports them then update these\n\t\t\t *   pages with current diag trigger values.\n\t\t\t * - If previous FW has supported driver trigger pages\n\t\t\t *   and new FW doesn't support them then disable\n\t\t\t *   support_trigger_pages flag.\n\t\t\t */\n\t\t\ttg_flags = _base_check_for_trigger_pages_support(ioc);\n\t\t\tif (!ioc->supports_trigger_pages && tg_flags != -EFAULT)\n\t\t\t\t_base_update_diag_trigger_pages(ioc);\n\t\t\telse if (ioc->supports_trigger_pages &&\n\t\t\t    tg_flags == -EFAULT)\n\t\t\t\tioc->supports_trigger_pages = 0;\n\t\t}\n\t}\n}\n\n/**\n * mpt3sas_free_enclosure_list - release memory\n * @ioc: per adapter object\n *\n * Free memory allocated during enclosure add.\n */\nvoid\nmpt3sas_free_enclosure_list(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct _enclosure_node *enclosure_dev, *enclosure_dev_next;\n\n\t/* Free enclosure list */\n\tlist_for_each_entry_safe(enclosure_dev,\n\t\t\tenclosure_dev_next, &ioc->enclosure_list, list) {\n\t\tlist_del(&enclosure_dev->list);\n\t\tkfree(enclosure_dev);\n\t}\n}\n\n/**\n * _base_release_memory_pools - release memory\n * @ioc: per adapter object\n *\n * Free memory allocated from _base_allocate_memory_pools.\n */\nstatic void\n_base_release_memory_pools(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint i = 0;\n\tint j = 0;\n\tint dma_alloc_count = 0;\n\tstruct chain_tracker *ct;\n\tint count = ioc->rdpq_array_enable ? ioc->reply_queue_count : 1;\n\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->request) {\n\t\tdma_free_coherent(&ioc->pdev->dev, ioc->request_dma_sz,\n\t\t    ioc->request,  ioc->request_dma);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"request_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->request));\n\t\tioc->request = NULL;\n\t}\n\n\tif (ioc->sense) {\n\t\tdma_pool_free(ioc->sense_dma_pool, ioc->sense, ioc->sense_dma);\n\t\tdma_pool_destroy(ioc->sense_dma_pool);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"sense_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->sense));\n\t\tioc->sense = NULL;\n\t}\n\n\tif (ioc->reply) {\n\t\tdma_pool_free(ioc->reply_dma_pool, ioc->reply, ioc->reply_dma);\n\t\tdma_pool_destroy(ioc->reply_dma_pool);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"reply_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->reply));\n\t\tioc->reply = NULL;\n\t}\n\n\tif (ioc->reply_free) {\n\t\tdma_pool_free(ioc->reply_free_dma_pool, ioc->reply_free,\n\t\t    ioc->reply_free_dma);\n\t\tdma_pool_destroy(ioc->reply_free_dma_pool);\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"reply_free_pool(0x%p): free\\n\",\n\t\t\t\t     ioc->reply_free));\n\t\tioc->reply_free = NULL;\n\t}\n\n\tif (ioc->reply_post) {\n\t\tdma_alloc_count = DIV_ROUND_UP(count,\n\t\t\t\tRDPQ_MAX_INDEX_IN_ONE_CHUNK);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tif (i % RDPQ_MAX_INDEX_IN_ONE_CHUNK == 0\n\t\t\t    && dma_alloc_count) {\n\t\t\t\tif (ioc->reply_post[i].reply_post_free) {\n\t\t\t\t\tdma_pool_free(\n\t\t\t\t\t    ioc->reply_post_free_dma_pool,\n\t\t\t\t\t    ioc->reply_post[i].reply_post_free,\n\t\t\t\t\tioc->reply_post[i].reply_post_free_dma);\n\t\t\t\t\tdexitprintk(ioc, ioc_info(ioc,\n\t\t\t\t\t   \"reply_post_free_pool(0x%p): free\\n\",\n\t\t\t\t\t   ioc->reply_post[i].reply_post_free));\n\t\t\t\t\tioc->reply_post[i].reply_post_free =\n\t\t\t\t\t\t\t\t\tNULL;\n\t\t\t\t}\n\t\t\t\t--dma_alloc_count;\n\t\t\t}\n\t\t}\n\t\tdma_pool_destroy(ioc->reply_post_free_dma_pool);\n\t\tif (ioc->reply_post_free_array &&\n\t\t\tioc->rdpq_array_enable) {\n\t\t\tdma_pool_free(ioc->reply_post_free_array_dma_pool,\n\t\t\t    ioc->reply_post_free_array,\n\t\t\t    ioc->reply_post_free_array_dma);\n\t\t\tioc->reply_post_free_array = NULL;\n\t\t}\n\t\tdma_pool_destroy(ioc->reply_post_free_array_dma_pool);\n\t\tkfree(ioc->reply_post);\n\t}\n\n\tif (ioc->pcie_sgl_dma_pool) {\n\t\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\t\tdma_pool_free(ioc->pcie_sgl_dma_pool,\n\t\t\t\t\tioc->pcie_sg_lookup[i].pcie_sgl,\n\t\t\t\t\tioc->pcie_sg_lookup[i].pcie_sgl_dma);\n\t\t\tioc->pcie_sg_lookup[i].pcie_sgl = NULL;\n\t\t}\n\t\tdma_pool_destroy(ioc->pcie_sgl_dma_pool);\n\t}\n\tif (ioc->config_page) {\n\t\tdexitprintk(ioc,\n\t\t\t    ioc_info(ioc, \"config_page(0x%p): free\\n\",\n\t\t\t\t     ioc->config_page));\n\t\tdma_free_coherent(&ioc->pdev->dev, ioc->config_page_sz,\n\t\t    ioc->config_page, ioc->config_page_dma);\n\t}\n\n\tkfree(ioc->hpr_lookup);\n\tioc->hpr_lookup = NULL;\n\tkfree(ioc->internal_lookup);\n\tioc->internal_lookup = NULL;\n\tif (ioc->chain_lookup) {\n\t\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\t\tfor (j = ioc->chains_per_prp_buffer;\n\t\t\t    j < ioc->chains_needed_per_io; j++) {\n\t\t\t\tct = &ioc->chain_lookup[i].chains_per_smid[j];\n\t\t\t\tif (ct && ct->chain_buffer)\n\t\t\t\t\tdma_pool_free(ioc->chain_dma_pool,\n\t\t\t\t\t\tct->chain_buffer,\n\t\t\t\t\t\tct->chain_buffer_dma);\n\t\t\t}\n\t\t\tkfree(ioc->chain_lookup[i].chains_per_smid);\n\t\t}\n\t\tdma_pool_destroy(ioc->chain_dma_pool);\n\t\tkfree(ioc->chain_lookup);\n\t\tioc->chain_lookup = NULL;\n\t}\n\n\tkfree(ioc->io_queue_num);\n\tioc->io_queue_num = NULL;\n}\n\n/**\n * mpt3sas_check_same_4gb_region - checks whether all reply queues in a set are\n *\thaving same upper 32bits in their base memory address.\n * @reply_pool_start_address: Base address of a reply queue set\n * @pool_sz: Size of single Reply Descriptor Post Queues pool size\n *\n * Return: 1 if reply queues in a set have a same upper 32bits in their base\n * memory address, else 0.\n */\n\nstatic int\nmpt3sas_check_same_4gb_region(long reply_pool_start_address, u32 pool_sz)\n{\n\tlong reply_pool_end_address;\n\n\treply_pool_end_address = reply_pool_start_address + pool_sz;\n\n\tif (upper_32_bits(reply_pool_start_address) ==\n\t\tupper_32_bits(reply_pool_end_address))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n/**\n * _base_reduce_hba_queue_depth- Retry with reduced queue depth\n * @ioc: Adapter object\n *\n * Return: 0 for success, non-zero for failure.\n **/\nstatic inline int\n_base_reduce_hba_queue_depth(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint reduce_sz = 64;\n\n\tif ((ioc->hba_queue_depth - reduce_sz) >\n\t    (ioc->internal_depth + INTERNAL_SCSIIO_CMDS_COUNT)) {\n\t\tioc->hba_queue_depth -= reduce_sz;\n\t\treturn 0;\n\t} else\n\t\treturn -ENOMEM;\n}\n\n/**\n * _base_allocate_pcie_sgl_pool - Allocating DMA'able memory\n *\t\t\tfor pcie sgl pools.\n * @ioc: Adapter object\n * @sz: DMA Pool size\n * @ct: Chain tracker\n * Return: 0 for success, non-zero for failure.\n */\n\nstatic int\n_base_allocate_pcie_sgl_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\tint i = 0, j = 0;\n\tstruct chain_tracker *ct;\n\n\tioc->pcie_sgl_dma_pool =\n\t    dma_pool_create(\"PCIe SGL pool\", &ioc->pdev->dev, sz,\n\t    ioc->page_size, 0);\n\tif (!ioc->pcie_sgl_dma_pool) {\n\t\tioc_err(ioc, \"PCIe SGL pool: dma_pool_create failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tioc->chains_per_prp_buffer = sz/ioc->chain_segment_sz;\n\tioc->chains_per_prp_buffer =\n\t    min(ioc->chains_per_prp_buffer, ioc->chains_needed_per_io);\n\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\tioc->pcie_sg_lookup[i].pcie_sgl =\n\t\t    dma_pool_alloc(ioc->pcie_sgl_dma_pool, GFP_KERNEL,\n\t\t    &ioc->pcie_sg_lookup[i].pcie_sgl_dma);\n\t\tif (!ioc->pcie_sg_lookup[i].pcie_sgl) {\n\t\t\tioc_err(ioc, \"PCIe SGL pool: dma_pool_alloc failed\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (!mpt3sas_check_same_4gb_region(\n\t\t    (long)ioc->pcie_sg_lookup[i].pcie_sgl, sz)) {\n\t\t\tioc_err(ioc, \"PCIE SGLs are not in same 4G !! pcie sgl (0x%p) dma = (0x%llx)\\n\",\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl,\n\t\t\t    (unsigned long long)\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl_dma);\n\t\t\tioc->use_32bit_dma = true;\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tfor (j = 0; j < ioc->chains_per_prp_buffer; j++) {\n\t\t\tct = &ioc->chain_lookup[i].chains_per_smid[j];\n\t\t\tct->chain_buffer =\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl +\n\t\t\t    (j * ioc->chain_segment_sz);\n\t\t\tct->chain_buffer_dma =\n\t\t\t    ioc->pcie_sg_lookup[i].pcie_sgl_dma +\n\t\t\t    (j * ioc->chain_segment_sz);\n\t\t}\n\t}\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"PCIe sgl pool depth(%d), element_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->scsiio_depth, sz, (sz * ioc->scsiio_depth)/1024));\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"Number of chains can fit in a PRP page(%d)\\n\",\n\t    ioc->chains_per_prp_buffer));\n\treturn 0;\n}\n\n/**\n * _base_allocate_chain_dma_pool - Allocating DMA'able memory\n *\t\t\tfor chain dma pool.\n * @ioc: Adapter object\n * @sz: DMA Pool size\n * @ctr: Chain tracker\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_allocate_chain_dma_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\tint i = 0, j = 0;\n\tstruct chain_tracker *ctr;\n\n\tioc->chain_dma_pool = dma_pool_create(\"chain pool\", &ioc->pdev->dev,\n\t    ioc->chain_segment_sz, 16, 0);\n\tif (!ioc->chain_dma_pool)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\tfor (j = ioc->chains_per_prp_buffer;\n\t\t    j < ioc->chains_needed_per_io; j++) {\n\t\t\tctr = &ioc->chain_lookup[i].chains_per_smid[j];\n\t\t\tctr->chain_buffer = dma_pool_alloc(ioc->chain_dma_pool,\n\t\t\t    GFP_KERNEL, &ctr->chain_buffer_dma);\n\t\t\tif (!ctr->chain_buffer)\n\t\t\t\treturn -EAGAIN;\n\t\t\tif (!mpt3sas_check_same_4gb_region((long)\n\t\t\t    ctr->chain_buffer, ioc->chain_segment_sz)) {\n\t\t\t\tioc_err(ioc,\n\t\t\t\t    \"Chain buffers are not in same 4G !!! Chain buff (0x%p) dma = (0x%llx)\\n\",\n\t\t\t\t    ctr->chain_buffer,\n\t\t\t\t    (unsigned long long)ctr->chain_buffer_dma);\n\t\t\t\tioc->use_32bit_dma = true;\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\t}\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"chain_lookup depth (%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->scsiio_depth, ioc->chain_segment_sz, ((ioc->scsiio_depth *\n\t    (ioc->chains_needed_per_io - ioc->chains_per_prp_buffer) *\n\t    ioc->chain_segment_sz))/1024));\n\treturn 0;\n}\n\n/**\n * _base_allocate_sense_dma_pool - Allocating DMA'able memory\n *\t\t\tfor sense dma pool.\n * @ioc: Adapter object\n * @sz: DMA Pool size\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_allocate_sense_dma_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\tioc->sense_dma_pool =\n\t    dma_pool_create(\"sense pool\", &ioc->pdev->dev, sz, 4, 0);\n\tif (!ioc->sense_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->sense = dma_pool_alloc(ioc->sense_dma_pool,\n\t    GFP_KERNEL, &ioc->sense_dma);\n\tif (!ioc->sense)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region((long)ioc->sense, sz)) {\n\t\tdinitprintk(ioc, pr_err(\n\t\t    \"Bad Sense Pool! sense (0x%p) sense_dma = (0x%llx)\\n\",\n\t\t    ioc->sense, (unsigned long long) ioc->sense_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\tioc_info(ioc,\n\t    \"sense pool(0x%p) - dma(0x%llx): depth(%d), element_size(%d), pool_size (%d kB)\\n\",\n\t    ioc->sense, (unsigned long long)ioc->sense_dma,\n\t    ioc->scsiio_depth, SCSI_SENSE_BUFFERSIZE, sz/1024);\n\treturn 0;\n}\n\n/**\n * _base_allocate_reply_pool - Allocating DMA'able memory\n *\t\t\tfor reply pool.\n * @ioc: Adapter object\n * @sz: DMA Pool size\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_allocate_reply_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\t/* reply pool, 4 byte align */\n\tioc->reply_dma_pool = dma_pool_create(\"reply pool\",\n\t    &ioc->pdev->dev, sz, 4, 0);\n\tif (!ioc->reply_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->reply = dma_pool_alloc(ioc->reply_dma_pool, GFP_KERNEL,\n\t    &ioc->reply_dma);\n\tif (!ioc->reply)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region((long)ioc->reply_free, sz)) {\n\t\tdinitprintk(ioc, pr_err(\n\t\t    \"Bad Reply Pool! Reply (0x%p) Reply dma = (0x%llx)\\n\",\n\t\t    ioc->reply, (unsigned long long) ioc->reply_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\tioc->reply_dma_min_address = (u32)(ioc->reply_dma);\n\tioc->reply_dma_max_address = (u32)(ioc->reply_dma) + sz;\n\tioc_info(ioc,\n\t    \"reply pool(0x%p) - dma(0x%llx): depth(%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->reply, (unsigned long long)ioc->reply_dma,\n\t    ioc->reply_free_queue_depth, ioc->reply_sz, sz/1024);\n\treturn 0;\n}\n\n/**\n * _base_allocate_reply_free_dma_pool - Allocating DMA'able memory\n *\t\t\tfor reply free dma pool.\n * @ioc: Adapter object\n * @sz: DMA Pool size\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_allocate_reply_free_dma_pool(struct MPT3SAS_ADAPTER *ioc, u32 sz)\n{\n\t/* reply free queue, 16 byte align */\n\tioc->reply_free_dma_pool = dma_pool_create(\n\t    \"reply_free pool\", &ioc->pdev->dev, sz, 16, 0);\n\tif (!ioc->reply_free_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->reply_free = dma_pool_alloc(ioc->reply_free_dma_pool,\n\t    GFP_KERNEL, &ioc->reply_free_dma);\n\tif (!ioc->reply_free)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region((long)ioc->reply_free, sz)) {\n\t\tdinitprintk(ioc,\n\t\t    pr_err(\"Bad Reply Free Pool! Reply Free (0x%p) Reply Free dma = (0x%llx)\\n\",\n\t\t    ioc->reply_free, (unsigned long long) ioc->reply_free_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\tmemset(ioc->reply_free, 0, sz);\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"reply_free pool(0x%p): depth(%d), element_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->reply_free, ioc->reply_free_queue_depth, 4, sz/1024));\n\tdinitprintk(ioc, ioc_info(ioc,\n\t    \"reply_free_dma (0x%llx)\\n\",\n\t    (unsigned long long)ioc->reply_free_dma));\n\treturn 0;\n}\n\n/**\n * _base_allocate_reply_post_free_array - Allocating DMA'able memory\n *\t\t\tfor reply post free array.\n * @ioc: Adapter object\n * @reply_post_free_array_sz: DMA Pool size\n * Return: 0 for success, non-zero for failure.\n */\n\nstatic int\n_base_allocate_reply_post_free_array(struct MPT3SAS_ADAPTER *ioc,\n\tu32 reply_post_free_array_sz)\n{\n\tioc->reply_post_free_array_dma_pool =\n\t    dma_pool_create(\"reply_post_free_array pool\",\n\t    &ioc->pdev->dev, reply_post_free_array_sz, 16, 0);\n\tif (!ioc->reply_post_free_array_dma_pool)\n\t\treturn -ENOMEM;\n\tioc->reply_post_free_array =\n\t    dma_pool_alloc(ioc->reply_post_free_array_dma_pool,\n\t    GFP_KERNEL, &ioc->reply_post_free_array_dma);\n\tif (!ioc->reply_post_free_array)\n\t\treturn -EAGAIN;\n\tif (!mpt3sas_check_same_4gb_region((long)ioc->reply_post_free_array,\n\t    reply_post_free_array_sz)) {\n\t\tdinitprintk(ioc, pr_err(\n\t\t    \"Bad Reply Free Pool! Reply Free (0x%p) Reply Free dma = (0x%llx)\\n\",\n\t\t    ioc->reply_free,\n\t\t    (unsigned long long) ioc->reply_free_dma));\n\t\tioc->use_32bit_dma = true;\n\t\treturn -EAGAIN;\n\t}\n\treturn 0;\n}\n/**\n * base_alloc_rdpq_dma_pool - Allocating DMA'able memory\n *                     for reply queues.\n * @ioc: per adapter object\n * @sz: DMA Pool size\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\nbase_alloc_rdpq_dma_pool(struct MPT3SAS_ADAPTER *ioc, int sz)\n{\n\tint i = 0;\n\tu32 dma_alloc_count = 0;\n\tint reply_post_free_sz = ioc->reply_post_queue_depth *\n\t\tsizeof(Mpi2DefaultReplyDescriptor_t);\n\tint count = ioc->rdpq_array_enable ? ioc->reply_queue_count : 1;\n\n\tioc->reply_post = kcalloc(count, sizeof(struct reply_post_struct),\n\t\t\tGFP_KERNEL);\n\tif (!ioc->reply_post)\n\t\treturn -ENOMEM;\n\t/*\n\t *  For INVADER_SERIES each set of 8 reply queues(0-7, 8-15, ..) and\n\t *  VENTURA_SERIES each set of 16 reply queues(0-15, 16-31, ..) should\n\t *  be within 4GB boundary i.e reply queues in a set must have same\n\t *  upper 32-bits in their memory address. so here driver is allocating\n\t *  the DMA'able memory for reply queues according.\n\t *  Driver uses limitation of\n\t *  VENTURA_SERIES to manage INVADER_SERIES as well.\n\t */\n\tdma_alloc_count = DIV_ROUND_UP(count,\n\t\t\t\tRDPQ_MAX_INDEX_IN_ONE_CHUNK);\n\tioc->reply_post_free_dma_pool =\n\t\tdma_pool_create(\"reply_post_free pool\",\n\t\t    &ioc->pdev->dev, sz, 16, 0);\n\tif (!ioc->reply_post_free_dma_pool)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < count; i++) {\n\t\tif ((i % RDPQ_MAX_INDEX_IN_ONE_CHUNK == 0) && dma_alloc_count) {\n\t\t\tioc->reply_post[i].reply_post_free =\n\t\t\t    dma_pool_zalloc(ioc->reply_post_free_dma_pool,\n\t\t\t\tGFP_KERNEL,\n\t\t\t\t&ioc->reply_post[i].reply_post_free_dma);\n\t\t\tif (!ioc->reply_post[i].reply_post_free)\n\t\t\t\treturn -ENOMEM;\n\t\t\t/*\n\t\t\t * Each set of RDPQ pool must satisfy 4gb boundary\n\t\t\t * restriction.\n\t\t\t * 1) Check if allocated resources for RDPQ pool are in\n\t\t\t *\tthe same 4GB range.\n\t\t\t * 2) If #1 is true, continue with 64 bit DMA.\n\t\t\t * 3) If #1 is false, return 1. which means free all the\n\t\t\t * resources and set DMA mask to 32 and allocate.\n\t\t\t */\n\t\t\tif (!mpt3sas_check_same_4gb_region(\n\t\t\t\t(long)ioc->reply_post[i].reply_post_free, sz)) {\n\t\t\t\tdinitprintk(ioc,\n\t\t\t\t    ioc_err(ioc, \"bad Replypost free pool(0x%p)\"\n\t\t\t\t    \"reply_post_free_dma = (0x%llx)\\n\",\n\t\t\t\t    ioc->reply_post[i].reply_post_free,\n\t\t\t\t    (unsigned long long)\n\t\t\t\t    ioc->reply_post[i].reply_post_free_dma));\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tdma_alloc_count--;\n\n\t\t} else {\n\t\t\tioc->reply_post[i].reply_post_free =\n\t\t\t    (Mpi2ReplyDescriptorsUnion_t *)\n\t\t\t    ((long)ioc->reply_post[i-1].reply_post_free\n\t\t\t    + reply_post_free_sz);\n\t\t\tioc->reply_post[i].reply_post_free_dma =\n\t\t\t    (dma_addr_t)\n\t\t\t    (ioc->reply_post[i-1].reply_post_free_dma +\n\t\t\t    reply_post_free_sz);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * _base_allocate_memory_pools - allocate start of day memory pools\n * @ioc: per adapter object\n *\n * Return: 0 success, anything else error.\n */\nstatic int\n_base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc)\n{\n\tstruct mpt3sas_facts *facts;\n\tu16 max_sge_elements;\n\tu16 chains_needed_per_io;\n\tu32 sz, total_sz, reply_post_free_sz, reply_post_free_array_sz;\n\tu32 retry_sz;\n\tu32 rdpq_sz = 0, sense_sz = 0;\n\tu16 max_request_credit, nvme_blocks_needed;\n\tunsigned short sg_tablesize;\n\tu16 sge_size;\n\tint i;\n\tint ret = 0, rc = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\n\tretry_sz = 0;\n\tfacts = &ioc->facts;\n\n\t/* command line tunables for max sgl entries */\n\tif (max_sgl_entries != -1)\n\t\tsg_tablesize = max_sgl_entries;\n\telse {\n\t\tif (ioc->hba_mpi_version_belonged == MPI2_VERSION)\n\t\t\tsg_tablesize = MPT2SAS_SG_DEPTH;\n\t\telse\n\t\t\tsg_tablesize = MPT3SAS_SG_DEPTH;\n\t}\n\n\t/* max sgl entries <= MPT_KDUMP_MIN_PHYS_SEGMENTS in KDUMP mode */\n\tif (reset_devices)\n\t\tsg_tablesize = min_t(unsigned short, sg_tablesize,\n\t\t   MPT_KDUMP_MIN_PHYS_SEGMENTS);\n\n\tif (ioc->is_mcpu_endpoint)\n\t\tioc->shost->sg_tablesize = MPT_MIN_PHYS_SEGMENTS;\n\telse {\n\t\tif (sg_tablesize < MPT_MIN_PHYS_SEGMENTS)\n\t\t\tsg_tablesize = MPT_MIN_PHYS_SEGMENTS;\n\t\telse if (sg_tablesize > MPT_MAX_PHYS_SEGMENTS) {\n\t\t\tsg_tablesize = min_t(unsigned short, sg_tablesize,\n\t\t\t\t\tSG_MAX_SEGMENTS);\n\t\t\tioc_warn(ioc, \"sg_tablesize(%u) is bigger than kernel defined SG_CHUNK_SIZE(%u)\\n\",\n\t\t\t\t sg_tablesize, MPT_MAX_PHYS_SEGMENTS);\n\t\t}\n\t\tioc->shost->sg_tablesize = sg_tablesize;\n\t}\n\n\tioc->internal_depth = min_t(int, (facts->HighPriorityCredit + (5)),\n\t\t(facts->RequestCredit / 4));\n\tif (ioc->internal_depth < INTERNAL_CMDS_COUNT) {\n\t\tif (facts->RequestCredit <= (INTERNAL_CMDS_COUNT +\n\t\t\t\tINTERNAL_SCSIIO_CMDS_COUNT)) {\n\t\t\tioc_err(ioc, \"IOC doesn't have enough Request Credits, it has just %d number of credits\\n\",\n\t\t\t\tfacts->RequestCredit);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->internal_depth = 10;\n\t}\n\n\tioc->hi_priority_depth = ioc->internal_depth - (5);\n\t/* command line tunables  for max controller queue depth */\n\tif (max_queue_depth != -1 && max_queue_depth != 0) {\n\t\tmax_request_credit = min_t(u16, max_queue_depth +\n\t\t\tioc->internal_depth, facts->RequestCredit);\n\t\tif (max_request_credit > MAX_HBA_QUEUE_DEPTH)\n\t\t\tmax_request_credit =  MAX_HBA_QUEUE_DEPTH;\n\t} else if (reset_devices)\n\t\tmax_request_credit = min_t(u16, facts->RequestCredit,\n\t\t    (MPT3SAS_KDUMP_SCSI_IO_DEPTH + ioc->internal_depth));\n\telse\n\t\tmax_request_credit = min_t(u16, facts->RequestCredit,\n\t\t    MAX_HBA_QUEUE_DEPTH);\n\n\t/* Firmware maintains additional facts->HighPriorityCredit number of\n\t * credits for HiPriprity Request messages, so hba queue depth will be\n\t * sum of max_request_credit and high priority queue depth.\n\t */\n\tioc->hba_queue_depth = max_request_credit + ioc->hi_priority_depth;\n\n\t/* request frame size */\n\tioc->request_sz = facts->IOCRequestFrameSize * 4;\n\n\t/* reply frame size */\n\tioc->reply_sz = facts->ReplyFrameSize * 4;\n\n\t/* chain segment size */\n\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tif (facts->IOCMaxChainSegmentSize)\n\t\t\tioc->chain_segment_sz =\n\t\t\t\t\tfacts->IOCMaxChainSegmentSize *\n\t\t\t\t\tMAX_CHAIN_ELEMT_SZ;\n\t\telse\n\t\t/* set to 128 bytes size if IOCMaxChainSegmentSize is zero */\n\t\t\tioc->chain_segment_sz = DEFAULT_NUM_FWCHAIN_ELEMTS *\n\t\t\t\t\t\t    MAX_CHAIN_ELEMT_SZ;\n\t} else\n\t\tioc->chain_segment_sz = ioc->request_sz;\n\n\t/* calculate the max scatter element size */\n\tsge_size = max_t(u16, ioc->sge_size, ioc->sge_size_ieee);\n\n retry_allocation:\n\ttotal_sz = 0;\n\t/* calculate number of sg elements left over in the 1st frame */\n\tmax_sge_elements = ioc->request_sz - ((sizeof(Mpi2SCSIIORequest_t) -\n\t    sizeof(Mpi2SGEIOUnion_t)) + sge_size);\n\tioc->max_sges_in_main_message = max_sge_elements/sge_size;\n\n\t/* now do the same for a chain buffer */\n\tmax_sge_elements = ioc->chain_segment_sz - sge_size;\n\tioc->max_sges_in_chain_message = max_sge_elements/sge_size;\n\n\t/*\n\t *  MPT3SAS_SG_DEPTH = CONFIG_FUSION_MAX_SGE\n\t */\n\tchains_needed_per_io = ((ioc->shost->sg_tablesize -\n\t   ioc->max_sges_in_main_message)/ioc->max_sges_in_chain_message)\n\t    + 1;\n\tif (chains_needed_per_io > facts->MaxChainDepth) {\n\t\tchains_needed_per_io = facts->MaxChainDepth;\n\t\tioc->shost->sg_tablesize = min_t(u16,\n\t\tioc->max_sges_in_main_message + (ioc->max_sges_in_chain_message\n\t\t* chains_needed_per_io), ioc->shost->sg_tablesize);\n\t}\n\tioc->chains_needed_per_io = chains_needed_per_io;\n\n\t/* reply free queue sizing - taking into account for 64 FW events */\n\tioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;\n\n\t/* mCPU manage single counters for simplicity */\n\tif (ioc->is_mcpu_endpoint)\n\t\tioc->reply_post_queue_depth = ioc->reply_free_queue_depth;\n\telse {\n\t\t/* calculate reply descriptor post queue depth */\n\t\tioc->reply_post_queue_depth = ioc->hba_queue_depth +\n\t\t\tioc->reply_free_queue_depth +  1;\n\t\t/* align the reply post queue on the next 16 count boundary */\n\t\tif (ioc->reply_post_queue_depth % 16)\n\t\t\tioc->reply_post_queue_depth += 16 -\n\t\t\t\t(ioc->reply_post_queue_depth % 16);\n\t}\n\n\tif (ioc->reply_post_queue_depth >\n\t    facts->MaxReplyDescriptorPostQueueDepth) {\n\t\tioc->reply_post_queue_depth =\n\t\t\t\tfacts->MaxReplyDescriptorPostQueueDepth -\n\t\t    (facts->MaxReplyDescriptorPostQueueDepth % 16);\n\t\tioc->hba_queue_depth =\n\t\t\t\t((ioc->reply_post_queue_depth - 64) / 2) - 1;\n\t\tioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;\n\t}\n\n\tioc_info(ioc,\n\t    \"scatter gather: sge_in_main_msg(%d), sge_per_chain(%d), \"\n\t    \"sge_per_io(%d), chains_per_io(%d)\\n\",\n\t    ioc->max_sges_in_main_message,\n\t    ioc->max_sges_in_chain_message,\n\t    ioc->shost->sg_tablesize,\n\t    ioc->chains_needed_per_io);\n\n\t/* reply post queue, 16 byte align */\n\treply_post_free_sz = ioc->reply_post_queue_depth *\n\t    sizeof(Mpi2DefaultReplyDescriptor_t);\n\trdpq_sz = reply_post_free_sz * RDPQ_MAX_INDEX_IN_ONE_CHUNK;\n\tif ((_base_is_controller_msix_enabled(ioc) && !ioc->rdpq_array_enable)\n\t    || (ioc->reply_queue_count < RDPQ_MAX_INDEX_IN_ONE_CHUNK))\n\t\trdpq_sz = reply_post_free_sz * ioc->reply_queue_count;\n\tret = base_alloc_rdpq_dma_pool(ioc, rdpq_sz);\n\tif (ret == -EAGAIN) {\n\t\t/*\n\t\t * Free allocated bad RDPQ memory pools.\n\t\t * Change dma coherent mask to 32 bit and reallocate RDPQ\n\t\t */\n\t\t_base_release_memory_pools(ioc);\n\t\tioc->use_32bit_dma = true;\n\t\tif (_base_config_dma_addressing(ioc, ioc->pdev) != 0) {\n\t\t\tioc_err(ioc,\n\t\t\t    \"32 DMA mask failed %s\\n\", pci_name(ioc->pdev));\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (base_alloc_rdpq_dma_pool(ioc, rdpq_sz))\n\t\t\treturn -ENOMEM;\n\t} else if (ret == -ENOMEM)\n\t\treturn -ENOMEM;\n\ttotal_sz = rdpq_sz * (!ioc->rdpq_array_enable ? 1 :\n\t    DIV_ROUND_UP(ioc->reply_queue_count, RDPQ_MAX_INDEX_IN_ONE_CHUNK));\n\tioc->scsiio_depth = ioc->hba_queue_depth -\n\t    ioc->hi_priority_depth - ioc->internal_depth;\n\n\t/* set the scsi host can_queue depth\n\t * with some internal commands that could be outstanding\n\t */\n\tioc->shost->can_queue = ioc->scsiio_depth - INTERNAL_SCSIIO_CMDS_COUNT;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"scsi host: can_queue depth (%d)\\n\",\n\t\t\t     ioc->shost->can_queue));\n\n\t/* contiguous pool for request and chains, 16 byte align, one extra \"\n\t * \"frame for smid=0\n\t */\n\tioc->chain_depth = ioc->chains_needed_per_io * ioc->scsiio_depth;\n\tsz = ((ioc->scsiio_depth + 1) * ioc->request_sz);\n\n\t/* hi-priority queue */\n\tsz += (ioc->hi_priority_depth * ioc->request_sz);\n\n\t/* internal queue */\n\tsz += (ioc->internal_depth * ioc->request_sz);\n\n\tioc->request_dma_sz = sz;\n\tioc->request = dma_alloc_coherent(&ioc->pdev->dev, sz,\n\t\t\t&ioc->request_dma, GFP_KERNEL);\n\tif (!ioc->request) {\n\t\tioc_err(ioc, \"request pool: dma_alloc_coherent failed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), total(%d kB)\\n\",\n\t\t\tioc->hba_queue_depth, ioc->chains_needed_per_io,\n\t\t\tioc->request_sz, sz / 1024);\n\t\tif (ioc->scsiio_depth < MPT3SAS_SAS_QUEUE_DEPTH)\n\t\t\tgoto out;\n\t\tretry_sz = 64;\n\t\tioc->hba_queue_depth -= retry_sz;\n\t\t_base_release_memory_pools(ioc);\n\t\tgoto retry_allocation;\n\t}\n\n\tif (retry_sz)\n\t\tioc_err(ioc, \"request pool: dma_alloc_coherent succeed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), total(%d kb)\\n\",\n\t\t\tioc->hba_queue_depth, ioc->chains_needed_per_io,\n\t\t\tioc->request_sz, sz / 1024);\n\n\t/* hi-priority queue */\n\tioc->hi_priority = ioc->request + ((ioc->scsiio_depth + 1) *\n\t    ioc->request_sz);\n\tioc->hi_priority_dma = ioc->request_dma + ((ioc->scsiio_depth + 1) *\n\t    ioc->request_sz);\n\n\t/* internal queue */\n\tioc->internal = ioc->hi_priority + (ioc->hi_priority_depth *\n\t    ioc->request_sz);\n\tioc->internal_dma = ioc->hi_priority_dma + (ioc->hi_priority_depth *\n\t    ioc->request_sz);\n\n\tioc_info(ioc,\n\t    \"request pool(0x%p) - dma(0x%llx): \"\n\t    \"depth(%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->request, (unsigned long long) ioc->request_dma,\n\t    ioc->hba_queue_depth, ioc->request_sz,\n\t    (ioc->hba_queue_depth * ioc->request_sz) / 1024);\n\n\ttotal_sz += sz;\n\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"scsiio(0x%p): depth(%d)\\n\",\n\t\t\t     ioc->request, ioc->scsiio_depth));\n\n\tioc->chain_depth = min_t(u32, ioc->chain_depth, MAX_CHAIN_DEPTH);\n\tsz = ioc->scsiio_depth * sizeof(struct chain_lookup);\n\tioc->chain_lookup = kzalloc(sz, GFP_KERNEL);\n\tif (!ioc->chain_lookup) {\n\t\tioc_err(ioc, \"chain_lookup: __get_free_pages failed\\n\");\n\t\tgoto out;\n\t}\n\n\tsz = ioc->chains_needed_per_io * sizeof(struct chain_tracker);\n\tfor (i = 0; i < ioc->scsiio_depth; i++) {\n\t\tioc->chain_lookup[i].chains_per_smid = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->chain_lookup[i].chains_per_smid) {\n\t\t\tioc_err(ioc, \"chain_lookup: kzalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* initialize hi-priority queue smid's */\n\tioc->hpr_lookup = kcalloc(ioc->hi_priority_depth,\n\t    sizeof(struct request_tracker), GFP_KERNEL);\n\tif (!ioc->hpr_lookup) {\n\t\tioc_err(ioc, \"hpr_lookup: kcalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tioc->hi_priority_smid = ioc->scsiio_depth + 1;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"hi_priority(0x%p): depth(%d), start smid(%d)\\n\",\n\t\t\t     ioc->hi_priority,\n\t\t\t     ioc->hi_priority_depth, ioc->hi_priority_smid));\n\n\t/* initialize internal queue smid's */\n\tioc->internal_lookup = kcalloc(ioc->internal_depth,\n\t    sizeof(struct request_tracker), GFP_KERNEL);\n\tif (!ioc->internal_lookup) {\n\t\tioc_err(ioc, \"internal_lookup: kcalloc failed\\n\");\n\t\tgoto out;\n\t}\n\tioc->internal_smid = ioc->hi_priority_smid + ioc->hi_priority_depth;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"internal(0x%p): depth(%d), start smid(%d)\\n\",\n\t\t\t     ioc->internal,\n\t\t\t     ioc->internal_depth, ioc->internal_smid));\n\n\tioc->io_queue_num = kcalloc(ioc->scsiio_depth,\n\t    sizeof(u16), GFP_KERNEL);\n\tif (!ioc->io_queue_num)\n\t\tgoto out;\n\t/*\n\t * The number of NVMe page sized blocks needed is:\n\t *     (((sg_tablesize * 8) - 1) / (page_size - 8)) + 1\n\t * ((sg_tablesize * 8) - 1) is the max PRP's minus the first PRP entry\n\t * that is placed in the main message frame.  8 is the size of each PRP\n\t * entry or PRP list pointer entry.  8 is subtracted from page_size\n\t * because of the PRP list pointer entry at the end of a page, so this\n\t * is not counted as a PRP entry.  The 1 added page is a round up.\n\t *\n\t * To avoid allocation failures due to the amount of memory that could\n\t * be required for NVMe PRP's, only each set of NVMe blocks will be\n\t * contiguous, so a new set is allocated for each possible I/O.\n\t */\n\n\tioc->chains_per_prp_buffer = 0;\n\tif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_NVME_DEVICES) {\n\t\tnvme_blocks_needed =\n\t\t\t(ioc->shost->sg_tablesize * NVME_PRP_SIZE) - 1;\n\t\tnvme_blocks_needed /= (ioc->page_size - NVME_PRP_SIZE);\n\t\tnvme_blocks_needed++;\n\n\t\tsz = sizeof(struct pcie_sg_list) * ioc->scsiio_depth;\n\t\tioc->pcie_sg_lookup = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->pcie_sg_lookup) {\n\t\t\tioc_info(ioc, \"PCIe SGL lookup: kzalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tsz = nvme_blocks_needed * ioc->page_size;\n\t\trc = _base_allocate_pcie_sgl_pool(ioc, sz);\n\t\tif (rc == -ENOMEM)\n\t\t\treturn -ENOMEM;\n\t\telse if (rc == -EAGAIN)\n\t\t\tgoto try_32bit_dma;\n\t\ttotal_sz += sz * ioc->scsiio_depth;\n\t}\n\n\trc = _base_allocate_chain_dma_pool(ioc, ioc->chain_segment_sz);\n\tif (rc == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\ttotal_sz += ioc->chain_segment_sz * ((ioc->chains_needed_per_io -\n\t\tioc->chains_per_prp_buffer) * ioc->scsiio_depth);\n\tdinitprintk(ioc,\n\t    ioc_info(ioc, \"chain pool depth(%d), frame_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->chain_depth, ioc->chain_segment_sz,\n\t    (ioc->chain_depth * ioc->chain_segment_sz) / 1024));\n\t/* sense buffers, 4 byte align */\n\tsense_sz = ioc->scsiio_depth * SCSI_SENSE_BUFFERSIZE;\n\trc = _base_allocate_sense_dma_pool(ioc, sense_sz);\n\tif (rc  == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\ttotal_sz += sense_sz;\n\tioc_info(ioc,\n\t    \"sense pool(0x%p)- dma(0x%llx): depth(%d),\"\n\t    \"element_size(%d), pool_size(%d kB)\\n\",\n\t    ioc->sense, (unsigned long long)ioc->sense_dma, ioc->scsiio_depth,\n\t    SCSI_SENSE_BUFFERSIZE, sz / 1024);\n\t/* reply pool, 4 byte align */\n\tsz = ioc->reply_free_queue_depth * ioc->reply_sz;\n\trc = _base_allocate_reply_pool(ioc, sz);\n\tif (rc == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\ttotal_sz += sz;\n\n\t/* reply free queue, 16 byte align */\n\tsz = ioc->reply_free_queue_depth * 4;\n\trc = _base_allocate_reply_free_dma_pool(ioc, sz);\n\tif (rc  == -ENOMEM)\n\t\treturn -ENOMEM;\n\telse if (rc == -EAGAIN)\n\t\tgoto try_32bit_dma;\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"reply_free_dma (0x%llx)\\n\",\n\t\t\t     (unsigned long long)ioc->reply_free_dma));\n\ttotal_sz += sz;\n\tif (ioc->rdpq_array_enable) {\n\t\treply_post_free_array_sz = ioc->reply_queue_count *\n\t\t    sizeof(Mpi2IOCInitRDPQArrayEntry);\n\t\trc = _base_allocate_reply_post_free_array(ioc,\n\t\t    reply_post_free_array_sz);\n\t\tif (rc == -ENOMEM)\n\t\t\treturn -ENOMEM;\n\t\telse if (rc == -EAGAIN)\n\t\t\tgoto try_32bit_dma;\n\t}\n\tioc->config_page_sz = 512;\n\tioc->config_page = dma_alloc_coherent(&ioc->pdev->dev,\n\t\t\tioc->config_page_sz, &ioc->config_page_dma, GFP_KERNEL);\n\tif (!ioc->config_page) {\n\t\tioc_err(ioc, \"config page: dma_pool_alloc failed\\n\");\n\t\tgoto out;\n\t}\n\n\tioc_info(ioc, \"config page(0x%p) - dma(0x%llx): size(%d)\\n\",\n\t    ioc->config_page, (unsigned long long)ioc->config_page_dma,\n\t    ioc->config_page_sz);\n\ttotal_sz += ioc->config_page_sz;\n\n\tioc_info(ioc, \"Allocated physical memory: size(%d kB)\\n\",\n\t\t total_sz / 1024);\n\tioc_info(ioc, \"Current Controller Queue Depth(%d),Max Controller Queue Depth(%d)\\n\",\n\t\t ioc->shost->can_queue, facts->RequestCredit);\n\tioc_info(ioc, \"Scatter Gather Elements per IO(%d)\\n\",\n\t\t ioc->shost->sg_tablesize);\n\treturn 0;\n\ntry_32bit_dma:\n\t_base_release_memory_pools(ioc);\n\tif (ioc->use_32bit_dma && (ioc->dma_mask > 32)) {\n\t\t/* Change dma coherent mask to 32 bit and reallocate */\n\t\tif (_base_config_dma_addressing(ioc, ioc->pdev) != 0) {\n\t\t\tpr_err(\"Setting 32 bit coherent DMA mask Failed %s\\n\",\n\t\t\t    pci_name(ioc->pdev));\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (_base_reduce_hba_queue_depth(ioc) != 0)\n\t\treturn -ENOMEM;\n\tgoto retry_allocation;\n\n out:\n\treturn -ENOMEM;\n}\n\n/**\n * mpt3sas_base_get_iocstate - Get the current state of a MPT adapter.\n * @ioc: Pointer to MPT_ADAPTER structure\n * @cooked: Request raw or cooked IOC state\n *\n * Return: all IOC Doorbell register bits if cooked==0, else just the\n * Doorbell bits in MPI_IOC_STATE_MASK.\n */\nu32\nmpt3sas_base_get_iocstate(struct MPT3SAS_ADAPTER *ioc, int cooked)\n{\n\tu32 s, sc;\n\n\ts = ioc->base_readl(&ioc->chip->Doorbell);\n\tsc = s & MPI2_IOC_STATE_MASK;\n\treturn cooked ? sc : s;\n}\n\n/**\n * _base_wait_on_iocstate - waiting on a particular ioc state\n * @ioc: ?\n * @ioc_state: controller state { READY, OPERATIONAL, or RESET }\n * @timeout: timeout in second\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_wait_on_iocstate(struct MPT3SAS_ADAPTER *ioc, u32 ioc_state, int timeout)\n{\n\tu32 count, cntdn;\n\tu32 current_state;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tcurrent_state = mpt3sas_base_get_iocstate(ioc, 1);\n\t\tif (current_state == ioc_state)\n\t\t\treturn 0;\n\t\tif (count && current_state == MPI2_IOC_STATE_FAULT)\n\t\t\tbreak;\n\t\tif (count && current_state == MPI2_IOC_STATE_COREDUMP)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\treturn current_state;\n}\n\n/**\n * _base_dump_reg_set -\tThis function will print hexdump of register set.\n * @ioc: per adapter object\n *\n * Returns nothing.\n */\nstatic inline void\n_base_dump_reg_set(struct MPT3SAS_ADAPTER *ioc)\n{\n\tunsigned int i, sz = 256;\n\tu32 __iomem *reg = (u32 __iomem *)ioc->chip;\n\n\tioc_info(ioc, \"System Register set:\\n\");\n\tfor (i = 0; i < (sz / sizeof(u32)); i++)\n\t\tpr_info(\"%08x: %08x\\n\", (i * 4), readl(&reg[i]));\n}\n\n/**\n * _base_wait_for_doorbell_int - waiting for controller interrupt(generated by\n * a write to the doorbell)\n * @ioc: per adapter object\n * @timeout: timeout in seconds\n *\n * Return: 0 for success, non-zero for failure.\n *\n * Notes: MPI2_HIS_IOC2SYS_DB_STATUS - set to one when IOC writes to doorbell.\n */\n\nstatic int\n_base_wait_for_doorbell_int(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 int_status;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tint_status = ioc->base_readl(&ioc->chip->HostInterruptStatus);\n\t\tif (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), int_status(%x)!\\n\",\n\t\t__func__, count, int_status);\n\treturn -EFAULT;\n}\n\nstatic int\n_base_spin_on_doorbell_int(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 int_status;\n\n\tcount = 0;\n\tcntdn = 2000 * timeout;\n\tdo {\n\t\tint_status = ioc->base_readl(&ioc->chip->HostInterruptStatus);\n\t\tif (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), int_status(%x)!\\n\",\n\t\t__func__, count, int_status);\n\treturn -EFAULT;\n\n}\n\n/**\n * _base_wait_for_doorbell_ack - waiting for controller to read the doorbell.\n * @ioc: per adapter object\n * @timeout: timeout in second\n *\n * Return: 0 for success, non-zero for failure.\n *\n * Notes: MPI2_HIS_SYS2IOC_DB_STATUS - set to one when host writes to\n * doorbell.\n */\nstatic int\n_base_wait_for_doorbell_ack(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 int_status;\n\tu32 doorbell;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tint_status = ioc->base_readl(&ioc->chip->HostInterruptStatus);\n\t\tif (!(int_status & MPI2_HIS_SYS2IOC_DB_STATUS)) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t} else if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\n\t\t\tdoorbell = ioc->base_readl(&ioc->chip->Doorbell);\n\t\t\tif ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_FAULT) {\n\t\t\t\tmpt3sas_print_fault_code(ioc, doorbell);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tif ((doorbell & MPI2_IOC_STATE_MASK) ==\n\t\t\t    MPI2_IOC_STATE_COREDUMP) {\n\t\t\t\tmpt3sas_print_coredump_info(ioc, doorbell);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (int_status == 0xFFFFFFFF)\n\t\t\tgoto out;\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n out:\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), int_status(%x)!\\n\",\n\t\t__func__, count, int_status);\n\treturn -EFAULT;\n}\n\n/**\n * _base_wait_for_doorbell_not_used - waiting for doorbell to not be in use\n * @ioc: per adapter object\n * @timeout: timeout in second\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_wait_for_doorbell_not_used(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 cntdn, count;\n\tu32 doorbell_reg;\n\n\tcount = 0;\n\tcntdn = 1000 * timeout;\n\tdo {\n\t\tdoorbell_reg = ioc->base_readl(&ioc->chip->Doorbell);\n\t\tif (!(doorbell_reg & MPI2_DOORBELL_USED)) {\n\t\t\tdhsprintk(ioc,\n\t\t\t\t  ioc_info(ioc, \"%s: successful count(%d), timeout(%d)\\n\",\n\t\t\t\t\t   __func__, count, timeout));\n\t\t\treturn 0;\n\t\t}\n\n\t\tusleep_range(1000, 1500);\n\t\tcount++;\n\t} while (--cntdn);\n\n\tioc_err(ioc, \"%s: failed due to timeout count(%d), doorbell_reg(%x)!\\n\",\n\t\t__func__, count, doorbell_reg);\n\treturn -EFAULT;\n}\n\n/**\n * _base_send_ioc_reset - send doorbell reset\n * @ioc: per adapter object\n * @reset_type: currently only supports: MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET\n * @timeout: timeout in second\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_send_ioc_reset(struct MPT3SAS_ADAPTER *ioc, u8 reset_type, int timeout)\n{\n\tu32 ioc_state;\n\tint r = 0;\n\tunsigned long flags;\n\n\tif (reset_type != MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET) {\n\t\tioc_err(ioc, \"%s: unknown reset_type\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (!(ioc->facts.IOCCapabilities &\n\t   MPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY))\n\t\treturn -EFAULT;\n\n\tioc_info(ioc, \"sending message unit reset !!\\n\");\n\n\twritel(reset_type << MPI2_DOORBELL_FUNCTION_SHIFT,\n\t    &ioc->chip->Doorbell);\n\tif ((_base_wait_for_doorbell_ack(ioc, 15))) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, timeout);\n\tif (ioc_state) {\n\t\tioc_err(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t__func__, ioc_state);\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n out:\n\tif (r != 0) {\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\t\t/*\n\t\t * Wait for IOC state CoreDump to clear only during\n\t\t * HBA initialization & release time.\n\t\t */\n\t\tif ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t\t    MPI2_IOC_STATE_COREDUMP && (ioc->is_driver_loading == 1 ||\n\t\t    ioc->fault_reset_work_q == NULL)) {\n\t\t\tspin_unlock_irqrestore(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t\tmpt3sas_print_coredump_info(ioc, ioc_state);\n\t\t\tmpt3sas_base_wait_for_coredump_completion(ioc,\n\t\t\t    __func__);\n\t\t\tspin_lock_irqsave(\n\t\t\t    &ioc->ioc_reset_in_progress_lock, flags);\n\t\t}\n\t\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\t}\n\tioc_info(ioc, \"message unit reset: %s\\n\",\n\t\t r == 0 ? \"SUCCESS\" : \"FAILED\");\n\treturn r;\n}\n\n/**\n * mpt3sas_wait_for_ioc - IOC's operational state is checked here.\n * @ioc: per adapter object\n * @timeout: timeout in seconds\n *\n * Return: Waits up to timeout seconds for the IOC to\n * become operational. Returns 0 if IOC is present\n * and operational; otherwise returns -EFAULT.\n */\n\nint\nmpt3sas_wait_for_ioc(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tint wait_state_count = 0;\n\tu32 ioc_state;\n\n\tdo {\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 1);\n\t\tif (ioc_state == MPI2_IOC_STATE_OPERATIONAL)\n\t\t\tbreak;\n\t\tssleep(1);\n\t\tioc_info(ioc, \"%s: waiting for operational state(count=%d)\\n\",\n\t\t\t\t__func__, ++wait_state_count);\n\t} while (--timeout);\n\tif (!timeout) {\n\t\tioc_err(ioc, \"%s: failed due to ioc not operational\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\tif (wait_state_count)\n\t\tioc_info(ioc, \"ioc is operational\\n\");\n\treturn 0;\n}\n\n/**\n * _base_handshake_req_reply_wait - send request thru doorbell interface\n * @ioc: per adapter object\n * @request_bytes: request length\n * @request: pointer having request payload\n * @reply_bytes: reply length\n * @reply: pointer to reply payload\n * @timeout: timeout in second\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_handshake_req_reply_wait(struct MPT3SAS_ADAPTER *ioc, int request_bytes,\n\tu32 *request, int reply_bytes, u16 *reply, int timeout)\n{\n\tMPI2DefaultReply_t *default_reply = (MPI2DefaultReply_t *)reply;\n\tint i;\n\tu8 failed;\n\t__le32 *mfp;\n\n\t/* make sure doorbell is not in use */\n\tif ((ioc->base_readl(&ioc->chip->Doorbell) & MPI2_DOORBELL_USED)) {\n\t\tioc_err(ioc, \"doorbell is in use (line=%d)\\n\", __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* clear pending doorbell interrupts from previous state changes */\n\tif (ioc->base_readl(&ioc->chip->HostInterruptStatus) &\n\t    MPI2_HIS_IOC2SYS_DB_STATUS)\n\t\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\t/* send message to ioc */\n\twritel(((MPI2_FUNCTION_HANDSHAKE<<MPI2_DOORBELL_FUNCTION_SHIFT) |\n\t    ((request_bytes/4)<<MPI2_DOORBELL_ADD_DWORDS_SHIFT)),\n\t    &ioc->chip->Doorbell);\n\n\tif ((_base_spin_on_doorbell_int(ioc, 5))) {\n\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\tif ((_base_wait_for_doorbell_ack(ioc, 5))) {\n\t\tioc_err(ioc, \"doorbell handshake ack failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* send message 32-bits at a time */\n\tfor (i = 0, failed = 0; i < request_bytes/4 && !failed; i++) {\n\t\twritel(cpu_to_le32(request[i]), &ioc->chip->Doorbell);\n\t\tif ((_base_wait_for_doorbell_ack(ioc, 5)))\n\t\t\tfailed = 1;\n\t}\n\n\tif (failed) {\n\t\tioc_err(ioc, \"doorbell handshake sending request failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* now wait for the reply */\n\tif ((_base_wait_for_doorbell_int(ioc, timeout))) {\n\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* read the first two 16-bits, it gives the total length of the reply */\n\treply[0] = le16_to_cpu(ioc->base_readl(&ioc->chip->Doorbell)\n\t    & MPI2_DOORBELL_DATA_MASK);\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\tif ((_base_wait_for_doorbell_int(ioc, 5))) {\n\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t__LINE__);\n\t\treturn -EFAULT;\n\t}\n\treply[1] = le16_to_cpu(ioc->base_readl(&ioc->chip->Doorbell)\n\t    & MPI2_DOORBELL_DATA_MASK);\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\tfor (i = 2; i < default_reply->MsgLength * 2; i++)  {\n\t\tif ((_base_wait_for_doorbell_int(ioc, 5))) {\n\t\t\tioc_err(ioc, \"doorbell handshake int failed (line=%d)\\n\",\n\t\t\t\t__LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (i >=  reply_bytes/2) /* overflow case */\n\t\t\tioc->base_readl(&ioc->chip->Doorbell);\n\t\telse\n\t\t\treply[i] = le16_to_cpu(\n\t\t\t    ioc->base_readl(&ioc->chip->Doorbell)\n\t\t\t    & MPI2_DOORBELL_DATA_MASK);\n\t\twritel(0, &ioc->chip->HostInterruptStatus);\n\t}\n\n\t_base_wait_for_doorbell_int(ioc, 5);\n\tif (_base_wait_for_doorbell_not_used(ioc, 5) != 0) {\n\t\tdhsprintk(ioc,\n\t\t\t  ioc_info(ioc, \"doorbell is in use (line=%d)\\n\",\n\t\t\t\t   __LINE__));\n\t}\n\twritel(0, &ioc->chip->HostInterruptStatus);\n\n\tif (ioc->logging_level & MPT_DEBUG_INIT) {\n\t\tmfp = (__le32 *)reply;\n\t\tpr_info(\"\\toffset:data\\n\");\n\t\tfor (i = 0; i < reply_bytes/4; i++)\n\t\t\tioc_info(ioc, \"\\t[0x%02x]:%08x\\n\", i*4,\n\t\t\t    le32_to_cpu(mfp[i]));\n\t}\n\treturn 0;\n}\n\n/**\n * mpt3sas_base_sas_iounit_control - send sas iounit control to FW\n * @ioc: per adapter object\n * @mpi_reply: the reply payload from FW\n * @mpi_request: the request payload sent to FW\n *\n * The SAS IO Unit Control Request message allows the host to perform low-level\n * operations, such as resets on the PHYs of the IO Unit, also allows the host\n * to obtain the IOC assigned device handles for a device if it has other\n * identifying information about the device, in addition allows the host to\n * remove IOC resources associated with the device.\n *\n * Return: 0 for success, non-zero for failure.\n */\nint\nmpt3sas_base_sas_iounit_control(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2SasIoUnitControlReply_t *mpi_reply,\n\tMpi2SasIoUnitControlRequest_t *mpi_request)\n{\n\tu16 smid;\n\tu8 issue_reset = 0;\n\tint rc;\n\tvoid *request;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmutex_lock(&ioc->base_cmds.mutex);\n\n\tif (ioc->base_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: base_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemcpy(request, mpi_request, sizeof(Mpi2SasIoUnitControlRequest_t));\n\tif (mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||\n\t    mpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET)\n\t\tioc->ioc_link_reset_in_progress = 1;\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->base_cmds.done,\n\t    msecs_to_jiffies(10000));\n\tif ((mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||\n\t    mpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET) &&\n\t    ioc->ioc_link_reset_in_progress)\n\t\tioc->ioc_link_reset_in_progress = 0;\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc, ioc->base_cmds.status,\n\t\t    mpi_request, sizeof(Mpi2SasIoUnitControlRequest_t)/4,\n\t\t    issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\tif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID)\n\t\tmemcpy(mpi_reply, ioc->base_cmds.reply,\n\t\t    sizeof(Mpi2SasIoUnitControlReply_t));\n\telse\n\t\tmemset(mpi_reply, 0, sizeof(Mpi2SasIoUnitControlReply_t));\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\tgoto out;\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\trc = -EFAULT;\n out:\n\tmutex_unlock(&ioc->base_cmds.mutex);\n\treturn rc;\n}\n\n/**\n * mpt3sas_base_scsi_enclosure_processor - sending request to sep device\n * @ioc: per adapter object\n * @mpi_reply: the reply payload from FW\n * @mpi_request: the request payload sent to FW\n *\n * The SCSI Enclosure Processor request message causes the IOC to\n * communicate with SES devices to control LED status signals.\n *\n * Return: 0 for success, non-zero for failure.\n */\nint\nmpt3sas_base_scsi_enclosure_processor(struct MPT3SAS_ADAPTER *ioc,\n\tMpi2SepReply_t *mpi_reply, Mpi2SepRequest_t *mpi_request)\n{\n\tu16 smid;\n\tu8 issue_reset = 0;\n\tint rc;\n\tvoid *request;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmutex_lock(&ioc->base_cmds.mutex);\n\n\tif (ioc->base_cmds.status != MPT3_CMD_NOT_USED) {\n\t\tioc_err(ioc, \"%s: base_cmd in use\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = mpt3sas_wait_for_ioc(ioc, IOC_OPERATIONAL_WAIT_COUNT);\n\tif (rc)\n\t\tgoto out;\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\trc = 0;\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\trequest = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemset(request, 0, ioc->request_sz);\n\tmemcpy(request, mpi_request, sizeof(Mpi2SepReply_t));\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->base_cmds.done,\n\t    msecs_to_jiffies(10000));\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tmpt3sas_check_cmd_timeout(ioc,\n\t\t    ioc->base_cmds.status, mpi_request,\n\t\t    sizeof(Mpi2SepRequest_t)/4, issue_reset);\n\t\tgoto issue_host_reset;\n\t}\n\tif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID)\n\t\tmemcpy(mpi_reply, ioc->base_cmds.reply,\n\t\t    sizeof(Mpi2SepReply_t));\n\telse\n\t\tmemset(mpi_reply, 0, sizeof(Mpi2SepReply_t));\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\tgoto out;\n\n issue_host_reset:\n\tif (issue_reset)\n\t\tmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\trc = -EFAULT;\n out:\n\tmutex_unlock(&ioc->base_cmds.mutex);\n\treturn rc;\n}\n\n/**\n * _base_get_port_facts - obtain port facts reply and save in ioc\n * @ioc: per adapter object\n * @port: ?\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_get_port_facts(struct MPT3SAS_ADAPTER *ioc, int port)\n{\n\tMpi2PortFactsRequest_t mpi_request;\n\tMpi2PortFactsReply_t mpi_reply;\n\tstruct mpt3sas_port_facts *pfacts;\n\tint mpi_reply_sz, mpi_request_sz, r;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmpi_reply_sz = sizeof(Mpi2PortFactsReply_t);\n\tmpi_request_sz = sizeof(Mpi2PortFactsRequest_t);\n\tmemset(&mpi_request, 0, mpi_request_sz);\n\tmpi_request.Function = MPI2_FUNCTION_PORT_FACTS;\n\tmpi_request.PortNumber = port;\n\tr = _base_handshake_req_reply_wait(ioc, mpi_request_sz,\n\t    (u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5);\n\n\tif (r != 0) {\n\t\tioc_err(ioc, \"%s: handshake failed (r=%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tpfacts = &ioc->pfacts[port];\n\tmemset(pfacts, 0, sizeof(struct mpt3sas_port_facts));\n\tpfacts->PortNumber = mpi_reply.PortNumber;\n\tpfacts->VP_ID = mpi_reply.VP_ID;\n\tpfacts->VF_ID = mpi_reply.VF_ID;\n\tpfacts->MaxPostedCmdBuffers =\n\t    le16_to_cpu(mpi_reply.MaxPostedCmdBuffers);\n\n\treturn 0;\n}\n\n/**\n * _base_wait_for_iocstate - Wait until the card is in READY or OPERATIONAL\n * @ioc: per adapter object\n * @timeout:\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_wait_for_iocstate(struct MPT3SAS_ADAPTER *ioc, int timeout)\n{\n\tu32 ioc_state;\n\tint rc;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->pci_error_recovery) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"%s: host in pci error recovery\\n\",\n\t\t\t\t     __func__));\n\t\treturn -EFAULT;\n\t}\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tdhsprintk(ioc,\n\t\t  ioc_info(ioc, \"%s: ioc_state(0x%08x)\\n\",\n\t\t\t   __func__, ioc_state));\n\n\tif (((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_READY) ||\n\t    (ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_OPERATIONAL)\n\t\treturn 0;\n\n\tif (ioc_state & MPI2_DOORBELL_USED) {\n\t\tdhsprintk(ioc, ioc_info(ioc, \"unexpected doorbell active!\\n\"));\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tgoto issue_diag_reset;\n\t} else if ((ioc_state & MPI2_IOC_STATE_MASK) ==\n\t    MPI2_IOC_STATE_COREDUMP) {\n\t\tioc_info(ioc,\n\t\t    \"%s: Skipping the diag reset here. (ioc_state=0x%x)\\n\",\n\t\t    __func__, ioc_state);\n\t\treturn -EFAULT;\n\t}\n\n\tioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, timeout);\n\tif (ioc_state) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t\t     __func__, ioc_state));\n\t\treturn -EFAULT;\n\t}\n\n issue_diag_reset:\n\trc = _base_diag_reset(ioc);\n\treturn rc;\n}\n\n/**\n * _base_get_ioc_facts - obtain ioc facts reply and save in ioc\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2IOCFactsRequest_t mpi_request;\n\tMpi2IOCFactsReply_t mpi_reply;\n\tstruct mpt3sas_facts *facts;\n\tint mpi_reply_sz, mpi_request_sz, r;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tr = _base_wait_for_iocstate(ioc, 10);\n\tif (r) {\n\t\tdfailprintk(ioc,\n\t\t\t    ioc_info(ioc, \"%s: failed getting to correct state\\n\",\n\t\t\t\t     __func__));\n\t\treturn r;\n\t}\n\tmpi_reply_sz = sizeof(Mpi2IOCFactsReply_t);\n\tmpi_request_sz = sizeof(Mpi2IOCFactsRequest_t);\n\tmemset(&mpi_request, 0, mpi_request_sz);\n\tmpi_request.Function = MPI2_FUNCTION_IOC_FACTS;\n\tr = _base_handshake_req_reply_wait(ioc, mpi_request_sz,\n\t    (u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5);\n\n\tif (r != 0) {\n\t\tioc_err(ioc, \"%s: handshake failed (r=%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tfacts = &ioc->facts;\n\tmemset(facts, 0, sizeof(struct mpt3sas_facts));\n\tfacts->MsgVersion = le16_to_cpu(mpi_reply.MsgVersion);\n\tfacts->HeaderVersion = le16_to_cpu(mpi_reply.HeaderVersion);\n\tfacts->VP_ID = mpi_reply.VP_ID;\n\tfacts->VF_ID = mpi_reply.VF_ID;\n\tfacts->IOCExceptions = le16_to_cpu(mpi_reply.IOCExceptions);\n\tfacts->MaxChainDepth = mpi_reply.MaxChainDepth;\n\tfacts->WhoInit = mpi_reply.WhoInit;\n\tfacts->NumberOfPorts = mpi_reply.NumberOfPorts;\n\tfacts->MaxMSIxVectors = mpi_reply.MaxMSIxVectors;\n\tif (ioc->msix_enable && (facts->MaxMSIxVectors <=\n\t    MAX_COMBINED_MSIX_VECTORS(ioc->is_gen35_ioc)))\n\t\tioc->combined_reply_queue = 0;\n\tfacts->RequestCredit = le16_to_cpu(mpi_reply.RequestCredit);\n\tfacts->MaxReplyDescriptorPostQueueDepth =\n\t    le16_to_cpu(mpi_reply.MaxReplyDescriptorPostQueueDepth);\n\tfacts->ProductID = le16_to_cpu(mpi_reply.ProductID);\n\tfacts->IOCCapabilities = le32_to_cpu(mpi_reply.IOCCapabilities);\n\tif ((facts->IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID))\n\t\tioc->ir_firmware = 1;\n\tif ((facts->IOCCapabilities &\n\t      MPI2_IOCFACTS_CAPABILITY_RDPQ_ARRAY_CAPABLE) && (!reset_devices))\n\t\tioc->rdpq_array_capable = 1;\n\tif ((facts->IOCCapabilities & MPI26_IOCFACTS_CAPABILITY_ATOMIC_REQ)\n\t    && ioc->is_aero_ioc)\n\t\tioc->atomic_desc_capable = 1;\n\tfacts->FWVersion.Word = le32_to_cpu(mpi_reply.FWVersion.Word);\n\tfacts->IOCRequestFrameSize =\n\t    le16_to_cpu(mpi_reply.IOCRequestFrameSize);\n\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tfacts->IOCMaxChainSegmentSize =\n\t\t\tle16_to_cpu(mpi_reply.IOCMaxChainSegmentSize);\n\t}\n\tfacts->MaxInitiators = le16_to_cpu(mpi_reply.MaxInitiators);\n\tfacts->MaxTargets = le16_to_cpu(mpi_reply.MaxTargets);\n\tioc->shost->max_id = -1;\n\tfacts->MaxSasExpanders = le16_to_cpu(mpi_reply.MaxSasExpanders);\n\tfacts->MaxEnclosures = le16_to_cpu(mpi_reply.MaxEnclosures);\n\tfacts->ProtocolFlags = le16_to_cpu(mpi_reply.ProtocolFlags);\n\tfacts->HighPriorityCredit =\n\t    le16_to_cpu(mpi_reply.HighPriorityCredit);\n\tfacts->ReplyFrameSize = mpi_reply.ReplyFrameSize;\n\tfacts->MaxDevHandle = le16_to_cpu(mpi_reply.MaxDevHandle);\n\tfacts->CurrentHostPageSize = mpi_reply.CurrentHostPageSize;\n\n\t/*\n\t * Get the Page Size from IOC Facts. If it's 0, default to 4k.\n\t */\n\tioc->page_size = 1 << facts->CurrentHostPageSize;\n\tif (ioc->page_size == 1) {\n\t\tioc_info(ioc, \"CurrentHostPageSize is 0: Setting default host page size to 4k\\n\");\n\t\tioc->page_size = 1 << MPT3SAS_HOST_PAGE_SIZE_4K;\n\t}\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"CurrentHostPageSize(%d)\\n\",\n\t\t\t     facts->CurrentHostPageSize));\n\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"hba queue depth(%d), max chains per io(%d)\\n\",\n\t\t\t     facts->RequestCredit, facts->MaxChainDepth));\n\tdinitprintk(ioc,\n\t\t    ioc_info(ioc, \"request frame size(%d), reply frame size(%d)\\n\",\n\t\t\t     facts->IOCRequestFrameSize * 4,\n\t\t\t     facts->ReplyFrameSize * 4));\n\treturn 0;\n}\n\n/**\n * _base_send_ioc_init - send ioc_init to firmware\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_send_ioc_init(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2IOCInitRequest_t mpi_request;\n\tMpi2IOCInitReply_t mpi_reply;\n\tint i, r = 0;\n\tktime_t current_time;\n\tu16 ioc_status;\n\tu32 reply_post_free_array_sz = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmemset(&mpi_request, 0, sizeof(Mpi2IOCInitRequest_t));\n\tmpi_request.Function = MPI2_FUNCTION_IOC_INIT;\n\tmpi_request.WhoInit = MPI2_WHOINIT_HOST_DRIVER;\n\tmpi_request.VF_ID = 0; /* TODO */\n\tmpi_request.VP_ID = 0;\n\tmpi_request.MsgVersion = cpu_to_le16(ioc->hba_mpi_version_belonged);\n\tmpi_request.HeaderVersion = cpu_to_le16(MPI2_HEADER_VERSION);\n\tmpi_request.HostPageSize = MPT3SAS_HOST_PAGE_SIZE_4K;\n\n\tif (_base_is_controller_msix_enabled(ioc))\n\t\tmpi_request.HostMSIxVectors = ioc->reply_queue_count;\n\tmpi_request.SystemRequestFrameSize = cpu_to_le16(ioc->request_sz/4);\n\tmpi_request.ReplyDescriptorPostQueueDepth =\n\t    cpu_to_le16(ioc->reply_post_queue_depth);\n\tmpi_request.ReplyFreeQueueDepth =\n\t    cpu_to_le16(ioc->reply_free_queue_depth);\n\n\tmpi_request.SenseBufferAddressHigh =\n\t    cpu_to_le32((u64)ioc->sense_dma >> 32);\n\tmpi_request.SystemReplyAddressHigh =\n\t    cpu_to_le32((u64)ioc->reply_dma >> 32);\n\tmpi_request.SystemRequestFrameBaseAddress =\n\t    cpu_to_le64((u64)ioc->request_dma);\n\tmpi_request.ReplyFreeQueueAddress =\n\t    cpu_to_le64((u64)ioc->reply_free_dma);\n\n\tif (ioc->rdpq_array_enable) {\n\t\treply_post_free_array_sz = ioc->reply_queue_count *\n\t\t    sizeof(Mpi2IOCInitRDPQArrayEntry);\n\t\tmemset(ioc->reply_post_free_array, 0, reply_post_free_array_sz);\n\t\tfor (i = 0; i < ioc->reply_queue_count; i++)\n\t\t\tioc->reply_post_free_array[i].RDPQBaseAddress =\n\t\t\t    cpu_to_le64(\n\t\t\t\t(u64)ioc->reply_post[i].reply_post_free_dma);\n\t\tmpi_request.MsgFlags = MPI2_IOCINIT_MSGFLAG_RDPQ_ARRAY_MODE;\n\t\tmpi_request.ReplyDescriptorPostQueueAddress =\n\t\t    cpu_to_le64((u64)ioc->reply_post_free_array_dma);\n\t} else {\n\t\tmpi_request.ReplyDescriptorPostQueueAddress =\n\t\t    cpu_to_le64((u64)ioc->reply_post[0].reply_post_free_dma);\n\t}\n\n\t/*\n\t * Set the flag to enable CoreDump state feature in IOC firmware.\n\t */\n\tmpi_request.ConfigurationFlags |=\n\t    cpu_to_le16(MPI26_IOCINIT_CFGFLAGS_COREDUMP_ENABLE);\n\n\t/* This time stamp specifies number of milliseconds\n\t * since epoch ~ midnight January 1, 1970.\n\t */\n\tcurrent_time = ktime_get_real();\n\tmpi_request.TimeStamp = cpu_to_le64(ktime_to_ms(current_time));\n\n\tif (ioc->logging_level & MPT_DEBUG_INIT) {\n\t\t__le32 *mfp;\n\t\tint i;\n\n\t\tmfp = (__le32 *)&mpi_request;\n\t\tioc_info(ioc, \"\\toffset:data\\n\");\n\t\tfor (i = 0; i < sizeof(Mpi2IOCInitRequest_t)/4; i++)\n\t\t\tioc_info(ioc, \"\\t[0x%02x]:%08x\\n\", i*4,\n\t\t\t    le32_to_cpu(mfp[i]));\n\t}\n\n\tr = _base_handshake_req_reply_wait(ioc,\n\t    sizeof(Mpi2IOCInitRequest_t), (u32 *)&mpi_request,\n\t    sizeof(Mpi2IOCInitReply_t), (u16 *)&mpi_reply, 30);\n\n\tif (r != 0) {\n\t\tioc_err(ioc, \"%s: handshake failed (r=%d)\\n\", __func__, r);\n\t\treturn r;\n\t}\n\n\tioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS ||\n\t    mpi_reply.IOCLogInfo) {\n\t\tioc_err(ioc, \"%s: failed\\n\", __func__);\n\t\tr = -EIO;\n\t}\n\n\t/* Reset TimeSync Counter*/\n\tioc->timestamp_update_count = 0;\n\treturn r;\n}\n\n/**\n * mpt3sas_port_enable_done - command completion routine for port enable\n * @ioc: per adapter object\n * @smid: system request message index\n * @msix_index: MSIX table index supplied by the OS\n * @reply: reply message frame(lower 32bit addr)\n *\n * Return: 1 meaning mf should be freed from _base_interrupt\n *          0 means the mf is freed from this function.\n */\nu8\nmpt3sas_port_enable_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\n\tu32 reply)\n{\n\tMPI2DefaultReply_t *mpi_reply;\n\tu16 ioc_status;\n\n\tif (ioc->port_enable_cmds.status == MPT3_CMD_NOT_USED)\n\t\treturn 1;\n\n\tmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\n\tif (!mpi_reply)\n\t\treturn 1;\n\n\tif (mpi_reply->Function != MPI2_FUNCTION_PORT_ENABLE)\n\t\treturn 1;\n\n\tioc->port_enable_cmds.status &= ~MPT3_CMD_PENDING;\n\tioc->port_enable_cmds.status |= MPT3_CMD_COMPLETE;\n\tioc->port_enable_cmds.status |= MPT3_CMD_REPLY_VALID;\n\tmemcpy(ioc->port_enable_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\n\t\tioc->port_enable_failed = 1;\n\n\tif (ioc->is_driver_loading) {\n\t\tif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\n\t\t\tmpt3sas_port_enable_complete(ioc);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tioc->start_scan_failed = ioc_status;\n\t\t\tioc->start_scan = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tcomplete(&ioc->port_enable_cmds.done);\n\treturn 1;\n}\n\n/**\n * _base_send_port_enable - send port_enable(discovery stuff) to firmware\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_send_port_enable(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2PortEnableRequest_t *mpi_request;\n\tMpi2PortEnableReply_t *mpi_reply;\n\tint r = 0;\n\tu16 smid;\n\tu16 ioc_status;\n\n\tioc_info(ioc, \"sending port enable !!\\n\");\n\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->port_enable_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tioc->port_enable_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->port_enable_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;\n\n\tinit_completion(&ioc->port_enable_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->port_enable_cmds.done, 300*HZ);\n\tif (!(ioc->port_enable_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2PortEnableRequest_t)/4);\n\t\tif (ioc->port_enable_cmds.status & MPT3_CMD_RESET)\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = -ETIME;\n\t\tgoto out;\n\t}\n\n\tmpi_reply = ioc->port_enable_cmds.reply;\n\tioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\n\tif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\n\t\tioc_err(ioc, \"%s: failed with (ioc_status=0x%08x)\\n\",\n\t\t\t__func__, ioc_status);\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n out:\n\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\tioc_info(ioc, \"port enable: %s\\n\", r == 0 ? \"SUCCESS\" : \"FAILED\");\n\treturn r;\n}\n\n/**\n * mpt3sas_port_enable - initiate firmware discovery (don't wait for reply)\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nint\nmpt3sas_port_enable(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2PortEnableRequest_t *mpi_request;\n\tu16 smid;\n\n\tioc_info(ioc, \"sending port enable !!\\n\");\n\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->port_enable_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tioc->port_enable_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->port_enable_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;\n\n\tioc->put_smid_default(ioc, smid);\n\treturn 0;\n}\n\n/**\n * _base_determine_wait_on_discovery - desposition\n * @ioc: per adapter object\n *\n * Decide whether to wait on discovery to complete. Used to either\n * locate boot device, or report volumes ahead of physical devices.\n *\n * Return: 1 for wait, 0 for don't wait.\n */\nstatic int\n_base_determine_wait_on_discovery(struct MPT3SAS_ADAPTER *ioc)\n{\n\t/* We wait for discovery to complete if IR firmware is loaded.\n\t * The sas topology events arrive before PD events, so we need time to\n\t * turn on the bit in ioc->pd_handles to indicate PD\n\t * Also, it maybe required to report Volumes ahead of physical\n\t * devices when MPI2_IOCPAGE8_IRFLAGS_LOW_VOLUME_MAPPING is set.\n\t */\n\tif (ioc->ir_firmware)\n\t\treturn 1;\n\n\t/* if no Bios, then we don't need to wait */\n\tif (!ioc->bios_pg3.BiosVersion)\n\t\treturn 0;\n\n\t/* Bios is present, then we drop down here.\n\t *\n\t * If there any entries in the Bios Page 2, then we wait\n\t * for discovery to complete.\n\t */\n\n\t/* Current Boot Device */\n\tif ((ioc->bios_pg2.CurrentBootDeviceForm &\n\t    MPI2_BIOSPAGE2_FORM_MASK) ==\n\t    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&\n\t/* Request Boot Device */\n\t   (ioc->bios_pg2.ReqBootDeviceForm &\n\t    MPI2_BIOSPAGE2_FORM_MASK) ==\n\t    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&\n\t/* Alternate Request Boot Device */\n\t   (ioc->bios_pg2.ReqAltBootDeviceForm &\n\t    MPI2_BIOSPAGE2_FORM_MASK) ==\n\t    MPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**\n * _base_unmask_events - turn on notification for this event\n * @ioc: per adapter object\n * @event: firmware event\n *\n * The mask is stored in ioc->event_masks.\n */\nstatic void\n_base_unmask_events(struct MPT3SAS_ADAPTER *ioc, u16 event)\n{\n\tu32 desired_event;\n\n\tif (event >= 128)\n\t\treturn;\n\n\tdesired_event = (1 << (event % 32));\n\n\tif (event < 32)\n\t\tioc->event_masks[0] &= ~desired_event;\n\telse if (event < 64)\n\t\tioc->event_masks[1] &= ~desired_event;\n\telse if (event < 96)\n\t\tioc->event_masks[2] &= ~desired_event;\n\telse if (event < 128)\n\t\tioc->event_masks[3] &= ~desired_event;\n}\n\n/**\n * _base_event_notification - send event notification\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_event_notification(struct MPT3SAS_ADAPTER *ioc)\n{\n\tMpi2EventNotificationRequest_t *mpi_request;\n\tu16 smid;\n\tint r = 0;\n\tint i;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc_err(ioc, \"%s: internal command already in use\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\n\tif (!smid) {\n\t\tioc_err(ioc, \"%s: failed obtaining a smid\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\tioc->base_cmds.status = MPT3_CMD_PENDING;\n\tmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\n\tioc->base_cmds.smid = smid;\n\tmemset(mpi_request, 0, sizeof(Mpi2EventNotificationRequest_t));\n\tmpi_request->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;\n\tmpi_request->VF_ID = 0; /* TODO */\n\tmpi_request->VP_ID = 0;\n\tfor (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\tmpi_request->EventMasks[i] =\n\t\t    cpu_to_le32(ioc->event_masks[i]);\n\tinit_completion(&ioc->base_cmds.done);\n\tioc->put_smid_default(ioc, smid);\n\twait_for_completion_timeout(&ioc->base_cmds.done, 30*HZ);\n\tif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\n\t\tioc_err(ioc, \"%s: timeout\\n\", __func__);\n\t\t_debug_dump_mf(mpi_request,\n\t\t    sizeof(Mpi2EventNotificationRequest_t)/4);\n\t\tif (ioc->base_cmds.status & MPT3_CMD_RESET)\n\t\t\tr = -EFAULT;\n\t\telse\n\t\t\tr = -ETIME;\n\t} else\n\t\tdinitprintk(ioc, ioc_info(ioc, \"%s: complete\\n\", __func__));\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\treturn r;\n}\n\n/**\n * mpt3sas_base_validate_event_type - validating event types\n * @ioc: per adapter object\n * @event_type: firmware event\n *\n * This will turn on firmware event notification when application\n * ask for that event. We don't mask events that are already enabled.\n */\nvoid\nmpt3sas_base_validate_event_type(struct MPT3SAS_ADAPTER *ioc, u32 *event_type)\n{\n\tint i, j;\n\tu32 event_mask, desired_event;\n\tu8 send_update_to_fw;\n\n\tfor (i = 0, send_update_to_fw = 0; i <\n\t    MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++) {\n\t\tevent_mask = ~event_type[i];\n\t\tdesired_event = 1;\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tif (!(event_mask & desired_event) &&\n\t\t\t    (ioc->event_masks[i] & desired_event)) {\n\t\t\t\tioc->event_masks[i] &= ~desired_event;\n\t\t\t\tsend_update_to_fw = 1;\n\t\t\t}\n\t\t\tdesired_event = (desired_event << 1);\n\t\t}\n\t}\n\n\tif (!send_update_to_fw)\n\t\treturn;\n\n\tmutex_lock(&ioc->base_cmds.mutex);\n\t_base_event_notification(ioc);\n\tmutex_unlock(&ioc->base_cmds.mutex);\n}\n\n/**\n * _base_diag_reset - the \"big hammer\" start of day reset\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_diag_reset(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 host_diagnostic;\n\tu32 ioc_state;\n\tu32 count;\n\tu32 hcb_size;\n\n\tioc_info(ioc, \"sending diag reset !!\\n\");\n\n\tdrsprintk(ioc, ioc_info(ioc, \"clear interrupts\\n\"));\n\n\tcount = 0;\n\tdo {\n\t\t/* Write magic sequence to WriteSequence register\n\t\t * Loop until in diagnostic mode\n\t\t */\n\t\tdrsprintk(ioc, ioc_info(ioc, \"write magic sequence\\n\"));\n\t\twritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_1ST_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_2ND_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_3RD_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_4TH_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_5TH_KEY_VALUE, &ioc->chip->WriteSequence);\n\t\twritel(MPI2_WRSEQ_6TH_KEY_VALUE, &ioc->chip->WriteSequence);\n\n\t\t/* wait 100 msec */\n\t\tmsleep(100);\n\n\t\tif (count++ > 20) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Stop writing magic sequence after 20 retries\\n\");\n\t\t\t_base_dump_reg_set(ioc);\n\t\t\tgoto out;\n\t\t}\n\n\t\thost_diagnostic = ioc->base_readl(&ioc->chip->HostDiagnostic);\n\t\tdrsprintk(ioc,\n\t\t\t  ioc_info(ioc, \"wrote magic sequence: count(%d), host_diagnostic(0x%08x)\\n\",\n\t\t\t\t   count, host_diagnostic));\n\n\t} while ((host_diagnostic & MPI2_DIAG_DIAG_WRITE_ENABLE) == 0);\n\n\thcb_size = ioc->base_readl(&ioc->chip->HCBSize);\n\n\tdrsprintk(ioc, ioc_info(ioc, \"diag reset: issued\\n\"));\n\twritel(host_diagnostic | MPI2_DIAG_RESET_ADAPTER,\n\t     &ioc->chip->HostDiagnostic);\n\n\t/*This delay allows the chip PCIe hardware time to finish reset tasks*/\n\tmsleep(MPI2_HARD_RESET_PCIE_FIRST_READ_DELAY_MICRO_SEC/1000);\n\n\t/* Approximately 300 second max wait */\n\tfor (count = 0; count < (300000000 /\n\t\tMPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC); count++) {\n\n\t\thost_diagnostic = ioc->base_readl(&ioc->chip->HostDiagnostic);\n\n\t\tif (host_diagnostic == 0xFFFFFFFF) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Invalid host diagnostic register value\\n\");\n\t\t\t_base_dump_reg_set(ioc);\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(host_diagnostic & MPI2_DIAG_RESET_ADAPTER))\n\t\t\tbreak;\n\n\t\tmsleep(MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC / 1000);\n\t}\n\n\tif (host_diagnostic & MPI2_DIAG_HCB_MODE) {\n\n\t\tdrsprintk(ioc,\n\t\t\t  ioc_info(ioc, \"restart the adapter assuming the HCB Address points to good F/W\\n\"));\n\t\thost_diagnostic &= ~MPI2_DIAG_BOOT_DEVICE_SELECT_MASK;\n\t\thost_diagnostic |= MPI2_DIAG_BOOT_DEVICE_SELECT_HCDW;\n\t\twritel(host_diagnostic, &ioc->chip->HostDiagnostic);\n\n\t\tdrsprintk(ioc, ioc_info(ioc, \"re-enable the HCDW\\n\"));\n\t\twritel(hcb_size | MPI2_HCB_SIZE_HCB_ENABLE,\n\t\t    &ioc->chip->HCBSize);\n\t}\n\n\tdrsprintk(ioc, ioc_info(ioc, \"restart the adapter\\n\"));\n\twritel(host_diagnostic & ~MPI2_DIAG_HOLD_IOC_RESET,\n\t    &ioc->chip->HostDiagnostic);\n\n\tdrsprintk(ioc,\n\t\t  ioc_info(ioc, \"disable writes to the diagnostic register\\n\"));\n\twritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);\n\n\tdrsprintk(ioc, ioc_info(ioc, \"Wait for FW to go to the READY state\\n\"));\n\tioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, 20);\n\tif (ioc_state) {\n\t\tioc_err(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t__func__, ioc_state);\n\t\t_base_dump_reg_set(ioc);\n\t\tgoto out;\n\t}\n\n\tioc_info(ioc, \"diag reset: SUCCESS\\n\");\n\treturn 0;\n\n out:\n\tioc_err(ioc, \"diag reset: FAILED\\n\");\n\treturn -EFAULT;\n}\n\n/**\n * _base_make_ioc_ready - put controller in READY state\n * @ioc: per adapter object\n * @type: FORCE_BIG_HAMMER or SOFT_RESET\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_make_ioc_ready(struct MPT3SAS_ADAPTER *ioc, enum reset_type type)\n{\n\tu32 ioc_state;\n\tint rc;\n\tint count;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tif (ioc->pci_error_recovery)\n\t\treturn 0;\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tdhsprintk(ioc,\n\t\t  ioc_info(ioc, \"%s: ioc_state(0x%08x)\\n\",\n\t\t\t   __func__, ioc_state));\n\n\t/* if in RESET state, it should move to READY state shortly */\n\tcount = 0;\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_RESET) {\n\t\twhile ((ioc_state & MPI2_IOC_STATE_MASK) !=\n\t\t    MPI2_IOC_STATE_READY) {\n\t\t\tif (count++ == 10) {\n\t\t\t\tioc_err(ioc, \"%s: failed going to ready state (ioc_state=0x%x)\\n\",\n\t\t\t\t\t__func__, ioc_state);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tssleep(1);\n\t\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\t}\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_READY)\n\t\treturn 0;\n\n\tif (ioc_state & MPI2_DOORBELL_USED) {\n\t\tioc_info(ioc, \"unexpected doorbell active!\\n\");\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\n\t\tmpt3sas_print_fault_code(ioc, ioc_state &\n\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_COREDUMP) {\n\t\t/*\n\t\t * if host reset is invoked while watch dog thread is waiting\n\t\t * for IOC state to be changed to Fault state then driver has\n\t\t * to wait here for CoreDump state to clear otherwise reset\n\t\t * will be issued to the FW and FW move the IOC state to\n\t\t * reset state without copying the FW logs to coredump region.\n\t\t */\n\t\tif (ioc->ioc_coredump_loop != MPT3SAS_COREDUMP_LOOP_DONE) {\n\t\t\tmpt3sas_print_coredump_info(ioc, ioc_state &\n\t\t\t    MPI2_DOORBELL_DATA_MASK);\n\t\t\tmpt3sas_base_wait_for_coredump_completion(ioc,\n\t\t\t    __func__);\n\t\t}\n\t\tgoto issue_diag_reset;\n\t}\n\n\tif (type == FORCE_BIG_HAMMER)\n\t\tgoto issue_diag_reset;\n\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_OPERATIONAL)\n\t\tif (!(_base_send_ioc_reset(ioc,\n\t\t    MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET, 15))) {\n\t\t\treturn 0;\n\t}\n\n issue_diag_reset:\n\trc = _base_diag_reset(ioc);\n\treturn rc;\n}\n\n/**\n * _base_make_ioc_operational - put controller in OPERATIONAL state\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nstatic int\n_base_make_ioc_operational(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint r, i, index, rc;\n\tunsigned long\tflags;\n\tu32 reply_address;\n\tu16 smid;\n\tstruct _tr_list *delayed_tr, *delayed_tr_next;\n\tstruct _sc_list *delayed_sc, *delayed_sc_next;\n\tstruct _event_ack_list *delayed_event_ack, *delayed_event_ack_next;\n\tu8 hide_flag;\n\tstruct adapter_reply_queue *reply_q;\n\tMpi2ReplyDescriptorsUnion_t *reply_post_free_contig;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t/* clean the delayed target reset list */\n\tlist_for_each_entry_safe(delayed_tr, delayed_tr_next,\n\t    &ioc->delayed_tr_list, list) {\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t}\n\n\n\tlist_for_each_entry_safe(delayed_tr, delayed_tr_next,\n\t    &ioc->delayed_tr_volume_list, list) {\n\t\tlist_del(&delayed_tr->list);\n\t\tkfree(delayed_tr);\n\t}\n\n\tlist_for_each_entry_safe(delayed_sc, delayed_sc_next,\n\t    &ioc->delayed_sc_list, list) {\n\t\tlist_del(&delayed_sc->list);\n\t\tkfree(delayed_sc);\n\t}\n\n\tlist_for_each_entry_safe(delayed_event_ack, delayed_event_ack_next,\n\t    &ioc->delayed_event_ack_list, list) {\n\t\tlist_del(&delayed_event_ack->list);\n\t\tkfree(delayed_event_ack);\n\t}\n\n\tspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\n\n\t/* hi-priority queue */\n\tINIT_LIST_HEAD(&ioc->hpr_free_list);\n\tsmid = ioc->hi_priority_smid;\n\tfor (i = 0; i < ioc->hi_priority_depth; i++, smid++) {\n\t\tioc->hpr_lookup[i].cb_idx = 0xFF;\n\t\tioc->hpr_lookup[i].smid = smid;\n\t\tlist_add_tail(&ioc->hpr_lookup[i].tracker_list,\n\t\t    &ioc->hpr_free_list);\n\t}\n\n\t/* internal queue */\n\tINIT_LIST_HEAD(&ioc->internal_free_list);\n\tsmid = ioc->internal_smid;\n\tfor (i = 0; i < ioc->internal_depth; i++, smid++) {\n\t\tioc->internal_lookup[i].cb_idx = 0xFF;\n\t\tioc->internal_lookup[i].smid = smid;\n\t\tlist_add_tail(&ioc->internal_lookup[i].tracker_list,\n\t\t    &ioc->internal_free_list);\n\t}\n\n\tspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\n\n\t/* initialize Reply Free Queue */\n\tfor (i = 0, reply_address = (u32)ioc->reply_dma ;\n\t    i < ioc->reply_free_queue_depth ; i++, reply_address +=\n\t    ioc->reply_sz) {\n\t\tioc->reply_free[i] = cpu_to_le32(reply_address);\n\t\tif (ioc->is_mcpu_endpoint)\n\t\t\t_base_clone_reply_to_sys_mem(ioc,\n\t\t\t\t\treply_address, i);\n\t}\n\n\t/* initialize reply queues */\n\tif (ioc->is_driver_loading)\n\t\t_base_assign_reply_queues(ioc);\n\n\t/* initialize Reply Post Free Queue */\n\tindex = 0;\n\treply_post_free_contig = ioc->reply_post[0].reply_post_free;\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\t/*\n\t\t * If RDPQ is enabled, switch to the next allocation.\n\t\t * Otherwise advance within the contiguous region.\n\t\t */\n\t\tif (ioc->rdpq_array_enable) {\n\t\t\treply_q->reply_post_free =\n\t\t\t\tioc->reply_post[index++].reply_post_free;\n\t\t} else {\n\t\t\treply_q->reply_post_free = reply_post_free_contig;\n\t\t\treply_post_free_contig += ioc->reply_post_queue_depth;\n\t\t}\n\n\t\treply_q->reply_post_host_index = 0;\n\t\tfor (i = 0; i < ioc->reply_post_queue_depth; i++)\n\t\t\treply_q->reply_post_free[i].Words =\n\t\t\t    cpu_to_le64(ULLONG_MAX);\n\t\tif (!_base_is_controller_msix_enabled(ioc))\n\t\t\tgoto skip_init_reply_post_free_queue;\n\t}\n skip_init_reply_post_free_queue:\n\n\tr = _base_send_ioc_init(ioc);\n\tif (r) {\n\t\t/*\n\t\t * No need to check IOC state for fault state & issue\n\t\t * diag reset during host reset. This check is need\n\t\t * only during driver load time.\n\t\t */\n\t\tif (!ioc->is_driver_loading)\n\t\t\treturn r;\n\n\t\trc = _base_check_for_fault_and_issue_reset(ioc);\n\t\tif (rc || (_base_send_ioc_init(ioc)))\n\t\t\treturn r;\n\t}\n\n\t/* initialize reply free host index */\n\tioc->reply_free_host_index = ioc->reply_free_queue_depth - 1;\n\twritel(ioc->reply_free_host_index, &ioc->chip->ReplyFreeHostIndex);\n\n\t/* initialize reply post host index */\n\tlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\n\t\tif (ioc->combined_reply_queue)\n\t\t\twritel((reply_q->msix_index & 7)<<\n\t\t\t   MPI2_RPHI_MSIX_INDEX_SHIFT,\n\t\t\t   ioc->replyPostRegisterIndex[reply_q->msix_index/8]);\n\t\telse\n\t\t\twritel(reply_q->msix_index <<\n\t\t\t\tMPI2_RPHI_MSIX_INDEX_SHIFT,\n\t\t\t\t&ioc->chip->ReplyPostHostIndex);\n\n\t\tif (!_base_is_controller_msix_enabled(ioc))\n\t\t\tgoto skip_init_reply_post_host_index;\n\t}\n\n skip_init_reply_post_host_index:\n\n\tmpt3sas_base_unmask_interrupts(ioc);\n\n\tif (ioc->hba_mpi_version_belonged != MPI2_VERSION) {\n\t\tr = _base_display_fwpkg_version(ioc);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t_base_static_config_pages(ioc);\n\tr = _base_event_notification(ioc);\n\tif (r)\n\t\treturn r;\n\n\tif (ioc->is_driver_loading) {\n\n\t\tif (ioc->is_warpdrive && ioc->manu_pg10.OEMIdentifier\n\t\t    == 0x80) {\n\t\t\thide_flag = (u8) (\n\t\t\t    le32_to_cpu(ioc->manu_pg10.OEMSpecificFlags0) &\n\t\t\t    MFG_PAGE10_HIDE_SSDS_MASK);\n\t\t\tif (hide_flag != MFG_PAGE10_HIDE_SSDS_MASK)\n\t\t\t\tioc->mfg_pg10_hide_flag = hide_flag;\n\t\t}\n\n\t\tioc->wait_for_discovery_to_complete =\n\t\t    _base_determine_wait_on_discovery(ioc);\n\n\t\treturn r; /* scan_start and scan_finished support */\n\t}\n\n\tr = _base_send_port_enable(ioc);\n\tif (r)\n\t\treturn r;\n\n\treturn r;\n}\n\n/**\n * mpt3sas_base_free_resources - free resources controller resources\n * @ioc: per adapter object\n */\nvoid\nmpt3sas_base_free_resources(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t/* synchronizing freeing resource with pci_access_mutex lock */\n\tmutex_lock(&ioc->pci_access_mutex);\n\tif (ioc->chip_phys && ioc->chip) {\n\t\tmpt3sas_base_mask_interrupts(ioc);\n\t\tioc->shost_recovery = 1;\n\t\t_base_make_ioc_ready(ioc, SOFT_RESET);\n\t\tioc->shost_recovery = 0;\n\t}\n\n\tmpt3sas_base_unmap_resources(ioc);\n\tmutex_unlock(&ioc->pci_access_mutex);\n\treturn;\n}\n\n/**\n * mpt3sas_base_attach - attach controller instance\n * @ioc: per adapter object\n *\n * Return: 0 for success, non-zero for failure.\n */\nint\nmpt3sas_base_attach(struct MPT3SAS_ADAPTER *ioc)\n{\n\tint r, i, rc;\n\tint cpu_id, last_cpu_id = 0;\n\n\tdinitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\t/* setup cpu_msix_table */\n\tioc->cpu_count = num_online_cpus();\n\tfor_each_online_cpu(cpu_id)\n\t\tlast_cpu_id = cpu_id;\n\tioc->cpu_msix_table_sz = last_cpu_id + 1;\n\tioc->cpu_msix_table = kzalloc(ioc->cpu_msix_table_sz, GFP_KERNEL);\n\tioc->reply_queue_count = 1;\n\tif (!ioc->cpu_msix_table) {\n\t\tioc_info(ioc, \"Allocation for cpu_msix_table failed!!!\\n\");\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tif (ioc->is_warpdrive) {\n\t\tioc->reply_post_host_index = kcalloc(ioc->cpu_msix_table_sz,\n\t\t    sizeof(resource_size_t *), GFP_KERNEL);\n\t\tif (!ioc->reply_post_host_index) {\n\t\t\tioc_info(ioc, \"Allocation for reply_post_host_index failed!!!\\n\");\n\t\t\tr = -ENOMEM;\n\t\t\tgoto out_free_resources;\n\t\t}\n\t}\n\n\tioc->smp_affinity_enable = smp_affinity_enable;\n\n\tioc->rdpq_array_enable_assigned = 0;\n\tioc->use_32bit_dma = false;\n\tioc->dma_mask = 64;\n\tif (ioc->is_aero_ioc)\n\t\tioc->base_readl = &_base_readl_aero;\n\telse\n\t\tioc->base_readl = &_base_readl;\n\tr = mpt3sas_base_map_resources(ioc);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\tpci_set_drvdata(ioc->pdev, ioc->shost);\n\tr = _base_get_ioc_facts(ioc);\n\tif (r) {\n\t\trc = _base_check_for_fault_and_issue_reset(ioc);\n\t\tif (rc || (_base_get_ioc_facts(ioc)))\n\t\t\tgoto out_free_resources;\n\t}\n\n\tswitch (ioc->hba_mpi_version_belonged) {\n\tcase MPI2_VERSION:\n\t\tioc->build_sg_scmd = &_base_build_sg_scmd;\n\t\tioc->build_sg = &_base_build_sg;\n\t\tioc->build_zero_len_sge = &_base_build_zero_len_sge;\n\t\tioc->get_msix_index_for_smlio = &_base_get_msix_index;\n\t\tbreak;\n\tcase MPI25_VERSION:\n\tcase MPI26_VERSION:\n\t\t/*\n\t\t * In SAS3.0,\n\t\t * SCSI_IO, SMP_PASSTHRU, SATA_PASSTHRU, Target Assist, and\n\t\t * Target Status - all require the IEEE formated scatter gather\n\t\t * elements.\n\t\t */\n\t\tioc->build_sg_scmd = &_base_build_sg_scmd_ieee;\n\t\tioc->build_sg = &_base_build_sg_ieee;\n\t\tioc->build_nvme_prp = &_base_build_nvme_prp;\n\t\tioc->build_zero_len_sge = &_base_build_zero_len_sge_ieee;\n\t\tioc->sge_size_ieee = sizeof(Mpi2IeeeSgeSimple64_t);\n\t\tif (ioc->high_iops_queues)\n\t\t\tioc->get_msix_index_for_smlio =\n\t\t\t\t\t&_base_get_high_iops_msix_index;\n\t\telse\n\t\t\tioc->get_msix_index_for_smlio = &_base_get_msix_index;\n\t\tbreak;\n\t}\n\tif (ioc->atomic_desc_capable) {\n\t\tioc->put_smid_default = &_base_put_smid_default_atomic;\n\t\tioc->put_smid_scsi_io = &_base_put_smid_scsi_io_atomic;\n\t\tioc->put_smid_fast_path =\n\t\t\t\t&_base_put_smid_fast_path_atomic;\n\t\tioc->put_smid_hi_priority =\n\t\t\t\t&_base_put_smid_hi_priority_atomic;\n\t} else {\n\t\tioc->put_smid_default = &_base_put_smid_default;\n\t\tioc->put_smid_fast_path = &_base_put_smid_fast_path;\n\t\tioc->put_smid_hi_priority = &_base_put_smid_hi_priority;\n\t\tif (ioc->is_mcpu_endpoint)\n\t\t\tioc->put_smid_scsi_io =\n\t\t\t\t&_base_put_smid_mpi_ep_scsi_io;\n\t\telse\n\t\t\tioc->put_smid_scsi_io = &_base_put_smid_scsi_io;\n\t}\n\t/*\n\t * These function pointers for other requests that don't\n\t * the require IEEE scatter gather elements.\n\t *\n\t * For example Configuration Pages and SAS IOUNIT Control don't.\n\t */\n\tioc->build_sg_mpi = &_base_build_sg;\n\tioc->build_zero_len_sge_mpi = &_base_build_zero_len_sge;\n\n\tr = _base_make_ioc_ready(ioc, SOFT_RESET);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\tioc->pfacts = kcalloc(ioc->facts.NumberOfPorts,\n\t    sizeof(struct mpt3sas_port_facts), GFP_KERNEL);\n\tif (!ioc->pfacts) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tfor (i = 0 ; i < ioc->facts.NumberOfPorts; i++) {\n\t\tr = _base_get_port_facts(ioc, i);\n\t\tif (r) {\n\t\t\trc = _base_check_for_fault_and_issue_reset(ioc);\n\t\t\tif (rc || (_base_get_port_facts(ioc, i)))\n\t\t\t\tgoto out_free_resources;\n\t\t}\n\t}\n\n\tr = _base_allocate_memory_pools(ioc);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\tif (irqpoll_weight > 0)\n\t\tioc->thresh_hold = irqpoll_weight;\n\telse\n\t\tioc->thresh_hold = ioc->hba_queue_depth/4;\n\n\t_base_init_irqpolls(ioc);\n\tinit_waitqueue_head(&ioc->reset_wq);\n\n\t/* allocate memory pd handle bitmask list */\n\tioc->pd_handles_sz = (ioc->facts.MaxDevHandle / 8);\n\tif (ioc->facts.MaxDevHandle % 8)\n\t\tioc->pd_handles_sz++;\n\tioc->pd_handles = kzalloc(ioc->pd_handles_sz,\n\t    GFP_KERNEL);\n\tif (!ioc->pd_handles) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\tioc->blocking_handles = kzalloc(ioc->pd_handles_sz,\n\t    GFP_KERNEL);\n\tif (!ioc->blocking_handles) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\t/* allocate memory for pending OS device add list */\n\tioc->pend_os_device_add_sz = (ioc->facts.MaxDevHandle / 8);\n\tif (ioc->facts.MaxDevHandle % 8)\n\t\tioc->pend_os_device_add_sz++;\n\tioc->pend_os_device_add = kzalloc(ioc->pend_os_device_add_sz,\n\t    GFP_KERNEL);\n\tif (!ioc->pend_os_device_add)\n\t\tgoto out_free_resources;\n\n\tioc->device_remove_in_progress_sz = ioc->pend_os_device_add_sz;\n\tioc->device_remove_in_progress =\n\t\tkzalloc(ioc->device_remove_in_progress_sz, GFP_KERNEL);\n\tif (!ioc->device_remove_in_progress)\n\t\tgoto out_free_resources;\n\n\tioc->fwfault_debug = mpt3sas_fwfault_debug;\n\n\t/* base internal command bits */\n\tmutex_init(&ioc->base_cmds.mutex);\n\tioc->base_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->base_cmds.status = MPT3_CMD_NOT_USED;\n\n\t/* port_enable command bits */\n\tioc->port_enable_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\n\n\t/* transport internal command bits */\n\tioc->transport_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->transport_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->transport_cmds.mutex);\n\n\t/* scsih internal command bits */\n\tioc->scsih_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->scsih_cmds.mutex);\n\n\t/* task management internal command bits */\n\tioc->tm_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->tm_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->tm_cmds.mutex);\n\n\t/* config page internal command bits */\n\tioc->config_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->config_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->config_cmds.mutex);\n\n\t/* ctl module internal command bits */\n\tioc->ctl_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\n\tioc->ctl_cmds.sense = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\n\tioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\n\tmutex_init(&ioc->ctl_cmds.mutex);\n\n\tif (!ioc->base_cmds.reply || !ioc->port_enable_cmds.reply ||\n\t    !ioc->transport_cmds.reply || !ioc->scsih_cmds.reply ||\n\t    !ioc->tm_cmds.reply || !ioc->config_cmds.reply ||\n\t    !ioc->ctl_cmds.reply || !ioc->ctl_cmds.sense) {\n\t\tr = -ENOMEM;\n\t\tgoto out_free_resources;\n\t}\n\n\tfor (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\n\t\tioc->event_masks[i] = -1;\n\n\t/* here we enable the events we care about */\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_DISCOVERY);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_BROADCAST_PRIMITIVE);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_VOLUME);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_PHYSICAL_DISK);\n\t_base_unmask_events(ioc, MPI2_EVENT_IR_OPERATION_STATUS);\n\t_base_unmask_events(ioc, MPI2_EVENT_LOG_ENTRY_ADDED);\n\t_base_unmask_events(ioc, MPI2_EVENT_TEMP_THRESHOLD);\n\t_base_unmask_events(ioc, MPI2_EVENT_ACTIVE_CABLE_EXCEPTION);\n\t_base_unmask_events(ioc, MPI2_EVENT_SAS_DEVICE_DISCOVERY_ERROR);\n\tif (ioc->hba_mpi_version_belonged == MPI26_VERSION) {\n\t\tif (ioc->is_gen35_ioc) {\n\t\t\t_base_unmask_events(ioc,\n\t\t\t\tMPI2_EVENT_PCIE_DEVICE_STATUS_CHANGE);\n\t\t\t_base_unmask_events(ioc, MPI2_EVENT_PCIE_ENUMERATION);\n\t\t\t_base_unmask_events(ioc,\n\t\t\t\tMPI2_EVENT_PCIE_TOPOLOGY_CHANGE_LIST);\n\t\t}\n\t}\n\tr = _base_make_ioc_operational(ioc);\n\tif (r)\n\t\tgoto out_free_resources;\n\n\t/*\n\t * Copy current copy of IOCFacts in prev_fw_facts\n\t * and it will be used during online firmware upgrade.\n\t */\n\tmemcpy(&ioc->prev_fw_facts, &ioc->facts,\n\t    sizeof(struct mpt3sas_facts));\n\n\tioc->non_operational_loop = 0;\n\tioc->ioc_coredump_loop = 0;\n\tioc->got_task_abort_from_ioctl = 0;\n\treturn 0;\n\n out_free_resources:\n\n\tioc->remove_host = 1;\n\n\tmpt3sas_base_free_resources(ioc);\n\t_base_release_memory_pools(ioc);\n\tpci_set_drvdata(ioc->pdev, NULL);\n\tkfree(ioc->cpu_msix_table);\n\tif (ioc->is_warpdrive)\n\t\tkfree(ioc->reply_post_host_index);\n\tkfree(ioc->pd_handles);\n\tkfree(ioc->blocking_handles);\n\tkfree(ioc->device_remove_in_progress);\n\tkfree(ioc->pend_os_device_add);\n\tkfree(ioc->tm_cmds.reply);\n\tkfree(ioc->transport_cmds.reply);\n\tkfree(ioc->scsih_cmds.reply);\n\tkfree(ioc->config_cmds.reply);\n\tkfree(ioc->base_cmds.reply);\n\tkfree(ioc->port_enable_cmds.reply);\n\tkfree(ioc->ctl_cmds.reply);\n\tkfree(ioc->ctl_cmds.sense);\n\tkfree(ioc->pfacts);\n\tioc->ctl_cmds.reply = NULL;\n\tioc->base_cmds.reply = NULL;\n\tioc->tm_cmds.reply = NULL;\n\tioc->scsih_cmds.reply = NULL;\n\tioc->transport_cmds.reply = NULL;\n\tioc->config_cmds.reply = NULL;\n\tioc->pfacts = NULL;\n\treturn r;\n}\n\n\n/**\n * mpt3sas_base_detach - remove controller instance\n * @ioc: per adapter object\n */\nvoid\nmpt3sas_base_detach(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdexitprintk(ioc, ioc_info(ioc, \"%s\\n\", __func__));\n\n\tmpt3sas_base_stop_watchdog(ioc);\n\tmpt3sas_base_free_resources(ioc);\n\t_base_release_memory_pools(ioc);\n\tmpt3sas_free_enclosure_list(ioc);\n\tpci_set_drvdata(ioc->pdev, NULL);\n\tkfree(ioc->cpu_msix_table);\n\tif (ioc->is_warpdrive)\n\t\tkfree(ioc->reply_post_host_index);\n\tkfree(ioc->pd_handles);\n\tkfree(ioc->blocking_handles);\n\tkfree(ioc->device_remove_in_progress);\n\tkfree(ioc->pend_os_device_add);\n\tkfree(ioc->pfacts);\n\tkfree(ioc->ctl_cmds.reply);\n\tkfree(ioc->ctl_cmds.sense);\n\tkfree(ioc->base_cmds.reply);\n\tkfree(ioc->port_enable_cmds.reply);\n\tkfree(ioc->tm_cmds.reply);\n\tkfree(ioc->transport_cmds.reply);\n\tkfree(ioc->scsih_cmds.reply);\n\tkfree(ioc->config_cmds.reply);\n}\n\n/**\n * _base_pre_reset_handler - pre reset handler\n * @ioc: per adapter object\n */\nstatic void _base_pre_reset_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tmpt3sas_scsih_pre_reset_handler(ioc);\n\tmpt3sas_ctl_pre_reset_handler(ioc);\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_PRE_RESET\\n\", __func__));\n}\n\n/**\n * _base_clear_outstanding_mpt_commands - clears outstanding mpt commands\n * @ioc: per adapter object\n */\nstatic void\n_base_clear_outstanding_mpt_commands(struct MPT3SAS_ADAPTER *ioc)\n{\n\tdtmprintk(ioc,\n\t    ioc_info(ioc, \"%s: clear outstanding mpt cmds\\n\", __func__));\n\tif (ioc->transport_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->transport_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->transport_cmds.smid);\n\t\tcomplete(&ioc->transport_cmds.done);\n\t}\n\tif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->base_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->base_cmds.smid);\n\t\tcomplete(&ioc->base_cmds.done);\n\t}\n\tif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->port_enable_failed = 1;\n\t\tioc->port_enable_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->port_enable_cmds.smid);\n\t\tif (ioc->is_driver_loading) {\n\t\t\tioc->start_scan_failed =\n\t\t\t\tMPI2_IOCSTATUS_INTERNAL_ERROR;\n\t\t\tioc->start_scan = 0;\n\t\t\tioc->port_enable_cmds.status =\n\t\t\t\tMPT3_CMD_NOT_USED;\n\t\t} else {\n\t\t\tcomplete(&ioc->port_enable_cmds.done);\n\t\t}\n\t}\n\tif (ioc->config_cmds.status & MPT3_CMD_PENDING) {\n\t\tioc->config_cmds.status |= MPT3_CMD_RESET;\n\t\tmpt3sas_base_free_smid(ioc, ioc->config_cmds.smid);\n\t\tioc->config_cmds.smid = USHRT_MAX;\n\t\tcomplete(&ioc->config_cmds.done);\n\t}\n}\n\n/**\n * _base_clear_outstanding_commands - clear all outstanding commands\n * @ioc: per adapter object\n */\nstatic void _base_clear_outstanding_commands(struct MPT3SAS_ADAPTER *ioc)\n{\n\tmpt3sas_scsih_clear_outstanding_scsi_tm_commands(ioc);\n\tmpt3sas_ctl_clear_outstanding_ioctls(ioc);\n\t_base_clear_outstanding_mpt_commands(ioc);\n}\n\n/**\n * _base_reset_done_handler - reset done handler\n * @ioc: per adapter object\n */\nstatic void _base_reset_done_handler(struct MPT3SAS_ADAPTER *ioc)\n{\n\tmpt3sas_scsih_reset_done_handler(ioc);\n\tmpt3sas_ctl_reset_done_handler(ioc);\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: MPT3_IOC_DONE_RESET\\n\", __func__));\n}\n\n/**\n * mpt3sas_wait_for_commands_to_complete - reset controller\n * @ioc: Pointer to MPT_ADAPTER structure\n *\n * This function is waiting 10s for all pending commands to complete\n * prior to putting controller in reset.\n */\nvoid\nmpt3sas_wait_for_commands_to_complete(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu32 ioc_state;\n\n\tioc->pending_io_count = 0;\n\n\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\tif ((ioc_state & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL)\n\t\treturn;\n\n\t/* pending command count */\n\tioc->pending_io_count = scsi_host_busy(ioc->shost);\n\n\tif (!ioc->pending_io_count)\n\t\treturn;\n\n\t/* wait for pending commands to complete */\n\twait_event_timeout(ioc->reset_wq, ioc->pending_io_count == 0, 10 * HZ);\n}\n\n/**\n * _base_check_ioc_facts_changes - Look for increase/decrease of IOCFacts\n *     attributes during online firmware upgrade and update the corresponding\n *     IOC variables accordingly.\n *\n * @ioc: Pointer to MPT_ADAPTER structure\n */\nstatic int\n_base_check_ioc_facts_changes(struct MPT3SAS_ADAPTER *ioc)\n{\n\tu16 pd_handles_sz;\n\tvoid *pd_handles = NULL, *blocking_handles = NULL;\n\tvoid *pend_os_device_add = NULL, *device_remove_in_progress = NULL;\n\tstruct mpt3sas_facts *old_facts = &ioc->prev_fw_facts;\n\n\tif (ioc->facts.MaxDevHandle > old_facts->MaxDevHandle) {\n\t\tpd_handles_sz = (ioc->facts.MaxDevHandle / 8);\n\t\tif (ioc->facts.MaxDevHandle % 8)\n\t\t\tpd_handles_sz++;\n\n\t\tpd_handles = krealloc(ioc->pd_handles, pd_handles_sz,\n\t\t    GFP_KERNEL);\n\t\tif (!pd_handles) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for pd_handles of sz: %d\\n\",\n\t\t\t    pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(pd_handles + ioc->pd_handles_sz, 0,\n\t\t    (pd_handles_sz - ioc->pd_handles_sz));\n\t\tioc->pd_handles = pd_handles;\n\n\t\tblocking_handles = krealloc(ioc->blocking_handles,\n\t\t    pd_handles_sz, GFP_KERNEL);\n\t\tif (!blocking_handles) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for \"\n\t\t\t    \"blocking_handles of sz: %d\\n\",\n\t\t\t    pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(blocking_handles + ioc->pd_handles_sz, 0,\n\t\t    (pd_handles_sz - ioc->pd_handles_sz));\n\t\tioc->blocking_handles = blocking_handles;\n\t\tioc->pd_handles_sz = pd_handles_sz;\n\n\t\tpend_os_device_add = krealloc(ioc->pend_os_device_add,\n\t\t    pd_handles_sz, GFP_KERNEL);\n\t\tif (!pend_os_device_add) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for pend_os_device_add of sz: %d\\n\",\n\t\t\t    pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(pend_os_device_add + ioc->pend_os_device_add_sz, 0,\n\t\t    (pd_handles_sz - ioc->pend_os_device_add_sz));\n\t\tioc->pend_os_device_add = pend_os_device_add;\n\t\tioc->pend_os_device_add_sz = pd_handles_sz;\n\n\t\tdevice_remove_in_progress = krealloc(\n\t\t    ioc->device_remove_in_progress, pd_handles_sz, GFP_KERNEL);\n\t\tif (!device_remove_in_progress) {\n\t\t\tioc_info(ioc,\n\t\t\t    \"Unable to allocate the memory for \"\n\t\t\t    \"device_remove_in_progress of sz: %d\\n \"\n\t\t\t    , pd_handles_sz);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(device_remove_in_progress +\n\t\t    ioc->device_remove_in_progress_sz, 0,\n\t\t    (pd_handles_sz - ioc->device_remove_in_progress_sz));\n\t\tioc->device_remove_in_progress = device_remove_in_progress;\n\t\tioc->device_remove_in_progress_sz = pd_handles_sz;\n\t}\n\n\tmemcpy(&ioc->prev_fw_facts, &ioc->facts, sizeof(struct mpt3sas_facts));\n\treturn 0;\n}\n\n/**\n * mpt3sas_base_hard_reset_handler - reset controller\n * @ioc: Pointer to MPT_ADAPTER structure\n * @type: FORCE_BIG_HAMMER or SOFT_RESET\n *\n * Return: 0 for success, non-zero for failure.\n */\nint\nmpt3sas_base_hard_reset_handler(struct MPT3SAS_ADAPTER *ioc,\n\tenum reset_type type)\n{\n\tint r;\n\tunsigned long flags;\n\tu32 ioc_state;\n\tu8 is_fault = 0, is_trigger = 0;\n\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: enter\\n\", __func__));\n\n\tif (ioc->pci_error_recovery) {\n\t\tioc_err(ioc, \"%s: pci error recovery reset\\n\", __func__);\n\t\tr = 0;\n\t\tgoto out_unlocked;\n\t}\n\n\tif (mpt3sas_fwfault_debug)\n\t\tmpt3sas_halt_firmware(ioc);\n\n\t/* wait for an active reset in progress to complete */\n\tmutex_lock(&ioc->reset_in_progress_mutex);\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tioc->shost_recovery = 1;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\n\tif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_REGISTERED) &&\n\t    (!(ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\n\t    MPT3_DIAG_BUFFER_IS_RELEASED))) {\n\t\tis_trigger = 1;\n\t\tioc_state = mpt3sas_base_get_iocstate(ioc, 0);\n\t\tif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT ||\n\t\t    (ioc_state & MPI2_IOC_STATE_MASK) ==\n\t\t    MPI2_IOC_STATE_COREDUMP) {\n\t\t\tis_fault = 1;\n\t\t\tioc->htb_rel.trigger_info_dwords[1] =\n\t\t\t    (ioc_state & MPI2_DOORBELL_DATA_MASK);\n\t\t}\n\t}\n\t_base_pre_reset_handler(ioc);\n\tmpt3sas_wait_for_commands_to_complete(ioc);\n\tmpt3sas_base_mask_interrupts(ioc);\n\tr = _base_make_ioc_ready(ioc, type);\n\tif (r)\n\t\tgoto out;\n\t_base_clear_outstanding_commands(ioc);\n\n\t/* If this hard reset is called while port enable is active, then\n\t * there is no reason to call make_ioc_operational\n\t */\n\tif (ioc->is_driver_loading && ioc->port_enable_failed) {\n\t\tioc->remove_host = 1;\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\tr = _base_get_ioc_facts(ioc);\n\tif (r)\n\t\tgoto out;\n\n\tr = _base_check_ioc_facts_changes(ioc);\n\tif (r) {\n\t\tioc_info(ioc,\n\t\t    \"Some of the parameters got changed in this new firmware\"\n\t\t    \" image and it requires system reboot\\n\");\n\t\tgoto out;\n\t}\n\tif (ioc->rdpq_array_enable && !ioc->rdpq_array_capable)\n\t\tpanic(\"%s: Issue occurred with flashing controller firmware.\"\n\t\t      \"Please reboot the system and ensure that the correct\"\n\t\t      \" firmware version is running\\n\", ioc->name);\n\n\tr = _base_make_ioc_operational(ioc);\n\tif (!r)\n\t\t_base_reset_done_handler(ioc);\n\n out:\n\tioc_info(ioc, \"%s: %s\\n\", __func__, r == 0 ? \"SUCCESS\" : \"FAILED\");\n\n\tspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\n\tioc->shost_recovery = 0;\n\tspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\n\tioc->ioc_reset_count++;\n\tmutex_unlock(&ioc->reset_in_progress_mutex);\n\n out_unlocked:\n\tif ((r == 0) && is_trigger) {\n\t\tif (is_fault)\n\t\t\tmpt3sas_trigger_master(ioc, MASTER_TRIGGER_FW_FAULT);\n\t\telse\n\t\t\tmpt3sas_trigger_master(ioc,\n\t\t\t    MASTER_TRIGGER_ADAPTER_RESET);\n\t}\n\tdtmprintk(ioc, ioc_info(ioc, \"%s: exit\\n\", __func__));\n\treturn r;\n}\n"}}, "reports": [{"events": [{"location": {"col": 28, "file": 0, "line": 1921}, "message": "ERROR: invalid reference to the index variable of the iterator on line 1896"}], "macros": [], "notes": [], "path": "/src/drivers/scsi/mpt3sas/mpt3sas_base.c", "reportHash": "fd4093d0fa0fdcd710031c79fe9d51a6", "checkerName": "coccinelle", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
